<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Char&#39;s Blog</title>
  
  <subtitle>如切如磋，如琢如磨。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xuebaonline.com/"/>
  <updated>2020-04-25T08:33:09.103Z</updated>
  <id>http://www.xuebaonline.com/</id>
  
  <author>
    <name>Char</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift命令设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T08:12:58.000Z</published>
    <updated>2020-04-25T08:33:09.103Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令设计模式是众多设计模式中的一种，也比较常用。 这是用Swift编写的命令设计模板的一个小例子。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="命令模式">命令模式</a>（英语：Command pattern）是一种设计模式，它尝试以对象来代表实际行动。命令对象可以把行动(action) 及其参数封装起来，于是这些行动可以被：</p><ul><li>重复多次</li><li>取消（如果该对象有实现的话）</li><li>取消后又再重做</li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些都是现代大型应用程序所必须的功能，即“撤销”及“重复”。除此之外，可以用命令模式来实现的功能例子还有：</p><ul><li>交易行为</li><li>进度列</li><li>向导</li><li>用户界面按钮及功能表项目</li><li>线程 pool</li><li>宏收录</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想为稍后将要执行的不同操作提供一个通用界面，那么该命令模式将非常方便。 通常，它是一个对象，其中包含正确运行基础操作所需的所有信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令通常用于处理用户界面操作，创建撤消管理器或管理事务。 让我们通过使用表情符号创建命令行参数处理程序来查看 <code>Swift</code> 中的命令模式实现。 💾</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env swift</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelpCommand</span>: <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Help</span>().info()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Help</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">info</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">             🤖 Commander 🤖</span></span><br><span class="line"><span class="string">                  v1.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Available commands:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            👉 help      This command</span></span><br><span class="line"><span class="string">            👉 ls        List documents</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Bye! 👋</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListCommand</span>: <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">List</span>().homeDirectoryContents()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">homeDirectoryContents</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> documentsURL = fileManager.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask).first <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Could not open documents directory"</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> fileURLs = <span class="keyword">try</span> fileManager.contentsOfDirectory(at: documentsURL, includingPropertiesForKeys: <span class="literal">nil</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\n\t📁 Listing documents directory:\n"</span>)</span><br><span class="line">            <span class="built_in">print</span>(fileURLs.<span class="built_in">map</span> &#123; <span class="string">"\t\t💾 "</span> + $<span class="number">0</span>.lastPathComponent &#125;.joined(separator: <span class="string">"\n\n"</span>) + <span class="string">"\n"</span> )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> commands: [<span class="type">String</span>:<span class="type">Command</span>] = [:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.commands[<span class="string">"help"</span>] = <span class="type">HelpCommand</span>()</span><br><span class="line">        <span class="keyword">self</span>.commands[<span class="string">"ls"</span>] = <span class="type">ListCommand</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arguments = <span class="type">CommandLine</span>.arguments[<span class="number">1</span>...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> key = arguments.first, <span class="keyword">self</span>.commands[key] != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Usage: ./command.swift [\(self.commands.keys.joined(separator: "</span>|<span class="string">"))]"</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.commands[key]!.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">App</span>().run()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果保存此文件，只需在终端窗口中键入 <code>./file-name.swift</code> 即可运行它。 <code>Swift</code> 编译器将负责其余的工作。 ⚒</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令设计模式的实际用例：</p><ul><li>各种按钮动作</li><li>集合/表视图选择操作</li><li>在控制器之间导航</li><li>历史记录管理/撤消管理器</li><li>交易行为</li><li>进度管理</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如你所了解那样，该模式可以应用于多个区域。 苹果为此专门制作了一个名为 <code>NSInvocation</code> 的特定类，但不幸的是，由于它的动态行为，它在 <code>Swift</code> 中不可用。 没什么大不了的，你始终可以制定自己的协议和实现，在大多数情况下，你只需要一个包装基础命令逻辑的额外类即可。 😛</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;命令设计模式是众多设计模式中的一种，也比较常用。 这是用Swift编写的命令设计模板的一个小例子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;命令模式&quot;&gt;命令模式&lt;/a&gt;（英语：Command pattern）是一种设计模式，它尝试以对象来代表实际行动。命令对象可以把行动(action) 及其参数封装起来，于是这些行动可以被：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复多次&lt;/li&gt;
&lt;li&gt;取消（如果该对象有实现的话）&lt;/li&gt;
&lt;li&gt;取消后又再重做&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="命令设计模式" scheme="http://www.xuebaonline.com/tags/%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift原型设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T07:49:06.000Z</published>
    <updated>2020-04-25T08:03:11.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型设计模式用于创建基础对象的克隆，因此让我们看一些用Swift编写的实际示例。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式是 <a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="创建型模式">创建型模式</a> 的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这也是一种创新的设计模式，当你对一个对象进行非常基本的配置并且想要将这些预定义值提供（复制）给另一个对象时，这很有用。 基本上，你是从原型对象制作复制。 😊😊😊</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法有一些好处，例如，你不必继承子类，但可以单独配置复制。 这也意味着，如果你要使用原型，则可以删除一堆样板代码（配置）。 🤔</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paragraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> font: <span class="type">UIFont</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(font: <span class="type">UIFont</span> = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>),</span><br><span class="line">         color: <span class="type">UIColor</span> = .darkText,</span><br><span class="line">         text: <span class="type">String</span> = <span class="string">""</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = font</span><br><span class="line">        <span class="keyword">self</span>.color = color</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clone</span><span class="params">()</span></span> -&gt; <span class="type">Paragraph</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Paragraph</span>(font: <span class="keyword">self</span>.font, color: <span class="keyword">self</span>.color, text: <span class="keyword">self</span>.text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> base = <span class="type">Paragraph</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = base.clone()</span><br><span class="line">title.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">title.text = <span class="string">"This is the title"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = base.clone()</span><br><span class="line">first.text = <span class="string">"This is the first paragraph"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> second = base.clone()</span><br><span class="line">second.text = <span class="string">"This is the second paragraph"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上面的代码所示，实现只是几行代码。 你只需要一个默认的初始化程序和一个复制方法。 一切都将在 <code>init</code> 方法中针对原型对象进行预配置，并且你可以使用 <code>clone</code> 方法进行复制，但这时很明显……</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们再看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paragraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> font: <span class="type">UIFont</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(font: <span class="type">UIFont</span> = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>),</span><br><span class="line">         color: <span class="type">UIColor</span> = .darkText,</span><br><span class="line">         text: <span class="type">String</span> = <span class="string">""</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = font</span><br><span class="line">        <span class="keyword">self</span>.color = color</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clone</span><span class="params">()</span></span> -&gt; <span class="type">Paragraph</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Paragraph</span>(font: <span class="keyword">self</span>.font, color: <span class="keyword">self</span>.color, text: <span class="keyword">self</span>.text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> base = <span class="type">Paragraph</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = base.clone()</span><br><span class="line">title.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">title.text = <span class="string">"This is the title"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = base.clone()</span><br><span class="line">first.text = <span class="string">"This is the first paragraph"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> second = base.clone()</span><br><span class="line">second.text = <span class="string">"This is the second paragraph"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你打算获取已知对象状态的快照，则原型设计模式也很有用。 例如，在绘图应用程序中，你可以将形状类作为原型，可以开始向其添加路径，有时甚至可以从中创建快照。 你可以继续处理新对象，但这将使你能够在将来的任何时间返回到保存状态。 🎉</p><p>当你的应用程序不依赖于创建，合成和表示对象的方法时，应考虑选择它，以及至少下列各项之一：</p><ul><li>在运行时创建对象</li><li>你想避免工厂的复杂层次结构</li><li>对象只能有很少的状态</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，就是 <code>Swift</code> 中的原型设计模式。 🐿</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型设计模式用于创建基础对象的克隆，因此让我们看一些用Swift编写的实际示例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型模式是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;创建型模式&quot;&gt;创建型模式&lt;/a&gt; 的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="原型设计模式" scheme="http://www.xuebaonline.com/tags/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>比较工厂设计模式</title>
    <link href="http://www.xuebaonline.com/%E6%AF%94%E8%BE%83%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/%E6%AF%94%E8%BE%83%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T07:38:40.000Z</published>
    <updated>2020-04-25T07:49:56.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用Swift语言了解静态工厂，简单工厂，工厂方法和抽象工厂之间的区别。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为对所有工厂模式进行汇总比较会很高兴，所以这里是你应该了解的所有内容。 构造它们相对简单，在本示例中，我将使用一些用 <code>Swift</code> 编程语言编写的 <code>UIColor</code> 来向你展示基础知识。 🧙‍♂️</p><a id="more"></a><h1 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a><strong>静态工厂</strong></h1><ul><li>没有单独的工厂类别</li><li>命名静态方法来初始化对象</li><li>可以具有缓存并可以返回子类型</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> primary: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> .black &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> secondary: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> .white &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> primary = <span class="type">UIColor</span>.primary</span><br><span class="line"><span class="keyword">let</span> secondary = <span class="type">UIColor</span>.secondary</span><br></pre></td></tr></table></figure><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a><strong>简单工厂</strong></h1><ul><li>一个工厂类</li><li>枚举( <code>switch-case</code> )出其中的实例对象</li><li>封装各种代码</li><li>如果列表太大，请使用工厂方法</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> primary</span><br><span class="line">        <span class="keyword">case</span> secondary</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> style: Style)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style</span><br><span class="line">        <span class="keyword">case</span> .primary:</span><br><span class="line">            <span class="keyword">return</span> .black</span><br><span class="line">        <span class="keyword">case</span> .secondary:</span><br><span class="line">            <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primary = factory.create(.primary)</span><br><span class="line"><span class="keyword">let</span> secondary = factory.create(.secondary)</span><br></pre></td></tr></table></figure><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong>工厂方法</strong></h1><ul><li>多个（解耦的）工厂类</li><li>每个实例的工厂方法</li><li>为工厂创建一个简单的协议</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .black</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> primaryColorFactory = <span class="type">PrimaryColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> secondaryColorFactory = <span class="type">SecondaryColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primary = primaryColorFactory.create()</span><br><span class="line"><span class="keyword">let</span> secondary = secondaryColorFactory.create()</span><br></pre></td></tr></table></figure><h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a><strong>抽象工厂</strong></h1><ul><li>结合简单的工厂和工厂方法</li><li>对整个应用程序具有全局作用</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exact same factory method pattern from above</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .black</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple factory pattern from above using the factory methods</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> dark</span><br><span class="line">        <span class="keyword">case</span> light</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> theme: Theme)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> theme &#123;</span><br><span class="line">        <span class="keyword">case</span> .dark:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">PrimaryColorFactory</span>().create()</span><br><span class="line">        <span class="keyword">case</span> .light:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">SecondaryColorFactory</span>().create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">AppColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primaryColor = factory.create(.dark)</span><br><span class="line"><span class="keyword">let</span> secondaryColor = factory.create(.light)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，所有这些都是使用 <code>Swift</code> 编写的实际示例的工厂模式。 👍</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用Swift语言了解静态工厂，简单工厂，工厂方法和抽象工厂之间的区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我认为对所有工厂模式进行汇总比较会很高兴，所以这里是你应该了解的所有内容。 构造它们相对简单，在本示例中，我将使用一些用 &lt;code&gt;Swift&lt;/code&gt; 编程语言编写的 &lt;code&gt;UIColor&lt;/code&gt; 来向你展示基础知识。 🧙‍♂️&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂设计模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift抽象工厂设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T07:26:13.000Z</published>
    <updated>2020-04-25T07:39:20.965Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们将工厂方法与简单的工厂外观结合起来：这是用Swift语言编写的抽象工厂设计模式！</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82" target="_blank" rel="noopener" title="抽象工厂模式">抽象工厂模式</a>（英语：Abstract factory pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举个例子来说，比如一个抽象工厂类叫做DocumentCreator（文档创建器），此类提供创建若干种产品的接口，包括createLetter()（创建信件）和createResume()（创建简历）。其中，createLetter()返回一个Letter（信件），createResume()返回一个Resume（简历）。系统中还有一些DocumentCreator的具体实现类，包括FancyDocumentCreator和ModernDocumentCreator。这两个类对DocumentCreator的两个方法分别有不同的实现，用来创建不同的“信件”和“简历”（用FancyDocumentCreator的实例可以创建FancyLetter和FancyResume，用ModernDocumentCreator的实例可以创建ModernLetter和ModernResume）。这些具体的“信件”和“简历”类均继承自抽象类，即Letter和Resume类。客户端需要创建“信件”或“简历”时，先要得到一个合适的DocumentCreator实例，然后调用它的方法。一个工厂中创建的每个对象都是同一个主题的（“fancy”或者“modern”）。客户端程序只需要知道得到的对象是“信件”或者“简历”，而不需要知道具体的主题，因此客户端程序从抽象工厂DocumentCreator中得到了Letter或Resume类的引用，而不是具体类的对象引用。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“工厂”是创建产品（对象）的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够抵消这样的“额外工作”。</p></blockquote><h1 id="Swift抽象工厂"><a href="#Swift抽象工厂" class="headerlink" title="Swift抽象工厂"></a><strong>Swift抽象工厂</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂模式提供了一种封装一组具有共同主题的单个工厂而无需指定其具体类的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，抽象工厂可以为你创建相关对象的族。 该实现通常结合简单的工厂和工厂方法原理。 单个对象是通过工厂方法创建的，而整个对象都包装在一个“抽象”的简单工厂中。 现在检查代码！ 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service protocols</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StagingService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://dev.localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StagingServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">StagingService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// production</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://live.localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProductionService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// abstract factory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Environment</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> production</span><br><span class="line">        <span class="keyword">case</span> staging</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> env: <span class="type">Environment</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(env: <span class="type">Environment</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.env = env</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>.env &#123;</span><br><span class="line">        <span class="keyword">case</span> .production:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ProductionServiceFactory</span>().create()</span><br><span class="line">        <span class="keyword">case</span> .staging:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">StagingServiceFactory</span>().create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">AppServiceFactory</span>(env: .production)</span><br><span class="line"><span class="keyword">let</span> service = factory.create()</span><br><span class="line"><span class="built_in">print</span>(service.url)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上代码看到的，使用抽象工厂将影响整个应用程序逻辑，而工厂方法仅对本地部分产生影响。 实现可能会有所不同，例如你也可以为抽象工厂创建一个独立的协议，但是在此示例中，我想使事情尽可能简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂通常用于实现对象独立性。 例如，如果你使用通用接口用 <code>Swift</code> 编写了多个不同的 <code>SQL</code> 数据库连接器（ <code>PostgreSQL</code> ，<code>MySQL</code> 等），则可以随时使用此模式在它们之间轻松切换。 可以将类似的逻辑应用于具有类似情况的业务。 🤔</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;让我们将工厂方法与简单的工厂外观结合起来：这是用Swift语言编写的抽象工厂设计模式！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;抽象工厂模式&quot;&gt;抽象工厂模式&lt;/a&gt;（英语：Abstract factory pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="抽象工厂设计模式" scheme="http://www.xuebaonline.com/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift工厂方法设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T07:16:57.000Z</published>
    <updated>2020-04-25T07:23:43.529Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法设计模式是一种专用的非静态方法，用于隐藏对象的创建逻辑。 让我们用Swift做吧！</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p><a id="more"></a><h1 id="工厂方法只是一种非静态方法"><a href="#工厂方法只是一种非静态方法" class="headerlink" title="工厂方法只是一种非静态方法"></a><strong>工厂方法只是一种非静态方法</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面对现实，这种模式只是通常由简单协议和类支持的一种方法。 从一个非常简单的示例开始：想象一个可以为您的服务端点创建基本URL的类。 我们称之为服务工厂。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createProductionUrl</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ServiceFactory</span>()</span><br><span class="line">factory.createProductionUrl()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会想，这甚至不接近工厂方法模式，但请稍候…让我们通过为服务类创建协议以及返回 <code>URL</code> 的协议，使事情变得有些复杂。 现在，我们可以将基本生产环境url协议实现为一个单独的类，并从生产服务工厂类返回该特定实例。 只需检查一下代码即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProductionService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ProductionServiceFactory</span>()</span><br><span class="line"><span class="keyword">let</span> request = factory.create()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么我们将所有逻辑分为两类和协议？ 请相信我去耦是一件好事。 从现在开始，你可以轻松编写带有虚拟 <code>url</code> 的模拟服务。 显然，这需要一个匹配的工厂类。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些模拟实例还将实现服务协议，因此你可以以相对轻松的方式添加新类型，而无需更改原始代码库。 工厂方法解决了简单工厂模式的一个特定问题。 如果列表（ <code>switch-case</code> 的列表）太长，那么只有一个工厂就很难维护新对象。 工厂方法通过引入多个工厂对象来解决此问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工厂方法设计模式是一种专用的非静态方法，用于隐藏对象的创建逻辑。 让我们用Swift做吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂方法设计模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift中快速简单的工厂设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T05:15:16.000Z</published>
    <updated>2020-04-25T07:15:19.575Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，我们来讨论简单的工厂设计模式，该模式使用Swift以一种非常简单的方式封装对象创建。</p></blockquote><h1 id="使用-switch-case-实现简单的工厂模式"><a href="#使用-switch-case-实现简单的工厂模式" class="headerlink" title="使用 switch-case 实现简单的工厂模式"></a><strong>使用 switch-case 实现简单的工厂模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式的目标是封装一些经常变化的东西。 想象一下应用程序的调色板。 你可能必须每天根据设计师的最新习惯来更改颜色。 如果你不得不手动搜索和替换每个单独的颜色代码实例，那将给你带来极大的不便。 因此，让我们在Swift中创建一个简单的工厂，该工厂可以根据给定的样式返回颜色。 🎩</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> text</span><br><span class="line">        <span class="keyword">case</span> background</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> style: Style)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style &#123;</span><br><span class="line">        <span class="keyword">case</span> .text:</span><br><span class="line">            <span class="keyword">return</span> .black</span><br><span class="line">        <span class="keyword">case</span> .background:</span><br><span class="line">            <span class="keyword">return</span> .white</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> textColor = factory.create(.text)</span><br><span class="line"><span class="keyword">let</span> backgroundColor = factory.create(.background)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这真的很有用，尤其是涉及复杂的对象初始化过程时。 您还可以定义一个协议，并使用 <code>switch-case</code> 块返回实现所需接口的各种实例类型。 🚦</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevEnvironment</span>: <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"dev"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiveEnvironment</span>: <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"live"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnvironmentFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> dev</span><br><span class="line">        <span class="keyword">case</span> live</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> type: EnvType)</span></span> -&gt; <span class="type">Environment</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> type &#123;</span><br><span class="line">        <span class="keyword">case</span> .dev:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">DevEnvironment</span>()</span><br><span class="line">        <span class="keyword">case</span> .live:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">LiveEnvironment</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">EnvironmentFactory</span>()</span><br><span class="line"><span class="keyword">let</span> dev = factory.create(.dev)</span><br><span class="line"><span class="built_in">print</span>(dev.identifier)</span><br></pre></td></tr></table></figure><p>因此，有关简单工厂设计模式的几件事要记住：</p><ul><li>通过分离初始化和使用逻辑，有助于松耦合</li><li>它只是包装可以经常更改的东西的包装器</li><li>可以使用枚举和开关盒在Swift中实现简单的工厂</li><li>如果您计划返回不同的对象（POP🎉），请使用协议</li><li>保持简单🏭</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式将创建与实际用法分开，并将职责移至特定角色，因此，如果发生某些变化，你只需要修改工厂即可。 你可以保留所有测试，而其他所有功能则完全不受影响。 强大而简单！ 💪</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这次，我们来讨论简单的工厂设计模式，该模式使用Swift以一种非常简单的方式封装对象创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;使用-switch-case-实现简单的工厂模式&quot;&gt;&lt;a href=&quot;#使用-switch-case-实现简单的工厂模式&quot; class=&quot;headerlink&quot; title=&quot;使用 switch-case 实现简单的工厂模式&quot;&gt;&lt;/a&gt;&lt;strong&gt;使用 switch-case 实现简单的工厂模式&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这种模式的目标是封装一些经常变化的东西。 想象一下应用程序的调色板。 你可能必须每天根据设计师的最新习惯来更改颜色。 如果你不得不手动搜索和替换每个单独的颜色代码实例，那将给你带来极大的不便。 因此，让我们在Swift中创建一个简单的工厂，该工厂可以根据给定的样式返回颜色。 🎩&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="构造函数" scheme="http://www.xuebaonline.com/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="静态工厂方法" scheme="http://www.xuebaonline.com/tags/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift中构造函数与静态工厂方法的比较</title>
    <link href="http://www.xuebaonline.com/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>http://www.xuebaonline.com/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-04-25T04:19:43.000Z</published>
    <updated>2020-04-25T05:12:12.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当实例化对象时，哪个更好：构造函数还是静态工厂方法？ 我们来看一看。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我相信Joshua Bloch 在他的非常不错的书 《Effective Java》 中首先说了它：与构造函数相比，静态工厂方法是实例化对象的首选方法。 我不同意。 不仅因为我相信静态方法是纯粹的邪恶，而且主要是因为在这种特殊情况下，它们形成好的方法，使我们认为我们必须偏向使用它们。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从面向对象的角度分析推理并弄清楚其原因。这是一个具有一个主要构造函数和两个次要构造函数的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">Color</span>(<span class="type">String</span> rgb) &#123;</span><br><span class="line">        this(<span class="type">Integer</span>.parseInt(rgb, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Color</span>(int red, int green, int blue) &#123;</span><br><span class="line">        this(red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是带有三个静态工厂方法的类似类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromRGB(<span class="type">String</span> rgb) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(<span class="type">Integer</span>.parseInt(rgb, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromPalette(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromHex(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你更喜欢哪一个？</p><p>根据Joshua Bloch的说法，使用静态工厂方法而不是构造函数具有三个基本优点（实际上有四个优点，但是第四个不再适用于Java）：</p><ul><li>他们有名字。</li><li>他们可以缓存。</li><li>它们可以是子类型。</li></ul><p>我认为，如果设计错误，那么这三者都是很合理的。 它们是解决问题的好办法。 让我们一一介绍。</p><h1 id="命名存在"><a href="#命名存在" class="headerlink" title="命名存在"></a><strong>命名存在</strong></h1><p>这是使用构造函数制作 <code>red tomato</code> 颜色对象的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>这是使用静态工厂方法的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>makeFromPalette（）</code> 在语义上比新的 <code>Color（）</code> 更丰富。 如果我们将它们传递给构造函数，谁知道这三个数字意味着什么。 但是“palette”可以帮助我们立即解决所有问题。</p><p>但是，正确的解决方案是使用多态和封装，以将问题分解为几个语义丰富的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="type">Color</span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HexColor</span> <span class="title">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">HexColor</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RGBColor</span> <span class="title">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Color</span> origin;</span><br><span class="line">    <span class="type">RGBColor</span>(int red, int green, int blue) &#123;</span><br><span class="line">        this.origin = new <span class="type">HexColor</span>(</span><br><span class="line">            red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们使用类的构造函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">RGBColor</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure></br><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h1><p>假设我在应用程序中的多个位置需要一个 <code>red tomato</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// ... sometime later</span></span><br><span class="line"><span class="type">Color</span> red = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此创建两个对象，这显然是低效的，因为它们是相同的。 最好将第一个实例保留在内存中的某个位置，并在第二个调用到达时将其返回。 静态工厂方法可以解决这个问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// ... sometime later</span></span><br><span class="line"><span class="type">Color</span> red = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在 <code>Color</code> 内的某个地方，保存一个私有静态 <code>Map</code> ，其中已实例化了所有对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Map</span> &lt; <span class="type">Integer</span>, <span class="type">Color</span> &gt; <span class="type">CACHE</span> =</span><br><span class="line">        new <span class="type">HashMap</span> &lt; &gt; ();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromPalette(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">final</span> int hex = red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Color</span>.<span class="type">CACHE</span>.computeIfAbsent(</span><br><span class="line">            hex, h - &gt; new <span class="type">Color</span>(h)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是非常高效的。 对于像我们的 <code>Color</code> 这样的对象，问题可能不会那么明显，但是当对象较大时，其实例化和垃圾回收可能会浪费大量时间。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有一种面向对象的方法可以解决此问题。 我们只是介绍了一个新的类 <code>Palette</code> ，它将变成一个颜色存储区：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Palette</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Map</span> &lt; <span class="type">Integer</span>, <span class="type">Color</span> &gt; colors =</span><br><span class="line">        new <span class="type">HashMap</span> &lt; &gt; ();</span><br><span class="line">    <span class="type">Color</span> take(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">final</span> int hex = red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue;</span><br><span class="line">        <span class="keyword">return</span> this.computerIfAbsent(</span><br><span class="line">            hex, h - &gt; new <span class="type">Color</span>(h)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们一次创建一个 <code>Palette</code> 实例，并要求它在每次需要时向我们返回一种颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = palette.take(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// Later we will get the same instance:</span></span><br><span class="line"><span class="type">Color</span> red = palette.take(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p><strong>没有静态方法，没有静态属性。</strong></p></br><h1 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a><strong>子类型</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们的 <code>Color</code> 类具有 <code>lighter()</code> 方法，该方法应该将颜色转移到下一个可用的 <code>lighter</code> 上：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    protected <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(hex + <span class="number">0x111</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有时更希望通过一组可用的 <code>Pantone</code> 颜色选择下一种较浅的颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PantoneColor</span> <span class="title">extends</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">PantoneName</span> pantone;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">String</span> name) &#123;</span><br><span class="line">        this(new <span class="type">PantoneName</span>(name));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">PantoneName</span> name) &#123;</span><br><span class="line">        this.pantone = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">PantoneColor</span>(this.pantone.up());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建一个静态工厂方法，该方法将决定哪种 <code>Color</code> 实现最适合我们：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> code;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> make(int h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> new <span class="type">PantoneColor</span>(<span class="string">"19-1664 TPX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">RGBColor</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果要求使用真正的红色，我们将返回 <code>PantoneColor</code> 的一个实例。 在所有其他情况下，它只是标准的 <code>RGBColor</code> 。 该决定是通过静态工厂方法做出的。 这就是我们所说的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> color = <span class="type">Color</span>.make(<span class="number">0xBF1932</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于构造函数只能返回在其中声明的类，因此不可能对构造函数执行相同的 <code>“forking”</code> 。静态方法具有返回 <code>Color</code> 的任何子类型所需的所有自由。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是，在面向对象的世界中，我们可以而且必须以不同的方式去做。 首先，我们将 <code>Color</code> 设置为接口：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="type">Color</span> &#123;</span><br><span class="line">    <span class="type">Color</span> lighter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们将需要的构造方法移至其自己的类 <code>Colors</code> ，就像在上一个示例中所做的那样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colors</span> </span>&#123;</span><br><span class="line">    <span class="type">Color</span> make(int h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> new <span class="type">PantoneColor</span>(<span class="string">"19-1664-TPX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">RGBColor</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而且我们将使用 <code>Colors</code> 类的实例，而不是 <code>Color</code> 内部的静态方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colors.make(<span class="number">0xBF1932</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，这仍然不是真正的面向对象的思维方式，因为我们正在将决策权从它所属的对象上移开。 通过静态工厂方法 <code>make（</code>）或新类 <code>Colors</code> （实际上并不重要），我们将对象分成两部分。 第一部分是对象本身，第二部分是决策算法，它位于其他地方。<br>面向对象的设计是将逻辑放入 <code>PantoneColor</code> 类的对象中，该对象将装饰原始的RGBColor：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PantoneColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Color</span> origin;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">Color</span> color) &#123;</span><br><span class="line">        this.origin = color;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Color</span> next;</span><br><span class="line">        <span class="keyword">if</span> (this.origin.hex() == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            next = new <span class="type">RGBColor</span>(<span class="number">0xD12631</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next = this.origin.lighter();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">PantoneColor</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建一个 <code>RGBColor</code> 实例，并使用 <code>PantoneColor</code> 装饰它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> red = new <span class="type">PantoneColor</span>(</span><br><span class="line">    new <span class="type">RGBColor</span>(<span class="number">0xBF1932</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要求红色返回较浅的颜色，它返回 <code>Pantone</code> 调色板中的一种，而不是仅在 <code>RGB</code> 坐标中较浅的颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> lighter = red.lighter(); <span class="comment">// 0xD12631</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，这个示例是原始的，如果我们真的希望它适用于所有 <code>Pantone</code> 颜色，则需要进一步改进。 逻辑必须保留在类内部，而不是外部，静态工厂方法甚至其他补充类中。 当然，我在说的是属于这个特定类的逻辑。 如果与类实例的管理有关，则可以有容器和存储，就像上面的上一个示例一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总而言之，我强烈建议您不要使用静态方法，尤其是当它们要替换对象构造函数时。 通过其构造函数生成对象是任何面向对象软件中最“神圣”的时刻，请不要错过它的美丽。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当实例化对象时，哪个更好：构造函数还是静态工厂方法？ 我们来看一看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我相信Joshua Bloch 在他的非常不错的书 《Effective Java》 中首先说了它：与构造函数相比，静态工厂方法是实例化对象的首选方法。 我不同意。 不仅因为我相信静态方法是纯粹的邪恶，而且主要是因为在这种特殊情况下，它们形成好的方法，使我们认为我们必须偏向使用它们。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="构造函数" scheme="http://www.xuebaonline.com/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="静态工厂方法" scheme="http://www.xuebaonline.com/tags/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift静态工厂设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T03:48:39.000Z</published>
    <updated>2020-04-25T04:21:36.398Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，我们一起看一下有关 <a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95" target="_blank" rel="noopener" title="静态工厂设计模式">静态工厂设计模式</a> 的知识，并展示一些使用Swift编程语言的用例。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。” </p></blockquote><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个对象常常需要复杂的过程，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。</p></blockquote></br><h1 id="静态工厂模式示例"><a href="#静态工厂模式示例" class="headerlink" title="静态工厂模式示例"></a><strong>静态工厂模式示例</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象创建中的有些过程包括决定创建哪个对象、管理对象的生命周期，以及管理特定对象的创建和销毁的概念。</p></blockquote><h2 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a><strong>命名构造函数</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于静态装饰模式的第一个好处是，每个静态装饰方法都可以有一个名称。 <code>Apple</code> 在其 <code>UIColor</code> 类实现中使用此模式来创建诸如 <code>.red</code> ，<code>.yellow</code> 等的命名颜色。请注意，<code>Swift</code> 中的实现实际上不是方法，而是静态属性，它返回实际实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">TimeInterval</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> second: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> minute: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">60</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> hour: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">3_600</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> day: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">86_400</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> week: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">604_800</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果很难记住一天或一周是几秒钟，为什么不为它创建一个命名初始化器。 看到 <code>TimeInterval.week</code> 比 <code>604_800</code> 好得多。 😅</p></br><h2 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a><strong>缓存对象</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态工厂模式的下一个优点是，为了更好地使用内存，它可以支持缓存。 这样，如果你通过静态构造函数（也称为<a href="http://www.xuebaonline.com/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/" title="Swift中构造函数与静态工厂方法的比较">静态工厂方法</a>）对其进行初始化，则可以限制所创建对象的数量。 🏭</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - cache</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> cache: [<span class="type">String</span>:<span class="type">Service</span>] = [:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cached</span><span class="params">(name: String)</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">Service</span>.cache[name] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="type">Service</span>.cache[name] = <span class="type">Service</span>(named: name)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cache[name]!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - static factory</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> local: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cached(name: <span class="string">"local"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> remote: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cached(name: <span class="string">"remote"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(named name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h2 id="本地初始化范围"><a href="#本地初始化范围" class="headerlink" title="本地初始化范围"></a><strong>本地初始化范围</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于静态工厂方法的另一个好处是，你可以将类的初始化限制为私有作用域。 换句话说，只能通过静态工厂方法进行对象创建。 你只需要将 <code>init</code> 方法设为私有。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> local: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>(name: <span class="string">"local"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> remote: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>(name: <span class="string">"remote"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>请注意，您可以使用 <code>final＆static</code> 关键字限制子类化。 如果要允许子类化，则应删除 <code>final</code> 并为属性使用 <code>class</code> 关键字而不是 <code>static</code> ，这样子类可以覆盖工厂方法。</strong> 🤔</p></br><h2 id="静态返回任何数据"><a href="#静态返回任何数据" class="headerlink" title="静态返回任何数据"></a><strong>静态返回任何数据</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 静态工厂也可以返回给定对象的子类型，但是为什么我们不更进一步呢？ 你还可以从静态方法返回任何类型的数据，我知道这似乎是一种作弊，因为我不是在这里创建 <code>UIColor</code> 的实例，但是我相信在这里值得一提这个方法，静态工厂。 有时，这个技术可能非常有用。 😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span><span class="params">(with color: UIColor)</span></span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">1</span>, height: <span class="number">1</span>)</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(rect.size)</span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()!</span><br><span class="line">        context.setFillColor(color.cgColor)</span><br><span class="line">        context.fill(rect)</span><br><span class="line">        <span class="keyword">let</span> img = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> img!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> redImage: <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>.image(with: .red)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在本文中，我们一起看一下有关 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;静态工厂设计模式&quot;&gt;静态工厂设计模式&lt;/a&gt; 的知识，并展示一些使用Swift编程语言的用例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。” &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift生成器模式</title>
    <link href="http://www.xuebaonline.com/Swift%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T03:24:29.000Z</published>
    <updated>2020-04-25T03:49:52.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>了解如何在Swift中实现生成器模式，以隐藏创建具有许多单独属性的对象的复杂性。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>iOS</code> 开发中，会使用到很多设计模式，<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="生成器模式">生成器模式</a> 也叫构建器模式，我们也会经常用到。在以下的行文过程中均使用生成器模式来表述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成器模式（英：Builder Pattern）是一种设计模式，又名：建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p><a id="more"></a></br><h1 id="生成器模式如何工作？"><a href="#生成器模式如何工作？" class="headerlink" title="生成器模式如何工作？"></a><strong>生成器模式如何工作？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成器模式可以通过多种方式实现，但是如果你了解该模式的主要目标，那实际上就没有关系：</p><blockquote><p><strong>Builder设计模式的目的是将复杂对象的构造与其表示分开。</strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如果你有一个具有很多属性的对象，想隐藏初始化过程的复杂性，可以编写一个生成器并通过该生成器构造该对象。 它可以像控制整个构建过程的构建方法或外部类一样简单。 这完全取决于给定的环境。 🏗</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，我们对该设计模式有一个详细的认知，让我们来看一下使用实例和强大的 <code>Swift</code> 编程语言的生成器模式！ 💪</p></br><h1 id="简单的-Emitter-生成器"><a href="#简单的-Emitter-生成器" class="headerlink" title="简单的 Emitter 生成器"></a><strong>简单的 Emitter 生成器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SKEmitterNode</code> 是一个很好的例子。 如果要创建自定义 <code>Emitter</code> 并以编程方式设置属性（通常用于 <code>SpriteKit</code> 游戏），则像这样的 <code>Emitter</code> 生成器类可能是一个合理的解决方案。 👾</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmitterBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKEmitterNode</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> emitter = <span class="type">SKEmitterNode</span>()</span><br><span class="line">        emitter.particleTexture = <span class="type">SKTexture</span>(imageNamed: <span class="string">"MyTexture"</span>)</span><br><span class="line">        emitter.particleBirthRate = <span class="number">100</span></span><br><span class="line">        emitter.particleLifetime = <span class="number">60</span></span><br><span class="line">        emitter.particlePositionRange = <span class="type">CGVector</span>(dx: <span class="number">100</span>, dy: <span class="number">100</span>)</span><br><span class="line">        emitter.particleSpeed = <span class="number">10</span></span><br><span class="line">        emitter.particleColor = .red</span><br><span class="line">        emitter.particleColorBlendFactor = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> emitter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">EmitterBuilder</span>().build()</span><br></pre></td></tr></table></figure></br><h1 id="简单的-theme-生成器"><a href="#简单的-theme-生成器" class="headerlink" title="简单的 theme 生成器"></a><strong>简单的 theme 生成器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们远离游戏，想象一下你正在为UIKit应用程序创建一个主题引擎，该引擎具有许多自定义字体，颜色等。生成器对于构造独立主题可能很有用。 🔨</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> textColor: <span class="type">UIColor?</span></span><br><span class="line">    <span class="keyword">let</span> backgroundColor: <span class="type">UIColor?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> light</span><br><span class="line">        <span class="keyword">case</span> dark</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(<span class="number">_</span> style: Style)</span></span> -&gt; <span class="type">Theme</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style &#123;</span><br><span class="line">        <span class="keyword">case</span> .light:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Theme</span>(textColor: .black, backgroundColor: .white)</span><br><span class="line">        <span class="keyword">case</span> .dark:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Theme</span>(textColor: .white, backgroundColor: .black)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="type">ThemeBuilder</span>()</span><br><span class="line"><span class="keyword">let</span> light = builder.build(.light)</span><br><span class="line"><span class="keyword">let</span> dark = builder.build(.dark)</span><br></pre></td></tr></table></figure></br><h1 id="“Chained”-URL构建器"><a href="#“Chained”-URL构建器" class="headerlink" title="“Chained” URL构建器"></a><strong>“Chained” URL构建器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用这种方法，你可以通过多种方法配置对象，并且每个方法都将返回相同的生成器对象。 这样，您可以链接配置，并在最后一步构建最终对象实例。 ⛓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> components: <span class="type">URLComponents</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.components = <span class="type">URLComponents</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(scheme: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.scheme = scheme</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(host: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.host = host</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(port: Int)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.port = port</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(path: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> path = path</span><br><span class="line">        <span class="keyword">if</span> !path.hasPrefix(<span class="string">"/"</span>) &#123;</span><br><span class="line">            path = <span class="string">"/"</span> + path</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.components.path = path</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addQueryItem</span><span class="params">(name: String, value: String)</span></span> -&gt; <span class="type">URLBuilder</span>  &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.components.queryItems == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.components.queryItems = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.components.queryItems?.append(<span class="type">URLQueryItem</span>(name: name, value: value))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">URL?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.components.url</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URLBuilder</span>()</span><br><span class="line">    .<span class="keyword">set</span>(scheme: <span class="string">"https"</span>)</span><br><span class="line">    .<span class="keyword">set</span>(host: <span class="string">"localhost"</span>)</span><br><span class="line">    .<span class="keyword">set</span>(path: <span class="string">"api/v1"</span>)</span><br><span class="line">    .addQueryItem(name: <span class="string">"sort"</span>, value: <span class="string">"name"</span>)</span><br><span class="line">    .addQueryItem(name: <span class="string">"order"</span>, value: <span class="string">"asc"</span>)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure></br><h1 id="director-类的生成器模式"><a href="#director-类的生成器模式" class="headerlink" title="director 类的生成器模式"></a><strong>director 类的生成器模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们认识一下 <code>director</code> 实例。 使构建器与确切的配置部分解耦。 因此，举例来说，你可以制作带有圆圈的游戏，但是后来如果你改变主意并想使用正方形，那相对容易。 你只需要创建一个新的生成器，其他所有内容都可以相同。 🎬</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NodeBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">SKColor</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NodeDirector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> builder: <span class="type">NodeBuilder</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleNodeBuilder</span>: <span class="title">NodeBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">SKColor</span> = .clear</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="type">SKShapeNode</span>(circleOfRadius: <span class="keyword">self</span>.size)</span><br><span class="line">        node.name = <span class="keyword">self</span>.name</span><br><span class="line">        node.fillColor = <span class="keyword">self</span>.color</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerNodeDirector</span>: <span class="title">NodeDirector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> builder: <span class="type">NodeBuilder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(builder: <span class="type">NodeBuilder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.builder = builder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.builder.name = <span class="string">"Hello"</span></span><br><span class="line">        <span class="keyword">self</span>.builder.size = <span class="number">32</span></span><br><span class="line">        <span class="keyword">self</span>.builder.color = .red</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.builder.build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="type">CircleNodeBuilder</span>()</span><br><span class="line"><span class="keyword">let</span> director = <span class="type">PlayerNodeDirector</span>(builder: builder)</span><br><span class="line"><span class="keyword">let</span> player = director.build()</span><br></pre></td></tr></table></figure><h1 id="基于Block的构建器"><a href="#基于Block的构建器" class="headerlink" title="基于Block的构建器"></a><strong>基于Block的构建器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一种更快捷的方法是使用 <code>Block</code> 而不是生成器类来配置对象。 当然，我们可以争论这是否仍然是生成器模式…😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(block: <span class="params">(<span class="params">(UILabel)</span></span></span></span> -&gt; <span class="type">Void</span>)) -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        block(label)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> label = <span class="type">UILabel</span>.build &#123; label <span class="keyword">in</span></span><br><span class="line">    label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    label.text = <span class="string">"Hello wold!"</span></span><br><span class="line">    label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 请注意，生成器的实现可能会因具体实例而异。 有时，生成器模式与工厂模式结合在一起。 对此，几乎每个人都以不同的方式解释它，但是我认为这不是问题。 设计模式是精心设计的准则，但有时你必须这么做。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;了解如何在Swift中实现生成器模式，以隐藏创建具有许多单独属性的对象的复杂性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 &lt;code&gt;iOS&lt;/code&gt; 开发中，会使用到很多设计模式，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;生成器模式&quot;&gt;生成器模式&lt;/a&gt; 也叫构建器模式，我们也会经常用到。在以下的行文过程中均使用生成器模式来表述。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成器模式（英：Builder Pattern）是一种设计模式，又名：建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="生成器模式" scheme="http://www.xuebaonline.com/tags/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>在Swift中重构单例模式用法</title>
    <link href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/"/>
    <id>http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/</id>
    <published>2020-04-25T02:38:47.000Z</published>
    <updated>2020-04-25T03:52:42.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>清洁，模块化和可测试代码库的小技巧。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件开发中，不鼓励使用单例，并且对此表示反对，但这是有充分理由的。 它们很难测试或无法测试，并且在其他类中隐式使用它们时会纠缠你的代码库，从而使代码重用变得困难。 在大多数情况下，单例模式无非是对全局易变状态的保存。 每个人至少知道这是一个糟糕的主意。 但是，<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="单例模式">单例模式</a> 有时是不可避免和必要的错误。 我们如何以一种干净，模块化和可测试的方式将它们合并到我们的代码中？</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 </p></blockquote><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p></blockquote><h1 id="单例模式无处不在"><a href="#单例模式无处不在" class="headerlink" title="单例模式无处不在"></a><strong>单例模式无处不在</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 <code>Apple</code> 平台上，<code>Cocoa</code> 和 <code>Cocoa Touch</code> 框架中到处都有单例。 有 <code>UIApplication.shared</code>，<code>FileManager.default</code>，<code>NotificationCenter.default</code>，<code>UserDefaults.standard</code>，<code>URLSession.shared</code> 等。 设计模式甚至在 <code>Cocoa</code> 核心能力指南中都有自己的部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当你隐式引用这些（以及你自己的）单例时，将增加更改代码所需的工作量。 这也使测试代码变得困难或不可能，因为无法从使用它们的类之外更改或模拟这些单例。 这是你在iOS应用中都会看到的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentUser = <span class="type">CurrentUserManager</span>.shared.user</span><br><span class="line">        <span class="keyword">if</span> currentUser != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// do something with current user</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mySetting = <span class="type">UserDefaults</span>.standard.bool(forKey: <span class="string">"mySetting"</span>)</span><br><span class="line">        <span class="keyword">if</span> mySetting &#123;</span><br><span class="line">            <span class="comment">// do something with setting</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">URLSession</span>.shared.dataTask(with: <span class="type">URL</span>(string: <span class="string">"http://someResource"</span>)!) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// handle response</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这就是我所说 隐式引用 的意思-你只需在类中直接使用单例。 我们可以做得更好。 在Swift中，有一种轻量级，简便且影响小的方式来改善这一点。 Swift也使其使用起来更加优雅。</p><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简而言之，答案是 <a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener" title="依赖注入"><strong>依赖注入</strong></a> 。 该原则表明你应该设计类和函数，以使所有输入都是显式的。 如果你重构上面的代码片段以使用依赖项注入，它将看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> userManager: <span class="type">CurrentUserManager</span></span><br><span class="line">    <span class="keyword">let</span> defaults: <span class="type">UserDefaults</span></span><br><span class="line">    <span class="keyword">let</span> urlSession: <span class="type">URLSession</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userManager: <span class="type">CurrentUserManager</span>, defaults: <span class="type">UserDefaults</span>, urlSession: <span class="type">URLSession</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">        <span class="keyword">self</span>.defaults = defaults</span><br><span class="line">        <span class="keyword">self</span>.urlSession = urlSession</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentUser = userManager.user</span><br><span class="line">        <span class="keyword">if</span> currentUser != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// do something with current user</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mySetting = defaults.bool(forKey: <span class="string">"mySetting"</span>)</span><br><span class="line">        <span class="keyword">if</span> mySetting &#123;</span><br><span class="line">            <span class="comment">// do something with setting</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        urlSession.dataTask(with: <span class="type">URL</span>(string: <span class="string">"http://someResource"</span>)!) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// handle response</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此类不再隐式（或显式）依赖于任何单例。 它显式依赖于 <code>CurrentUserManager</code>， <code>UserDefaults</code> 和 <code>URLSession</code> ，但是有关这些依赖项的任何内容均表示它们是单例。 这个细节不再重要，但是功能保持不变。 视图控制器仅知道这些对象的实例存在。 在需要使用该对象时，你可以传递单例。 同样，从类的角度来看，此细节无关紧要。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>(userManager: .shared, defaults: .standard, urlSession: .shared)</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p><strong>特别提示：<code>Swift</code> 类型推断在这里起作用。 除了编写 <code>URLSession.shared</code>，您还可以编写 <code>.shared</code> 。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你需要提供其他默认值（例如，如果你需要与<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW6" target="_blank" rel="noopener" title="应用组内共享数据">应用组共享数据</a>），则更改起来很容易。 实际上，你不必更改此类中的任何代码。 而不传递 <code>UserDefaults.standard</code>，而是传递 <code>UserDefaults（suiteName：“ com.myApp”）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，在单元测试中，你现在可以传递这些类的其他实例。 在Swift中无法进行真正的模拟，但是有一些解决方法。 这取决于您要如何构造代码。 你可以为 <code>CurrentUserManager</code> 使用协议，然后可以在测试中“模拟”该协议。 你可以为 <code>UserDefaults</code> 提供构造的方法类进行测试。 你可以将 <code>URLSession</code> 设置为可选，并在测试中传递 <code>nil</code>。</p><h1 id="重构陷阱"><a href="#重构陷阱" class="headerlink" title="重构陷阱"></a><strong>重构陷阱</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能对这个想法很感兴趣，现在你想解开并解放陷入困境的代码库。尽管依赖注入是理想的选择，并且可以为你提供更纯净的对象模型，但是实现它通常很困难。更重要的是，在首次编写代码时，很少会设计出适应这种情况的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们上面重构的内容现在更具模块化和可测试性-但确实存在问题。 <code>MyViewController</code> 的初始值设定项曾经是空的 <code>（init（））</code> ，但现在需要三个参数。每个调用位置都必须更改。构造此方法的干净而正确的方法是将实例从上到下或从以前的视图控制器传递到此实例。这将需要将数据从对象图的根传递到所有子类。特别是在iOS中，当你将数据从视图控制器传递到视图控制器时，这可能会引起很多麻烦。尤其是传统代码库将难以立即实现如此大的更改。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大多数类（尤其是视图控制器）的初始化程序都需要更改。当你意识到必须重构整个应用程序时，这种更改变得异常困难。要么一切都将被破坏，要么仅某些类将被更新以进行依赖注入，而其他一些类将继续隐式引用单例。这种不一致可能在将来引起问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在复杂、大型的旧版代码库中，这样的重构可能根本不可行-至少不能同时进行，而且也不能没有回归。因此，你可能会争辩说，你根本不应该重构并忍受这种情况。然后需要几个月或几年的时间你您必须支持多个用户-现在在实现切换帐户时 <code>CurrentUserManager</code> 无法正常工作。你如何应对？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一种更为先进的方式，也有一种从一开始就设计你要使用的类以适应下一次此类变化的方法。</p><h1 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a><strong>默认参数值</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最喜欢的Swift功能之一是默认参数值。 它们非常有用，可以为你的代码带来很大的灵活性。 使用默认参数，你可以解决上述问题，而不必担心依赖注入问题，也不会在代码库中引入过多的复杂性。 也许你的应用程序实际上只有一个用户，所以实现所有这种依赖注入是不必要的开销。</p><p>你可以给单例设置默认参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userManager: <span class="type">CurrentUserManager</span> = .shared, defaults: <span class="type">UserDefaults</span> = .standard, urlSession: <span class="type">URLSession</span> = .shared) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">        <span class="keyword">self</span>.defaults = defaults</span><br><span class="line">        <span class="keyword">self</span>.urlSession = urlSession</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，从方法调用的角度来看，初始化程序没有改变。 但是类本身存在很大的差异，它现在使用依赖项注入，不再引用单例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>()</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你从此更改中学到了什么？你可以使用此模式重构每个类，而无需更新任何调用的地方。语义上或功能上都没有改变。但是，你的类也在使用依赖注入。他们只是在内部使用实例。你可以如上所述测试它们并维护一个灵活的模块化API，同时公共接口保持不变。本质上，你可以继续在代码库中工作，就好像什么都没有改变一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有时间传入自定义非空参数，你可以执行此操作而无需更改任何类。你只需要更新调用的位置即可。此外，如果你决定使用成熟的依赖关系注入并从上至下传递每个单个依赖关系，则只需删除默认参数并从上方传递依赖关系。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要，你甚至可以选择加入或选择退出任何默认值。在以下示例中，我们提供了自定义 <code>UserDefaults</code>，但保留了 <code>CurrentUserManager</code> 和 <code>URLSession</code> 的默认参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appGroupDefaults = <span class="type">UserDefaults</span>(suiteName: <span class="string">"com.myApp"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>(defaults: appGroupDefaults)</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></bar><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 使这种“部分”依赖注入变得很方便实用。通过为类添加新属性和带有默认值的初始化参数，你可以使你的代码具有更大的模块化和可测试性，而不必重构，也不必完全使用成熟的依赖项注入。如果从一开始就设计这样的类，那么你会发现自己写出 <code>bug</code> 的概率降低了很多-当你遇到 <code>bug</code> 是，将更容易定位和解决。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 除了此处的简单示例（类，结构，枚举，函数）之外，你还可以将这些概念和设计应用于代码的所有区域。 <code>Swift</code> 中的每个函数都可以采用默认参数值。通过花一些时间来思考未来可能发生的变化，我们可以创建可以轻松适应变化的类型和功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 构建和设计好的软件意味着编写<strong>易于更改</strong>但<strong>难以破解的代码</strong>。这就是依赖项注入的动机，而 <code>Swift</code> 的默认参数可以帮助你快速，轻松且优雅地实现这一目标。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;清洁，模块化和可测试代码库的小技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在软件开发中，不鼓励使用单例，并且对此表示反对，但这是有充分理由的。 它们很难测试或无法测试，并且在其他类中隐式使用它们时会纠缠你的代码库，从而使代码重用变得困难。 在大多数情况下，单例模式无非是对全局易变状态的保存。 每个人至少知道这是一个糟糕的主意。 但是，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;单例模式&quot;&gt;单例模式&lt;/a&gt; 有时是不可避免和必要的错误。 我们如何以一种干净，模块化和可测试的方式将它们合并到我们的代码中？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="单例模式" scheme="http://www.xuebaonline.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift单例模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T02:13:37.000Z</published>
    <updated>2020-04-25T03:13:50.738Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Singleto</code>n 是有史以来最受争议的设计模式。了解在 <code>iOS</code> 项目中使用 <code>Swift</code> 单例类的正确方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每个人都在批评的单例模式，大多数人都将其称为反模式。但是单例模式到底是什么，为什么这么差呢？</p><a id="more"></a><h1 id="Singleton-是什么"><a href="#Singleton-是什么" class="headerlink" title="Singleton 是什么?"></a><strong>Singleton 是什么?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于简单，这是一种非常流行且普遍采用的模式。在整个应用程序生命周期中，单例类只能有一个实例。单个实例只能通过静态属性访问，并且初始化后的对象通常在全局范围内共享。这就像一个全局变量。 🌏</p><h1 id="全局变量和状态"><a href="#全局变量和状态" class="headerlink" title="全局变量和状态"></a><strong>全局变量和状态</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式的声誉很差，因为他们共享全局可变的状态。即使在经验丰富的开发人员圈子中，始终会担心使用 <code>global</code> 关键字。全局状态和变量是副作用的温床。可以从程序的任何位置访问全局变量，因此使用它们的类将变为有状态，不安全，紧密耦合且难以调试。出于明显的原因，通过这种方式与对象共享状态不是一个好习惯。 🤮</p><h1 id="Singleton-的副作用"><a href="#Singleton-的副作用" class="headerlink" title="Singleton 的副作用"></a><strong>Singleton 的副作用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你应该尽可能确定范围和隔离变量，并最大程度地减少代码的状态性。这将消除副作用，使您的代码更安全地使用。考虑以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// method is written by someone else</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    global = x</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">global = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> result = square(<span class="number">5</span>)</span><br><span class="line">result += global <span class="comment">//we assume that global is 1</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">//wtf 30 it should be 26</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>square</code> 方法由其他人编写，由于某种原因，他们希望将输入存储在相同的全局变量中。现在，当您调用该函数时，除非您查看他的代码，否则您将一无所获。想象一下，在一个由多个代码作者编写的具有大量oop类的项目中的此类问题……GOOD LUCK! 🐛🐛🐛</p><h1 id="单例对象的生命周期"><a href="#单例对象的生命周期" class="headerlink" title="单例对象的生命周期"></a><strong>单例对象的生命周期</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 单例创建一次并永久存在，它们的工作几乎就像全局变量一样，这就是为什么你必须格外小心。你应该仅使用在应用程序整个生命周期内都能维持的单例状态来管理这些状态。例如，特定于用户的会话通常是不好的做法，你应该重新考虑设计。另外，默认情况下，Swift也不是线程安全的，因此，如果你使用单例，则还必须为多线程问题做好准备。但是，如果它们因此造成问题，我们难道不应该完全避免它们吗？答案是不。 🚫</p><h1 id="我们应该在什么时候使用单例类"><a href="#我们应该在什么时候使用单例类" class="headerlink" title="我们应该在什么时候使用单例类"></a><strong>我们应该在什么时候使用单例类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>UIApplication</code> 很可能是单例的，因为应该只有一个应用程序实例，并且该实例应该一直存在，直到你将其关闭为止。这就是单例的完美例子。另一个用例可以是 <code>Logger</code> 类。使用单例是安全的，因为无论记录器是否打开，你的应用程序的行为都不会有所不同。没有其他人会拥有或管理记录器，并且你只会将信息传递到记录器中，因此状态不会混乱。<strong>结论：对于单例模式的使用，控制台或记录器类是完全可以接受的方案。</strong> 👏</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Console</span>.<span class="keyword">default</span>.notice(<span class="string">"Hello I'm a singleton!"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apple 框架中有很多“单一”（并非一切都是真正的单例对象）用例，这是一个简短列表，因此您可以从中获得一些启发：</p><ul><li>HTTPCookieStorage.shared</li><li>URLCredentialStorage.shared</li><li>URLSessionConfiguration.default</li><li>URLSession.shared</li><li>FileManager.default</li><li>Bundle.main</li><li>UserDefaults.standard</li><li>NotificationCenter.default</li><li>UIScreen.main</li><li>UIDevice.current</li><li>UIApplication.shared</li><li>MPMusicPlayerController.systemMusicPlayer</li><li>GKLocalPlayer.localPlayer（）</li><li>SKPaymentQueue.default（）</li><li>WCSession.default</li><li>CKContainer.default（）</li><li>etc</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经看到许多管理器类以单例形式实现，例如网络，位置或核心数据管理器，但是这些对象通常不应该是单例，仅仅是因为它可以是多个单例。 💩</p><p><strong>单例模式可能非常有用，但应谨慎使用。</strong></p><p>如果要将某个类变成单例，请问自己以下问题：</p><ul><li>还有其他任何东西拥有，管理或负责吗？</li><li>是否将只有一个实例？</li><li>它会是一个全局状态变量吗？</li><li>我真的应该使用全局共享对象吗？</li><li>是否应该贯穿整个应用程序生命周期？</li><li>有其他选择吗？</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果以上所有内容的答案都是肯定的，那么您可以“安全地”使用单例或全局变量来存储数据。 🎉🎉🎉</p><h1 id="如何使用Swift创建一个单例"><a href="#如何使用Swift创建一个单例" class="headerlink" title="如何使用Swift创建一个单例?"></a><strong>如何使用Swift创建一个单例?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建单例对象确实很容易，但是在应用此设计模式之前，请务必三思而后行，并考虑其他选择。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Singleton</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// don't forget to make this private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> singleton = <span class="type">Singleton</span>.shared</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，我总是创建一个特定的单例对象，称为App。通过这种方式，我可以将与应用程序相关的全局状态属性连接到那个单例中。命名约定也有助于关联和理解其中的内容。 💡</p><h1 id="如何消除单例"><a href="#如何消除单例" class="headerlink" title="如何消除单例?"></a><strong>如何消除单例?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果还有其他方法，则应在大约90％的情况下使用该方法。单例模式最常见的替代解决方案是依赖注入。首先，你应该将单例方法抽象为协议，然后，如果仍然需要，可以将其用作默认实现。现在，您可以将单例或<a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/" title="重构对象">重构的对象</a>注入正确的位置。这样，你的代码就可以使用协议的模拟对象进行测试，甚至可以忽略单例本身。 😎</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">DataCompletionBlock</span> = (<span class="type">Data?</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. abstract away the required functions</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. make your "singleton" conform to the protocol</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSession</span>: <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> task = <span class="keyword">self</span>.dataTask(with: request) &#123; data, <span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            completionHandler(data)</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> session: <span class="type">Session</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. using dependency injection with the "singleton" object</span></span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">Session</span> = <span class="type">URLSession</span>.shared) &#123;</span><br><span class="line">        <span class="keyword">self</span>.session = session</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(<span class="number">_</span> request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.session.make(request: request, completionHandler: completionHandler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. create mock object</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockedSession</span>: <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        completionHandler(<span class="string">"Mocked data response"</span>.data(using: .utf8))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. write your tests</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> api = <span class="type">ApiService</span>(session: <span class="type">MockedSession</span>())</span><br><span class="line">    <span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)!)</span><br><span class="line">    api.load(request) &#123; data <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(data: data!, encoding: .utf8)!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像你看到的，单例模式非常容易实现，但是很难决定其应用程序形式。我并不是说这是一种反模式，因为显然不是这样，但是如果你打算使用单例模式，请当心。 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Singleto&lt;/code&gt;n 是有史以来最受争议的设计模式。了解在 &lt;code&gt;iOS&lt;/code&gt; 项目中使用 &lt;code&gt;Swift&lt;/code&gt; 单例类的正确方法。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 每个人都在批评的单例模式，大多数人都将其称为反模式。但是单例模式到底是什么，为什么这么差呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="单例模式" scheme="http://www.xuebaonline.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>NSCODER和SWIFT初始化</title>
    <link href="http://www.xuebaonline.com/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://www.xuebaonline.com/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2020-04-25T01:36:42.000Z</published>
    <updated>2020-04-25T01:53:24.699Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您正在使用 <code>Swift</code> 并想对实现 <code>NSCoding</code> 的东西进行子类化（例如 <code>UIView</code>，<code>UIViewController</code> 等），则可能会遇到麻烦的情况。即，<code>NSCoding</code> 协议需要 <code>init(coder：aDecoder)</code> 初始化程序，这意味着如果你为超类重写了指定的初始化程序，则需要实现该初始化程序。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那就好了，但是 <code>Swift</code> 在确保对类的所有属性进行超级严格的调用之前，都要确保在 <code>init()</code> 中分配了一个值。这意味着，如果您想提供自己的初始化程序，则无法执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    name = <span class="string">"Bar"</span></span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle:<span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>init（coder :)</code> 初始值设定项未设置 <code>name</code> 属性，因此不会进行编译。你可以在两个初始值设定项中都重复初始化和设置名称，但是当你在init中进行了很多工作时，这很糟糕（如果希望尽可能避免使用可选属性，则应该这样做）。</p><p>在 Objective-C 中，如果要在多个 <code>init</code> 方法之间共享初始化逻辑，则只需定义一个通用的 <strong>“setup”</strong> 方法即可执行所有共享的东西，并从两个初始化器中调用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype) <span class="keyword">init</span> &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span> <span class="keyword">self</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype) initWithCoder:(<span class="type">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span> <span class="keyword">self</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) setup &#123;</span><br><span class="line">  <span class="keyword">self</span>.name = @<span class="string">"Foo"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  这种方式不会立即就创建出你想要的对象。问题在于，在这两个初始化程序中，我们都在调用    <code>[super init]</code> 之前，先给 <code>self.name</code> 分配了一个值，但这在 <code>Swift</code> 语法中是不可行的。我们也不能将对 <code>self.setup</code> 的调用移到对 <code>super.init（）</code> 的调用之上，因为在类通过调用 <code>super.init（）</code> 完全初始化之后，才允许您引用 <code>self</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  那么，如何将这只鸡从鸡蛋中取出并放到盘子上呢？好吧，我们要等到初始化后才能对 <code>self</code> 调用方法，但是只要我们从 <strong>“convienience”</strong> 初始化程序中调用它，就可以调用另一个 <code>init</code> 。仅通过示例进行解释可能更容易：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> coder: <span class="type">NSCoder?</span> = <span class="literal">nil</span>) &#123;</span><br><span class="line">    name = <span class="string">"Bar"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> coder = coder &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle:<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(coder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在指定的初始化程序中添加了一个可选的 <code>NSCoder</code> 参数，并将其默认设置为 <code>nil</code> ，因此我们仍然可以像以前一样在没有任何参数的情况下调用它。但是，现在已将<code>NSCoding</code> 协议中要求的 <code>init（coder :)</code> 初始值设定项标记为<strong>convienience</strong>，这意味着它可以调用指定的初始值设定项并传入编码器。</p><p>在指定的 <code>init</code> 中，我们检查 <code>coder</code> 是否为非 <code>nil</code> （如果让coder = conditional为条件），如果是，则调用 <code>super.init（coder :)</code> 。如果为 <code>nil</code>，我们将执行本来应该做的事情，并调用 <code>super.init（nibName：nil，bundle：nil）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，编译器很高兴在调用 <code>super.init（）</code> 之前为属性分配值，并且可以将初始化逻辑放在一个地方。如果要在情节提要中使用 <code>ViewController</code> ，则框架将调用init（coder :)，如果要以编程方式创建一个，则可以说 <code>let fooVC = FooViewController（）</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果您正在使用 &lt;code&gt;Swift&lt;/code&gt; 并想对实现 &lt;code&gt;NSCoding&lt;/code&gt; 的东西进行子类化（例如 &lt;code&gt;UIView&lt;/code&gt;，&lt;code&gt;UIViewController&lt;/code&gt; 等），则可能会遇到麻烦的情况。即，&lt;code&gt;NSCoding&lt;/code&gt; 协议需要 &lt;code&gt;init(coder：aDecoder)&lt;/code&gt; 初始化程序，这意味着如果你为超类重写了指定的初始化程序，则需要实现该初始化程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>UIKit初始化模式</title>
    <link href="http://www.xuebaonline.com/UIKit%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/UIKit%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T00:05:14.000Z</published>
    <updated>2020-04-25T02:12:15.476Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>了解UIKit中两个常用类的初始化过程。了解UIViewcontroller和UIView初始化模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIKit</code> 是在iOS开发过程中必须也是使用频次最高的一个类库，里面包含了许多与用户直接交互的控件比如：<code>UIView</code>, <code>UITableView</code>, <code>UIScrollView</code> 等。在收到用户交互的设计图之后，我们要合理的使用这些控件，就能编写出交互良好的应用。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了类库中包含的基础控件之外，我们也能够对控件根据业务需要进行整合，也就是设计出一套适用于本公司的组件，提高开发速度。</p><h1 id="UIViewController-初始化"><a href="#UIViewController-初始化" class="headerlink" title="UIViewController 初始化"></a><strong>UIViewController 初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，<code>UIViewController</code> 的初始化非常简单。如果要完全控制，则只需要重写一些方法。这取决于你使用何种方式调用 <code>init</code> ，如果你使用一个 <code>storyboard</code> 初始化控制器，那么 <a href="http://www.xuebaonline.com/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/" title="NSCODER和SWIFT初始化">init(coder)</a> 是你所需要的。如果你尝试从外部 <code>nib</code> 文件启动控制器，则将调用 <code>init（nib，bundle）</code> 。你还有第三个选择，你可以通过代码以编程方式初始化控制器。简而言之，为了进行合理的初始化过程，这是你必须要做的。</p></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍两种 <code>UIViewControllers</code> 的初始化模式，第一种只是一个常见的init函数，在每种情况下都可以调用该函数来初始化控制器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(nibName nibNameOrNil: <span class="type">String?</span>, bundle nibBundleOrNil: <span class="type">Bundle?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do your stuff here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以在之后的子类中隐藏 <code>init（nib，bundle）</code> 和 <code>init（coder）</code> 方法。在子类中不必重写 <code>init（nib，bundle）</code>，并且可以将 <code>init（coder）</code> 标记为默认初始化程序。这个似乎是有点棘手的解决方案，使用起来不是很方便，但确实可以完成 <code>ViewController</code> 的初始化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do your stuff here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFutureViewController</span>: <span class="title">ViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> vc = <span class="type">MyFutureViewController</span>()</span><br></pre></td></tr></table></figure><hr></br><h1 id="UIView-初始化"><a href="#UIView-初始化" class="headerlink" title="UIView 初始化"></a><strong>UIView 初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通常为 <code>UIView</code> 创建一个通用的初始化程序，以使初始化过程更加轻松，使用起来更加方便。还会在该初始值设定项方法中将 <code>translate autoresizing mask</code> 属性设置为 <code>false</code> ，因为它是2017年，没有人再使用 <code>spring＆struts</code> 了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用自动布局助手也很不错，如果你想从nib文件中初始化视图，那么有一些便利的方法也很好。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(autolayout: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(autolayout: Bool = <span class="literal">true</span>)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _self = <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">let</span> view  = _self <span class="keyword">as</span> <span class="type">UIView</span></span><br><span class="line">        view.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">        <span class="keyword">return</span> _self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">createFromNib</span><span class="params">(owner: <span class="keyword">Any</span>? = <span class="literal">nil</span>, options: [AnyHashable: <span class="keyword">Any</span>]? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Bundle</span>.main.loadNibNamed(<span class="type">String</span>(describing: <span class="keyword">self</span>), owner: owner, options: options)?.last <span class="keyword">as</span>! <span class="type">UIView</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> view = <span class="type">UIView</span>(autolayout: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>使用这些代码片段，为所有 <code>UIKit</code> 类维护一个合理的初始化过程确实很容易，因为其中大多数都是从这两个 “主要” 类派生的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;了解UIKit中两个常用类的初始化过程。了解UIViewcontroller和UIView初始化模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;UIKit&lt;/code&gt; 是在iOS开发过程中必须也是使用频次最高的一个类库，里面包含了许多与用户直接交互的控件比如：&lt;code&gt;UIView&lt;/code&gt;, &lt;code&gt;UITableView&lt;/code&gt;, &lt;code&gt;UIScrollView&lt;/code&gt; 等。在收到用户交互的设计图之后，我们要合理的使用这些控件，就能编写出交互良好的应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>后端实践三:Ubuntu18.04安装Vapor4.0</title>
    <link href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89:Ubuntu18.04%E5%AE%89%E8%A3%85Vapor4.0/"/>
    <id>http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89:Ubuntu18.04%E5%AE%89%E8%A3%85Vapor4.0/</id>
    <published>2020-04-17T08:52:46.000Z</published>
    <updated>2020-04-25T01:11:06.910Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文章《<a href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/" title="后端实践二:Ubuntu18.04安装最新版Swift5.2">后端实践二:Ubuntu18.04安装最新版Swift5.2</a>》可以在 Ubuntu18.04 的服务器上顺利安装最新版本的 <code>Swift</code> 。我们参照 <a href="https://docs.vapor.codes/3.0/install/ubuntu/" target="_blank" rel="noopener">官网文档</a> 安装 <code>Vapor4.0</code> 的开发环境。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官网上的文档跟开发维护的速度有一定的版本误差，所以现在在官网上看到的安装方法是针对 <code>Vapor(&gt;3.0 &amp;&amp; &lt; 4.0)</code> 的版本。由于版本间差异比较大，在实践过程中，只会关注到 <code>Vapor(&gt;=4.0)</code> 以上版本的新特性。在创建工程和引入依赖库的过程中也会出现微小的差别，我们在后续的实践中会总结到。</p></blockquote><h1 id="验证-Swift-安装"><a href="#验证-Swift-安装" class="headerlink" title="验证 Swift 安装"></a><strong>验证 Swift 安装</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过访问 <code>Swift.org</code>，可以得到一份如何在 <code>Linux</code> 上安装 <code>Swift</code> 的文档。我们完成对 <code>Swift</code> 的安装之后，在终端中输入如下命令：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><a id="more"></a><p>如果在终端中输出如下信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Apple</span> <span class="type">Swift</span> version <span class="number">4.1</span>.<span class="number">0</span> (swiftlang-<span class="number">900.0</span>.<span class="number">69.2</span> clang-<span class="number">900.0</span>.<span class="number">38</span>)</span><br><span class="line"><span class="type">Target</span>: x86_64-apple-macosx10.<span class="number">9</span></span><br></pre></td></tr></table></figure><p>那么标识我们在 <code>Linux</code> 上成功安装 <code>Swift</code>。</p><h1 id="安装-Vapor-Toolbox"><a href="#安装-Vapor-Toolbox" class="headerlink" title="安装 Vapor Toolbox"></a><strong>安装 Vapor Toolbox</strong></h1><p>在 <code>Vapor 4.0</code> 发布之前，在 <code>Linux</code> 上安装，只需要在终端中敲入如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL apt.vapor.sh -o apt.vapor.sh</span><br></pre></td></tr></table></figure><p>这个执行安装的命令已经被废弃。</p><h2 id="Toolbox-源代码"><a href="#Toolbox-源代码" class="headerlink" title="Toolbox 源代码"></a><code>Toolbox</code> 源代码</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于之后的版本中，不在将该文件托管至软件源，所以我们在安装时需要做出如下操作获取到 <code>Toolbox</code> 源代码到本地文件夹中：</p><p>下载 <code>Toolbox</code> 源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vapor/toolbox.git</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-1stp.png" alt="Toolbox"></p><h2 id="编译-Vapor-可执行文件"><a href="#编译-Vapor-可执行文件" class="headerlink" title="编译 Vapor 可执行文件"></a>编译 <code>Vapor</code> 可执行文件</h2><p>进入到 <code>Toolbox</code> 工程的根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> toolbox/</span><br></pre></td></tr></table></figure><p>编译 <code>Toolbox</code>  发布版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build -<span class="built_in">c</span> release</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于获取的源代码中缺少部分文件，期间或存在报错发现 <code>Toolbox</code> 中没有 <code>LinuxMain.swift</code> 文件在 <code>Tests</code> 文件夹中，这时我们进入到 <code>XCTest</code> 文件夹中。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-2stp.png" alt="Vapor"></p><p>创建 <code>LinuxMain.swift</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch LinuxMain.swift</span><br></pre></td></tr></table></figure><p>编辑 <code>LinuxMain.swift</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim LinuxMain.swift</span><br></pre></td></tr></table></figure><p>向 <code>LinuxMain.swift</code> 文件中添加测试代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> AppTests</span><br><span class="line"></span><br><span class="line"><span class="type">XCTMain</span>([testCase(<span class="type">AppTests</span>.allTests)])</span><br></pre></td></tr></table></figure><p>保存修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq!</span><br></pre></td></tr></table></figure><p>重新执行如下命令，完成编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build -c release</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-3stp.png" alt="Vapor"></p><p>找到编译成功的 <code>Vapor</code> 文件</p><blockquote><p>执行完 <code>build</code> 命令之后，会在输出的文件中生成一个可执行的二进制文件。</p></blockquote><p>查找 <code>Vapor</code> 所在的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name vapor</span><br></pre></td></tr></table></figure><blockquote><p>这时会看到输出一个类似如下的文件夹 <code>.build/x86_64-unknown-linux/release/vapor</code> ,这个文件夹里就是我们要使用到的文件 <code>Vapor</code> 。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-4stp.png" alt="Vapor"></p><p>配置 <code>Vapor</code> 的环境变量</p><p>将包含可执行文件 <code>Vapor</code> 的文件目录添加在 <code>PATH</code> 中。</p><p>配置 <code>Vapor</code> 环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp vapor /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>验证是否配置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vapor --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-5stp.png" alt="Vaporhelp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此 <code>Vapor 4.0</code> 的环境配置已经完成。由于 <code>3.0</code> 和 <code>4.0</code> 版本差异比较大，在配置方面也有差异。在创建项目时更需要加上 <code>branch=4</code> 等。后续会加入：创建第一个 <code>Hello World</code> 工程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过文章《&lt;a href=&quot;http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/&quot; title=&quot;后端实践二:Ubuntu18.04安装最新版Swift5.2&quot;&gt;后端实践二:Ubuntu18.04安装最新版Swift5.2&lt;/a&gt;》可以在 Ubuntu18.04 的服务器上顺利安装最新版本的 &lt;code&gt;Swift&lt;/code&gt; 。我们参照 &lt;a href=&quot;https://docs.vapor.codes/3.0/install/ubuntu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网文档&lt;/a&gt; 安装 &lt;code&gt;Vapor4.0&lt;/code&gt; 的开发环境。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;官网上的文档跟开发维护的速度有一定的版本误差，所以现在在官网上看到的安装方法是针对 &lt;code&gt;Vapor(&amp;gt;3.0 &amp;amp;&amp;amp; &amp;lt; 4.0)&lt;/code&gt; 的版本。由于版本间差异比较大，在实践过程中，只会关注到 &lt;code&gt;Vapor(&amp;gt;=4.0)&lt;/code&gt; 以上版本的新特性。在创建工程和引入依赖库的过程中也会出现微小的差别，我们在后续的实践中会总结到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;验证-Swift-安装&quot;&gt;&lt;a href=&quot;#验证-Swift-安装&quot; class=&quot;headerlink&quot; title=&quot;验证 Swift 安装&quot;&gt;&lt;/a&gt;&lt;strong&gt;验证 Swift 安装&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们通过访问 &lt;code&gt;Swift.org&lt;/code&gt;，可以得到一份如何在 &lt;code&gt;Linux&lt;/code&gt; 上安装 &lt;code&gt;Swift&lt;/code&gt; 的文档。我们完成对 &lt;code&gt;Swift&lt;/code&gt; 的安装之后，在终端中输入如下命令：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/categories/Server/"/>
    
      <category term="Vapor4.0" scheme="http://www.xuebaonline.com/categories/Vapor4-0/"/>
    
      <category term="Ubuntu18.04" scheme="http://www.xuebaonline.com/categories/Ubuntu18-04/"/>
    
      <category term="Swift5.2" scheme="http://www.xuebaonline.com/categories/Swift5-2/"/>
    
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="Server" scheme="http://www.xuebaonline.com/tags/Server/"/>
    
      <category term="Ubuntu" scheme="http://www.xuebaonline.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>后端实践二:Ubuntu18.04安装最新版Swift5.2</title>
    <link href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/"/>
    <id>http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/</id>
    <published>2020-04-17T06:51:16.000Z</published>
    <updated>2020-04-25T01:06:57.345Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文章《<a href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/" title="后端实践一:开发环境搭建VMware下安装Ubuntu18.04">后端实践一:开发环境搭建VMware下安装Ubuntu18.04</a>》可以完成在  <code>mac</code> 上搭建起可用的 <code>Ubuntu 18.04</code> 的服务器。接下来我们要在此基础上完善 <code>Vapor 4.0</code> 的开发环境。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ubuntu 18.04 安装 Swift 5.2.2 ，可在 Vapor 官网的引导完成。这篇文章就是讲解如何完成在 Ubuntu 上安装最新版本 Swift，构建出一个强大的云端服务器。</p></blockquote><h1 id="Ubuntu-系统环境搭建"><a href="#Ubuntu-系统环境搭建" class="headerlink" title="Ubuntu 系统环境搭建"></a><strong><code>Ubuntu</code> 系统环境搭建</strong></h1><h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里使用的SecureCRT作为终端连接服务器，也可以使用 <code>iTerm2</code> 连接服务器。</p></blockquote><a id="more"></a><p>使用 <code>SecureCRT</code> 提供的远程登录功能连接 <code>Ubuntu</code> 服务器的配置信息：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-1stop.png" alt="SecureCRT"></p><p>使用 <code>SecureCRT</code> 终端使用系统自带的远程登录功能连接 <code>Ubuntu</code> 服务器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-2stp.png" alt="使用SecureCRT"></p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-3stp.png" alt="使用SecureCRT"></p><p>使用 <code>iTerm2</code> 终端使用系统自带的远程登录功能连接Ubuntu 服务器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-4stp.png" alt="iTerm2"></p><p>查看当前服务器系统版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><blockquote><p>Swift 依赖一些三方类库。</p></blockquote><p>必须安装的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install clang libicu-dev -y</span><br><span class="line">sudo apt-get install libcurl3 libpython2.7 libpython2.7-dev</span><br></pre></td></tr></table></figure><h2 id="安装-Swift"><a href="#安装-Swift" class="headerlink" title="安装 Swift"></a>安装 <code>Swift</code></h2><p>在 <a href="https://swift.org/download/#releases" target="_blank" rel="noopener">Swift.org</a> 查找我们要安装的Swift对应版本的Toolchain，复制下载链接。</p><blockquote><p>在写这篇文章时最新版的Swift是v5.2.2。</p></blockquote><p>找到对应系统以及对应版本<a href="https://swift.org/builds/swift-5.2.2-release/ubuntu1804/swift-5.2.2-RELEASE/swift-5.2.2-RELEASE-ubuntu18.04.tar.gz" target="_blank" rel="noopener">下载链接</a>：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-5stp.png" alt="下载链接"></p><p>可以采用两种下载方式：</p><ul><li>在本机上使用上方链接，下载 <code>Toolchain</code> ，上传到 <code>Ubuntu</code> 服务器上，完成后续安装；</li><li>在 <code>Ubuntu</code> 上使用 <code>wget url</code> 的方式直接在服务器上安装。</li></ul><p>接下来 使用  <code>wget url</code> 下载 <code>swift</code> 安装包，并解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://swift.org/builds/swift-5.2.2-release/ubuntu1804/swift-5.2.2-RELEASE/swift-5.2.2-RELEASE-ubuntu18.04.tar.gz</span><br></pre></td></tr></table></figure><p>解压 <code>swift</code> 到文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf swift-5.2.2-RELEASE-ubuntu18.04.tar.gz</span><br></pre></td></tr></table></figure><p>将解压的文件保存在 <code>share</code> 目录下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv swift-5.2.2-RELEASE-ubuntu18.04 /usr/share/swift</span><br></pre></td></tr></table></figure><h2 id="配置-Swift-环境变量"><a href="#配置-Swift-环境变量" class="headerlink" title="配置 Swift 环境变量"></a>配置 <code>Swift</code> 环境变量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成以上操作即完成了 <code>swift</code> 的的安装，为了更方便的使用 <code>Swift</code> ，需要配置其在全局任意目录下可使用。</p><p>配置 <code>Swift</code> 环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=/usr/share/swift/usr/bin:<span class="variable">$PATH</span>"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h2><p>检查当前系统的 <code>Swift</code> 版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift -version</span><br></pre></td></tr></table></figure><ul><li>如果出现 <code>Command &#39;swift&#39; not found ...</code> 该提示，关闭连接终端，重新连接服务器，再次执行上述命令。</li></ul><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-6stp.png" alt="installSuccess"></p><h1 id="运行-Swift-程序"><a href="#运行-Swift-程序" class="headerlink" title="运行 Swift 程序"></a><strong>运行 <code>Swift</code> 程序</strong></h1><h2 id="在终端运行程序，简单测试环境是否达建成功。"><a href="#在终端运行程序，简单测试环境是否达建成功。" class="headerlink" title="在终端运行程序，简单测试环境是否达建成功。"></a>在终端运行程序，简单测试环境是否达建成功。</h2><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift</span><br></pre></td></tr></table></figure><p>此时进入到终端界面。</p><p>编辑一段 <code>Swift</code> 程序代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>, b = <span class="number">13</span>, <span class="built_in">c</span> = a + b</span><br></pre></td></tr></table></figure><p>在终端输入以下命令退出编辑模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:exit</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-7stp.png" alt="Swift"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成 <code>Swift</code> 在 <code>Ubuntu</code> 环境下的配置，接下来可以配置 <code>Vapor 4.0</code> 的开发环境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过文章《&lt;a href=&quot;http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/&quot; title=&quot;后端实践一:开发环境搭建VMware下安装Ubuntu18.04&quot;&gt;后端实践一:开发环境搭建VMware下安装Ubuntu18.04&lt;/a&gt;》可以完成在  &lt;code&gt;mac&lt;/code&gt; 上搭建起可用的 &lt;code&gt;Ubuntu 18.04&lt;/code&gt; 的服务器。接下来我们要在此基础上完善 &lt;code&gt;Vapor 4.0&lt;/code&gt; 的开发环境。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Ubuntu 18.04 安装 Swift 5.2.2 ，可在 Vapor 官网的引导完成。这篇文章就是讲解如何完成在 Ubuntu 上安装最新版本 Swift，构建出一个强大的云端服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Ubuntu-系统环境搭建&quot;&gt;&lt;a href=&quot;#Ubuntu-系统环境搭建&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 系统环境搭建&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;code&gt;Ubuntu&lt;/code&gt; 系统环境搭建&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;连接服务器&quot;&gt;&lt;a href=&quot;#连接服务器&quot; class=&quot;headerlink&quot; title=&quot;连接服务器&quot;&gt;&lt;/a&gt;连接服务器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这里使用的SecureCRT作为终端连接服务器，也可以使用 &lt;code&gt;iTerm2&lt;/code&gt; 连接服务器。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/categories/Server/"/>
    
      <category term="Vapor4.0" scheme="http://www.xuebaonline.com/categories/Vapor4-0/"/>
    
      <category term="Ubuntu18.04" scheme="http://www.xuebaonline.com/categories/Ubuntu18-04/"/>
    
      <category term="Swift5.2" scheme="http://www.xuebaonline.com/categories/Swift5-2/"/>
    
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="Server" scheme="http://www.xuebaonline.com/tags/Server/"/>
    
      <category term="Ubuntu" scheme="http://www.xuebaonline.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04替换国内源</title>
    <link href="http://www.xuebaonline.com/Ubuntu18.04%E6%9B%BF%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"/>
    <id>http://www.xuebaonline.com/Ubuntu18.04%E6%9B%BF%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</id>
    <published>2020-04-17T04:58:13.000Z</published>
    <updated>2020-04-25T01:10:03.748Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再国内使用国外的软件源普遍会比较慢，但是国内也有很多的软件源可供选择。在修改软件源之前，查看系统软件源版本：</p><p><strong><em>查看版本：</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -c</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong><em>备份系统源配置文件：</em></strong></p><p>在修改之前要对系统的配置文件做好备份，这是个好习惯。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h1 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a><strong>阿里源</strong></h1><h2 id="更新源的配置文件"><a href="#更新源的配置文件" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multivers</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a><strong>中科大源</strong></h1><h2 id="更新源的配置文件-1"><a href="#更新源的配置文件-1" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="163源"><a href="#163源" class="headerlink" title="163源"></a><strong>163源</strong></h1><h2 id="更新源的配置文件-2"><a href="#更新源的配置文件-2" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-2"><a href="#更新-2" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a><strong>清华源</strong></h1><h2 id="更新源的配置文件-3"><a href="#更新源的配置文件-3" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-3"><a href="#更新-3" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Ubuntu18.04的配置中，更新了系统的软件源，国内源推荐使用清华源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;再国内使用国外的软件源普遍会比较慢，但是国内也有很多的软件源可供选择。在修改软件源之前，查看系统软件源版本：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;查看版本：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lsb_release -c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/categories/Server/"/>
    
      <category term="Vapor4.0" scheme="http://www.xuebaonline.com/categories/Vapor4-0/"/>
    
      <category term="Ubuntu18.04" scheme="http://www.xuebaonline.com/categories/Ubuntu18-04/"/>
    
      <category term="Ubuntu软件源" scheme="http://www.xuebaonline.com/categories/Ubuntu%E8%BD%AF%E4%BB%B6%E6%BA%90/"/>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/tags/Server/"/>
    
      <category term="Ubuntu" scheme="http://www.xuebaonline.com/tags/Ubuntu/"/>
    
      <category term="VMware" scheme="http://www.xuebaonline.com/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>后端实践一:开发环境搭建VMware下安装Ubuntu18.04</title>
    <link href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/"/>
    <id>http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/</id>
    <published>2020-04-17T01:17:13.000Z</published>
    <updated>2020-04-25T01:08:41.946Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Mac</code> 环境下使用 <code>VMware</code> 安装 <code>Ubuntu 18.04</code> 的主要目的是用于对后端开发框架：<code>Vapor 4.0</code> 的实践。由于 <code>Vapor 4.0</code> 框架支持 <code>MacOS</code> 和 <code>Ubuntu</code> ，所以实践时间，以使用 <code>Ubuntu</code> 为主。</p><a id="more"></a><blockquote><p>VMware  的下载和安装这里就不在赘述，自行下载安装即可。</p></blockquote><h1 id="下载-Ubuntu-的-ISO-文件"><a href="#下载-Ubuntu-的-ISO-文件" class="headerlink" title="下载 Ubuntu 的 ISO 文件"></a><strong>下载 <code>Ubuntu</code> 的 <code>ISO</code> 文件</strong></h1><h2 id="国内有很多镜像源，这里选用网易的镜像源。"><a href="#国内有很多镜像源，这里选用网易的镜像源。" class="headerlink" title="国内有很多镜像源，这里选用网易的镜像源。"></a>国内有很多镜像源，这里选用<a href="http://mirrors.163.com/ubuntu-releases/" target="_blank" rel="noopener" title="网易的镜像源">网易的镜像源</a>。</h2><p>这里建议使用 <code>Ubuntu 18.04</code> 版本，按照图示下载即可。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/163-source.png" alt="网易镜像源"></p><p>本次安装中使用的镜像为：<a href="http://mirrors.163.com/ubuntu-releases/18.04/ubuntu-18.04.4-live-server-amd64.iso" target="_blank" rel="noopener" title="Ubuntu18.04"><code>ubuntu-18.04.4-live-server-amd64.iso</code></a>。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/Ubuntu-1804-server.png" alt="Ubuntu1804"></p><h1 id="VMware-虚拟机配置"><a href="#VMware-虚拟机配置" class="headerlink" title="VMware 虚拟机配置"></a><strong><code>VMware</code> 虚拟机配置</strong></h1><p>在使用 <code>VMware</code> 安装 <code>Ubuntu</code>虚拟机时，按照引导安装即可。</p><h2 id="打开-VMware-软件"><a href="#打开-VMware-软件" class="headerlink" title="打开 VMware 软件"></a>打开 <code>VMware</code> 软件</h2><blockquote><p>根据提示我们在准备安装时，选择<strong>自定义安装</strong>。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-1stp.png" alt="自定义安装"></p><h2 id="选择虚拟的操作系统"><a href="#选择虚拟的操作系统" class="headerlink" title="选择虚拟的操作系统"></a>选择虚拟的操作系统</h2><p>这里选择 <code>Linux</code> -&gt; <code>Ubuntu</code> 64位。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们下载的系统就是 <code>Ubuntu 18.04</code> 64位。还有很重要的一点，因为安装这个操作系统的目的是作为 <code>Vapor 4.0</code> 的服务器，所以在选用操作系统时，我们不需要图形界面。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-2stp.png" alt="选择操作系统类型"></p><h2 id="选择固件类型"><a href="#选择固件类型" class="headerlink" title="选择固件类型"></a>选择固件类型</h2><p>选择固件类型其实就是选择磁盘引导方式。</p><blockquote><p>相对这两种方式进一步了解，可自行查资料。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-3stp.png" alt="选择引导方式"></p><h2 id="选择虚拟磁盘"><a href="#选择虚拟磁盘" class="headerlink" title="选择虚拟磁盘"></a>选择虚拟磁盘</h2><p>选择虚拟磁盘为虚拟操作系统在本机上开辟操作磁盘的空间。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为不会再虚拟机上做比较大的文件操作， <code>20G</code> 的磁盘空间已经够用。在开辟磁盘空间时，开辟的是空间使用上限，在虚拟操作系统文件所占用的空间以实际使用为准，并不是开辟了多少，就是用多少。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-4stp.png" alt="选择虚拟磁盘"></p><h2 id="完成配置"><a href="#完成配置" class="headerlink" title="完成配置"></a>完成配置</h2><p>点击继续即可完成虚拟机配置。</p><blockquote><p>虚拟机配置采用 <code>VMWare</code> 提供的默认配置即可，不用过多的操作。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-5stp.png" alt="完成配置"></p><h2 id="保存虚拟机文件"><a href="#保存虚拟机文件" class="headerlink" title="保存虚拟机文件"></a>保存虚拟机文件</h2><p>点击保存将虚拟机文件保存在默认文件夹中。</p><blockquote><p>文件的保存位置可以是默认位置，也可以是自定义的位置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-6stp.png" alt="完成配置"></p><h1 id="安装-Ubuntu-18-04"><a href="#安装-Ubuntu-18-04" class="headerlink" title="安装 Ubuntu 18.04"></a><strong>安装 <code>Ubuntu 18.04</code></strong></h1><p>在使用 <code>VMware</code> 完成对 <code>Ubuntu</code>虚拟机配置时，即会进入系统的安装界面。</p><h2 id="开启-CD-DVD-，并选取镜像"><a href="#开启-CD-DVD-，并选取镜像" class="headerlink" title="开启 CD/DVD ，并选取镜像"></a>开启 <code>CD/DVD</code> ，并选取镜像</h2><p>在完成对虚拟机配置之后，进入到引导界面，开启 <code>CD/DVD</code> ，并加载镜像。</p><blockquote><p>因为启动时未加载系统镜像，所在期初会出现引导出错的问题。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-7stp.png" alt="引导失败"></p><blockquote><p>开启CD/DVD，并加载镜像。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-8stp.png" alt="加载镜像"></p><h2 id="选择系统引导语言"><a href="#选择系统引导语言" class="headerlink" title="选择系统引导语言"></a>选择系统引导语言</h2><p>镜像加载完成，选择系统引导语言的默认语言。</p><blockquote><p>安装系统的提示比较简单，也见名知意，所以在安装的全过程，我们均会使用英文完成安装。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-9stp.png" alt="选择系统引导语言"></p><h2 id="选择系统语言"><a href="#选择系统语言" class="headerlink" title="选择系统语言"></a>选择系统语言</h2><p>镜像加载完成，选择操作系统的默认语言。</p><blockquote><p>因为是作为服务器使用，为了避免以后因为字符编码上造成不必要的麻烦，这里选择英文。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-10stp.png" alt="选择系统语言"></p><h2 id="选择键盘布局"><a href="#选择键盘布局" class="headerlink" title="选择键盘布局"></a>选择键盘布局</h2><p>选择键盘布局默认选择英文键盘。</p><blockquote><p>键盘布局选择英文，大部分的笔记本、台式电脑键盘采用英文布局。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-11stp.png" alt="选择键盘布局"></p><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>网络设置主要是设置操作系统的网络链接方式，这里采用默认跟随本机网络变化。</p><blockquote><p>因为是在虚拟软件中使用操作系统，网络配置采用默认配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-12stp.png" alt="网络设置"></p><h2 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h2><p>系统需要一个代理接口联网，默认网络链接走本机。</p><blockquote><p>代理网络可以设置链接特定的网络中，比如公司内网。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-13stp.png" alt="代理设置"></p><h2 id="设置系统镜像"><a href="#设置系统镜像" class="headerlink" title="设置系统镜像"></a>设置系统镜像</h2><p>这里的镜像是软件包的镜像源。</p><blockquote><p>在安装的过程中使用默认的软件包镜像源，后续推荐替换的国内镜像。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-14stp.png" alt="设置系统镜像"></p><h2 id="设置文件系统"><a href="#设置文件系统" class="headerlink" title="设置文件系统"></a>设置文件系统</h2><p>文件系统设置采用默认设置。</p><blockquote><p>选取使用整个磁盘空间。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-15stp.png" alt="设置文件系统"></p><blockquote><p>文件系统采用系统推荐的默认方式配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-16stp.png" alt="设置文件系统"></p><blockquote><p>文件系统分区采用默认的分区方式。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-17stp.png" alt="设置文件系统"></p><h2 id="个人信息设置"><a href="#个人信息设置" class="headerlink" title="个人信息设置"></a>个人信息设置</h2><p>个人信息设置主要是设置 <code>root</code> 账户密码，服务器名称，登录账户及密码。</p><blockquote><p>完成设置信息之后，建议对该信息进行备份保存。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-18stp.png" alt="个人信息设置"></p><h2 id="OpenSSH-设置"><a href="#OpenSSH-设置" class="headerlink" title="OpenSSH 设置"></a><code>OpenSSH</code> 设置</h2><p>OpenSSH可是系统支持远程登录，远程操作。</p><blockquote><p>建议安装，在以后的操作中会比较方便，远程操作软件推荐 <code>SecureCRT</code> 。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-19stp.png" alt="OpenSSH设置"></p><h2 id="服务软件"><a href="#服务软件" class="headerlink" title="服务软件"></a>服务软件</h2><p>这里可以选择性的安装。</p><blockquote><p>针对自己想用的软件进行安装，建议用到什么安装什么。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-20stp.png" alt="服务软件一览"></p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>完成所有的配置之后，系统机会进入安装界面，安装过程比较久。</p><blockquote><p>系统安装时间会长一些，具体看各自电脑配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-21stp.png" alt="安装系统"></p><h1 id="登录-Ubuntu18-04"><a href="#登录-Ubuntu18-04" class="headerlink" title="登录 Ubuntu18.04"></a><strong>登录 <code>Ubuntu18.04</code></strong></h1><p>完成安装之后，系统就会进入终端，输入用户名和密码进入系统。</p><h2 id="输入用户信息"><a href="#输入用户信息" class="headerlink" title="输入用户信息"></a>输入用户信息</h2><p>输入用户名和密码，按照提示输入。</p><blockquote><p>在 <code>2.9</code> 中的用户信息，就是需要的登录信息。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-22stp.png" alt="输入用户信息"></p><blockquote><p>成功进入 <code>Ubuntu</code> 系统中。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-23stp.png" alt="输入用户信息"></p><h1 id="Ubuntu-18-04-个性化配置"><a href="#Ubuntu-18-04-个性化配置" class="headerlink" title="Ubuntu 18.04 个性化配置"></a><strong><code>Ubuntu 18.04</code> 个性化配置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后续会加入一些实用的小技巧：国内的软件源，远程登录、配置数据库、安装 <code>Vapor 4.0</code> 开发环境等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Mac&lt;/code&gt; 环境下使用 &lt;code&gt;VMware&lt;/code&gt; 安装 &lt;code&gt;Ubuntu 18.04&lt;/code&gt; 的主要目的是用于对后端开发框架：&lt;code&gt;Vapor 4.0&lt;/code&gt; 的实践。由于 &lt;code&gt;Vapor 4.0&lt;/code&gt; 框架支持 &lt;code&gt;MacOS&lt;/code&gt; 和 &lt;code&gt;Ubuntu&lt;/code&gt; ，所以实践时间，以使用 &lt;code&gt;Ubuntu&lt;/code&gt; 为主。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/categories/Server/"/>
    
      <category term="Vapor4.0" scheme="http://www.xuebaonline.com/categories/Vapor4-0/"/>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/tags/Server/"/>
    
      <category term="Ubuntu" scheme="http://www.xuebaonline.com/tags/Ubuntu/"/>
    
      <category term="VMware" scheme="http://www.xuebaonline.com/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.xuebaonline.com/hello-world/"/>
    <id>http://www.xuebaonline.com/hello-world/</id>
    <published>2020-04-14T03:41:23.589Z</published>
    <updated>2020-04-18T13:42:59.685Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://www.xuebaonline.com/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
