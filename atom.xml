<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Char&#39;s Blog</title>
  
  <subtitle>如切如磋，如琢如磨。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xuebaonline.com/"/>
  <updated>2020-04-27T03:54:02.695Z</updated>
  <id>http://www.xuebaonline.com/</id>
  
  <author>
    <name>Char</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS自定义转场(By Swift)</title>
    <link href="http://www.xuebaonline.com/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA(By%20Swift)/"/>
    <id>http://www.xuebaonline.com/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA(By%20Swift)/</id>
    <published>2020-04-27T03:50:09.000Z</published>
    <updated>2020-04-27T03:54:02.695Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，您将学习如何使用自定义转场和百分比驱动的交互来替换 <code>Push</code> ，<code>pop</code> 和模式动画。</p></br><h1 id="UIKit自定义过渡API-理论知识"><a href="#UIKit自定义过渡API-理论知识" class="headerlink" title="UIKit自定义过渡API-理论知识"></a><strong>UIKit自定义过渡API-理论知识</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在进行 <a href="https://developer.apple.com/videos/play/wwdc2013/218/" target="_blank" rel="noopener"><strong><code>自定义转换</code></strong></a> 的过程中涉及许多类和委托，让我们快速地完成这些项目，然后再进行一些编码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在本文中，您将学习如何使用自定义转场和百分比驱动的交互来替换 &lt;code&gt;Push&lt;/code&gt; ，&lt;code&gt;pop&lt;/code&gt; 和模式动画。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自定义转场" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA/"/>
    
      <category term="transition" scheme="http://www.xuebaonline.com/tags/transition/"/>
    
  </entry>
  
  <entry>
    <title>Swift UICollectionView使用指南</title>
    <link href="http://www.xuebaonline.com/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://www.xuebaonline.com/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2020-04-27T02:56:48.000Z</published>
    <updated>2020-04-27T03:45:35.328Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>UICollectionView</code> ，具有高度可重用性的 <code>UIKit</code> 组件和一些 <code>MVVM</code> 模式，而不会费力地进行索引路径计算。</p></br><h1 id="UICollectionView类的剖析"><a href="#UICollectionView类的剖析" class="headerlink" title="UICollectionView类的剖析"></a><strong>UICollectionView类的剖析</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您不熟悉 <code>UICollectionView</code> ，建议立即熟悉此类。 它们是 <code>Apple</code> 和其他第三方开发人员提供的许多应用程序的基本构建块。 就像 <code>UITableView</code> 一样。 结合 <code>IB</code> 和 <code>Swift</code> 代码快速了解和使用它们。 💻</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp1.png" alt="UICollectionView"></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将仅使用强大的 <code>UICollectionView</code> 类来构建 <code>Apple Music</code> 目录，例如从零开始的外观。 标头，水平和垂直滚动，圆形图像，因此，基本上，构建强大的用户界面所需的几乎所有内容。 🤘🏻</p></br><h1 id="如何使用Xcode中的Interface-Builder（IB）创建-UICollectionView-？"><a href="#如何使用Xcode中的Interface-Builder（IB）创建-UICollectionView-？" class="headerlink" title="如何使用Xcode中的Interface Builder（IB）创建 UICollectionView ？"></a><strong>如何使用Xcode中的Interface Builder（IB）创建 UICollectionView ？</strong></h1><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要使用 <code>IB</code> ！</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您仍然想使用 <code>IB</code> ，这是绝对入门的真正快速教程：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp2.png" alt="IB"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建第一个基于 <code>UICollectionView</code> 的屏幕的主要步骤如下：</p><ul><li>将 <code>UICollectionView</code> 对象拖到您的视图控制器</li><li>在集合视图上设置适当的约束</li><li>设置数据源和集合视图的委托</li><li>在控制器内部对单元布局进行原型设计</li><li>在单元格内的视图中添加约束</li><li>设置原型单元格类和重用标识符</li><li>做一些编码：</li></ul></br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">            flowLayout.itemSize = <span class="type">CGSize</span>(width: <span class="keyword">self</span>.collectionView.bounds.width, height: <span class="number">120</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> collectionView: UICollectionView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">"MyCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">MyCell</span></span><br><span class="line">        cell.textLabel.text = <span class="type">String</span>(indexPath.row + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(indexPath.item + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，数据源将提供有关如何填充集合视图的所有必需数据，并且委托将处理用户事件，例如在单元格上轻按。 您应该对数据源和委托方法有清楚的了解，因此请稍候片刻。 ⌨️</p></br><h1 id="如何在-Swift-5-中使用代码设置创建-UICollectionView"><a href="#如何在-Swift-5-中使用代码设置创建-UICollectionView" class="headerlink" title="如何在 Swift 5 中使用代码设置创建 UICollectionView?"></a><strong>如何在 <code>Swift 5</code> 中使用代码设置创建 <code>UICollectionView</code>?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您可能已经注意到，单元格是集合视图的核心组件。 它们是从可重用的视图派生的，这意味着，如果您有1000个元素的列表，则不会为每个元素创建一千个单元格，而只有少数几个可以填充屏幕大小，并且当您向下滚动列表时 这些项目将被重复使用以显示您的元素。 这仅仅是出于内存方面的考虑，因此与 <code>UIScrollView</code> 不同， <code>UICollectionView</code> （和 <code>UITableView</code> ）类是一个非常聪明且高效的类，但这也是每次显示之前都必须准备（重置内容）单元格的原因。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化也由系统处理，但是值得一提的是，如果使用 <code>Interface Builder</code> ，则应该在 <code>awakeFromNib</code> 方法内进行自定义，但是如果使用代码，则 <code>init（frame :)</code> 是您的地方。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> textLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        textLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(textLabel)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            textLabel.topAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.topAnchor),</span><br><span class="line">            textLabel.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.bottomAnchor),</span><br><span class="line">            textLabel.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.leadingAnchor),</span><br><span class="line">            textLabel.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.textLabel = textLabel</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.contentView.backgroundColor = .lightGray</span><br><span class="line">        <span class="keyword">self</span>.textLabel.textAlignment = .center</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Interface Builder is not supported!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Interface Builder is not supported!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel.text = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们必须实现负责管理集合视图的视图控制器，因为我们没有使用 <code>IB</code> ，所以必须在 <code>loadView</code> 方法内部使用自动布局锚点（如单元格中的 <code>textLabel</code> ）手动创建它。 在视图层次结构准备就绪后，我们还设置了数据源并委托并注册了我们的单元格类以供进一步重用。 请注意，如果您使用 <code>IB</code> ，则此操作由系统自动完成，但是如果您喜欢代码，则必须通过调用适当的注册方法来完成。 您可以注册 <code>nibs</code> 和 <code>classes</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> collectionView = <span class="type">UICollectionView</span>(frame: .zero, collectionViewLayout: <span class="type">UICollectionViewFlowLayout</span>())</span><br><span class="line">        collectionView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(collectionView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            collectionView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.topAnchor),</span><br><span class="line">            collectionView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.bottomAnchor),</span><br><span class="line">            collectionView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.leadingAnchor),</span><br><span class="line">            collectionView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView = collectionView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView.backgroundColor = .white</span><br><span class="line">        <span class="keyword">self</span>.collectionView.dataSource = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView.register(<span class="type">MyCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"MyCell"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> collectionView: UICollectionView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">"MyCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">MyCell</span></span><br><span class="line">        cell.textLabel.text = <span class="type">String</span>(indexPath.row + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(indexPath.row + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegateFlowLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        sizeForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.bounds.size.width - <span class="number">16</span>, height: <span class="number">120</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumLineSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumInteritemSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        insetForSectionAt section: Int)</span></span> -&gt; <span class="type">UIEdgeInsets</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIEdgeInsets</span>.<span class="keyword">init</span>(top: <span class="number">8</span>, <span class="keyword">left</span>: <span class="number">8</span>, bottom: <span class="number">8</span>, <span class="keyword">right</span>: <span class="number">8</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，您应该注意流布局委托方法。 您可以使用这些方法为布局系统提供支持。 流布局将基于这些数字和大小显示所有单元格。  <code>sizeForItemAt</code> 负责单元格的大小，<code>minimumInteritemSpacingForSectionAt</code> 是水平填充，<code>minimumLineSpacingForSectionAt</code> 是垂直填充，<code>insetForSectionAt</code> 是集合视图部分的边距。</p></br><h1 id="section-headers-and-footers"><a href="#section-headers-and-footers" class="headerlink" title="section headers and footers"></a><strong>section headers and footers</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在本节中，我将同时使用 <code>storyboards</code>，<code>nibs</code> 和一些 <code>Swift</code> 代码。 由于某些原因，这是我通常的方法。 虽然我很喜欢用代码进行约束，但大多数人更喜欢视觉编辑器，因此所有单元格都在笔尖内部创建。 为什么是笔尖？ 因为如果您有多个集合视图，这几乎是在它们之间共享单元格的唯一好方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您可以像创建 <code>section headers</code> 一样完全地创建 <code>section footers</code> ，因此这就是我这次只关注 <code>section headers</code> 的原因，因为从字面上看，您只需要更改一个字即可使用 <code>section footers</code> 。 ⚽️</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp3.png" alt="footers"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您只需要创建两个 <code>xib</code> 文件，一个用于单元格，一个用于头文件。 请注意，您可以使用完全相同的集合视图单元格来在 <code>section</code> 标题中显示内容，但这是一个演示，因此让我们处理两个不同的项目。 您甚至不必从 <code>IB</code> 设置重用标识符，因为我们必须在源代码中注册我们的可重用视图，因此只需设置单元类并连接您的 <code>outlets</code> 即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单元格的注册和 <code>section headers and footers</code> 的注册略有不同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cellNib = <span class="type">UINib</span>(nibName: <span class="string">"Cell"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.collectionView.register(cellNib, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sectionNib = <span class="type">UINib</span>(nibName: <span class="string">"Section"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.collectionView.register(sectionNib, forSupplementaryViewOfKind: <span class="type">UICollectionView</span>.elementKindSectionHeader, withReuseIdentifier: <span class="string">"Section"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现 <code>section header</code> 的数据源如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        viewForSupplementaryElementOfKind kind: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                        at indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionReusableView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> kind == <span class="type">UICollectionView</span>.elementKindSectionHeader <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UICollectionReusableView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> view = collectionView.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: <span class="string">"Section"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">Section</span></span><br><span class="line"></span><br><span class="line">    view.textLabel.text = <span class="type">String</span>(indexPath.section + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供流布局委托的大小也非常简单，但是有时我并没有得到 <code>Apple</code> 的命名约定。 一旦必须切换一种类型，而其他时候则有针对特定类型的确切方法。 🤷‍♂️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                    layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                    referenceSizeForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.bounds.size.width, height: <span class="number">64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 <code>iOS9</code> 开始，可以将 <code>section headers and footers</code> 固定在集合视图可见范围的顶部或底部。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">    flowLayout.sectionHeadersPinToVisibleBounds = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，现在您知道了如何使用集合视图构建基本布局。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复杂的情况怎么样，例如在同一集合视图中使用多种单元格呢？ 索引路径会使事情变得很混乱，所以这就是为什么我基于一种技术来重新发明更好的方法，该技术如何使用 <code>Apple</code> 在 <code>WWDC 2014</code> 上展示的 <a href="https://developer.apple.com/videos/wwdc2014" target="_blank" rel="noopener"><strong><code>集合视图来构建高级用户界面</code></strong></a> 。</p></br><h1 id="基于-CollectionView-的-UI-Framework"><a href="#基于-CollectionView-的-UI-Framework" class="headerlink" title="基于 CollectionView 的 UI Framework"></a><strong>基于 <code>CollectionView</code> 的 <code>UI Framework</code></strong></h1><blockquote><p>CollectionView + ViewModel pattern = ❤️ .</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将快速解释这些组件，然后，您将学习如何使用它们来构建起初我所谈论的 <code>Apple</code> 音乐风格的布局。 🎶</p><h2 id="网格系统"><a href="#网格系统" class="headerlink" title="网格系统"></a><strong><em>网格系统</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集合视图的第一个问题是大小计算。您必须提供集合视图中每个单元的大小（宽度和高度）。</p><ul><li>如果在集合视图中所有内容都具有固定的大小，则只需在流布局本身上设置大小属性</li><li>如果您需要每个项目的动态尺寸，则可以实施流布局委托。 <code>UICollectionViewDelegateFlowLayout</code>（为什么在名称中间使用委托词？？？）并返回布局系统的确切大小</li><li>如果您需要更多控制权，则可以创建一个从 <code>CollectionView（Flow）Layout</code> 派生的新布局子类，并在那里进行所有尺寸计算</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很好，但是您仍然必须弄乱索引路径，特征集合，框架等，以使简单的2、4，n列布局适用于所有设备。这就是为什么我创建了一个非常基本的网格系统进行尺寸计算的原因。使用我的网格类，您可以设置列数并获取x列数的大小，就像在基于 <code>Web</code> 的 <code>CSS</code> 网格系统中一样。 🕸</p><h2 id="单元格重用"><a href="#单元格重用" class="headerlink" title="单元格重用"></a><strong><em>单元格重用</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单元格的注册和重用应该并且可以以类型安全的方式自动化。 您只想使用单元，而根本不关心重用标识符和单元注册。 我做了一些辅助方法，以使进步更加愉快。 重用标识符是从单元格类的名称派生的，因此您不必担心。 大多数开发人员都使用这种做法。</p><h2 id="View-model"><a href="#View-model" class="headerlink" title="View model"></a><strong><em>View model</em></strong></h2><blockquote><p><strong><code>view model = cell (view) + data (model)</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用实际数据填充“模板”单元应该是视图模型的任务。 这就是 <code>MVVM</code> 发挥作用的地方。 我做了一个通用的基本视图模型类，应该将其子类化。 借助协议，您可以在单个集合视图中使用各种单元，而不必担心行和节的计算，并且您可以专注于一项简单的任务：将视图与模型联系起来。 😛</p><h2 id="Section"><a href="#Section" class="headerlink" title="Section"></a><strong><em>Section</em></strong></h2><blockquote><p><strong><code>section = header + footer + cells</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要强调的是，您不想弄乱索引路径，只想将数据放在一起就可以了。 过去，我对“不必要的索引路径计算”进行了充分的努力，因此，我将 <code>section</code> 对象作为一个简单的容器来包装标题，页脚和该部分中的所有项目。 结果？ 通用数据源类，可以与多个单元格一起使用，而无需任何行或节索引计算。 👏👏👏</p><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a><strong><em>数据源</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，为了使我上面提到的所有事情都能起作用，我需要实现集合视图委托，数据源和流布局委托方法。 这就是我的源代码类的诞生。 一切都在这里实现，我正在使用各部分，通过视图模型对网格系统进行建模以建立集合视图。 但是，从理论上讲，足够了，让我们在实践中进行观察。 👓</p></br><h1 id="CollectionView-框架创建示例"><a href="#CollectionView-框架创建示例" class="headerlink" title="CollectionView 框架创建示例"></a><strong>CollectionView 框架创建示例</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何使任何列表或网格布局轻松自如？ 好吧，作为第一步，只需将我的 <code>CollectionView</code> 框架添加为依赖项。 它已经支持<code>Xcode 11</code> ，因此您可以直接从文件菜单使用 <code>Swift</code> 软件包管理器来集成此软件包。</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需在 <code>AppDelegate</code> 文件中添加 <code>@_exported import CollectionView</code> 行，那么您不必担心逐个文件导入框架。</p></blockquote><h2 id="创建-Cell"><a href="#创建-Cell" class="headerlink" title="创建 Cell"></a><strong><em>创建 Cell</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此步骤与常规设置相同，除了您的单元必须是我的 <code>Cell</code> 类的子类。 添加您自己的单元并像往常一样执行所有操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumCell</span>: <span class="title">Cell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> detailTextLabel: <span class="type">UILabel!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">self</span>.textLabel.textColor = .black</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel.textColor = .darkGray</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="number">8</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.reset()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.image = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-Model"><a href="#创建-Model" class="headerlink" title="创建 Model"></a><strong><em>创建 Model</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需选择一个模型对象。 可以是任何东西，但是我的方法是使用 <code>Model</code> 后缀创建新的结构或类。 这样，我知道模型正在引用可重用组件文件夹中的集合视图模型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlbumModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> artist: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> image: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-ViewModel"><a href="#创建-ViewModel" class="headerlink" title="创建 ViewModel"></a><strong><em>创建 ViewModel</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，不用在委托内部或在某些地方的 <code>configure</code> 方法中配置单元格，而是为单元格和将通过视图表示的数据模型创建一个真实的视图模型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumViewModel</span>: <span class="title">ViewModel</span>&lt;<span class="title">AlbumCell</span>, <span class="title">AlbumModel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">updateView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view?.textLabel.text = <span class="keyword">self</span>.model.artist</span><br><span class="line">        <span class="keyword">self</span>.view?.detailTextLabel.text = <span class="keyword">self</span>.model.name</span><br><span class="line">        <span class="keyword">self</span>.view?.imageView.image = <span class="type">UIImage</span>(named: <span class="keyword">self</span>.model.image)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">(grid: Grid)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">            (<span class="keyword">self</span>.collectionView.traitCollection.userInterfaceIdiom == .phone &amp;&amp;</span><br><span class="line">             <span class="keyword">self</span>.collectionView.traitCollection.verticalSizeClass == .compact) ||</span><br><span class="line">            <span class="keyword">self</span>.collectionView?.traitCollection.userInterfaceIdiom == .pad</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> grid.size(<span class="keyword">for</span>: <span class="keyword">self</span>.collectionView, ratio: <span class="number">1.2</span>, items: grid.columns / <span class="number">4</span>, gaps: grid.columns - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> grid.columns == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> grid.size(<span class="keyword">for</span>: <span class="keyword">self</span>.collectionView, ratio: <span class="number">1.1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid.size(<span class="keyword">for</span>: <span class="keyword">self</span>.collectionView, ratio: <span class="number">1.2</span>, items: grid.columns / <span class="number">2</span>, gaps: grid.columns - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置数据源"><a href="#设置数据源" class="headerlink" title="设置数据源"></a><strong><em>设置数据源</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，使用您的真实数据并使用视图模型填充您的集合视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> grid = <span class="type">Grid</span>(columns: <span class="number">1</span>, margin: <span class="type">UIEdgeInsets</span>(all: <span class="number">8</span>))</span><br><span class="line"><span class="keyword">self</span>.collectionView.source = .<span class="keyword">init</span>(grid: grid, [</span><br><span class="line">    [</span><br><span class="line">        <span class="type">HeaderViewModel</span>(.<span class="keyword">init</span>(title: <span class="string">"Albums"</span>))</span><br><span class="line">        <span class="type">AlbumViewModel</span>(<span class="keyword">self</span>.album)</span><br><span class="line">    ],</span><br><span class="line">])</span><br><span class="line"><span class="keyword">self</span>.collectionView.reloadData()</span><br></pre></td></tr></table></figure><h2 id="🍺🤘🏻🎸"><a href="#🍺🤘🏻🎸" class="headerlink" title="🍺🤘🏻🎸"></a>🍺🤘🏻🎸</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恭喜，您已完成第一个 <code>collection</code> 视图。 仅需几行代码，您便拥有了 <code>ROCK SOLID</code>代码，可在大多数情况下为您提供帮助！ 😎</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp4.png" alt="collection"></p></br><h1 id="垂直滚动内的水平滚动"><a href="#垂直滚动内的水平滚动" class="headerlink" title="垂直滚动内的水平滚动"></a><strong>垂直滚动内的水平滚动</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们制作一个包含集合视图的单元格并使用与上述相同的方法怎么办？ 包含 <code>collectionview</code> 的 <code>collection</code> 视图… <code>UICollectionViewception</code> !!! 😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全有可能并且确实很容易做到，为视图模型提供数据的将是一个集合视图源对象，您已经完成了。 示例应用程序中还包括轻松，神奇和超好实现的内容。</p></br><h1 id="带有圆角图片的-Section"><a href="#带有圆角图片的-Section" class="headerlink" title="带有圆角图片的 Section"></a><strong>带有圆角图片的 Section</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多个部分？这也是小菜一碟，如果您阅读了我先前有关 <a href="http://www.xuebaonline.com/UICollectionView%20Cells%EF%BC%9A%E5%9C%86%E5%BD%A2%E5%9B%BE%E5%83%8F%E3%80%81%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC/"><strong><code>设置圆形Collection视图单元</code></strong></a> 的文章，您将知道该如何做，但是请从gitlab中查看源代码，并亲自进行操作。</p></br><h1 id="Callbacks-amp-amp-Actions"><a href="#Callbacks-amp-amp-Actions" class="headerlink" title="Callbacks &amp;&amp; Actions"></a><strong>Callbacks &amp;&amp; Actions</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户事件可以非常容易地处理，因为视图模型可以具有委托或回调块，这仅取决于您喜欢哪一个。 该示例包含一个 <code>onSelect</code> 处理程序，该处理程序超级好并且内置于框架中。 😎</p></br><h1 id="重新计算动态单元大小"><a href="#重新计算动态单元大小" class="headerlink" title="重新计算动态单元大小"></a><strong>重新计算动态单元大小</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我也有一个关于<a href="http://www.xuebaonline.com/Swift%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%85%83%E6%A0%BC/"><strong><code>UICollection视图自动调整大小单元格</code></strong></a> 的文章。 在制作完网格系统并开始使用视图模型之后，我自己可以轻松计算出单元格的高度，大约需要两行额外的代码。 我相信这是值得的，因为就自动旋转而言，自定尺寸的单元格有点麻烦。</p></br><h1 id="支持旋转，自适应"><a href="#支持旋转，自适应" class="headerlink" title="支持旋转，自适应"></a><strong>支持旋转，自适应</strong></h1><p>不必担心太多，您可以根据需要简单地更改网格或检查视图模型中的特征集合。 我想说几乎所有事情都可以立即完成。 那就是它的美，可以随意做任何您想做的事情，并以自己喜欢的方式使用它。 📦</p></br><h1 id="如果我告诉你…又一件事：SwiftUI"><a href="#如果我告诉你…又一件事：SwiftUI" class="headerlink" title="如果我告诉你…又一件事：SwiftUI"></a><strong>如果我告诉你…又一件事：SwiftUI</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您喜欢这种方法很酷，但是如果我告诉您还有更多方法呢？ 您是否想在所有地方都使用相同的模式？ 我的意思是在 <code>iOS</code> ，<code>tvOS</code>，<code>macOS</code>甚至 <code>watchOS</code> 上。  我已经在 <code>CoreKit</code> 框架中创建了所有内容。 还支持 <code>UITableViews</code> ， <code>WKInterfaceTables</code> 。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我真的相信苹果今年会采用类似的方式处理下一代<code>UIKit / AppKit / UXKit</code>框架（当然是用<code>Swift</code>编写的）。 我不是在谈论视图模型模式，而是在每个平台上思考相同的<code>API</code>。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何使用 &lt;code&gt;UICollectionView&lt;/code&gt; ，具有高度可重用性的 &lt;code&gt;UIKit&lt;/code&gt; 组件和一些 &lt;code&gt;MVVM&lt;/code&gt; 模式，而不会费力地进行索引路径计算。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;UICollectionView类的剖析&quot;&gt;&lt;a href=&quot;#UICollectionView类的剖析&quot; class=&quot;headerlink&quot; title=&quot;UICollectionView类的剖析&quot;&gt;&lt;/a&gt;&lt;strong&gt;UICollectionView类的剖析&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果您不熟悉 &lt;code&gt;UICollectionView&lt;/code&gt; ，建议立即熟悉此类。 它们是 &lt;code&gt;Apple&lt;/code&gt; 和其他第三方开发人员提供的许多应用程序的基本构建块。 就像 &lt;code&gt;UITableView&lt;/code&gt; 一样。 结合 &lt;code&gt;IB&lt;/code&gt; 和 &lt;code&gt;Swift&lt;/code&gt; 代码快速了解和使用它们。 💻&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q8wtfza4q.bkt.clouddn.com/ug-stp1.png&quot; alt=&quot;UICollectionView&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自适应布局" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"/>
    
      <category term="UICollectionView" scheme="http://www.xuebaonline.com/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>UICollectionView Cells：圆形图像、支持旋转</title>
    <link href="http://www.xuebaonline.com/UICollectionView%20Cells%EF%BC%9A%E5%9C%86%E5%BD%A2%E5%9B%BE%E5%83%8F%E3%80%81%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC/"/>
    <id>http://www.xuebaonline.com/UICollectionView%20Cells%EF%BC%9A%E5%9C%86%E5%BD%A2%E5%9B%BE%E5%83%8F%E3%80%81%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC/</id>
    <published>2020-04-27T02:37:04.000Z</published>
    <updated>2020-04-27T02:53:13.821Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何通过旋转支持为包装在 <code>UICollectionView</code> 单元格内的 <code>UIImageView</code> 项制作圆角。</p></br><h1 id="UICollectionView-中的圆形单元格"><a href="#UICollectionView-中的圆形单元格" class="headerlink" title="UICollectionView 中的圆形单元格"></a><strong>UICollectionView 中的圆形单元格</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现目标相对容易，但是如果你不知道后台发生了什么，那可能会比你最初想的要难。 因此，让我们创建一个新项目，添加带有 <code>UICollectionViewController</code> 的情节提要，将 <code>UIImageView</code> 拖动到单元格内，调整其大小，添加一些约束，设置单元格标识符。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp1.png" alt="UICollectionViewController"></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它看起来应该像上面的图像。 对于我们的示例应用程序而言，没有什么特别的简单的 <code>UI</code> 。 现在搜索一些随机图像，将其添加到项目中，让我们进行一些实际的编码。 首先，我将向你展示单元子类内部的小技巧。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.layoutIfNeeded()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.setCircularImageView()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setCircularImageView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="type">CGFloat</span>(roundf(<span class="type">Float</span>(<span class="keyword">self</span>.imageView.frame.size.width / <span class="number">2.0</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你能看见它吗？ 是的，你应该重写 <code>bounds</code> 属性。 下一步，我们必须为控制器类编写一些用于收集视图的基本数据源，并为旋转方法提供适当的支持。 🤓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">"Cell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></span><br><span class="line"></span><br><span class="line">        cell.imageView.image = <span class="type">UIImage</span>(named: <span class="string">"Example.jpg"</span>)</span><br><span class="line">        cell.imageView.backgroundColor = .lightGray</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">traitCollectionDidChange</span><span class="params">(<span class="number">_</span> previousTraitCollection: UITraitCollection?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> previousTraitCollection = previousTraitCollection,</span><br><span class="line">            <span class="keyword">self</span>.traitCollection.verticalSizeClass != previousTraitCollection.verticalSizeClass ||</span><br><span class="line">            <span class="keyword">self</span>.traitCollection.horizontalSizeClass != previousTraitCollection.horizontalSizeClass</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">        <span class="keyword">self</span>.collectionView?.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillTransition</span><span class="params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillTransition(to: size, with: coordinator)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line"></span><br><span class="line">        coordinator.animate(alongsideTransition: &#123; context <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">        &#125;, completion: &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.collectionView?.visibleCells.forEach &#123; cell <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> cell = cell <span class="keyword">as</span>? <span class="type">Cell</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                cell.setCircularImageView()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegateFlowLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        sizeForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.frame.size.width/<span class="number">3.0</span> - <span class="number">8</span>,</span><br><span class="line">                      height: collectionView.frame.size.width/<span class="number">3.0</span> - <span class="number">8</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，如果没有重写的 <code>bounds</code> 属性，则该示例在左侧看起来像这样。 😢</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp2.jpg" alt="UICollectionViewController2"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好笑吧？ 右侧的图像是带有超出范围的实际结果，这是预期的行为。 如果你不覆盖边界并且不为可见视图重设 <code>cornerRadius</code> 属性，那么滚动和旋转将真的很奇怪。 你可能会问：但是为什么呢？ 🤔</p></br><h1 id="Layers-springs-amp-struts-说明"><a href="#Layers-springs-amp-struts-说明" class="headerlink" title="Layers, springs &amp; struts 说明"></a><strong>Layers, springs &amp; struts</strong> 说明</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Apple</code> 在 <code>UIKit</code> 中仍然具有基于 <code>“ Springs＆Struts”</code> 的代码。 这意味着框架和边界计算正在底层系统中进行，并且约束系统也在努力工作以找出适当的措施。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当有一个 <code>init（frame :)</code> 方法或一个必需的 <code>init（coder :)</code> 方法时，这些布局会糟透了。 我真的很喜欢 <code>Interface Builder</code> ，但是直到我们没有一个好的工具来创建出色的用户界面， <code>IB</code> 才可能是潜在错误的另一层。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果仅使用自动布局约束或布局锚从代码创建单元，则甚至不会出现此问题！ 这是因为IB根据你在设计原型时提供的框架来创建单元。 但是，如果你忘记了 <code>init（frame :)</code> ，而只是创建了一个新的 <code>UIImageView</code> 实例并让自动布局完成了艰苦的工作，则布局系统将解决所有其他问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> imageView = <span class="type">UIImageView</span>()</span><br><span class="line">        imageView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.addSubview(imageView)</span><br><span class="line">        <span class="keyword">self</span>.imageView = imageView</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.topAnchor)</span><br><span class="line">        <span class="keyword">self</span>.imageView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.bottomAnchor)</span><br><span class="line">        <span class="keyword">self</span>.imageView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.leadingAnchor)</span><br><span class="line">        <span class="keyword">self</span>.imageView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.trailingAnchor)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="type">CGFloat</span>(roundf(<span class="type">Float</span>(<span class="keyword">self</span>.imageView.frame.size.width/<span class="number">2.0</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，你必须编写更多代码，在控制器类中手动注册单元格类，并且还必须重写单元格中的 <code>layoutSubviews</code> 方法，但是它将按预期执行。 🙄</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.collectionView?.register(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，在注册以编程方式创建的单元格之后，你将有一种很好的方式来显示圆形图像。 使用这种技术非常棘手，但是在每种情况下它肯定都有效。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何通过旋转支持为包装在 &lt;code&gt;UICollectionView&lt;/code&gt; 单元格内的 &lt;code&gt;UIImageView&lt;/code&gt; 项制作圆角。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;UICollectionView-中的圆形单元格&quot;&gt;&lt;a href=&quot;#UICollectionView-中的圆形单元格&quot; class=&quot;headerlink&quot; title=&quot;UICollectionView 中的圆形单元格&quot;&gt;&lt;/a&gt;&lt;strong&gt;UICollectionView 中的圆形单元格&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;实现目标相对容易，但是如果你不知道后台发生了什么，那可能会比你最初想的要难。 因此，让我们创建一个新项目，添加带有 &lt;code&gt;UICollectionViewController&lt;/code&gt; 的情节提要，将 &lt;code&gt;UIImageView&lt;/code&gt; 拖动到单元格内，调整其大小，添加一些约束，设置单元格标识符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q8wtfza4q.bkt.clouddn.com/uc-stp1.png&quot; alt=&quot;UICollectionViewController&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自适应布局" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"/>
    
      <category term="UICollectionView" scheme="http://www.xuebaonline.com/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>Swift支持旋转的自适应单元格</title>
    <link href="http://www.xuebaonline.com/Swift%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%85%83%E6%A0%BC/"/>
    <id>http://www.xuebaonline.com/Swift%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%85%83%E6%A0%BC/</id>
    <published>2020-04-27T02:12:39.000Z</published>
    <updated>2020-04-27T02:39:32.786Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何在Swift中为表格视图和集合视图制作自定义大小的单元格，以支持方向更改和动态字体类型。</p></br><h1 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a><strong>UITableView</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们从 <code>iOS</code> 的标准单视图模板开始。 命名项目，然后直接转到 <code>Main.storyboard</code> 文件。 选择你的 <code>ViewController</code> ，将其删除并创建一个新的 <code>UITableViewController</code> <code>scene</code> 。</p><a id="more"></a><p><img src="http://q8wtfza4q.bkt.clouddn.com/sc-stp1.jpg" alt="Main.storyboard"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将表视图控制器场景设置为初始视图控制器，并使用相应的类创建 <code>TableViewController.swift</code> 文件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dataSource: [<span class="type">String</span>] = [</span><br><span class="line">        <span class="string">"Donec id elit non mi porta gravida at eget metus."</span>,</span><br><span class="line">        <span class="string">"Integer posuere erat a ante venenatis dapibus posuere velit aliquet. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus."</span>,</span><br><span class="line">        <span class="string">"Duis mollis, est non commodo luctus, nisi erat porttitor ligula, eget lacinia odio sem nec elit. Vestibulum id ligula porta felis euismod semper. Nullam id dolor id nibh ultricies vehicula ut id elit. Nullam quis risus eget urna mollis ornare vel eu leo."</span>,</span><br><span class="line">        <span class="string">"Maecenas faucibus mollis interdum."</span>,</span><br><span class="line">        <span class="string">"Donec ullamcorper nulla non metus auctor fringilla. Aenean lacinia bibendum nulla sed consectetur. Cras mattis consectetur purus sit amet fermentum."</span>,</span><br><span class="line">        <span class="string">"Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Maecenas faucibus mollis interdum."</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TableViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dataSource.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"Cell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">TableViewCell</span></span><br><span class="line"></span><br><span class="line">        cell.dynamicLabel?.text = <span class="keyword">self</span>.dataSource[indexPath.row]</span><br><span class="line">        cell.dynamicLabel.font  = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该设置实际上是自我描述的。 你已经有了一个字符串数组作为数据源，以及 <code>UITableViewDataSource</code> 协议的必需实现。</p><p>唯一缺少的是 <code>TableViewCell</code> 类:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> dynamicLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，创建类本身，然后使用界面构建器选择表视图控制器场景并将标签拖到原型单元中。 将原型单元格的类设置为 <code>TableViewCell</code> 。 可重复使用的标识符可以简单地是 <code>“ Cell”</code>。 将 <code>dynamicLabel</code> 插座连接到视图。 将标签的上，下，前，尾约束赋予父视图，默认值为8。选择标签，将字体设置为主体样式，并将 <code>lines</code> 属性设置为零。 就是这么简单。 😂</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sc-stp2.jpg" alt="TableViewCell"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在你已经准备好了。 你只需要在表格视图上设置估计的行高。 在 <code>TableViewController</code> 类内部，更改 <code>viewDidLoad</code> 方法，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">44</span></span><br><span class="line">    <span class="keyword">self</span>.tableView.rowHeight = <span class="type">UITableView</span>.automaticDimension</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>EstimateRowHeight</code> 属性将告诉系统 <code>tableview</code> 应该尝试动态计算每个单元格的高度。 你还应该将 <code>rowHeight</code> 属性更改为自动尺寸，如果不这样做，则系统将使用静态单元格高度-你可以在单元格上设置的界面生成器高度。 现在构建并运行。 你将拥有一个带有自定义尺寸单元格的绝佳表格视图。 你甚至可以旋转设备，它将在两个方向上都能正常工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你在 <code>iOS</code> 辅助功能设置下更改了文字大小，表格视图将反映这些更改，因此它将使布局适应新值。 表格视图的字体大小将使 <code>comcorint</code> 更改为滑块值。 你可能想要订阅 <code>UIContentSizeCategory.didChangeNotification</code> 以便检测大小更改并重新加载 <code>UI</code> 。 此功能称为动态类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>.tableView, selector: #selector(<span class="type">UITableView</span>.reloadData), name: <span class="type">UIContentSizeCategory</span>.didChangeNotification,, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></br><h1 id="UICollectionView"><a href="#UICollectionView" class="headerlink" title="UICollectionView"></a><strong>UICollectionView</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，我们完成了简单的部分。 现在，让我们尝试通过集合视图实现相同的功能。 <code>UICollectionView</code> 是一个通用类，旨在创建自定义布局，因为这种通用行为，你将无法从界面生成器创建自定义单元格。 你必须通过代码来完成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开始之前，我们仍然可以使用 <code>IB</code> 。 创建一个新的集合视图控制器场景，然后将一个推键从上一个表视图单元格拖到这个新的控制器上。 最后，将整个内容嵌入导航控制器中。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sc-stp3.jpg" alt="UICollectionView"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该单元将与我们用于表视图的单元完全相同，但是它是 <code>UICollectionViewCell</code> 的子类，并且我们将直接从代码构造布局。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionViewCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> dynamicLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="keyword">self</span>.bounds)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line">        label.backgroundColor = <span class="type">UIColor</span>.darkGray</span><br><span class="line">        label.numberOfLines = <span class="number">0</span></span><br><span class="line">        label.preferredMaxLayoutWidth = frame.size.width</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(label)</span><br><span class="line">        <span class="keyword">self</span>.dynamicLabel = label</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.dynamicLabel.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setPreferred</span><span class="params">(width: CGFloat)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.dynamicLabel.preferredMaxLayoutWidth = width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们为单元格提供了一个子类，现在让我们创建视图控制器类。 在 <code>viewDidLoad</code> 方法内部，你必须在集合视图上设置 <code>EstimatedItemSize</code> 属性。 如果输入的尺寸错误，自动旋转将无法正常工作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.navigationItem.rightBarButtonItem = <span class="type">UIBarButtonItem</span>(barButtonSystemItem: .refresh, target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.toggleColumns))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.register(<span class="type">CollectionViewCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView?.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">        flowLayout.itemSize = <span class="type">CGSize</span>(width: <span class="number">64</span>, height: <span class="number">64</span>)</span><br><span class="line">        flowLayout.minimumInteritemSpacing = <span class="number">10</span></span><br><span class="line">        flowLayout.minimumLineSpacing = <span class="number">20</span></span><br><span class="line">        flowLayout.sectionInset = <span class="type">UIEdgeInsets</span>(top: <span class="number">10</span>, <span class="keyword">left</span>: <span class="number">10</span>, bottom: <span class="number">10</span>, <span class="keyword">right</span>: <span class="number">10</span>)</span><br><span class="line">        flowLayout.estimatedItemSize = <span class="type">CGSize</span>(width: <span class="keyword">self</span>.preferredWith(forSize: <span class="keyword">self</span>.view.bounds.size), height: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.reloadData()</span><br><span class="line"></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>.collectionView!, selector: #selector(<span class="type">UICollectionView</span>.reloadData), name: <span class="type">UIContentSizeCategory</span>.didChangeNotification, object: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在旋转方法内部，必须使集合视图布局无效，并在发生过渡时重新计算可见的单元格大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">traitCollectionDidChange</span><span class="params">(<span class="number">_</span> previousTraitCollection: UITraitCollection?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span></span><br><span class="line">        <span class="keyword">let</span> previousTraitCollection = previousTraitCollection,</span><br><span class="line">        <span class="keyword">self</span>.traitCollection.verticalSizeClass != previousTraitCollection.verticalSizeClass ||</span><br><span class="line">        <span class="keyword">self</span>.traitCollection.horizontalSizeClass != previousTraitCollection.horizontalSizeClass</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">    <span class="keyword">self</span>.collectionView?.reloadData()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillTransition</span><span class="params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewWillTransition(to: size, with: coordinator)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">    <span class="keyword">self</span>.estimateVisibleCellSizes(to: size)</span><br><span class="line"></span><br><span class="line">    coordinator.animate(alongsideTransition: &#123; context <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    &#125;, completion: &#123; context <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有两种辅助方法可以计算估计的项目大小的首选宽度并重新计算可见的单元格大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preferredWith</span><span class="params">(forSize size: CGSize)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> columnFactor: <span class="type">CGFloat</span> = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.twoColumns &#123;</span><br><span class="line">        columnFactor = <span class="number">2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (size.width - <span class="number">30</span>) / columnFactor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">estimateVisibleCellSizes</span><span class="params">(to size: CGSize)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> collectionView = <span class="keyword">self</span>.collectionView <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView?.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">        flowLayout.estimatedItemSize = <span class="type">CGSize</span>(width: <span class="keyword">self</span>.preferredWith(forSize: size), height: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    collectionView.visibleCells.forEach(&#123; cell <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cell = cell <span class="keyword">as</span>? <span class="type">CollectionViewCell</span> &#123;</span><br><span class="line">            cell.setPreferred(width: <span class="keyword">self</span>.preferredWith(forSize: size))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果进行适当的计算，甚至可以包含多列。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我只有一件事无法解决，但这只是一条日志消息。 如果向后旋转设备，则某些单元格将不可见，布局引擎将无法对这些单元格进行快照。</p><p><strong><em>快照尚未渲染的视图将导致快照为空。 确保在快照之前或屏幕更新后快照至少已渲染一次视图。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你可以通过某种方式使此消息消失 <code>OS_ACTIVITY_MODE = disable</code> 。 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如何在Swift中为表格视图和集合视图制作自定义大小的单元格，以支持方向更改和动态字体类型。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;UITableView&quot;&gt;&lt;a href=&quot;#UITableView&quot; class=&quot;headerlink&quot; title=&quot;UITableView&quot;&gt;&lt;/a&gt;&lt;strong&gt;UITableView&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此，让我们从 &lt;code&gt;iOS&lt;/code&gt; 的标准单视图模板开始。 命名项目，然后直接转到 &lt;code&gt;Main.storyboard&lt;/code&gt; 文件。 选择你的 &lt;code&gt;ViewController&lt;/code&gt; ，将其删除并创建一个新的 &lt;code&gt;UITableViewController&lt;/code&gt; &lt;code&gt;scene&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自适应布局" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"/>
    
      <category term="UITableView" scheme="http://www.xuebaonline.com/tags/UITableView/"/>
    
  </entry>
  
  <entry>
    <title>Swift使用布局锚点添加约束</title>
    <link href="http://www.xuebaonline.com/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/"/>
    <id>http://www.xuebaonline.com/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/</id>
    <published>2020-04-26T12:12:24.000Z</published>
    <updated>2020-04-27T01:30:53.037Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Auto Layout</code> 经常引起抱怨的是，语法以编程方式创建约束的方式多么繁琐和难以理解。 幸运的是，<code>iOS 9</code> 做了很多改进。 <code>堆栈视图</code> 消除了我们在典型布局中创建许多约束的需要。 相比较而言，布局锚点和布局指南的引入却被忽略了，但同样有用。 从《 Apple自动版面指南》中：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以编程方式创建约束时，你有三个选择：可以使用 <code>layout anchors</code> ，可以使用 <code>NSLayoutConstraint</code> 类，或者可以使用可视格式语言。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将再次看一下布局指南，但是现在这里是我关于使用布局锚点在代码中轻松创建约束的说明：</p><a id="more"></a></br><h1 id="创建约束"><a href="#创建约束" class="headerlink" title="创建约束"></a><strong>创建约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先提醒一下使用 <code>NSLayoutConstraint</code> 类方法创建约束的方式。 假设我们有一个堆栈视图，我们想要固定到视图控制器顶级视图的左右边距：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLayoutConstraint</span>(item: stackView,</span><br><span class="line">  attribute: .leading,</span><br><span class="line">  relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">  toItem: view,</span><br><span class="line">  attribute: .leadingMargin,</span><br><span class="line">  multiplier: <span class="number">1</span>,</span><br><span class="line">  constant: <span class="number">0</span>).isActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="type">NSLayoutConstraint</span>(item: stackView,</span><br><span class="line">  attribute: .trailing,</span><br><span class="line">  relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">  toItem: view,</span><br><span class="line">  attribute: .trailingMargin,</span><br><span class="line">  multiplier: <span class="number">1</span>,</span><br><span class="line">  constant: <span class="number">0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以将堆栈视图固定在顶部布局指南下方，以免被导航栏隐藏：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLayoutConstraint</span>(item: stackView,</span><br><span class="line">attribute: .top,</span><br><span class="line">relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">toItem: topLayoutGuide,</span><br><span class="line">attribute: .bottom,</span><br><span class="line">multiplier: <span class="number">1</span>,</span><br><span class="line">constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为我们可以同意，这既不美观也不容易理解（ <code>Objective-C</code> 版本更糟）。 在我看来，使用 <strong><em>Visual Format Language</em></strong> 并不是更好：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> views: [<span class="type">String</span>: <span class="type">AnyObject</span>] =</span><br><span class="line">  [<span class="string">"stackView"</span> : stackView,</span><br><span class="line">   <span class="string">"topLayoutGuide"</span> : topLayoutGuide]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="type">NSLayoutConstraint</span>.constraints(</span><br><span class="line">  withVisualFormat: <span class="string">"|-[stackView]-|"</span>,</span><br><span class="line">  options: [],</span><br><span class="line">  metrics: <span class="literal">nil</span>,</span><br><span class="line">  views: views)</span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate(h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="type">NSLayoutConstraint</span>.constraints(</span><br><span class="line">  withVisualFormat: <span class="string">"V:|[topLayoutGuide]-[stackView]"</span>,</span><br><span class="line">  options: [],</span><br><span class="line">  metrics: <span class="literal">nil</span>,</span><br><span class="line">  views: views)</span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate(v)</span><br></pre></td></tr></table></figure></br><h1 id="使用-Layout-Anchors-创建约束"><a href="#使用-Layout-Anchors-创建约束" class="headerlink" title="使用 Layout Anchors 创建约束"></a><strong>使用 <code>Layout Anchors</code> 创建约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布局锚点使创建约束更加容易。 从文档中：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>NSLayoutAnchor</code> 类是用于使用流畅的 <code>API</code> 创建 <code>NSLayoutConstraint</code> 对象的工厂类。 使用这些约束可以使用“自动布局”以编程方式定义你的布局。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布局锚点是 <code>UIView</code>（或<code>UILayoutGuide</code> ）上的属性。 每个属性都是 <code>NSLayoutAnchor</code> 的子类，其方法可直接为其他相同类型的布局锚创建约束。 <code>UIView</code> 具有十二种不同的布局锚点属性，可用于创建水平，垂直或基于大小的约束：</p><h2 id="水平约束"><a href="#水平约束" class="headerlink" title="水平约束"></a><strong><em>水平约束</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于创建水平约束的  <code>NSLayoutXAxisAnchor</code> 类型的布局锚点：</p><ul><li><code>centerXAnchor</code></li><li><code>leadingAnchor</code> 和 <code>trailingAnchor</code></li><li><code>leftAnchor</code> 和 <code>rightAnchor</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，创建约束以使两个视图居中对齐：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">myView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.centerXAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.centerXAnchor].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><p><strong><em>请注意如何从一个视图上的锚点开始并为另一个视图上的锚点创建约束。</em></strong></p><h2 id="垂直约束"><a href="#垂直约束" class="headerlink" title="垂直约束"></a><strong><em>垂直约束</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于创建垂直约束的 <code>NSLayoutYAxisAnchor</code> 类型的布局锚点：</p><ul><li><code>centerYAnchor</code></li><li><code>bottomAnchor</code> 和 <code>topAnchor</code></li><li><code>firstBaselineAnchor</code> 和 <code>lastBaselineAnchor</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，要在间距恒定的两个视图的顶部和底部锚点之间创建约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swift</span><br><span class="line">myView.bottomAnchor.constraint(equalTo: view.topAnchor,</span><br><span class="line">       constant: 8).isActive&#x3D;true</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.bottomAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.topAnchor</span><br><span class="line">      constant:<span class="number">8.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="基于-Size-的约束"><a href="#基于-Size-的约束" class="headerlink" title="基于 Size 的约束"></a><strong><em>基于 Size 的约束</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>NSLayoutDimension</code> 类型的布局锚，用于创建基于 <code>Size</code> 的约束：</p><ul><li><code>heightAnchor</code> 和 <code>widthAnchor</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，为视图创建宽度约束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">myView.widthAnchor.constraint(equalToConstant: <span class="number">50.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.widthAnchor constraintEqualToConstant:<span class="number">50.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个示例，使用 <code>multiplier</code> 使一个视图的高度是另一个视图的高度的两倍：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">myView.heightAnchor.constraint(equalTo: otherView.heightAnchor,</span><br><span class="line">       multiplier: <span class="number">2.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.heightAnchor constraintEqualToAnchor:<span class="keyword">self</span>.otherView.heightAnchor </span><br><span class="line">      multiplier:<span class="number">2.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="视图边距"><a href="#视图边距" class="headerlink" title="视图边距"></a><strong><em>视图边距</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIView</code> 没有用于创建堆栈视图约束时使用的前，后边距的布局锚。 相反，<code>iOS 9</code> 添加了两个新属性， <code>layoutMarginGuide</code> 和可读 <code>readableContentGuide</code> ，它们又具有布局锚点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，要将子视图的前沿约束到父视图的前面：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="keyword">let</span> margins = view.layoutMarginsGuide    </span><br><span class="line">myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line"><span class="type">UILayoutGuide</span> *margins = <span class="keyword">self</span>.view.layoutMarginsGuide;</span><br><span class="line">[<span class="keyword">self</span>.myView.leadingAnchor constraintEqualToAnchor:</span><br><span class="line">      margins.leadingAnchor].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="顶部和底部布局"><a href="#顶部和底部布局" class="headerlink" title="顶部和底部布局"></a><strong><em>顶部和底部布局</em></strong></h2><blockquote><p><strong><code>提示:</code></strong> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顶部和底部布局指南已由 <code>iOS 11</code> 中的 <code>“Safe Area Layout Guide ”</code> 代替。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你要相对于顶部或底部 <code>UIKit</code> 工具栏定位内容时，视图控制器具有 <code>topLayoutGuide</code> 和 <code>bottomLayoutGuide</code> 属性。 从 <code>iOS 9</code> 开始，这两个属性均符合 <code>UILayoutSupport</code>  协议，该协议为 <code>bar</code> 提供了 <code>bottomAnchor</code> ， <code>topAnchor</code> 和 <code>heightAnchor</code> 属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，要将视图放置在顶部布局指南底部下方8个点处：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">    myView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor,</span><br><span class="line">       constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">    [<span class="keyword">self</span>.stackView.topAnchor constraintEqualToAnchor:<span class="keyword">self</span>.topLayoutGuide.bottomAnchor</span><br><span class="line">       constant:<span class="number">8.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="控件组合布局"><a href="#控件组合布局" class="headerlink" title="控件组合布局"></a><strong><em>控件组合布局</em></strong></h2><p><strong>那么我们如何使用布局锚创建堆栈视图约束？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们获得父视图的 <code>leading</code> 和 <code>trailing</code> 边距：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> margins = view.layoutMarginsGuide</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建 <code>leading</code> 和 <code>trailing</code>  水平约束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = <span class="literal">true</span></span><br><span class="line">stackView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我们使用视图控制器的 <code>topLayoutGuide</code> 属性将堆栈视图固定在导航栏下方的8点处：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor,</span><br><span class="line">          constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Objective-C</code> 版本稍微冗长一些，但仍有很大改进：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UILayoutGuide</span> *margins = <span class="keyword">self</span>.view.layoutMarginsGuide;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.stackView.leadingAnchor</span><br><span class="line">      constraintEqualToAnchor:margins.leadingAnchor].active = <span class="type">YES</span>;</span><br><span class="line">[<span class="keyword">self</span>.stackView.trailingAnchor</span><br><span class="line">      constraintEqualToAnchor:margins.trailingAnchor].active = <span class="type">YES</span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.stackView.topAnchor</span><br><span class="line">      constraintEqualToAnchor:<span class="keyword">self</span>.topLayoutGuide.bottomAnchor</span><br><span class="line">      constant:<span class="number">8.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与以前的代码相比，我发现更容易理解这些约束的意图。</p></br><h1 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a><strong>了解更多</strong></h1><ul><li><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ProgrammaticallyCreatingConstraints.html" target="_blank" rel="noopener"><strong><code>Programmatically Creating Constraints (Apple Auto Layout Guide)</code></strong></a></li><li><a href="https://developer.apple.com/videos/play/wwdc2015/219/" target="_blank" rel="noopener"><strong><code>WWDC 2015 Session 219 Mysteries of Auto Layout, Part 2</code></strong></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Auto Layout&lt;/code&gt; 经常引起抱怨的是，语法以编程方式创建约束的方式多么繁琐和难以理解。 幸运的是，&lt;code&gt;iOS 9&lt;/code&gt; 做了很多改进。 &lt;code&gt;堆栈视图&lt;/code&gt; 消除了我们在典型布局中创建许多约束的需要。 相比较而言，布局锚点和布局指南的引入却被忽略了，但同样有用。 从《 Apple自动版面指南》中：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在以编程方式创建约束时，你有三个选择：可以使用 &lt;code&gt;layout anchors&lt;/code&gt; ，可以使用 &lt;code&gt;NSLayoutConstraint&lt;/code&gt; 类，或者可以使用可视格式语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我将再次看一下布局指南，但是现在这里是我关于使用布局锚点在代码中轻松创建约束的说明：&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自动化布局" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>Swift掌握iOS自动布局锚点</title>
    <link href="http://www.xuebaonline.com/Swift%E6%8E%8C%E6%8F%A1iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9/"/>
    <id>http://www.xuebaonline.com/Swift%E6%8E%8C%E6%8F%A1iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9/</id>
    <published>2020-04-26T12:10:50.000Z</published>
    <updated>2020-04-27T01:59:09.032Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;寻找使用布局锚点的最佳实践吗？ 让我们学习如何使用 <code>Swift</code> 以正确的方式使用 <code>iOS</code> 自动布局系统。</p><h1 id="以代码方式创建视图和约束"><a href="#以代码方式创建视图和约束" class="headerlink" title="以代码方式创建视图和约束"></a><strong>以代码方式创建视图和约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我想回顾一下 <code>UIViewController</code> 生命周期方法，你可能对其中一些方法很熟悉。 它们按以下顺序被调用：</p><ul><li><code>loadView</code></li><li><code>viewDidLoad</code></li><li><code>viewWillAppear</code></li><li><code>viewWillLayoutSubviews</code></li><li><code>viewDidLayoutSubviews</code></li><li><code>viewDidAppear</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在自动布局之前，你必须在 <code>viewDidLayoutSubviews</code> 方法内进行布局计算，但是由于这是专业的自动布局教程，因此我们仅关注 <code>loadView</code> 和 <code>viewDidLoad</code> 方法。 🤓</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些是使用自动布局创建视图层次结构的基本规则：</p><ul><li>永远不要自己手动计算帧！</li><li>使用 <code>.zero</code> 初始化视图 <code>frame</code></li><li>将 <code>translatesAutoresizing</code>, <code>MaskIntoConstraints</code> 设置为 <code>false</code></li><li>使用 <code>addSubview</code> 将视图添加到视图层次结构</li><li>创建并激活你的布局约束 <code>NSLayoutConstraint.activate</code></li><li>使用 <code>loadView</code> 代替 <code>viewDidLoad</code> 创建具有约束的视图</li><li>通过使用弱引用来管理内存管理</li><li>在 <code>viewDidLoad</code> 中设置所有其他属性，例如背景色等。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理论足够，下面是一个简短的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> testView: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">        testView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(testView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            testView.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            testView.widthAnchor.constraint(equalTo: testView.heightAnchor),</span><br><span class="line">            testView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">            testView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.testView = testView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView.backgroundColor = .red</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很简单吧？ 只需几行代码，你就可以得到一个大小固定的中心对齐视图，并带有专用的类属性引用。 如果通过接口构建器创建完全相同的对象，则调用 <code>loadView</code> 方法，但是你必须设置对该视图的 <code>@IBOutlet</code> 引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没关系，请随意选择。 有时我喜欢和 <code>IB</code> 一起玩，但是在大多数情况下，我更喜欢编程的做事方式。 😛</p></br><h1 id="常见的UIKit自动布局约束用例"><a href="#常见的UIKit自动布局约束用例" class="headerlink" title="常见的UIKit自动布局约束用例"></a><strong>常见的UIKit自动布局约束用例</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我只使用布局锚。 你可能会浪费时间使用 <code>visual format language</code> ，但这绝对是死胡同。 因此，请记住我的话：仅使用锚点或堆栈视图，请勿使用其他任何视图！ 😇</p><p>这是我用来创建漂亮布局的最常见模式。 😉</p><h2 id="设置固定宽度或高度"><a href="#设置固定宽度或高度" class="headerlink" title="设置固定宽度或高度"></a><strong><em>设置固定宽度或高度</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个是最简单的一个：将视图的高度或宽度设置为固定点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.widthAnchor.constraint(equalToConstant: <span class="number">320</span>),</span><br><span class="line">testView.heightAnchor.constraint(equalToConstant: <span class="number">240</span>),</span><br></pre></td></tr></table></figure><h2 id="设定长宽比"><a href="#设定长宽比" class="headerlink" title="设定长宽比"></a><strong><em>设定长宽比</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置视图的纵横比只是将宽度限制为高度，反之亦然，你可以通过 <code>multiplier</code> 简单地定义倍数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">testView.widthAnchor.constraint(equalTo: testView.heightAnchor, multiplier: <span class="number">16</span>/<span class="number">9</span>),</span><br></pre></td></tr></table></figure><h2 id="水平和垂直居中"><a href="#水平和垂直居中" class="headerlink" title="水平和垂直居中"></a><strong><em>水平和垂直居中</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将视图居中放置在另一个视图中是一件很简单的事情，为此需要特定的锚点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">testView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br></pre></td></tr></table></figure><h2 id="伸展-用边距填充内部视图"><a href="#伸展-用边距填充内部视图" class="headerlink" title="伸展 | 用边距填充内部视图"></a><strong><em>伸展 | 用边距填充内部视图</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里唯一棘手的部分是，对于常量，尾部约束和底部约束的行为与顶部和前部约束略有不同。 通常，你必须使用负值，但经过几次尝试，你将在这里理解逻辑。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.topAnchor, constant: <span class="number">32</span>),</span><br><span class="line">testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.leadingAnchor, constant: <span class="number">32</span>),</span><br><span class="line">testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.trailingAnchor, constant: -<span class="number">32</span>),</span><br><span class="line">testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.bottomAnchor, constant: -<span class="number">32</span>),</span><br></pre></td></tr></table></figure><h2 id="比例宽度或高度"><a href="#比例宽度或高度" class="headerlink" title="比例宽度或高度"></a><strong><em>比例宽度或高度</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不想使用常量值，可以使用 <code>multiplier</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.widthAnchor.constraint(equalTo: <span class="keyword">self</span>.view.widthAnchor, multiplier: <span class="number">1</span>/<span class="number">3</span>),</span><br><span class="line">testView.heightAnchor.constraint(equalTo: <span class="keyword">self</span>.view.heightAnchor, multiplier: <span class="number">2</span>/<span class="number">3</span>),</span><br></pre></td></tr></table></figure><h2 id="使用-safe-area-layout"><a href="#使用-safe-area-layout" class="headerlink" title="使用 safe area layout"></a><strong><em>使用 safe area layout</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用最新的 <code>iPhone</code> ，你将需要一些指南，以确保你安全无虞。 这就是视图具有 <code>safeAreaLayoutGuide</code> 属性的原因。 调出安全区域指南后，即可获得所有常用锚。 💪</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor),</span><br><span class="line">testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.leadingAnchor),</span><br><span class="line">testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.trailingAnchor),</span><br><span class="line">testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor),</span><br></pre></td></tr></table></figure></br><h1 id="带有动画的布局约束"><a href="#带有动画的布局约束" class="headerlink" title="带有动画的布局约束"></a><strong>带有动画的布局约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有约束的动画很容易，你不应该相信别人会说什么。 我制定了一些规则和示例，可以帮助你理解为约束的常量值设置动画效果以及切换各种约束的基本原理。 👍</p><p><strong>规则</strong>：</p><ul><li>将标准 <code>UIView</code> 动画与 <code>layoutIfNeeded</code> 一起使用</li><li>始终先停用约束</li><li>遵守停用的约束</li><li>玩得开心！ 😛</li></ul><p>约束动画示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> testView: <span class="type">UIView!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> topConstraint: <span class="type">NSLayoutConstraint!</span></span><br><span class="line">    <span class="keyword">var</span> bottomConstraint: <span class="type">NSLayoutConstraint!</span></span><br><span class="line">    <span class="keyword">var</span> heightConstraint: <span class="type">NSLayoutConstraint!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">        testView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(testView)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> topConstraint = testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor)</span><br><span class="line">        <span class="keyword">let</span> bottomConstraint = testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor)</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            topConstraint,</span><br><span class="line">            testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.leadingAnchor),</span><br><span class="line">            testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.trailingAnchor),</span><br><span class="line">            bottomConstraint,</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> heightConstraint = testView.heightAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.heightAnchor, multiplier: <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView = testView</span><br><span class="line">        <span class="keyword">self</span>.topConstraint = topConstraint</span><br><span class="line">        <span class="keyword">self</span>.bottomConstraint = bottomConstraint</span><br><span class="line">        <span class="keyword">self</span>.heightConstraint = heightConstraint</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView.backgroundColor = .red</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> tap = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.tapped))</span><br><span class="line">        <span class="keyword">self</span>.view.addGestureRecognizer(tap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">tapped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.topConstraint.constant != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.topConstraint.constant = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.topConstraint.constant = <span class="number">64</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.bottomConstraint.isActive &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.deactivate([<span class="keyword">self</span>.bottomConstraint])</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate([<span class="keyword">self</span>.heightConstraint])</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.deactivate([<span class="keyword">self</span>.heightConstraint])</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate([<span class="keyword">self</span>.bottomConstraint])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: <span class="number">0.25</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.view.layoutIfNeeded()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，还算不错：适应性强并且支持多种设备屏幕尺寸。 🤔</p></br><h1 id="如何为iOS创建自适应布局？"><a href="#如何为iOS创建自适应布局？" class="headerlink" title="如何为iOS创建自适应布局？"></a><strong>如何为iOS创建自适应布局？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果公司内置的 <code>iOS</code> 应用程序中都难以适应自适应布局。 如果你查看使用收藏夹视图制作的应用程序（例如照片），则在每个设备上的布局都可以。 但是，还有其他一些-我认为-在更大的屏幕上是可怕的经历。 <code>#just use collectionview</code> 所有内容。 🤐</p><h2 id="支持旋转"><a href="#支持旋转" class="headerlink" title="支持旋转"></a><strong><em>支持旋转</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自适应布局的第一步是支持多种设备方向。 你可以查看我以前有关iOS自动布局的文章，其中有很多关于旋转支持，在自动布局区域内使用图层等方面的好文章。</p><h2 id="特征集合"><a href="#特征集合" class="headerlink" title="特征集合"></a><strong><em>特征集合</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步是调整特征集合。  <code>UITraitCollection</code> 可以为你分组所有特定于环境的特征，例如尺寸类别，显示比例，用户界面 <code>idom</code> 等。 大多数时候，你将不得不检查垂直和水平尺寸类别。 有设备尺寸类别的参考以及 <code>Apple</code> 所做的所有可能的变化，请参阅下面的外部资源部分。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的这个小段 <code>Swift</code> 代码示例演示了如何检查尺寸类别，以便为紧凑型和常规屏幕设置不同的布局。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> testView: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> regularConstraints: [<span class="type">NSLayoutConstraint</span>] = []</span><br><span class="line">    <span class="keyword">var</span> compactConstraints: [<span class="type">NSLayoutConstraint</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">        testView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(testView)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.regularConstraints = [</span><br><span class="line">            testView.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            testView.widthAnchor.constraint(equalTo: testView.heightAnchor),</span><br><span class="line">            testView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">            testView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.compactConstraints = [</span><br><span class="line">            testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor),</span><br><span class="line">            testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.leadingAnchor),</span><br><span class="line">            testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.trailingAnchor),</span><br><span class="line">            testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.activateCurrentConstraints()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView = testView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">activateCurrentConstraints</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.deactivate(<span class="keyword">self</span>.compactConstraints + <span class="keyword">self</span>.regularConstraints)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.traitCollection.verticalSizeClass == .regular &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate(<span class="keyword">self</span>.regularConstraints)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate(<span class="keyword">self</span>.compactConstraints)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView.backgroundColor = .red</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - rotation support</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .allButUpsideDown</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .portrait</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - trait collections</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">traitCollectionDidChange</span><span class="params">(<span class="number">_</span> previousTraitCollection: UITraitCollection?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.activateCurrentConstraints()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设备检测"><a href="#设备检测" class="headerlink" title="设备检测"></a><strong><em>设备检测</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以通过 <code>UIDevice</code> 类检查用户界面 <code>idom</code> （是 <code>iPhone</code> 还是 <code>iPad</code> ？），以基于该设备设置例如字体大小。 📱</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIDevice</span>.current.userInterfaceIdiom == .pad</span><br></pre></td></tr></table></figure><h2 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a><strong><em>屏幕尺寸</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定你的环境的另一个选项是检查屏幕的大小。 你可以检查原始像素数或以 <code>points</code> 为单位的相对大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iPhone X</span></span><br><span class="line"><span class="type">UIScreen</span>.main.nativeBounds   <span class="comment">// 1125x2436</span></span><br><span class="line"><span class="type">UIScreen</span>.main.bounds         <span class="comment">// 375x812</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常我会尽力遵守这些规则。 我真的不记得一个场景，在这种情况下，我需要的不只是上面列出的所有内容。 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;寻找使用布局锚点的最佳实践吗？ 让我们学习如何使用 &lt;code&gt;Swift&lt;/code&gt; 以正确的方式使用 &lt;code&gt;iOS&lt;/code&gt; 自动布局系统。&lt;/p&gt;
&lt;h1 id=&quot;以代码方式创建视图和约束&quot;&gt;&lt;a href=&quot;#以代码方式创建视图和约束&quot; class=&quot;headerlink&quot; title=&quot;以代码方式创建视图和约束&quot;&gt;&lt;/a&gt;&lt;strong&gt;以代码方式创建视图和约束&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先，我想回顾一下 &lt;code&gt;UIViewController&lt;/code&gt; 生命周期方法，你可能对其中一些方法很熟悉。 它们按以下顺序被调用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;loadView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewDidLoad&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewWillAppear&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewWillLayoutSubviews&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewDidLayoutSubviews&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewDidAppear&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在自动布局之前，你必须在 &lt;code&gt;viewDidLayoutSubviews&lt;/code&gt; 方法内进行布局计算，但是由于这是专业的自动布局教程，因此我们仅关注 &lt;code&gt;loadView&lt;/code&gt; 和 &lt;code&gt;viewDidLoad&lt;/code&gt; 方法。 🤓&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自动化布局" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>iOS自动化布局编程</title>
    <link href="http://www.xuebaonline.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.xuebaonline.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80%E7%BC%96%E7%A8%8B/</id>
    <published>2020-04-26T11:42:40.000Z</published>
    <updated>2020-04-26T12:14:39.344Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个出色的 <code>iOS Auto Layout</code> 教程中，我将教你如何支持旋转，使用约束，使用图层以及设置拐角半径的动画。</p><br><h1 id="支持旋转"><a href="#支持旋转" class="headerlink" title="支持旋转"></a><strong>支持旋转</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你的应用程序要支持多种设备方向，则应在视图控制器内部实现以下方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .portrait</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .portrait</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，你可以更改返回值以不仅支持纵向，还支持横向模式。 这很容易，但是，如果你的控制器嵌入在导航或选项卡栏控制器内部，则旋转将停止工作。 在这种情况下，你必须继承 <code>UINavigationController</code> 的子类，并且必须从顶视图控制器返回正确的值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NavigationController</span>: <span class="title">UINavigationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> shouldRotate = <span class="keyword">self</span>.topViewController?.shouldAutorotate &#123;</span><br><span class="line">            <span class="keyword">return</span> shouldRotate</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldAutorotate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> orientation = <span class="keyword">self</span>.topViewController?.supportedInterfaceOrientations &#123;</span><br><span class="line">            <span class="keyword">return</span> orientation</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.supportedInterfaceOrientations</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> orientation = <span class="keyword">self</span>.topViewController?.preferredInterfaceOrientationForPresentation &#123;</span><br><span class="line">            <span class="keyword">return</span> orientation</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preferredInterfaceOrientationForPresentation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果具有 <code>UITabBarController</code> ，则适用相同的逻辑，但必须使用 <code>selectedIndex</code> 并基于所选视图控制器返回属性，而不是顶视图控制器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabBarController</span>: <span class="title">UITabBarController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewController = <span class="keyword">self</span>.viewControllers?[<span class="keyword">self</span>.selectedIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> viewController.shouldAutorotate</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldAutorotate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewController = <span class="keyword">self</span>.viewControllers?[<span class="keyword">self</span>.selectedIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> viewController.supportedInterfaceOrientations</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.supportedInterfaceOrientations</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewController = <span class="keyword">self</span>.viewControllers?[<span class="keyword">self</span>.selectedIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> viewController.preferredInterfaceOrientationForPresentation</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preferredInterfaceOrientationForPresentation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，你的嵌入式控制器就可以控制支持的方向。 哦，顺便说一句，你可以使用此方法更改状态栏样式。</p></br><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a><strong>约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了 <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/" target="_blank" rel="noopener"><code>了解约束</code></a> 和 <a href="https://www.raywenderlich.com/160527/auto-layout-tutorial-ios-11-getting-started" target="_blank" rel="noopener"><code>Auto Layout engine</code></a> 的当前状态，我们应该回到过去并从头开始。</p><h2 id="Springs-and-struts"><a href="#Springs-and-struts" class="headerlink" title="Springs and struts"></a><strong><em>Springs and struts</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还记得第一部 <code>iPhone</code> 吗？ 一屏统治一切！ <code>320x480</code>，没有限制，没有适应性，只有帧和边界。 在固定大小的画布上放置视图绝对是理所当然的，这是一个示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> squareFrame: <span class="type">CGRect</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> midX = <span class="keyword">self</span>.view.bounds.midX</span><br><span class="line">        <span class="keyword">let</span> midY = <span class="keyword">self</span>.view.bounds.midY</span><br><span class="line">        <span class="keyword">let</span> size: <span class="type">CGFloat</span> = <span class="number">64</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGRect</span>(x: midX-size/<span class="number">2</span>, y: midY-size/<span class="number">2</span>, width: size, height: size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.frame = <span class="keyword">self</span>.squareFrame</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>viewDidLayoutSubviews</code> 方法可以非常方便地支持旋转，如果边界矩形发生变化，我每次都必须重新计算视图的框架。 你可能会想，这很容易，但是如果你必须支持许多设备尺寸会怎样？</p><blockquote><p><strong><em>算一算！</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于单个对象，进行计算非常容易，但是通常你在屏幕上有多个视图。 这些视图可以相互联系，简单的数学技巧可以使你完全陷入帧计算的混乱之中，你还会喜欢数学吗？ 肯定有更好的办法！</p></br><h1 id="Auto-Layout"><a href="#Auto-Layout" class="headerlink" title="Auto Layout"></a><strong>Auto Layout</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果通过<code>iOS6</code>为我们带来了布局技术的圣杯。 它是先前系统的完美继承者。 每个人都很快采用了它，这就是为什么苹果工程师在下一版本中完全删除了基于框架的布局<code>API</code>的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了开玩笑之外，这是一个新时代的开始，越来越多的设备诞生了，并且由于自动版式的限制，维护视图非常容易。 现在，我们应该使用布局约束来重构前面的示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        square.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addConstraints([</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .width, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="literal">nil</span>, attribute: .width, multiplier: <span class="number">1.0</span>, constant: <span class="number">64</span>),</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .height, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="literal">nil</span>, attribute: .height, multiplier: <span class="number">1.0</span>, constant: <span class="number">64</span>),</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .centerX, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="keyword">self</span>.view, attribute: .centerX, multiplier: <span class="number">1.0</span>, constant: <span class="number">0</span>),</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .centerY, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="keyword">self</span>.view, attribute: .centerY, multiplier: <span class="number">1.0</span>, constant: <span class="number">0</span>),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我们不需要手动计算视图的框架，但是以编程方式创建约束并不是那么方便。 这就是为什么 <code>Apple</code> 制定了限制格式 <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html" target="_blank" rel="noopener"><code>Visual Format Language</code></a>。</p><blockquote><p><strong><code>VFL = WTF?</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，这个<code>VFL</code>非常糟糕，我什至不想演示它，但是无论如何…</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        square.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> views: [<span class="type">String</span>:<span class="type">Any</span>] = [<span class="string">"view"</span>: <span class="keyword">self</span>.view, <span class="string">"subview"</span>: square]</span><br><span class="line">        <span class="keyword">let</span> vertical = <span class="type">NSLayoutConstraint</span>.constraints(withVisualFormat: <span class="string">"V:[view]-(&lt;=1)-[subview(==64)]"</span>, options: .alignAllCenterX, metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> horizontal = <span class="type">NSLayoutConstraint</span>.constraints(withVisualFormat: <span class="string">"H:[view]-(&lt;=1)-[subview(==64)]"</span>, options: .alignAllCenterY, metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line">        <span class="keyword">self</span>.view.addConstraints(vertical)</span><br><span class="line">        <span class="keyword">self</span>.view.addConstraints(horizontal)</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>God forbid the engineer who invented this black magic. :)</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如你所见，我们肯定存在约束方面的问题。 创建所有约束很糟糕，至少要花很多行代码。 当然，你可以使用神奇的界面生成器，但是如果只是拖动线，那么有趣的地方在哪里呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以编程方式创建约束并不比计算框架好，它会导致你达到相同的复杂度甚至更糟，这就是为什么这么多第三方框架活跃起来并最终由<code>Apple</code>发出问题的原因。</p><blockquote><p><strong><code>提示:</code></strong><br>我有一篇<a href="http://www.xuebaonline.com/Swift%E6%8E%8C%E6%8F%A1iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9/"><code>关于掌握自动布局锚点</code></a>的出色文章，如果你想熟悉锚点，强烈建议阅读。 📖</p></blockquote></br><h1 id="锚点-Anchors"><a href="#锚点-Anchors" class="headerlink" title="锚点(Anchors)"></a><strong>锚点(Anchors)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.xuebaonline.com/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/"><code>锚点(Anchors)</code></a>的诞生是因为“自动布局”存在一些构造缺陷。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>NSLayoutAnchor</code> 类是用于使用流畅的 <code>API</code> 创建 <code>NSLayoutConstraint</code> 对象的工厂类。 使用这些约束可以使用“自动布局”以编程方式定义你的布局。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        square.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            square.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            square.heightAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            square.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">            square.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>锚点是用于自动布局约束的最佳方法。</em></strong></p></br><h1 id="自适应布局-Adaptive-layout"><a href="#自适应布局-Adaptive-layout" class="headerlink" title="自适应布局(Adaptive layout)"></a><strong>自适应布局(Adaptive layout)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果查看 <code>Apple</code> 提供的内置应用程序的当前状态，你会发现只有其中一些是响应式/自适应的。 通常，使用集合视图的应用更容易适应更大的屏幕或不同的设备方向。</p><p><strong><em>始终使用 <code>collection views</code>。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了只是屏幕中心的一个视图之外，你都应该使用集合视图来构建用户界面。 它将为你提供可重用性，更低的内存开销，滚动以及更多好处。 如果你使用的是我的 <code>CollectionView</code> 微型框架，则甚至不必计算愚蠢的索引位置。</p></br><h1 id="基于图层的自动化布局"><a href="#基于图层的自动化布局" class="headerlink" title="基于图层的自动化布局"></a><strong>基于图层的自动化布局</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动布局很棒，但有时你必须直接处理图层。 现在在这种情况下，你仍然必须进行一些计算。 如果要处理视图子类，则可以轻松覆盖 <code>bounds</code> 属性并更新 <code>didSet</code> 块中的框架。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.gradientLayer.frame = <span class="keyword">self</span>.bounds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个选项是在视图控制器中重写 <code>viewDidLayoutSubviews</code> 方法，并根据新边界设置图层的框架。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.gradientView.gradientLayer.frame = <span class="keyword">self</span>.gradientView.bounds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以使用普通的键值监听来观察对象的 <code>bounds</code> 属性，并根据该属性来更新图层的框架。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// somewhere in the init method</span></span><br><span class="line"><span class="keyword">self</span>.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"bounds"</span>, options: .new, context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: <span class="keyword">Any</span>?, change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> keyPath == <span class="string">"bounds"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.gradientLayer.frame = <span class="keyword">self</span>.bounds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"bounds"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="带有动画的圆角设置"><a href="#带有动画的圆角设置" class="headerlink" title="带有动画的圆角设置"></a><strong>带有动画的圆角设置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，如果要在使用基于约束的布局时为视图设置动画，则必须执行类似的操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.widthConstraint.constant = <span class="number">64</span></span><br><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.view.layoutIfNeeded()</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，如果要为视图的拐角半径设置动画，则可以始终使用传统方式，并在边界更改上设置图层的 <code>cornerRadius</code> 属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，自<code>iOS 10</code>以来，我们有了这个精美的新 <code>UIViewPropertyAnimator API</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="number">16</span></span><br><span class="line"><span class="type">UIViewPropertyAnimator</span>(duration: <span class="number">2.5</span>, curve: .easeInOut) &#123;</span><br><span class="line">    <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="number">32</span></span><br><span class="line">&#125;.startAnimation()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这非常简单，你甚至可以应用 <code>cornerMask</code> 来仅对某些角进行倒圆。 基于图层的布局示例位于本文提供的源代码中，以及每种自动布局技术的完整示例。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在这个出色的 &lt;code&gt;iOS Auto Layout&lt;/code&gt; 教程中，我将教你如何支持旋转，使用约束，使用图层以及设置拐角半径的动画。&lt;/p&gt;
&lt;br&gt;

&lt;h1 id=&quot;支持旋转&quot;&gt;&lt;a href=&quot;#支持旋转&quot; class=&quot;headerlink&quot; title=&quot;支持旋转&quot;&gt;&lt;/a&gt;&lt;strong&gt;支持旋转&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你的应用程序要支持多种设备方向，则应在视图控制器内部实现以下方法。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewController&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; shouldAutorotate: &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; supportedInterfaceOrientations: &lt;span class=&quot;type&quot;&gt;UIInterfaceOrientationMask&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; .portrait&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; preferredInterfaceOrientationForPresentation: &lt;span class=&quot;type&quot;&gt;UIInterfaceOrientation&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; .portrait&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>产品开发的幕后花絮</title>
    <link href="http://www.xuebaonline.com/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E7%9A%84%E5%B9%95%E5%90%8E%E8%8A%B1%E7%B5%AE/"/>
    <id>http://www.xuebaonline.com/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E7%9A%84%E5%B9%95%E5%90%8E%E8%8A%B1%E7%B5%AE/</id>
    <published>2020-04-26T10:50:21.000Z</published>
    <updated>2020-04-26T11:41:43.062Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍产品专业人员用来定义问题，创建概念和选择最佳解决方案的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与关于设计师职务的争论类似，对于设计师是否应该编码，这是一个永无止境的讨论。 首先，我们谈论的是根本不同的心态。 尽管开发人员对技术流程的思考更多，但设计人员专注于用户执行的一系列操作，因为他们的目的是提出解决客户问题的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，产品设计师（或UX设计师，但正如我之前提到的那样，我不喜欢该职位）通常不做任何编码，仅因为我们从事的活动是专职职责。 设计师的大部分工作实际上甚至没有建立图形用户界面，而是进行了大量的交流和研究。 🔍</p><a id="more"></a></br><h1 id="我们有一个问题"><a href="#我们有一个问题" class="headerlink" title="我们有一个问题"></a><strong>我们有一个问题</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，当我拿到设计图时，该过程已经开始。 我们的产品经理来找我解决问题。 有几种定义问题的方法，例如根据数据分析或竞争对手的活动做出的假设； 技术改进为我们提供了更多空间； 或客户的直接要求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步（也是最重要的一步）是了解问题。 假设我们盯着分析，看到用户在流程的某个特定点下降，放弃它而没有完成任务。 问题是：为什么？ 提供解决方案之前，你需要确定要解决的问题。 你需要了解动机，目标，需求以及用户当前解决问题的方式。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接来自客户的想法可以对你的系统进行非常好的改进，但是你需要谨慎。 系统越大，用户对系统一无所知的机会就越大，这可能导致错误的假设。 他们可能不知道某些“隐藏”的细节，但是如果知道的话，他们会问一个完全不同的问题。 用户对现有系统的信念称为心理模型。 这仅表示他们基于对当前工具的了解，相信他们可以或不能使用你的工具。 心理模型可能会因教育或经验而改变，因此在你开始编写代码之前，你可能需要了解他们为什么想要特定的东西。 也许解决方案不是他们想要的，但是你可以给他们更好的解决方案。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有几种方法可以收集有关原因的信息，而我最喜欢的两个是调查和访谈。 你可以收集所有听众提出的一些高级问题，然后发送表格。 找到适合你的问卷调查的最佳平台并不总是容易的：虽然一个渠道可以为你提供大量的答案，但另一个渠道将是死路一条。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间安排也很重要：你应该注意听众的时间表。 当他们太忙甚至不工作时，他们将没有时间或精力来帮助你。 进行良好调查的秘诀还有很多，但重点是你需要耐心，尝试几种方法来吸引受众，直到找到最适合你的案例。</p></br><h1 id="与用户的真正联系：用户访谈"><a href="#与用户的真正联系：用户访谈" class="headerlink" title="与用户的真正联系：用户访谈"></a><strong>与用户的真正联系：用户访谈</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我喜欢的另一种做法是进行用户访谈。 听起来就是这样：你与用户（最好是一对一）坐下并与他们交谈。 你需要再次准备问题，但是调查虽然可以帮助你了解很多事情，但是面试仅可以帮助你解决一些问题，但范围更广。 重要的是进行实际对话而不是询问客户：你收集的问题是面试的基础，但是当客户回答时，你可以侧身甚至完全劫持讨论（只要你谈论的是你所遇到的问题） 都想解决）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你随身携带一个记事本，这将很有帮助，这样你就可以在伴侣写下最重要的要点时全神贯注于对话。 如果你的客户同意，你可以记录下采访，以便稍后再听并写下你自己的笔记。 🗒</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重要的是要观察到广泛的用户，尤其是在组中有多种用户的情况下。 如果你只关注一个小组，那么你可能会满足这对夫妇的需求，而拒绝其他人。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我对问题有满意的答案时，我可以通过创建草图或基本模型来开始实际的“设计”工作。在这一点上，我并没有将重点放在外观或精度上，我只是尝试为我的想法建立一些视觉支持。有时，我什至没有构建整个功能或页面，而只是构建一个特定的部分，例如复杂的控制器，模式，表单等等。我还尝试至少提出2-3个概念。这将帮助我与团队交流思想：那是我参与开发人员的地方，因为下一步是了解技术限制。当然，如果我们无法为用户找出有史以来最好的UI元素，那也没关系。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在收集了我们需要的所有信息之后（包括用户的必备信息，开发人员的约束以及可能的其他因素，例如设计，完整性和一致性准则等），我们的工作重点变得更加狭窄。这是我开始在像素完美的UI上工作的地方。我创建了可点击的原型，因此可以为团队提供一个快照，以显示实际软件的外观和工作方式，更重要的是，它们将成为可用性测试的核心：是的，我们将回头再回头。</p></br><h1 id="可用性测试简介"><a href="#可用性测试简介" class="headerlink" title="可用性测试简介"></a><strong>可用性测试简介</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户测试类似于访谈，你一次要与1位用户交谈，但是你可以提出任务而不是提问。你应该准备要执行的3-4个任务，就像它们已经存在时在系统中通常会执行的操作一样。这是验证你的工作，查看用户是否真的能够通过你的特定概念解决他们的问题的好方法。你如何进行这些会议的方式可能会因项目，概念因人员而异，但是以下一些重点可以派上用场：</p><ul><li>你测试用户界面而不是用户。无论他们做错了什么，不是他们的错，这是你的界面的缺陷。他们应该知道，你也知道。</li><li>不要给出详细的说明，而要编写高级任务，类似于现实生活中的任务。即使他们受过使用你的软件的教育，也不会一直有人陪他们走走。为了模拟这一点，你也不能通过原型指导他们。</li><li>包括与任务不直接相关的选项。如果你使用一些原型制作工具，它可能会以某种方式突出显示可点击元素。如果唯一可点击的东西是测试的控制器，他们将很容易找到解决方法。但是，如果有几个不同的可操作项目，它们将能够环顾四周，打开和关闭物品，并且一旦达成交易便会迷失方向。即使你感觉“来吧，就在那里，为什么不找到它”，也应该抵制胆量并保持沉默。对你来说也许很清楚，但对他们来说却是一个谜。这些测试的目的是发现谜语，而不是证明你的想法合理。</li><li>提醒参与者在整个会议过程中大声思考，以便你了解他们为什么做自己的事情。与面试期间一样，你应该创建笔记并可能记录会话。会议结束后，你还可以与用户聊天。你可以回去问一下，如果他们在会议期间没有解释，为什么他们要做特定的事情。你甚至可以在这一点上询问他们的意见，但绝不能在会议期间提出。放弃有关UI的想法可能会使你偏离测试目标，因此请保持专注并保持参与者的专注。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些会议的结果将帮助你了解概念的弱点，或者只是帮助你选择最佳的概念。 你可以重新考虑一些事情，然后再进行测试，然后再继续。 测试和迭代的次数取决于你的时间和预算：根据 <code>Jacob Nielsen</code> 的说法，如果与5个用户一起测试，最好的方法是考虑未发现的问题的数量和会话的成本，因为一段时间后，用户会反复发现其他已经存在的问题 裸露。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适当招募参与者也很重要。 如果你要为会计师构建应用程序，则可能不会获得机械师的宝贵反馈。 同样，如果你要改善现有服务，则最好与已经使用该服务的人联系，而不是与新员工交谈（除非你尝试弄清楚新手将如何与新功能交互）。</p><br><h1 id="要避免的常见错误"><a href="#要避免的常见错误" class="headerlink" title="要避免的常见错误"></a><strong>要避免的常见错误</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一种称为设计批判的做法，在这种做法中，大量的团队成员（设计师，开发人员，质量保证人员，产品经理等）坐在一起讨论设计。 你提出自己的想法，其他人则可以基于对一致性，技术约束，所有问题或简单的可用性假设的关注而提出问题并提出更改建议。 这可能真的很有帮助：当你花很长时间尝试解决问题时，可能会遇到困难。 睁开眼睛和其他角度可以帮助你摆脱困境，无论如何都要进行一些头脑风暴总是好的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，团队经常将<code>DC</code>会话与适当的可用性验证混淆。 为什么不能仅用它们代替<code>UX</code>研究有以下几个原因：</p><ul><li><strong><em>详细说明</em></strong> &nbsp;&nbsp;&nbsp;&nbsp;在可用性测试期间，你将执行任务并查看其他人如何与你的原型进行交互，而设计评论则是关于你自己讲述整个故事。你按照流程进行操作，并告诉团队正在发生什么以及为什么。这样很容易理解，但是如果仅<code>UI</code>没有解释，则可能会失败。</li><li><strong><em>领域知识</em></strong> &nbsp;&nbsp;&nbsp;&nbsp;即使你只是在从事合同项目，与你一起工作的团队也具有丰富的领域知识。你知道系统的工作原理，知道后台发生了什么，如何传输数据，调用了什么<code>API</code>……用户不知道这种事情，你也不是你的用户。</li><li><strong><em>主观性</em></strong> &nbsp;&nbsp;&nbsp;&nbsp;虽然你可能喜欢某些东西，但其他人可能不喜欢。另外，尽管你认为某些事情很清楚，但其他人可能不理解。当你说“我认为这可行”时，这只是你的观点，其他人可能会基于他们的观点对此进行争论。意见分歧可以帮助你取得进展，但是，如果保持不变，这是一个标志，你应该查看用户的反应方式，而不是争夺你的意见。</li><li><strong><em>自我</em></strong>  &nbsp;&nbsp;&nbsp;&nbsp;我并不是说它总是存在，但是这些讨论很容易变成有争议的论据，每个人都试图说服他人。我对此不够强调：你没有为自己设计（或编写代码），而是为用户设计。如果团队中的某个人有一个更好的主意，或者只是发现了一个错误，请高兴地为你提供改善产品的机会。这不是单人表演，而是团队失败或胜利。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，要在没有任何实际数据的情况下通过一次演示来证明自己要困难得多。当你的设计基于推测时，可能很难捍卫一个想法，因为你无法用事实来支持它。其他人可能有不同的假设，从这一点出发，论点立足或落在参与者的说服力上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这并不意味着这些会议根本没有用，它们无法替代研究，因为它们以不同的方式帮助你。我也认为争论通常是好的，因为我们可以了解很多彼此的观点。我要说的是不确定性使事情变得困难，因为你只有在发表作品后才能看到结果。最好的办法是定期与团队进行研究并进行同步，以便在技术上仍可行的情况下，确保要构建的内容能够很好地为用户服务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你创建的所有内容都会带来用户体验。 UX不是你设计的，而是工作的必然结果。请记住这一点。 🙏</p></br><h1 id="设计师应该编码吗？-开发人员应该设计吗？"><a href="#设计师应该编码吗？-开发人员应该设计吗？" class="headerlink" title="设计师应该编码吗？ 开发人员应该设计吗？"></a><strong>设计师应该编码吗？ 开发人员应该设计吗？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为存在这个永恒的问题是因为图形<code>UI</code>设计本身通常并不困难。 <code>UI</code>设计工具（例如<code>Sketch</code>或<code>Figma</code>）非常简单，即使没有经验也很容易使用，而无需谈论网络上成千上万的优质教程和资源。图形用户界面设计是一项技能，而成为专家意味着你还拥有许多其他有价值的技能，这些技能最终将定义你。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于设计师和开发人员的思维方式之间存在核心差异，因此我更喜欢将研究与设计结合起来，而不是将设计与编码结合起来。如果你对自己的系统技术知识有偏见，可能很难找到问题的抽象解决方案。这就是为什么我在多个学科的协作以及不同观点的结合中看到真正价值的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，以视觉方式呈现你的作品仍然是有益的，因为它可以帮助你发现潜在的盲点和缺失的边缘情况，还可以帮助连接点并查看整体图片，最后但并非最不重要的一点：它要快得多在设计工具中进行修复而不是在实际代码中进行修复。因此，虽然我不说开发人员应该设计，但某些设计技能可以很好地补充你的工作流程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;介绍产品专业人员用来定义问题，创建概念和选择最佳解决方案的方法。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;与关于设计师职务的争论类似，对于设计师是否应该编码，这是一个永无止境的讨论。 首先，我们谈论的是根本不同的心态。 尽管开发人员对技术流程的思考更多，但设计人员专注于用户执行的一系列操作，因为他们的目的是提出解决客户问题的方法。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此，产品设计师（或UX设计师，但正如我之前提到的那样，我不喜欢该职位）通常不做任何编码，仅因为我们从事的活动是专职职责。 设计师的大部分工作实际上甚至没有建立图形用户界面，而是进行了大量的交流和研究。 🔍&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="用户体验" scheme="http://www.xuebaonline.com/categories/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="用户体验" scheme="http://www.xuebaonline.com/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>作为Swift开发人员，如何提供更好的用户体验？</title>
    <link href="http://www.xuebaonline.com/%E4%BD%9C%E4%B8%BASwift%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%9F/"/>
    <id>http://www.xuebaonline.com/%E4%BD%9C%E4%B8%BASwift%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%9F/</id>
    <published>2020-04-26T10:34:02.000Z</published>
    <updated>2020-04-26T10:49:25.872Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过一些可访问性提示来学习用户体验设计的基础知识，你可以立即使用这些提示为每个人构建更好的移动应用程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 很有趣，但是你曾经尝试过 <code>UX</code> 吗？ 当然有 你使用的所有内容都会带来用户体验。 遵循这样的逻辑：你创建并将要由他人使用的所有内容也将导致 <code>UX</code> 。 但是到底是什么，设计师和开发人员在哪里适合呢？ 让我们找出答案。</p><a id="more"></a></br><h1 id="用户体验设计"><a href="#用户体验设计" class="headerlink" title="用户体验设计"></a><strong>用户体验设计</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于所有不同类型的设计师，都有大量的文章，我也可以编写自己的文章，但现在暂时跳过。 我唯一要提及的是，我个人不喜欢 <code>“用户体验设计师”</code> 这个称呼，因为它可能会引起误解。 几乎没有设计专业人员经验的公司都希望你神奇地找出最好的 <code>UX</code> ：“因为那是你的工作，对吧？ 错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><em>用户体验是任何使用工具的人都在发生的现象。</em></strong> 任何工具。你是否在Twitter上发帖？它是 <code>UX</code> 。你是否在 <code>iPad</code> 上阅读邮件？它是 <code>UX</code> 。你是否喝用旧金属咖啡机制作的咖啡？用户体验。你是否刚刚从宜家购买了新椅子，并且必须将其放在一起？相同。你是否只是坐在崭新的椅子上享受一杯咖啡？仍然是 <code>UX</code> 。 ☕️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我可以设计这些东西吗？我可以说你会从头到尾按照此特定顺序进行所有这些操作，并且你会喜欢吗？不。我可以映射这种情况的可能方式吗？是的开始了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户体验“设计”是了解需求（你想每天早上在舒适的椅子上上班前喝咖啡），然后提供满足需求的工具。当然，我希望你尽可能轻松地实现自己的目标，因此，我将尝试了解你现在的处事方式以及如何更改这些处境以改善你的处境。然后，我将找出一种方法并定义“预期的用户体验”，并为你进行设置。到达那里后，你将获得真实的用户体验，这可能与我们期望的有很大不同。<strong><em>用户体验设计的目标是使期望的用户体验尽可能接近实际用户体验。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，舒适性不是 <code>UX</code> 的唯一方面。无论你创建什么内容，都希望使其易于理解，可学习，令人难忘，一致，可访问且安全。</p><p><strong>如果看起来也不错，那很好。</strong></p></br><h1 id="UX-舒适：辅助功能简介"><a href="#UX-舒适：辅助功能简介" class="headerlink" title="UX != 舒适：辅助功能简介"></a><strong>UX != 舒适：辅助功能简介</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如前所述，构建良好的用户界面具有挑战性。假设你正在开发应用程序，网站，服务或其他任何东西，并且希望使用框架的帮助。网路上有许多使用者介面框架和范本，因此你会很容易找到适合你的介面。可能要格外小心，为你的用户找到合适的产品。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可访问性（简称<code>a11y</code>）是 <code>UX</code> 最重要的方面之一。世界人口的10-20％患有一种或多种残疾。根据此摘要，英国，美国和加拿大的网络用户中有 <code>7％</code> 有灵活性问题；其中<code>8％</code>有某种色盲；并且其中<code>3-4％</code>的人看不清自己的阅读能力，而且随着时间的流逝越来越多。人们经常说a11y是有特殊需求的用户，但是我们不是都有我们自己的“特殊”自定义偏好吗？我们整理工作表以轻松实现所有功能，将应用程序按特定顺序分组在<code>iPhone</code>上，我们打开黑暗模式以获得更好的阅读体验和爱侣般的功耗… <code>A11y</code>并没有太大不同，并且移动设备很多辅助功能注意事项实际上非常简单：将信息最小化以适合小屏幕；使用明确的措辞，尤其是在可诉诸事项上；提供合理的触摸目标尺寸和间距；将控制器放置在易于访问的位置；使用正确的背景-前景对比（有类似的工具可以帮助你）；不仅依赖颜色：使用绿色，黄色和红色点进行状态反馈对你来说可能是一个简单明了的主意，但是对于某些人来说，它们只是灰色阴影（这是一个很酷的浏览器扩展程序，可以帮助你了解其他人看到）；手势应尽可能简单，如果你可以添加变通功能以通过屏幕菜单甚至键盘操作来模拟手势，则效果会更好，因为越来越多的移动设备也支持键盘。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，<code>iOS</code>具有强大的<code>a11y</code>支持，我也非常推荐这篇关于<code>SwiftUI</code>可访问性的文章。长话短说：通过采用<code>SwiftUI</code>，你将在正确的道路上为所有<code>iOS</code>用户提供可访问的<code>UI</code>（当然，与设计无关）。 <code>UIKit</code>也并非没有选项，但我将保留<code>Tib</code>的技术部分。 🙂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有更多的原则，但是下面列出的是一个好的开始。你可以将它们应用到<code>Web</code>应用程序中，因为无论如何都需要使其可移动。但是，即使你已做好一切准备，你仍然可能会出错。让我给你看一个例子。</p></br><h1 id="视觉设计的力量"><a href="#视觉设计的力量" class="headerlink" title="视觉设计的力量"></a><strong>视觉设计的力量</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设你在一个网页上，其中加载了“无限”元素列表以进行滚动（例如新闻源）。页面底部有一个固定的页脚，其中包含一些持久性和动态（隐藏）操作。你可以从页面中选择项目，然后在页脚中通过批量操作按钮“全部删除”。容易吧？ 👌</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在假设你不能使用触摸或鼠标，只能使用物理键盘。你可以按<code>Tab</code>键进行导航，从一个<code>UI</code>元素跳到另一个<code>UI</code>元素，但是列表仅加载越来越多的数据，因此你无法到达页脚，这意味着你无法进行操作。当然，修复起来很容易，只需将“加载滚动”选项替换为“加载更多”按钮，即可集中精力跳转到页脚，而无需加载更多项目。但是，如果你错过了它，则可能会阻止某些用户执行操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从另一个角度来看这个例子。选择要删除的项目，然后出现“全部删除”按钮，取消选择它们后它消失，因此可以连接各个点。但是，如果你没有看到此视觉反馈，该怎么办？如果只有屏幕阅读器告诉你“全部删除”按钮处于焦点，该怎么办？你是否知道仅适用于所选项目，还是希望它清除所有数据？如你所见，你使用的副本也很重要。当你看到“全部删除”已连接到所选项目时，“仅删除所选内容”对于那些只能依靠耳朵听的人也很清楚。虽然基本的UI对大多数用户都适用，但可访问的UI对所有人都更好。因此，别忘了照顾它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编码前设计UI可以帮助你解决这些情况，因此你不必浪费时间实施有缺陷的UI的多个版本。最受欢迎的框架都具有用于设计工具（例如<code>Sketch</code>或<code>Figma</code>）的组件库，因此你不会费劲将代码与设计进行匹配。大型公司非常注重维护和记录自己的自定义框架和<code>UI</code>库（共称为设计系统），以实现更快的工作流和更一致的<code>UI</code>，从而满足所有<code>UX</code>要求。但我会保留此内容以备将来之用。 😉</p></br><h1 id="用户界面之外的用户体验"><a href="#用户界面之外的用户体验" class="headerlink" title="用户界面之外的用户体验"></a><strong>用户界面之外的用户体验</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经讨论了工具的“触感”，现在让我们来看看幕后。他们说，最好的UX是看不见的，我敢说，至少在我们要执行任务时，我们都更喜欢简单而不是美观或娱乐。你的用户界面有多酷，服务是否不好，或者没有给用户他们想要的东西都没有关系。但是，如果你提供的工具运行良好，并且可以帮助用户有效地完成工作，则他们可能不太在乎界面的外观（请记住将 <code>iOS6</code> 换成 <code>iOS7</code> 😏）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，<code>UI</code>的简单性意味着后台的复杂性。只需考虑一下搜索引擎：这是一个非常简单的用户体验，你只需在搜索字段（甚至是浏览器的网址栏）中输入内容，然后魔术般地出现在屏幕上。在这里，你无需关心美观，有趣的动画或其他任何内容，而只关心速度和准确性：你想找到东西，现在就想要。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道看到加载动画超过3秒钟是多么令人沮丧。实际上，有研究表明，如果加载时间超过3秒，用户将放弃你的网站，这可能会令人震惊。毋庸置疑，视觉设计师对此无能为力。这是<code>UX</code>高度依赖开发人员的工作的众多情况之一，这是巨大的责任！我们所有人都希望轻松完成工作，但是有时候选择短路径意味着我们的用户将不得不走更长的路。我知道在项目束缚我们的过程中有很多因素（期限，遗留代码，依赖项等），但是如果你有机会提出问题的解决方案，请不要犹豫，因为这样做更容易。你的用户稍后会感谢你。 😊</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过一些可访问性提示来学习用户体验设计的基础知识，你可以立即使用这些提示为每个人构建更好的移动应用程序。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Swift&lt;/code&gt; 很有趣，但是你曾经尝试过 &lt;code&gt;UX&lt;/code&gt; 吗？ 当然有 你使用的所有内容都会带来用户体验。 遵循这样的逻辑：你创建并将要由他人使用的所有内容也将导致 &lt;code&gt;UX&lt;/code&gt; 。 但是到底是什么，设计师和开发人员在哪里适合呢？ 让我们找出答案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="用户体验" scheme="http://www.xuebaonline.com/categories/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="用户体验" scheme="http://www.xuebaonline.com/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>揭秘 WordPress Hook 系统</title>
    <link href="http://www.xuebaonline.com/%E6%8F%AD%E7%A7%98%20WordPress%20Hook%20%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.xuebaonline.com/%E6%8F%AD%E7%A7%98%20WordPress%20Hook%20%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-04-26T09:50:08.000Z</published>
    <updated>2020-04-26T10:13:55.975Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你一直在使用 <code>WordPress</code> 开发网站（包括插件和主题开发），那么你可能已经听说过以下术语：<code>挂钩</code>，<code>操作</code>和<code>过滤器</code>。 这些是 <code>WordPress</code> 使用的 <a href="https://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="noopener"><code>事件驱动架构模式(英文：Event-driven architecture)</code></a> 的一部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是 <code>WordPress</code> 开发的新手还是发现难以理解基本概念？ 我不能推荐足够高的 <a href="https://www.sitepoint.com/author/scodrington/" target="_blank" rel="noopener"><code>Simon Codrington</code></a> 的 <code>WordPress</code> 插件开发简介教程。 他在解释 <code>动作</code> 和 <code>过滤器</code> 方面做得很出色。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本教程中，我将揭开 <code>WordPress</code> 钩子系统的神秘面纱，不遗余力。 事不宜迟，让我们开始吧。</p><a id="more"></a></br><h1 id="挂钩，动作，过滤器。-这些是什么？"><a href="#挂钩，动作，过滤器。-这些是什么？" class="headerlink" title="挂钩，动作，过滤器。 这些是什么？"></a><strong>挂钩，动作，过滤器。 这些是什么？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>“挂钩”</code>基本上是由 <code>WordPress</code> 核心，主题和插件在 <code>PHP</code> 执行或解释的各个阶段触发的事件。 当这些事件被触发时，挂钩或附加到它们的所有函数和/或类方法均以其正确顺序执行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>挂钩</code>有两种形式，<code>动作</code>和<code>过滤器</code>。 前者用于在流程执行的各个阶段添加和删除功能部件，而后者则用于修改各种功能部件和实现的行为。 如果你仍然不了解，请不要担心。 当我们开始在下面看到一些代码示例时，你将看到。</p></br><h1 id="WordPress中Hook系统的重要性"><a href="#WordPress中Hook系统的重要性" class="headerlink" title="WordPress中Hook系统的重要性"></a><strong>WordPress中Hook系统的重要性</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>钩子系统</code> 在 <code>WordPress</code> 中的重要性仅仅是可扩展性。 它使添加和删除功能以及调整/修改 <code>WordPress</code> 核心，插件和主题中功能的实现成为可能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你编写可扩展的插件和主题时，其他开发人员无需编辑核心源代码就可以改进和扩展它们。</p></br><h1 id="深入研究WordPress挂钩系统"><a href="#深入研究WordPress挂钩系统" class="headerlink" title="深入研究WordPress挂钩系统"></a><strong>深入研究WordPress挂钩系统</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>WordPress</code> 执行的各个阶段，通常会使用 <code>do_actions（）</code>和<code>a pply_filters（）</code> <code>PHP</code> 函数来触发大量事件。 这些事件可以通过 <code>add_action（）</code>和 <code>add_filter（）</code>进行订阅或挂接。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意使用“普通”一词。 还有其他触发事件的方法。 我们将在本教程的第二部分中对此进行探讨。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是插件中操作的示例。 在我的 <code>ProfilePress</code> 用户注册插件中成功注册用户后，将触发此操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fires after a user registration is completed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param int $form_id ID of the registration form.</span></span><br><span class="line"><span class="comment"> * @param mixed $user_data array of registered user info.</span></span><br><span class="line"><span class="comment"> * @param int $user_id ID of the registered user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">do_action( 'pp_after_registration', $form_id, $user_data, $user_id );</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>WordPress</code> 执行期间，将处理与该操作关联的所有功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过滤器挂钩的一个示例是 <code>WordPress</code> 核心中的 <code>the_content</code> ，它过滤每个帖子内容。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Filter the post content.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 0.71</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> string $content Content of the current post.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   $content = apply_filters( <span class="string">'the_content'</span>, $content );</span><br></pre></td></tr></table></figure></br><h1 id="做个笔记"><a href="#做个笔记" class="headerlink" title="做个笔记"></a><strong>做个笔记</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>do_action（）</code>中，第一个参数是动作挂钩的名称，后续参数是可供挂钩到动作的函数使用的变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>apply_filters（）</code>中，第一个参数是过滤器挂钩的名称，第二个参数是修改或应用连接到过滤器的函数的数据或值。 后面的参数是挂钩到过滤器的函数可用的变量/值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不用担心，当我们检查代码示例时，所有这些将更有意义。</p><br><h1 id="动作挂钩示例"><a href="#动作挂钩示例" class="headerlink" title="动作挂钩示例"></a><strong>动作挂钩示例</strong></h1><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a><strong><em>实例1</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;试一下我的 <code>ProfilePress</code> 插件的 <code>pp_after_registration</code> 操作； 假设我们要实现一项功能，使用户在注册后会立即收到一条 <code>SMS</code>（通过称为 <code>Dolio</code> 的消息传递服务），欢迎他们访问你的网站。 我们的函数挂钩可以采用以下形式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'pp_after_registration'</span>, <span class="string">'send_users_welcome_sms'</span>, <span class="number">20</span>, <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send_users_welcome_sms</span><span class="params">( $form_id, $user_data, $user_id )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $service_locator;</span><br><span class="line"></span><br><span class="line">    $username    = $user_data[<span class="string">'username'</span>];</span><br><span class="line">    $firstName   = $user_data[<span class="string">'first_name'</span>];</span><br><span class="line">    $lastName    = $user_data[<span class="string">'last_name'</span>];</span><br><span class="line">    $phoneNumber = $user_data[<span class="string">'phone_number'</span>];</span><br><span class="line"></span><br><span class="line">    $text = <span class="string">&lt;&lt;&lt;SMS_CONTENT</span></span><br><span class="line"><span class="string">Hello <span class="subst">$firstName</span> <span class="subst">$lastName</span>, Welcome to SitePoint. "\r\n"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">User ID: <span class="subst">$user_id</span> "\r\n"</span></span><br><span class="line"><span class="string">Username: <span class="subst">$username</span> "\r\n"</span></span><br><span class="line"><span class="string">Password: The password you sign up with "\r\n"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SMS_CONTENT;</span></span><br><span class="line"></span><br><span class="line">    $dolio = $service_locator-&gt;get( <span class="string">'dolio_sdk'</span> );</span><br><span class="line">    $dolio-&gt;phone_number( $phoneNumber );</span><br><span class="line">    $dolio-&gt;sms_content( $text );</span><br><span class="line">    $dolio-&gt;send();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中 <code>add_action</code> 的第三个参数是挂钩优先级，该挂钩优先级指定了挂钩到 <code>pp_after_registration</code> 动作的函数的执行顺序。 将其保留为空将默认为10。而第四个参数指定函数挂钩将接受的参数数量。 如果为空，则默认为1。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我省略了第四个参数，因此默认为1，则<code>$ user_data</code>和<code>$ user_id</code>变量将为<code>null</code>，因为我们只告诉函数仅接受一个参数。</p><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a><strong><em>实例2</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WordPress</code> 包含以下动作挂钩- <code>wp_head</code> 和 <code>wp_footer</code> ，它们分别在<code>head</code>标签和前端的<code>body</code>标签之前触发。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些挂钩可用于在那些关键位置显示脚本和数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看看一些代码示例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下代码使用 <code>wp_head</code> 将 <code>Google</code> 的站点验证元标记添加到 <code>WordPress</code> 前端的标头中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'wp_head'</span>, <span class="string">'google_site_verification'</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">google_site_verification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;meta name="google-site-verification" content="ytl89rlFsAzH7dWLs_U2mdlivbrr_jgV4Gq7wClHDUJ8" /&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有挂钩函数都将是匿名的，而不是命名函数，以避免不必要的函数名称重复。 例如，上面的 <code>Google</code> 网站验证元标记的代码将变为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'wp_head'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;meta name="google-site-verification" content="ytl89rlFsAzH7dWLs_U2mdlivbrr_jgV4Gq7wClHDUJ8" /&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的代码使用 <code>wp_footer</code> 在 <code>WordPress</code> 前端的页脚区域中添加 <code>JavaScript</code> 。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'wp_footer'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;script type="text/javascript" src="http://example.com/wp-content/plugins/site-specific-plugin/hello-bar.js"&gt;&lt;/script&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><em>动作钩子代码示例足够多，让我们看看过滤器。</em></strong></p></br><h1 id="滤钩示例"><a href="#滤钩示例" class="headerlink" title="滤钩示例"></a><strong>滤钩示例</strong></h1><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a><strong><em>示例1</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们正在开发一个广告插入器插件，该插件将以编程方式在每个帖子内容前后插入广告，因此我们需要 <code>the_content</code> 过滤器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下代码在每个帖子内容前后都包含“我们喜欢 <code>SitePoint</code> ”文字。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_filter( <span class="string">'the_content'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">( $content )</span> </span>&#123;</span><br><span class="line">        $text = sprintf( <span class="string">'&lt;div class="notice alert"&gt;%s&lt;/div&gt;'</span>, __( <span class="string">'We love SitePoint'</span>, <span class="string">'sp'</span> ) );</span><br><span class="line">        $content = $text . $content . $text;</span><br><span class="line">        <span class="keyword">return</span> $content;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：<code>$text</code> 变量的内容与&lt;div class =“ notice alert”&gt;我们喜欢SitePoint &lt;/ div&gt;一样，尽管它已经国际化，所以可以本地化。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，函数参数 <code>$content</code> 是提供帖子内容的变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们在帖子内容前后添加自定义文本，将结果数据保存到 <code>$content</code> 中，然后返回。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：所有滤镜挂钩函数都必须在操作或修改后返回变量参数。</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a><strong><em>示例2</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将看到的另一个过滤器示例是 <code>the_title</code> 。 以下是 <code>wp-includes/post-template.php</code> 的158行中的定义方式。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Filter the post title.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 0.71</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> string $title The post title.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> int    $id    The post ID.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">return</span> apply_filters( <span class="string">'the_title'</span>, $title, $id );</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的代码通过在其后面附加 <code>-WeLoveSitePoint</code> 来仅修改 ID 为 5978的帖子的标题。 这要归功于 <code>$id</code> 参数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_filter( <span class="string">'the_title'</span>, <span class="function"><span class="keyword">function</span> <span class="params">( $title, $id )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( $id == <span class="string">'5978'</span> ) &#123;</span><br><span class="line">            $title .= <span class="string">' - WeLoveSitePoint'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $title;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">10</span>, <span class="number">2</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WordPress</code> 之所以继续成为领先的内容管理系统的原因是其可扩展性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>WordPress Hook</code> 系统使 <code>WordPress</code> 可以转换为功能强大的 <code>Web</code> 应用程序，无论是 <code>WooCommerce</code> 的电子商务商店，<code>bbPress</code> 的论坛还是 <code>BuddyPress</code> 的社交网站。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你一直在使用 &lt;code&gt;WordPress&lt;/code&gt; 开发网站（包括插件和主题开发），那么你可能已经听说过以下术语：&lt;code&gt;挂钩&lt;/code&gt;，&lt;code&gt;操作&lt;/code&gt;和&lt;code&gt;过滤器&lt;/code&gt;。 这些是 &lt;code&gt;WordPress&lt;/code&gt; 使用的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Event-driven_architecture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;事件驱动架构模式(英文：Event-driven architecture)&lt;/code&gt;&lt;/a&gt; 的一部分。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;你是 &lt;code&gt;WordPress&lt;/code&gt; 开发的新手还是发现难以理解基本概念？ 我不能推荐足够高的 &lt;a href=&quot;https://www.sitepoint.com/author/scodrington/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Simon Codrington&lt;/code&gt;&lt;/a&gt; 的 &lt;code&gt;WordPress&lt;/code&gt; 插件开发简介教程。 他在解释 &lt;code&gt;动作&lt;/code&gt; 和 &lt;code&gt;过滤器&lt;/code&gt; 方面做得很出色。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在本教程中，我将揭开 &lt;code&gt;WordPress&lt;/code&gt; 钩子系统的神秘面纱，不遗余力。 事不宜迟，让我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="Modules And Hooks" scheme="http://www.xuebaonline.com/tags/Modules-And-Hooks/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的模块和挂钩</title>
    <link href="http://www.xuebaonline.com/Swift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E6%8C%82%E9%92%A9/"/>
    <id>http://www.xuebaonline.com/Swift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E6%8C%82%E9%92%A9/</id>
    <published>2020-04-26T09:32:28.000Z</published>
    <updated>2020-04-26T11:00:01.650Z</updated>
    
    <content type="html"><![CDATA[<p>了解如何使用以 <code>Swift</code> 编写的松耦合模块插件系统通过新功能扩展应用程序。</p><h1 id="模块（插件）如何工作？"><a href="#模块（插件）如何工作？" class="headerlink" title="模块（插件）如何工作？"></a><strong>模块（插件）如何工作？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你可以创建可以在不知彼此的情况下一起工作的对象，那会很酷吗？ 想象一下，你正在构建一个动态表单。 根据一些内部条件，将使用来自启用模块的数据来构成字段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，你拥有模块 <code>A</code> ，<code>B</code> ，<code>C</code> ，其中 <code>A</code> 为您提供字段 <code>1、2、3</code>，<code>B</code> 模块负责字段4、5，而 <code>C</code> 是字段6的提供者。现在，如果您关闭 <code>B</code>， 您应该只能看到字段1、2、3和6。如果已打开所有内容，则应该看到从1到6的所有字段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以将完全相同的模式应用于许多事物。 试想一下最大的插件生态系统之一。 <code>WordPress</code> 使用 <a href="https://www.sitepoint.com/wordpress-hook-system/" target="_blank" rel="noopener"><code>钩子(英文：hooks)</code></a> 来扩展核心功能。 这些都是基于我上面刚刚提到的概念。 这是 <a href="https://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="noopener"><code>事件驱动的体系结构设计模式(英文：Event-driven architecture)</code></a> 的一部分。 现在的问题是，我们如何使用 <code>Swift</code> 实现类似的东西？ 🤔</p><a id="more"></a></br><h1 id="钩子系统的实现"><a href="#钩子系统的实现" class="headerlink" title="钩子系统的实现"></a><strong>钩子系统的实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们从带有调用点的协议开始。 模块管理器将调用此方法，以按名称调用正确的钩子函数。 我们将传递参数字典，因此我们的钩子可以有参数。 我们在这里使用 <code>Any</code> 类型作为值，因此你可以在给定键下将任何内容作为参数发送。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123; <span class="literal">nil</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们使用基于表单示例的简化版本来实现我们的模块。 🤓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 1"</span>, <span class="string">"Field 2"</span>, <span class="string">"Field 3"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 4"</span>, <span class="string">"Field 5"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 6"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们需要一个模块管理器，可以使用模块数组对其进行初始化。 该管理器将负责在每个模块上调用正确的调用方法，并将以类型安全的方式处理返回的响应。 我们将立即实现两个 <code>invoke</code> 方法版本。 一个用于合并结果，另一个用于返回挂钩的第一个结果。</p><p><strong>你可以尝试实现一个可以使用 <code>&amp;&amp;</code> 运算符合并 <code>Bool</code> 值的版本。</strong></p><p>这是我们使用两种通用方法的模块管理器实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ModuleManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span>  modules: [<span class="type">Module</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invokeAllHooks</span>&lt;T&gt;<span class="params">(<span class="number">_</span> name: String, type: T.<span class="keyword">Type</span>, params: [String: <span class="keyword">Any</span>] = [:])</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">self</span>.modules.<span class="built_in">map</span> &#123; module <span class="keyword">in</span></span><br><span class="line">            module.invoke(name: name, params: params)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? [<span class="type">T</span>] &#125;.flatMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invokeHook</span>&lt;T&gt;<span class="params">(<span class="number">_</span> name: String, type: T.<span class="keyword">Type</span>, params: [String: <span class="keyword">Any</span>] = [:])</span></span> -&gt; <span class="type">T?</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> module <span class="keyword">in</span> <span class="keyword">self</span>.modules &#123;</span><br><span class="line">            <span class="keyword">let</span> result = module.invoke(name: name, params: params)</span><br><span class="line">            <span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result <span class="keyword">as</span>? <span class="type">T</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <code>invokeAllHooks</code> 方法将通用类型的数组合并在一起。 这是我们可以使用基础钩子方法收集他所有表单字段的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manager1 = <span class="type">ModuleManager</span>(modules: [<span class="type">A</span>(), <span class="type">B</span>(), <span class="type">C</span>()])</span><br><span class="line"><span class="keyword">let</span> form1 = manager1.invokeAllHooks(<span class="string">"example_form"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(form1) <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager2 = <span class="type">ModuleManager</span>(modules: [<span class="type">A</span>(), <span class="type">C</span>()])</span><br><span class="line"><span class="keyword">let</span> form2 = manager2.invokeAllHooks(<span class="string">"example_form"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(form2) <span class="comment">// 1, 2, 3, 6</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>invokeHook</code> 方法，你可以实现类似的行为，例如责任链设计模式。 响应程序链的工作方式非常相似，<code>Apple</code> 几乎在每个平台上都使用响应程序来处理 <code>UI</code> 事件。 让我通过更新模块 <code>B</code> 向你展示它的工作方式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_responder"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleResponderHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 4"</span>, <span class="string">"Field 5"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleResponderHook</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">"Hello, this is module B."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们在两个管理器上使用 <code>invokeHook</code> 方法触发新的 <code>example_responder</code> 挂钩，我们将看到结果完全不同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = manager1.invokeHook(<span class="string">"example_responder"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value) <span class="comment">// Hello, this is module B.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = manager2.invokeHook(<span class="string">"example_responder"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value) <span class="comment">// this won't be called at all...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第一种情况下，由于我们在其中一个模块中为此钩子实现了一个实现，因此将显示返回值，因此可以进行打印。 在第二种情况下，没有模块可以处理该事件，因此不会执行条件内的块。 告诉你，就像一个响应链。 😜</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用模块或插件是将代码的某些部分解耦的有效方法。 我真的很喜欢钩子函数，因为它们可以为应用程序中的几乎所有内容提供扩展点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将其与动态模块加载器混合使用，你将在 <code>Vapor</code> 之上拥有一个完全可扩展的下一代后端解决方案。 你可以独立于模块使用已编译的核心系统，以后可以仅升级整个组件的某些部分而无需接触其他部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解如何使用以 &lt;code&gt;Swift&lt;/code&gt; 编写的松耦合模块插件系统通过新功能扩展应用程序。&lt;/p&gt;
&lt;h1 id=&quot;模块（插件）如何工作？&quot;&gt;&lt;a href=&quot;#模块（插件）如何工作？&quot; class=&quot;headerlink&quot; title=&quot;模块（插件）如何工作？&quot;&gt;&lt;/a&gt;&lt;strong&gt;模块（插件）如何工作？&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你可以创建可以在不知彼此的情况下一起工作的对象，那会很酷吗？ 想象一下，你正在构建一个动态表单。 根据一些内部条件，将使用来自启用模块的数据来构成字段。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;例如，你拥有模块 &lt;code&gt;A&lt;/code&gt; ，&lt;code&gt;B&lt;/code&gt; ，&lt;code&gt;C&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 为您提供字段 &lt;code&gt;1、2、3&lt;/code&gt;，&lt;code&gt;B&lt;/code&gt; 模块负责字段4、5，而 &lt;code&gt;C&lt;/code&gt; 是字段6的提供者。现在，如果您关闭 &lt;code&gt;B&lt;/code&gt;， 您应该只能看到字段1、2、3和6。如果已打开所有内容，则应该看到从1到6的所有字段。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们可以将完全相同的模式应用于许多事物。 试想一下最大的插件生态系统之一。 &lt;code&gt;WordPress&lt;/code&gt; 使用 &lt;a href=&quot;https://www.sitepoint.com/wordpress-hook-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;钩子(英文：hooks)&lt;/code&gt;&lt;/a&gt; 来扩展核心功能。 这些都是基于我上面刚刚提到的概念。 这是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Event-driven_architecture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;事件驱动的体系结构设计模式(英文：Event-driven architecture)&lt;/code&gt;&lt;/a&gt; 的一部分。 现在的问题是，我们如何使用 &lt;code&gt;Swift&lt;/code&gt; 实现类似的东西？ 🤔&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="Modules And Hooks" scheme="http://www.xuebaonline.com/tags/Modules-And-Hooks/"/>
    
  </entry>
  
  <entry>
    <title>Swift初始化模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-26T08:53:01.000Z</published>
    <updated>2020-04-26T09:32:03.950Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终指南，如何在指定的，方便的，可使用的初始化工具等帮助下初始化你的 <code>Swift</code> 数据类型。</p><h1 id="什么是初始化？"><a href="#什么是初始化？" class="headerlink" title="什么是初始化？"></a><strong>什么是初始化？</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" target="_blank" rel="noopener"><code>初始化(英文: Initialization)</code></a> 是准备使用的类，结构或枚举实例的过程。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个过程是通过初始化程序来处理的，初始化程序只是一种特殊的函数，通常为它们保留 <code>init</code> 关键字-因此您不必使用 <code>func</code> 关键字-通常您不会从初始化程序中返回任何值 。</p><a id="more"></a></br><h1 id="初始化属性"><a href="#初始化属性" class="headerlink" title="初始化属性"></a><strong>初始化属性</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类和结构必须在创建该类或结构的实例时将其所有存储的属性设置为适当的初始值。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先想象一个非常简单的结构，它只有两个属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，上面的规则说我们必须初始化所有属性，因此让我们通过创建第一个 <code>init</code> 方法来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像其他所有 <code>Swift</code> 函数一样。 现在我们可以创建我们的第一点了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，如果它们是变量而不是常量，则不必初始化隐式解包的可选属性和可选属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相同的逻辑适用于类，你可以通过将 <code>struct</code> 关键字更改为 <code>class</code> 来尝试。 但是结构是值类型，类是引用类型，这种差异将为我们提供两种类型的独特功能。</p></br><h1 id="成员初始化（仅适用于结构）"><a href="#成员初始化（仅适用于结构）" class="headerlink" title="成员初始化（仅适用于结构）"></a><strong>成员初始化（仅适用于结构）</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于 <code>struct</code> 的好处是，如果你不提供自己的 <code>init</code> 方法，则编译器将免费生成一个逐成员的 <code>init</code> 。 但是有很多问题。 生成的方法将包含除具有默认值的常量以外的所有属性（也为可选属性），并且它将具有内部访问类型，因此在其他模块中将不可见。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果任何结构的存储属性都是私有的，则该结构类型的默认成员初始化器被视为私有的。 同样，如果结构的任何存储属性是文件专用的，则初始化程序是文件专用的。 否则，初始化程序的访问级别为 <code>internal</code> 。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> key: <span class="type">Int!</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span> = <span class="string">"zero"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, key: <span class="number">0</span>) <span class="comment">// provided by the memberwise init</span></span><br></pre></td></tr></table></figure></br><h1 id="初始化失败"><a href="#初始化失败" class="headerlink" title="初始化失败"></a><strong>初始化失败</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时情况可能会出错，并且你不想创建坏的或无效的对象，例如，你想从有效点列表中过滤掉 <code>origo</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>?(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123; <span class="comment">// ? marks that this could fail</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>) <span class="comment">// nil</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>) <span class="comment">// valid point</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过 <code>rawValues</code> 初始化从 <code>RawRepresentable</code> 协议传递的枚举，这也是一个失败的初始化模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> red</span><br><span class="line">    <span class="keyword">case</span> blue</span><br><span class="line">    <span class="keyword">case</span> yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c1 = <span class="type">Color</span>(rawValue: <span class="string">"orange"</span>) <span class="comment">// nil, no such case</span></span><br><span class="line"><span class="keyword">let</span> c2 = <span class="type">Color</span>(rawValue: <span class="string">"red"</span>) <span class="comment">// .red</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以使用 <code>init！</code> 而不是<code>init ?</code> ，这将创建实例的隐式展开的可选类型。 请注意，类也可以具有失败的初始化器。</p></br><h1 id="初始化纯Swift类"><a href="#初始化纯Swift类" class="headerlink" title="初始化纯Swift类"></a><strong>初始化纯Swift类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你知道类是 <code>Swift</code> 编程语言中的本机类型。 你甚至不必导入 <code>Foundation</code> 框架即可创建全新的类。 这是由纯 <code>Swift</code> 类表示的完全相同的 <code>Point</code> 对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次我们不得不自己提供 <code>init</code> 方法，因为类没有成员初始化器。 它们是引用类型和继承逻辑，因此为它们生成成员初始化方法会更加复杂。</p></br><h1 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a><strong>默认初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 <code>Swift</code> 类，如果为所有存储的属性提供默认值，即使是可选属性，也将免费获得内部默认初始化程序。 实际上，它看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>()</span><br></pre></td></tr></table></figure><p>或者，如果我们遵循前面的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> key: <span class="type">Int!</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span> = <span class="string">"zero"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这感觉太不对了。 为什么一个点具有键和标签属性？ 拥有一个可能具有额外属性的子对象会很好。 现在该通过类继承来重构此代码了。</p></br><h1 id="指定的初始值设定项-Designated-initializer"><a href="#指定的初始值设定项-Designated-initializer" class="headerlink" title="指定的初始值设定项(Designated initializer)"></a><strong>指定的初始值设定项(Designated initializer)</strong></h1><blockquote><p><strong><em>提示：</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.codingexplorer.com/designated-initializers-convenience-initializers-swift/" target="_blank" rel="noopener"><code>指定的初始化器(Designated initializer)</code></a> 是类的主要初始化器。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换句话说，它没有用便捷关键字标记。 一个类也可以具有多个指定的初始化器。 因此，让我们继续我们的 <code>Point</code> 类，它将成为 <code>NamedPoint</code> 类的超类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123; <span class="comment">// this is the designated initializer</span></span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedPoint</span>: <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>, label: <span class="type">String?</span>) &#123; <span class="comment">// designated</span></span><br><span class="line">        <span class="keyword">self</span>.label = label</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(point: <span class="type">Point</span>, label: <span class="type">String?</span>) &#123; <span class="comment">// also designated</span></span><br><span class="line">        <span class="keyword">self</span>.label = label</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: point.x, y: point.y) <span class="comment">// delegating up</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">NamedPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>, label: <span class="string">"first"</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="type">NamedPoint</span>(point: <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>), label: <span class="string">"second"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定的初始值设定项必须始终从其直接超类调用指定的初始值设定项，因此你必须委托链。 但是首先，我们必须按照初始化的第一条规则来初始化所有属性。 因此，这意味着 <code>Swift</code> 语言具有两个阶段的初始化过程。</p><p><strong><em>两阶段初始化</em></strong></p><ul><li>每个存储的属性由引入它的类分配一个初始值。</li><li>每个类都有机会自定义其存储的属性。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，根据这些规则，首先我们必须初始化 <code>label</code> 属性，然后进行委托，然后才有机会做其他事情。</p></br><h1 id="便捷初始化"><a href="#便捷初始化" class="headerlink" title="便捷初始化"></a><strong>便捷初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它们是用于简化初始化的初始化程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，例如在前面的例子中，如果我们可以为 <code>x</code> 和 <code>y</code> 等于数字的点设置一个初始化器。 在某些情况下，这将非常方便。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(z: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(x: z, y: z) <span class="comment">// we're calling the designated init</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(z: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;便捷初始化程序必须调用同一类中另一个 <code>&quot;convenience&quot;</code> 初始化程序，但是您不必写出关键字，实际上，这些 <code>init</code> 方法略有不同，你可以从一个到另一个进行调出，这就是为什么它看起来一样的原因。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(z: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(x: z, y: z)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="type">Point</span>(z: <span class="number">1</span>)</span><br></pre></td></tr></table></figure></br><h1 id="必需的初始值设定项-Required-initializer"><a href="#必需的初始值设定项-Required-initializer" class="headerlink" title="必需的初始值设定项(Required initializer)"></a><strong>必需的初始值设定项(Required initializer)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你在类中标记了一个必需的初始化器，则所有直接类（必须在每个级别中都标记为必需）也必须实现该类的子类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedPoint</span>: <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.label = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">NamedPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure></br><h1 id="覆盖初始化器"><a href="#覆盖初始化器" class="headerlink" title="覆盖初始化器"></a><strong>覆盖初始化器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中，默认情况下不会为子类继承初始化器。 如果要为父类已经具有的子类提供相同的初始化程序，则必须使用 <code>override</code> 关键字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedPoint</span>: <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.label = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">NamedPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong><em>初始化继承有两个规则，这是第一个…</em></strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你的子类没有定义任何指定的初始值设定项，它将自动继承其所有超类指定的初始值设定项。</span><br><span class="line"></span><br><span class="line">***...还有第二个：***</span><br><span class="line">&#96;&#96;&#96;提示:&#96;&#96;&#96;\</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你的子类提供了其所有超类指定的初始值设定项的实现（通过按规则1继承它们，或通过提供自定义实现作为其定义的一部分），则它会自动继承所有超类便利的初始值设定项。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;br&gt;</span><br><span class="line"></span><br><span class="line"># **取消初始化**</span><br><span class="line"></span><br><span class="line">&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在取消分配类实例之前，将立即调用反初始化程序。</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此，如果你想在类终止时进行一些手动清理，这就是你要寻找的方法。 在大多数情况下，你不必担心内存管理，因为 &#96;&#96;&#96;ARC&#96;&#96;&#96; 会为你完成。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; Swift</span><br><span class="line">class Point &#123;</span><br><span class="line">   let x: Int</span><br><span class="line">   let y: Int</span><br><span class="line"></span><br><span class="line">   init(x: Int, y: Int) &#123;</span><br><span class="line">       self.x &#x3D; x</span><br><span class="line">       self.y &#x3D; y</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   deinit &#123;</span><br><span class="line">       print(&quot;Point is clenaed up.&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1: Point? &#x3D; Point(x: 1, y: 1)</span><br><span class="line">p1 &#x3D; nil &#x2F;&#x2F;deinit is being called </span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最终指南，如何在指定的，方便的，可使用的初始化工具等帮助下初始化你的 &lt;code&gt;Swift&lt;/code&gt; 数据类型。&lt;/p&gt;
&lt;h1 id=&quot;什么是初始化？&quot;&gt;&lt;a href=&quot;#什么是初始化？&quot; class=&quot;headerlink&quot; title=&quot;什么是初始化？&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是初始化？&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;初始化(英文: Initialization)&lt;/code&gt;&lt;/a&gt; 是准备使用的类，结构或枚举实例的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这个过程是通过初始化程序来处理的，初始化程序只是一种特殊的函数，通常为它们保留 &lt;code&gt;init&lt;/code&gt; 关键字-因此您不必使用 &lt;code&gt;func&lt;/code&gt; 关键字-通常您不会从初始化程序中返回任何值 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="初始化模式" scheme="http://www.xuebaonline.com/tags/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift带闭包的懒惰初始化</title>
    <link href="http://www.xuebaonline.com/Swift%E5%B8%A6%E9%97%AD%E5%8C%85%E7%9A%84%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://www.xuebaonline.com/Swift%E5%B8%A6%E9%97%AD%E5%8C%85%E7%9A%84%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2020-04-26T07:55:06.000Z</published>
    <updated>2020-04-26T08:46:52.783Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何创建具有模块化和可读性的对象。</p><h1 id="使用初衷"><a href="#使用初衷" class="headerlink" title="使用初衷"></a><strong>使用初衷</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>iOS</code> 之旅的开始，我遵循了 <code>YouTube</code> 上的教程。 我看到一些使用如下所示的方法来创建 <code>UI</code> 对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> makeBox: <span class="type">UIView</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> view = <span class="type">UIView</span>()</span><br><span class="line"> <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为学习者，我复制了练习并使用了它。 但是，有一天，有人问我：“为什么要添加 <code>{}</code> ，为什么 <code>（）</code> 末尾存在？ 它是计算属性吗？” 我无法回答。</p><a id="more"></a></br><h1 id="学习的目标"><a href="#学习的目标" class="headerlink" title="学习的目标"></a><strong>学习的目标</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有三个目标。 首先，了解如何使用上述非常规方式初始化对象。 其次，了解何时在 <code>Swift</code> 中使用惰性 <code>var</code> 。 最后，如何最终正确使用它。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a><strong><em>先决条件</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了充分理解文章中的内容，我强烈建议您熟悉以下主题。</p><ul><li><a href="https://blog.bobthedeveloper.io/no-fear-closure-in-swift-3-with-bob-72a10577c564?gi=bfa929c89fa9" target="_blank" rel="noopener"><code>Closures</code></a></li><li><a href="https://blog.bobthedeveloper.io/swift-retention-cycle-in-closures-and-delegate-836c469ef128" target="_blank" rel="noopener"><code>Capture List and retention cycle [weak self]</code></a></li><li>Descent Object Oriented Programming</li></ul></br><h1 id="创建UI组件"><a href="#创建UI组件" class="headerlink" title="创建UI组件"></a><strong>创建UI组件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我解释上述非常规方法之前，让我们先回顾一下你的过去。 为了在 <code>Swift</code> 中创建一个按钮，你可能已经做了类似的事情。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine Size</span></span><br><span class="line"><span class="keyword">let</span> buttonSize = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="comment">// Create Instance</span></span><br><span class="line"><span class="keyword">let</span> bobButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">bobButton.backgroundColor = .black</span><br><span class="line">bobButton.titleLabel?.text = <span class="string">"Bob"</span></span><br><span class="line">bobButton.titleLabel?.textColor = .white</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设你必须创建其他三个按钮，你可能必须复制上面的代码，然后将名称从 <code>bobButton</code> 更改为 <code>bobbyButton</code> 。这非常繁琐。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New Button</span></span><br><span class="line"><span class="keyword">let</span> bobbyButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">bobbyButton.backgroundColor = .black</span><br><span class="line">bobbyButton.titleLabel?.text = <span class="string">"Bob"</span></span><br><span class="line">bobbyButton.titleLabel?.textColor = .white</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使事情变得容易一些，你可以：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xcode-edit-all.gif" alt="带闭包的懒惰初始化" title="这也适用于键盘快捷键：ctrl-cmd-e"></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用快捷键：ctrl-cmd-e，完成上述操作。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不想重复这样创建，则可以创建一个函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createButton</span><span class="params">(enterTitle: String)</span></span> -&gt; <span class="type">UIButton</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = enterTitle</span><br><span class="line"> <span class="keyword">return</span> button</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createButton(enterTitle: <span class="string">"Yoyo"</span>) <span class="comment">//  👍</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，在 <code>iOS</code> 开发中，很少有自定义按钮看起来相似的情况。 因此，一个函数可能需要更多的参数，包括背景颜色，标题，边框半径，阴影等。 你的功能可能最终看起来像：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createButton</span><span class="params">(title: String, borderWidth: Double, backgrounColor, ...)</span></span> -&gt; <span class="type">Button</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使你向函数添加默认参数，上面的代码也不是理想的选择。 它降低了可读性。 因此，最好还是保留上面乏味的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有什么方法可以使它减少乏味和更有条理？ 当然。 我们已经调查了你的过去—现在该加紧步伐，展望你的未来。</p></br><h1 id="引入非常规方式"><a href="#引入非常规方式" class="headerlink" title="引入非常规方式"></a><strong>引入非常规方式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以非常规的方式创建UI组件之前，让我们首先回答最初问题: <code>{}</code> 是什么意思，它是计算属性吗？</p><p><strong><em>不，这只是一个封闭块。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，让我们演示如何使用闭包创建对象。 我们将设计一个名为 <code>Human</code> 的结构。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"> <span class="keyword">init</span>() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Born 1996"</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，这就是创建带闭包的对象的方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createBob = &#123; () -&gt; <span class="type">Human</span> <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">let</span> human = <span class="type">Human</span>()</span><br><span class="line"> <span class="keyword">return</span> human</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> babyBob = createBob() <span class="comment">// "Born 1996"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>仅说明一下，createBob</code> 是一个类型为 <code>（）-&gt; Human</code> 的闭包。 您已经通过调用 <code>createBob（）</code> 创建了一个名为 <code>babyBob</code> 的实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，你必须创建两个常量： <code>createBob</code> 和 <code>babyBob</code> 。 如果你想在一个语句中做所有事情怎么办？ </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bobby = &#123; () -&gt; <span class="type">Human</span> <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">let</span> human = <span class="type">Human</span>()</span><br><span class="line"> <span class="keyword">return</span> human</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，闭包块通过在末尾添加 <code>（）</code> 来执行自身，而 <code>bobby</code> 现在附加了一个 <code>Human</code> 对象。 很好的东西。</p><p><strong><em>你已经了解了如何使用闭包块初始化对象。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们来创建一个 <code>UI</code> 对象，该对象应该与上面的示例相似。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bobView = &#123; () -&gt; <span class="type">UIView</span> <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">let</span> view = <span class="type">UIView</span>()</span><br><span class="line"> view.backgroundColor = .black</span><br><span class="line"> <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;太好了，我们可以缩短它的时间。 实际上，我们不需要指定封闭块的类型。 相反，我们要做的就是指定实例的类型，例如 <code>bobView</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bobbyView: <span class="type">UIView</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> view = <span class="type">UIView</span>()</span><br><span class="line"> view.backgroundColor = .black</span><br><span class="line"> <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 能够基于关键字 <code>return</code> 推断出闭包块是 <code>（）-&gt; UIView</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，看看。 上面的示例应该看起来与我担心的“非常规方式”相同。</p></br><h1 id="闭包初始化的好处"><a href="#闭包初始化的好处" class="headerlink" title="闭包初始化的好处"></a><strong>闭包初始化的好处</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们讨论了创建对象的乏味以及使用函数引起的问题。 在你的脑海中，你肯定在想：“为什么我应该改用闭包？”</p><h2 id="容易复制"><a href="#容易复制" class="headerlink" title="容易复制"></a><strong><em>容易复制</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我不喜欢使用 <code>Storyboard</code> ，我喜欢复制和粘贴 <code>UI</code> 对象。 实际上，我的计算机中有一个“库”。 让我们假设库中有一个如下所示的按钮。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = <span class="number">1</span></span><br><span class="line"> button.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要做的就是复制整行，然后将 <code>myButton</code> 的名称更改为 <code>newButton</code> 以供使用。 如果不使用闭包方法，则可能不得不将 <code>button</code> 的名称更改为 <code>newButton</code> 7–8次。 我们可以使用上面的 <code>Xcode</code> 快捷方式，但为什么不使其更简单。</p><h2 id="代码更整洁"><a href="#代码更整洁" class="headerlink" title="代码更整洁"></a><strong><em>代码更整洁</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于将对象组合在一起，看代码更加直观。 比较一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init with Closure</span></span><br><span class="line"><span class="keyword">let</span> leftCornerButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = <span class="number">1</span></span><br><span class="line"> button.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">let</span> rightCornerButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = <span class="number">1</span></span><br><span class="line"> button.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p><em><code>比较</code></em></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init With Fingers</span></span><br><span class="line"><span class="keyword">let</span> leftCornerButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">leftCornerButton.backgroundColor = .black</span><br><span class="line">leftCornerButton.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line">leftCornerButton.titleLabel?.textColor = .white</span><br><span class="line">leftCornerButton.layer.cornerRadius = <span class="number">1</span></span><br><span class="line">leftCornerButton.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rightCornerButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">rightCornerButton.backgroundColor = .black</span><br><span class="line">rightCornerButton.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line">rightCornerButton.titleLabel?.textColor = .white</span><br><span class="line">rightCornerButton.layer.cornerRadius = <span class="number">1</span></span><br><span class="line">rightCornerButton.layer.masksToBounds = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管使用闭包创建对象要多加几行，但我感到有点不知所措，因为我只需要向按钮添加属性，而不必向 <code>rightCornerButton</code> 或 <code>leftCornerButton</code> 添加属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，如果按钮的名称更具描述性，那么创建带有闭包块的对象通常需要较少的行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你已经实现了第一个目标。 恭喜你</p><h2 id="延迟初始化应用"><a href="#延迟初始化应用" class="headerlink" title="延迟初始化应用"></a><strong><em>延迟初始化应用</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你已经走了很长一段路。 现在该实现本教程的第二个目标。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能在下面看到了类似的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntenseMathProblem</span> </span>&#123;</span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> complexNumber: <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="comment">// imagine it requires a lot of CPU</span></span><br><span class="line">  <span class="number">1</span> * <span class="number">1</span></span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性允许您执行的操作是，仅当你尝试访问 <code>complexNumber</code> 属性时，才会计算 <code>complexNumber</code> 属性。 例如:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> problem = <span class="type">IntenseMathProblem</span></span><br><span class="line">problem()  <span class="comment">// No value for complexNumber</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前， <code>complexNumber</code> 没有值。 但是，一旦你访问该媒体资源，</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">problem().complexNumber <span class="comment">// Now returns 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性变量经常用于对数据库进行排序并从任何后端服务中获取数据，因为你绝对不想在创建对象时对所有内容进行计算和排序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，你的手机会崩溃，因为该物体过大且RAM无法处理。</p></br><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面只是 <code>lazy var</code> 的一个应用。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong><em>排序</em></strong></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortManager</span> </span>&#123;</span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> sortNumberFromDatabase: [<span class="type">Int</span>] = &#123;</span><br><span class="line">  <span class="comment">// Sorting logic</span></span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a><strong><em>图像压缩</em></strong></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompressionManager</span> </span>&#123;</span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> compressedImage: <span class="type">UIImage</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> image = <span class="type">UIImage</span>()</span><br><span class="line">  <span class="comment">// Compress the image</span></span><br><span class="line">  <span class="comment">// Logic</span></span><br><span class="line">  <span class="keyword">return</span> image</span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="懒加载规则"><a href="#懒加载规则" class="headerlink" title="懒加载规则"></a><strong>懒加载规则</strong></h1><ul><li>你不能将lazy与let一起使用，因为它没有初始值，并且在以后访问它时才可以达到。</li><li>你不能将其与计算属性一起使用，因为当你修改与惰性属性有关系的任何变量时，总是会重新计算计算属性（需要CPU）。</li><li>惰性仅对结构或类的成员有效</li></ul></br><h1 id="懒加载能捕获"><a href="#懒加载能捕获" class="headerlink" title="懒加载能捕获"></a><strong>懒加载能捕获</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如果你已阅读上一篇有关<a href="https://blog.bobthedeveloper.io/swift-retention-cycle-in-closures-and-delegate-836c469ef128" target="_blank" rel="noopener"><code>“封闭和委托中的循环引用”</code></a>的文章，您可能会感到奇怪。 让我们测试一下。 创建一个名为 <code>BobGreet</code> 的类。 它具有两个属性：名称为 <code>String</code> 的名称和问候语也为 <code>String</code> 的问候语，但使用闭包块进行了初始化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BobGreet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Bob the Developer"</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> greeting: <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, \(self.name)"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I'm gone, bruh 🙆‍"</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;封闭块可能对 <code>BobGuest</code> 强引用，但让我们尝试取消分配。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bobGreet: <span class="type">BobGreet?</span> = <span class="type">BobGreet</span>()</span><br><span class="line">bobGreet?.greeting</span><br><span class="line">bobGreet = <span class="literal">nil</span> <span class="comment">// I'm gone, bruh 🙆‍</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无需担心 <code>[unown self]</code> 闭包块没有对该对象的引用。 取而代之的是，它只是在封闭块内复制自身。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何创建具有模块化和可读性的对象。&lt;/p&gt;
&lt;h1 id=&quot;使用初衷&quot;&gt;&lt;a href=&quot;#使用初衷&quot; class=&quot;headerlink&quot; title=&quot;使用初衷&quot;&gt;&lt;/a&gt;&lt;strong&gt;使用初衷&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 &lt;code&gt;iOS&lt;/code&gt; 之旅的开始，我遵循了 &lt;code&gt;YouTube&lt;/code&gt; 上的教程。 我看到一些使用如下所示的方法来创建 &lt;code&gt;UI&lt;/code&gt; 对象。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; makeBox: &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt; = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; view = &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; view&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;作为学习者，我复制了练习并使用了它。 但是，有一天，有人问我：“为什么要添加 &lt;code&gt;{}&lt;/code&gt; ，为什么 &lt;code&gt;（）&lt;/code&gt; 末尾存在？ 它是计算属性吗？” 我无法回答。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="懒加载模式" scheme="http://www.xuebaonline.com/tags/%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift Lazy属性初始化</title>
    <link href="http://www.xuebaonline.com/Swift%20Lazy%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://www.xuebaonline.com/Swift%20Lazy%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2020-04-26T07:37:12.000Z</published>
    <updated>2020-04-26T07:52:47.513Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Swift中什么是惰性存储属性？ 你应该如何以及何时使用它？ 快速入门指南，需要记住的一些关键点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先回顾一下在 <code>Swift</code> 中声明和初始化存储属性的最常用方法：</p><h1 id="直接分配"><a href="#直接分配" class="headerlink" title="直接分配"></a><strong>直接分配</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过直接分配初始值来对常量和变量存储的属性进行初始化的最简单形式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constant</span></span><br><span class="line"><span class="keyword">let</span> fontSize: <span class="type">CGFloat</span> = <span class="number">24.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// variable</span></span><br><span class="line"><span class="keyword">var</span> spacing: <span class="type">CGFloat</span> = <span class="number">16.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Optional</span></span><br><span class="line"><span class="keyword">var</span> title: <span class="type">String?</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，默认情况下，可选参数初始化为 <code>nil</code> 。 我喜欢将恒定的魔术数字（如 <code>fontSize</code> ）收集到一个结构中，使它们成为静态的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">ViewMetrics</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> fontSize: <span class="type">CGFloat</span> = <span class="number">24.0</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">titleLabel.font = <span class="type">ViewMetrics</span>.fontSize</span><br></pre></td></tr></table></figure></br><h1 id="使用初始化器"><a href="#使用初始化器" class="headerlink" title="使用初始化器"></a><strong>使用初始化器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你没有将初始值分配给存储属性作为其定义的一部分，则必须在初始化程序中进行设置。 引用《 Swift编程语言》指南：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类和结构必须在创建该类或结构的实例时将其所有存储的属性设置为适当的初始值。 存储的属性不能处于不确定状态。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(title: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.title = title</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当属性始终采用相同的初始值时，最好在声明属性时进行设置，而不要在初始化程序中进行设置。</p></br><h1 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a><strong>使用闭包</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当初始值需要更多设置时，闭包是一个不错的选择。 我发现闭包样式比许多初始化程序代码更可取，因为它使设置接近属性声明。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button: <span class="type">UIButton</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> button = <span class="type">UIButton</span>(type: .system)</span><br><span class="line">  button.titleLabel?.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="type">ViewMetrics</span>.fontSize)</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化包含属性的类型时，将调用一次闭包。 闭包的返回值分配给该属性。 不要忘记尾随（）来执行关闭。</p></br><h1 id="懒加载方式"><a href="#懒加载方式" class="headerlink" title="懒加载方式"></a><strong>懒加载方式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当初始值创建起来开销相对较大时时，通常会使用惰性初始化。 仅在确定需要时才创建值。 如果你是从 <code>Objective-C</code> 转到 <code>Swift</code> 的，那么您可能会熟悉使用 <code>getter</code> 仅在首次使用属性时才对其进行延迟初始化的技术：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">NSNumberFormatter</span> *)decimalFormatter &#123;</span><br><span class="line">  <span class="keyword">if</span> (_decimalFormatter == <span class="literal">nil</span>) &#123;</span><br><span class="line">    _decimalFormatter = [[<span class="type">NSNumberFormatter</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [_decimalFormatter setNumberStyle:<span class="type">NSNumberFormatterDecimalStyle</span>];        </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _decimalFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么 <code>Swift</code> 中的惰性属性呢？ <code>Swift</code> 属性没有后备实例变量（如 <code>_decimalFormatter</code> ）。 要在 <code>Swift</code> 中延迟初始化属性，请添加 <code>lazy</code> 关键字：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> decimalFormatter: <span class="type">NumberFormatter</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> formatter = <span class="type">NumberFormatter</span>()</span><br><span class="line">  formatter.numberStyle = .decimal</span><br><span class="line">  <span class="keyword">return</span> formatter</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，惰性属性始终为 <code>var</code> 。 当访问属性时，可以在初始化完成后调用该闭包。</p></br><h1 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a><strong>访问属性</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性属性初始化的另一个常见用法是，当初始值取决于初始化实例的属性或方法时。 例如，使用闭包设置对象，此堆栈视图可以作为 <code>let constant</code> 属性使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stackView: <span class="type">UIStackView</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> stackView = <span class="type">UIStackView</span>()</span><br><span class="line">  stackView.spacing = <span class="type">ViewMetrics</span>.spacing</span><br><span class="line">  <span class="keyword">return</span> stackView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请记住，在初始化期间调用了闭包，因此你尚不能使用 <code>self</code> 来访问实例的任何属性或方法。 如果你需要访问 <code>self</code> ，则必须将 <code>let</code> 替换为 <code>lazy var</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spacing: <span class="type">CGFloat</span> = <span class="number">16.0</span>  &#123;</span><br><span class="line">  <span class="keyword">didSet</span> &#123;</span><br><span class="line">    stackView.spacing = spacing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> stackView: <span class="type">UIStackView</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> stackView = <span class="type">UIStackView</span>()</span><br><span class="line">  stackView.spacing = spacing</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> stackView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，在对象初始化之后执行关闭操作，因此你可以通过 <code>self</code> 完全访问实例属性和方法。 这是声明诸如用户界面组件之类的便捷方式。 将任何常见配置移至单独的方法或类扩展：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buttonFontSize: <span class="type">CGFloat</span> = <span class="number">18.0</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> redButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">UILabel</span>.colorButton(title: <span class="string">"Red"</span>, color: .red, fontSize: buttonFontSize)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> blueButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">UILabel</span>.colorButton(title: <span class="string">"Blue"</span>, color: .blue, fontSize: buttonFontSize)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></br><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a><strong>要点</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要记住的一些关键点并不明显，并且经常引起混乱（至少对我而言）：</p><ul><li>引用闭包内的其他实例属性或方法时，无需编写self。</li><li>闭包不会逃逸，因此你无需使用 <code>weak self</code> 避免形成循环引用。</li><li>初始化之前，如果属性可以被多个线程访问，请小心。 无法保证只有在设置初始值之前有多个线程同时访问该属性时才将其初始化一次。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在Swift中什么是惰性存储属性？ 你应该如何以及何时使用它？ 快速入门指南，需要记住的一些关键点。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先回顾一下在 &lt;code&gt;Swift&lt;/code&gt; 中声明和初始化存储属性的最常用方法：&lt;/p&gt;
&lt;h1 id=&quot;直接分配&quot;&gt;&lt;a href=&quot;#直接分配&quot; class=&quot;headerlink&quot; title=&quot;直接分配&quot;&gt;&lt;/a&gt;&lt;strong&gt;直接分配&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过直接分配初始值来对常量和变量存储的属性进行初始化的最简单形式：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// constant&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; fontSize: &lt;span class=&quot;type&quot;&gt;CGFloat&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;24.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// variable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; spacing: &lt;span class=&quot;type&quot;&gt;CGFloat&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;16.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Optional&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; title: &lt;span class=&quot;type&quot;&gt;String?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="懒加载模式" scheme="http://www.xuebaonline.com/tags/%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的懒加载模式</title>
    <link href="http://www.xuebaonline.com/Swift%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-26T03:01:52.000Z</published>
    <updated>2020-04-26T08:48:54.614Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何在 <code>Swift</code> 中使用惰性属性来提高性能，避免使用可选参数或只是为了使初始化过程更加简洁。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在程式设计中, 惰性初始是一种拖延战术。在第一次需求出现以前，先延迟创建物件、计算值或其它昂贵程序。这通常是以一个旗号来实现，用旗号来标示是否完成其程式。每次请求对象时，会先测试此旗号。如果已完成，直接传回，否则当场执行。<br>对于此想法更一般的论述，可见惰性求值。对指令式语言，这个模式可能潜藏着危险，尤其是使用共享状态的程式习惯。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以设计模式的观点来说，惰性初始通常会和工厂方法模式合作，这结合了三种构想：</p><ul><li>使用一个工厂去得到一个类别的实例（工厂方法模式）。</li><li>将实例存在一个集合中，所以下次要求一个实例却有相同参数时，可以得到同一个实例（可和单例模式来做比较）。</li><li>在第一次时，使用惰性初始来实例化物件（惰性初始模式）。</li></ul><a id="more"></a></br><h1 id="懒惰的终极指南"><a href="#懒惰的终极指南" class="headerlink" title="懒惰的终极指南"></a><strong>懒惰的终极指南</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果仅在某个时间点需要某个属性，则可以在其前面加上 <code>lazy</code> 关键字，以便在初始化过程中将其 <code>“excluded”</code> ，并且将按需分配其默认值。 这对于创建成本高昂或需要更多时间创建的类型很有用。 这是一个懒惰公主的小故事。 👸💤</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepingBeauty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zzz...sleeping..."</span>)</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"sleeping beauty is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Castle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> princess = <span class="type">SleepingBeauty</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"castle is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a new castle..."</span>)</span><br><span class="line"><span class="keyword">let</span> castle = <span class="type">Castle</span>()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此代码段的输出如下所示，但是你可以看到公主睡了很长时间，她也“堵住了”城堡。 🏰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a new castle...</span><br><span class="line">zzz...sleeping...</span><br><span class="line">sleeping beauty is ready!</span><br><span class="line">castle is ready!</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以通过添加 <code>lazy</code> 关键字来加快处理速度，因此你的英雄将有时间杀死龙，我们的公主可以睡在她的床上直到需要她为止。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepingBeauty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zzz...sleeping..."</span>)</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"sleeping beauty is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Castle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> princess = <span class="type">SleepingBeauty</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"castle is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a new castle..."</span>)</span><br><span class="line"><span class="keyword">let</span> castle = <span class="type">Castle</span>()</span><br><span class="line">castle.princess</span><br></pre></td></tr></table></figure><p>好多了！ 现在城堡立即为战斗做好了准备，因此王子可以唤醒他所爱的人，并且……他们从此过着幸福的生活。 故事结局。👸 ❤️ 🤴</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a new castle...</span><br><span class="line">castle is ready!</span><br><span class="line">zzz...sleeping...</span><br><span class="line">sleeping beauty is ready!</span><br></pre></td></tr></table></figure><p>希望你喜欢童话故事，但让我们做一些真正的编码吧！ 🤓</p></br><h1 id="避免懒加载可选属性"><a href="#避免懒加载可选属性" class="headerlink" title="避免懒加载可选属性"></a><strong>避免懒加载可选属性</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你在前面的示例中所看到的，可以使用惰性属性来提高 <code>Swift</code> 代码的性能。 您也可以消除对象中的可选项。 如果你要处理 <code>UIView</code> 派生类，这将很有用。 例如，如果你的视图层次结构需要 <code>UILabel</code> ，则通常必须将该属性声明为可选属性或隐式展开的可选存储属性。 让我们通过使用惰性和消除邪恶的可选要求的方式来重新制作此示例。 😈</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.label)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.label.textColor = .black</span><br><span class="line">        <span class="keyword">self</span>.label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况还不错，但是我仍然更喜欢将我的视图声明为隐式展开的可选对象。 💀</p></br><h1 id="使用懒加载闭包"><a href="#使用懒加载闭包" class="headerlink" title="使用懒加载闭包"></a>使用懒加载闭包</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <a href="http://www.xuebaonline.com/Swift%E5%B8%A6%E9%97%AD%E5%8C%85%E7%9A%84%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96/"><code>懒加载闭包(lazy closure)</code></a> 将一些代码包装在其中。 与存储的属性相比，懒惰的主要优点是，只有对该变量执行读取操作时，才执行块。 您还可以使用常规存储属性填充 <a href="http://www.xuebaonline.com/Swift%20Lazy%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/"><code>惰性属性(lazy property)</code></a> 的值。 让我们在实践中看一下。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.textColor = .black</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想整理一下init方法，这是一个不错的做法。 你可以将所有对象自定义逻辑放在闭包内。 闭包在读取时自动执行（自我执行的闭包），因此当你调用self.label时，你的代码块将被执行并贴紧：视图将准备就绪。</p><blockquote><p><strong><em>提示：</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你不能在存储的属性中使用 <code>self</code> ，但是可以使用 <code>lazy closure</code> 来使用 <code>self</code> 。 注意：如果你不想造成引用循环和内存泄漏，则应始终使用 <code>[unown self]</code> 。 ♻️</p></blockquote></br><h1 id="使用工厂模式进行-Lazy-initialization"><a href="#使用工厂模式进行-Lazy-initialization" class="headerlink" title="使用工厂模式进行 Lazy initialization"></a><strong><em>使用工厂模式进行 Lazy initialization</em></strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我已经有几篇关于 <code>Swift</code> 中 <a href="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><code>工厂设计模式</code></a> 的文章，所以现在我只想向你展示如何使用工厂方法和结合了 <code>lazy property</code> 的静态工厂。</p></br><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong><em>工厂方法</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不喜欢自动执行的闭包，则可以将代码移出工厂方法，并将其与惰性变量一起使用。 像这样简单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = <span class="keyword">self</span>.createCustomLabel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">createCustomLabel</span><span class="params">()</span></span> -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"called"</span>)</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.textColor = .black</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，工厂方法的工作方式类似于你的惰性属性的私有初始化程序。 让我们更进一步，以便可以稍微提高可重用性…</p><h2 id="静态工厂方式"><a href="#静态工厂方式" class="headerlink" title="静态工厂方式"></a><strong><em>静态工厂方式</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想在应用程序的多个部分中重复使用这些初始化代码，则将它们初始化为 <a href="http://www.xuebaonline.com/tags/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"><code>静态工厂(static factory)</code></a> 可能是一个好习惯。 例如，这非常适合初始化自定义视图。 另外，创建自定义视图实际上并不是视图控制器任务，因此本示例中的职责更加分离。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = <span class="type">UILabel</span>.createCustomLabel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">createCustomLabel</span><span class="params">()</span></span> -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.textColor = .black</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;免费获得你可以享受静态工厂属性/方法的优点，例如缓存或返回特定的子类型。 挺整洁的！ 👍</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性变量是优化代码的一种非常方便的方法，但是它们只能在结构和类上使用。 n你不能将它们用作计算属性，这意味着它们在你每次尝试访问它们时都不会返回闭包块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个重要的事情是，惰性属性不是线程安全的，因此你必须谨慎使用它们。 另外，你并不总是希望消除隐式解包的可选值，有时候崩溃只是更好的选择！ 🐛</p><blockquote><p><strong><em>提示：</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;别偷懒！</p></blockquote><p>…但是请随时使用惰性属性！ 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何在 &lt;code&gt;Swift&lt;/code&gt; 中使用惰性属性来提高性能，避免使用可选参数或只是为了使初始化过程更加简洁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在程式设计中, 惰性初始是一种拖延战术。在第一次需求出现以前，先延迟创建物件、计算值或其它昂贵程序。这通常是以一个旗号来实现，用旗号来标示是否完成其程式。每次请求对象时，会先测试此旗号。如果已完成，直接传回，否则当场执行。&lt;br&gt;对于此想法更一般的论述，可见惰性求值。对指令式语言，这个模式可能潜藏着危险，尤其是使用共享状态的程式习惯。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;以设计模式的观点来说，惰性初始通常会和工厂方法模式合作，这结合了三种构想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用一个工厂去得到一个类别的实例（工厂方法模式）。&lt;/li&gt;
&lt;li&gt;将实例存在一个集合中，所以下次要求一个实例却有相同参数时，可以得到同一个实例（可和单例模式来做比较）。&lt;/li&gt;
&lt;li&gt;在第一次时，使用惰性初始来实例化物件（惰性初始模式）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="懒加载模式" scheme="http://www.xuebaonline.com/tags/%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift对象池设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-26T02:56:07.000Z</published>
    <updated>2020-04-26T03:01:11.220Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本快速教程中，我将解释并向你展示如何使用 <code>Swift</code> 编程语言实现对象池设计模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="对象池"><code>对象池（英语：object pool pattern）</code></a>是一种设计模式。一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的效能提升。从池子中取得对象的时间是可预测的，但新建一个实例所需的时间是不确定。</p><a id="more"></a></br><h1 id="Swift-中的通用对象池"><a href="#Swift-中的通用对象池" class="headerlink" title="Swift 中的通用对象池"></a><strong>Swift 中的通用对象池</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象池模式是一种创新的设计模式。其背后的主要思想是，首先创建一组对象（一个池），然后从该池中获取和释放对象，而不是不断创建和释放它们。 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么？性能改进。例如， <code>Dispatch</code> 框架使用对象池模式为开发人员提供预先创建的队列，因为创建队列（带有关联线程）是相对昂贵的操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象池模式的另一个用例是 <code>worker</code> 。例如，您必须从Web上下载数百个图像，但是您只想同时下载5个图像，则可以使用5个工作对象池来完成。分配少量的工作程序（实际上将完成下载任务）可能要比为每个图像下载请求创建一个新的工作程序便宜得多。 🖼</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么这种模式的缺点呢？有一些。例如，如果池中有工作程序，则它们可能包含状态或敏感的用户数据。你也必须非常小心。重设所有内容。同样，如果你在多线程环境中运行，则还必须使池成为线程安全的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个简单的通用线程安全对象池类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> lockQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"pool.lock.queue"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> semaphore: <span class="type">DispatchSemaphore</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> items = [<span class="type">T</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> items: [<span class="type">T</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.semaphore = <span class="type">DispatchSemaphore</span>(value: items.<span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">self</span>.items.reserveCapacity(items.<span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">self</span>.items.append(contentsOf: items)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">acquire</span><span class="params">()</span></span> -&gt; <span class="type">T?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.semaphore.wait(timeout: .distantFuture) == .success, !<span class="keyword">self</span>.items.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.lockQueue.sync &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>.items.remove(at: <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">release</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.lockQueue.sync &#123;</span><br><span class="line">            <span class="keyword">self</span>.items.append(item)</span><br><span class="line">            <span class="keyword">self</span>.semaphore.signal()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pool = <span class="type">Pool</span>&lt;<span class="type">String</span>&gt;([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(a ?? "</span>n/a<span class="string">") acquired"</span>)</span><br><span class="line"><span class="keyword">let</span> b = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(b ?? "</span>n/a<span class="string">") acquired"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(c ?? "</span>n/a<span class="string">") acquired"</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .<span class="keyword">default</span>).asyncAfter(deadline: .now() + .seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> item = b &#123;</span><br><span class="line">        pool.release(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"No more resource in the pool, blocking thread until..."</span>)</span><br><span class="line"><span class="keyword">let</span> x = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(x ?? "</span>n/a<span class="string">") acquired again"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在示例中，实现仅几行。 你具有通用池项的线程安全数组，一个调度信号量（如果池中没有可用对象将阻塞该信号量）以及两个方法以实际使用对象池。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在示例中，你可以看到，如果池中没有剩余的对象，则当前队列将被阻塞，直到资源被释放并可以使用为止。 所以要当心，不要意外阻塞主线程！ 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在本快速教程中，我将解释并向你展示如何使用 &lt;code&gt;Swift&lt;/code&gt; 编程语言实现对象池设计模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;对象池&quot;&gt;&lt;code&gt;对象池（英语：object pool pattern）&lt;/code&gt;&lt;/a&gt;是一种设计模式。一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的效能提升。从池子中取得对象的时间是可预测的，但新建一个实例所需的时间是不确定。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="对象池设计模式" scheme="http://www.xuebaonline.com/tags/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift外观设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-26T02:30:49.000Z</published>
    <updated>2020-04-26T02:51:38.845Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观设计模式是复杂子系统上的简化界面。 展示一个使用 <code>Swift</code> 的快速实例。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="外观模式"><code>外观模式（Facade pattern）</code></a> ，是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。</p><a id="more"></a><p><img src="http://q8wtfza4q.bkt.clouddn.com/fp-stp1.png" alt="外观设计模式"></p><ul><li><p>结构</p><ul><li><p>Facade</p><p>  这个外观类为子系统中Packages 1、2、3提供一个共同的对外接口</p></li><li><p>Clients</p><p>  客户对象通过一个外观接口读写子系统中各接口的数据资源。</p></li><li><p>Packages</p><p>  客户可以通过外观接口读取的内部库。</p></li></ul></li></ul></br><h1 id="什么是外观设计模式"><a href="#什么是外观设计模式" class="headerlink" title="什么是外观设计模式"></a><strong>什么是外观设计模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观设计模式名字的由来是源于建筑结构的术语。</p><blockquote><p>one exterior side of a building, usually the front</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件开发中，此定义可以转换为外部所有内容，隐藏所有内部部分。 因此，外观的主要目的是在一些更复杂的丑陋外观上提供漂亮的API。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，如果你有两个或多个单独的子系统需要一起工作以完成某种任务，则外观设计模式会很方便。 它可以隐藏底层的复杂性，再加上如果隐藏方法内部发生任何更改，则外观的界面仍然可以保持不变。 👍</p></br><h1 id="外观设计模式实例"><a href="#外观设计模式实例" class="headerlink" title="外观设计模式实例"></a><strong>外观设计模式实例</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我让我们想象一个带有切换按钮的应用程序，该按钮可以打开或关闭特定设置。 如果用户点击它，我们将更改默认存储中的基础设置值，此外，我们还希望播放声音作为给定输入的额外反馈。 这是三个不同的东西组合在一起。 🎶</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toggleSettings</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// change underlying settings value</span></span><br><span class="line">    <span class="keyword">let</span> settingsKey = <span class="string">"my-settings"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> originalValue = <span class="type">UserDefaults</span>.standard.bool(forKey: settingsKey)</span><br><span class="line">    <span class="keyword">let</span> newValue = !originalValue</span><br><span class="line"></span><br><span class="line">    <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(newValue, forKey: settingsKey)</span><br><span class="line">    <span class="type">UserDefaults</span>.standard.synchronize()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// positive feedback sound</span></span><br><span class="line">    <span class="type">AudioServicesPlaySystemSound</span>(<span class="number">1054</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update UI</span></span><br><span class="line">    <span class="keyword">self</span>.switchButton.setOn(newValue, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恭喜，我们已经创建了最简单的外观！ 如果你对这段代码熟悉，则意味着您过去已经使用了 <code>Facade</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，事情可能会更加复杂，例如，如果你有一个 <code>Web</code> 服务，并且需要上传一些数据和附件文件，那么你还可以编写一个 <code>Facade</code> 来隐藏子系统的底层复杂性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观设计模式确实很容易创建，有时你甚至不会注意到正在使用外观模式，但是它们对于隐藏，解耦或简化事物非常有用。 😉</p></br><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><br><ul><li><p><a href="https://www.appcoda.com/design-pattern-structural/" target="_blank" rel="noopener"><code>Design Patterns in Swift #3: Facade and Adapter</code></a></p></li><li><p><a href="https://rubygarage.org/blog/swift-design-patterns" target="_blank" rel="noopener"><code>Top 5 Design Patterns in Swift for iOS App Development</code></a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;外观设计模式是复杂子系统上的简化界面。 展示一个使用 &lt;code&gt;Swift&lt;/code&gt; 的快速实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;外观模式&quot;&gt;&lt;code&gt;外观模式（Facade pattern）&lt;/code&gt;&lt;/a&gt; ，是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="外观设计模式" scheme="http://www.xuebaonline.com/tags/%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>在Swift中处理非可选选项</title>
    <link href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%A4%84%E7%90%86%E9%9D%9E%E5%8F%AF%E9%80%89%E9%80%89%E9%A1%B9/"/>
    <id>http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%A4%84%E7%90%86%E9%9D%9E%E5%8F%AF%E9%80%89%E9%80%89%E9%A1%B9/</id>
    <published>2020-04-26T01:49:49.000Z</published>
    <updated>2020-04-26T02:19:11.394Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可选参数可以说是 <code>Swift</code> 最重要的功能之一，也是将其与 <code>Objective-C</code> 之类的语言区分开来的关键。 通过被迫处理可能为 <code>nil</code> 的情况，我们倾向于编写更具可预测性和较少错误的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有时可选参数可能会使你处于一个很难处理的局面，在程序员看来，你知道（或至少在假设之下）某个变量在使用时始终为 <code>non-nil</code> ，即使它是 可选类型。 就像在视图控制器中处理视图时一样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tableView: <span class="type">UITableView?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        tableView = <span class="type">UITableView</span>(frame: view.bounds)</span><br><span class="line">        view.addSubview(tableView!)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewModelDidUpdate</span><span class="params">(<span class="number">_</span> viewModel: ViewModel)</span></span> &#123;</span><br><span class="line">        tableView?.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下， <code>Swift</code> 程序员会在与制表符和空格几乎相同的程度上存在分歧。 有人说：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“由于它是可选的，因此你应该始终正确地解开它，使用 <code>let</code> 或 <code>guard let</code> 。”</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而其他人会朝完全不同的方向说：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“由于你知道变量将不会为 <code>nil</code> ，请强制将其解包（使用！）。 崩溃比处于不确定状态要好。”</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本上，我们在这里谈论的是是否进行 <a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener" title="防御性编程"><code>防御性编程(英文：defensive programming)</code></a>。 我们是否试图从不确定的状态中恢复，还是仅仅放弃并崩溃？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我必须对这个问题给出一个二元的答案，那么我肯定会选择后者。 未定义状态会导致很难发现错误，可能会导致不必要的代码执行，而采用防御性编程只会导致难以推理的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，我宁愿不必给出二进制答案，而是研究一些可用于以更细微的方式解决此问题的技术。 </p></br><h1 id="真的可选吗？"><a href="#真的可选吗？" class="headerlink" title="真的可选吗？"></a><strong>真的可选吗？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变量和属性是可选的，但实际上是程序逻辑所必需的，实际上是体系结构缺陷的征兆。 如果需要某些东西，到没有它会使你处于不确定状态-它不是可选的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管在某些情况下（例如与某些系统 <code>API</code> 进行交互时），确实很难避免使用可选项–在许多情况下，我们可以使用某些技术来摆脱可选项。</p></br><h1 id="懒加载-lazy-比非可选的-non-optionally-optional-要好"><a href="#懒加载-lazy-比非可选的-non-optionally-optional-要好" class="headerlink" title="懒加载(lazy)比非可选的(non-optionally optional)要好"></a><strong>懒加载(lazy)比非可选的(non-optionally optional)要好</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种避免使用属性的可选选项的方法，即通过使用惰性属性来避免在创建父对象之后需要创建值的属性（例如，视图控制器中的视图-应该在 <code>loadView()</code> 或 <code>viewDidLoad()</code> 中创建）。 惰性属性可以是非可选的，但仍不需要在其父级的初始值设定项中创建。 它将在首次访问时创建。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从之前更新 <code>TableViewController</code> ，以对其表视图使用对属性进行懒加载：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> tableView = <span class="type">UITableView</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        tableView.frame = view.bounds</span><br><span class="line">        view.addSubview(tableView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewModelDidUpdate</span><span class="params">(<span class="number">_</span> viewModel: ViewModel)</span></span> &#123;</span><br><span class="line">        tableView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有可选项，没有不确定的状态！ 🎉</p></br><h1 id="适当的依赖项管理要比非可选的可选项好"><a href="#适当的依赖项管理要比非可选的可选项好" class="headerlink" title="适当的依赖项管理要比非可选的可选项好"></a><strong>适当的依赖项管理要比非可选的可选项好</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可选项的另一个常见用法是打破 <a href="https://en.wikipedia.org/wiki/Circular_dependency" target="_blank" rel="noopener" title="循环依赖关系"><code>循环依赖关系(circular dependencies)</code></a> 。 有时您可能会遇到 <code>A</code> 依赖于 <code>B</code> ，但 <code>B</code> 也依赖于 <code>A</code> 的情况。类似于此设置：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> commentManager: <span class="type">CommentManager?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userDidPostComment</span><span class="params">(<span class="number">_</span> comment: Comment)</span></span> &#123;</span><br><span class="line">        user.totalNumberOfComments += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">logOutCurrentUser</span><span class="params">()</span></span> &#123;</span><br><span class="line">        user.logOut()</span><br><span class="line">        commentManager?.clearCache()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> userManager: <span class="type">UserManager?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">composer</span><span class="params">(<span class="number">_</span> composer: CommentComposer</span></span></span><br><span class="line"><span class="function"><span class="params">                  didPostComment comment: Comment)</span></span> &#123;</span><br><span class="line">        userManager?.userDidPostComment(comment)</span><br><span class="line">        handle(comment)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clearCache</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cache.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们在上面看到的，我们在 <code>UserManager</code> 和 <code>CommentManager</code> 之间具有循环依赖关系，其中它们都不假定彼此拥有所有权，但是它们在逻辑上仍然相互依赖。 那只是等待发生的错误！ 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决上述问题，我们改为让 <code>CommentComposer</code> 充当中间人，并负责通知 <code>UserManager</code> 和 <code>CommentManager</code> 已做出评论：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentComposer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> commentManager: <span class="type">CommentManager</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> userManager: <span class="type">UserManager</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> textView = <span class="type">UITextView</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(commentManager: <span class="type">CommentManager</span>,</span><br><span class="line">         userManager: <span class="type">UserManager</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.commentManager = commentManager</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">postComment</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> comment = <span class="type">Comment</span>(text: textView.text)</span><br><span class="line">        commentManager.handle(comment)</span><br><span class="line">        userManager.userDidPostComment(comment)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，<code>UserManager</code> 可以拥有对 <code>CommentManager</code> 的强引用，而没有循环引用（或依赖)：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> commentManager: <span class="type">CommentManager</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(commentManager: <span class="type">CommentManager</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.commentManager = commentManager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userDidPostComment</span><span class="params">(<span class="number">_</span> comment: Comment)</span></span> &#123;</span><br><span class="line">        user.totalNumberOfComments += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再次删除了所有可选内容，并提供了可预测的代码！ 🎉</p></br><h1 id="崩溃"><a href="#崩溃" class="headerlink" title="崩溃"></a><strong>崩溃</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的示例中，我们看到了一些示例，在这些示例中我们可以调整代码以通过删除可选选项来消除不确定性。 但是，有时候这是不可能的。 假设你正在加载包含应用程序配置的本地 <code>JSON</code> 文件。 这本质上是一项可能会失败的操作，因此我们将需要添加一些错误处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果配置无法加载，则继续执行程序会使应用程序处于未定义状态，因此在这种情况下可能会引发崩溃。 这样，我们可以获得崩溃报告，并希望我们的 <code>tests &amp; QA</code> 检查流程能够早于解决此问题并将其传递给用户。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，我们如何崩溃？ 最简单的解决方案是简单地使用 <code>! operator</code> ，强制解开可选选项，如果它包含 <code>nil</code> 则导致崩溃：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = loadConfiguration()!</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管这种方法很简单，但缺点是很大。 如果此代码开始崩溃，我们将得到的错误消息是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: unexpectedly found <span class="literal">nil</span> <span class="keyword">while</span> unwrapping an <span class="type">Optional</span> value</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;错误消息不会告诉我们错误的原因和发生位置，也没有提供解决方法的线索。 相反，让我们结合使用 <code>guard</code> 语句和 <code>preconditionFailure()</code> 函数，以自定义消息退出。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> configuration = loadConfiguration() <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">preconditionFailure</span>(<span class="string">"Configuration couldn't be loaded. "</span> +</span><br><span class="line">                        <span class="string">"Verify that Config.JSON is valid."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用以上方法崩溃时，我们将获得更多有用的错误消息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: <span class="type">Configuration</span> couldn’t be loaded. <span class="type">Verify</span> that <span class="type">Config1</span>.<span class="type">JSON</span> <span class="keyword">is</span> valid.: file ~/<span class="type">DemoApp</span>/<span class="type">Sources</span>/<span class="type">AppDelegate</span>.swift, line <span class="number">17</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以采取明确的措施来解决该问题，并且我们确切知道它在代码库中的位置！ 🚀</p></br><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a><strong>更多</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进行上面的 <code>guard-let-preconditionFailure</code> 操作可能会有些乏味，并且确实会使代码难于遵循。 我们真的不想在代码中留出如此大的空间，这样的特殊情况-我们要专注于我们的逻辑。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的解决方案是 <code>Require</code> 。 它在 <code>Optional</code> 上添加了一个简单的 <code>require()</code> 方法，可以完成上述操作，但是使调用站点更加整洁。 使用 <code>Require</code> 时，上述配置加载代码如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = loadConfiguration().require(hint: <span class="string">"Verify that Config.JSON is valid"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果失败，它将给我们以下错误消息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: <span class="type">Required</span> value was <span class="literal">nil</span>. <span class="type">Debugging</span> hint: <span class="type">Verify</span> that <span class="type">Config1</span>.<span class="type">JSON</span> <span class="keyword">is</span> valid: file ~/<span class="type">DemoApp</span>/<span class="type">Sources</span>/<span class="type">AppDelegate</span>.swift, line <span class="number">17</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Require</code> 的另一个优点是，它还将引发 <code>NSException</code> 以及调用 <code>preconditionFailure</code> ，这将使崩溃报告工具（如 <code>Crashlytics</code> ）能够提取崩溃的所有元数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想在代码中使用  <a href="https://github.com/JohnSundell/Require" target="_blank" rel="noopener" title="Require"><code>Require</code></a> ，它是 <a href="https://github.com/JohnSundell/Require" target="_blank" rel="noopener" title="Require"><code>GitHub</code></a> 上的开源代码。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，这些是我在 <code>Swift</code> 中处理非可选可选内容的技巧：</p><ul><li>懒加载(lazy)比非可选的(non-optionally optional)要好</li><li>适当的依赖项管理要比非可选的可选项好</li><li>当您需要使用非可选的可选选项时，正常崩溃</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选参数可以说是 &lt;code&gt;Swift&lt;/code&gt; 最重要的功能之一，也是将其与 &lt;code&gt;Objective-C&lt;/code&gt; 之类的语言区分开来的关键。 通过被迫处理可能为 &lt;code&gt;nil&lt;/code&gt; 的情况，我们倾向于编写更具可预测性和较少错误的代码。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;但是，有时可选参数可能会使你处于一个很难处理的局面，在程序员看来，你知道（或至少在假设之下）某个变量在使用时始终为 &lt;code&gt;non-nil&lt;/code&gt; ，即使它是 可选类型。 就像在视图控制器中处理视图时一样：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TableViewController&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; tableView: &lt;span class=&quot;type&quot;&gt;UITableView?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tableView = &lt;span class=&quot;type&quot;&gt;UITableView&lt;/span&gt;(frame: view.bounds)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        view.addSubview(tableView!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewModelDidUpdate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; viewModel: ViewModel)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tableView?.reloadData()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="迭代器设计模式" scheme="http://www.xuebaonline.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="optionals" scheme="http://www.xuebaonline.com/tags/optionals/"/>
    
      <category term="non-optional" scheme="http://www.xuebaonline.com/tags/non-optional/"/>
    
  </entry>
  
  <entry>
    <title>在Swift中创建自定义集合</title>
    <link href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/"/>
    <id>http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/</id>
    <published>2020-04-26T01:29:52.000Z</published>
    <updated>2020-04-26T02:20:25.950Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建对象或值的集合时，我们通常使用标准库提供的数据结构-例如 <code>Array</code> ，<code>Dictionary</code> 和 <code>Set</code> 。 尽管这三个案例涵盖了大多数用例，但有时创建自定义包装器集合可以使你使代码更可预测，并且更不易出错。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此次，让我们看看作为应用程序开发人员的我们如何在 <code>Swift</code> 中定义此类自定义集合，以及结合枚举的强大功能，如何让我们为自己创建一些非常漂亮的 <code>API</code> 。</p><a id="more"></a></br><h1 id="删除可选"><a href="#删除可选" class="headerlink" title="删除可选"></a><strong>删除可选</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像我们在 <a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%A4%84%E7%90%86%E9%9D%9E%E5%8F%AF%E9%80%89%E9%80%89%E9%A1%B9/" title="在Swift中处理非可选的可选内容"><code>“在Swift中处理非可选的可选内容”</code></a> 中介绍的那样，减少了在实际需要的值真正需要时使用可选的需求，这确实可以帮助我们避免错误并简化我们的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，集合的问题在于，你通常无法保证它们是否包含一定的值，因此，你往往会遇到很多可选内容和逻辑，这些可选内容和逻辑要求以一种或另一种方式将它们拆开。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们正在为一家杂货店构建应用程序，并且我们希望拥有一个用户界面，该界面可让用户按类别显示所有产品。 要为此类UI创建模型，我们可以使用 <code>Dictionary</code> ，其使用 <code>Category</code> 作为其键类型，并使用 <code>[Product]</code> 作为其值类型，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> products: [<span class="type">Category</span> : [<span class="type">Product</span>]] = [</span><br><span class="line">    .dairy: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Milk"</span>, category: .dairy),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Butter"</span>, category: .dairy)</span><br><span class="line">    ],</span><br><span class="line">    .vegetables: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Cucumber"</span>, category: .vegetables),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Lettuce"</span>, category: .vegetables)</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管上述方法有效，但要求我们编写这样的代码，以便例如仅显示所有 <code>Product</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> dairyProducts = products[.dairy] &#123;</span><br><span class="line">    <span class="keyword">guard</span> !dairyProducts.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        renderEmptyView()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render(dairyProducts)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    renderEmptyView()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很好，但是可能会更好。 但是，插入新产品变得更加麻烦：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> products = [<span class="type">Category</span> : [<span class="type">Product</span>]]()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> product: Product)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> productsInCategory = products[product.category] &#123;</span><br><span class="line">            productsInCategory.append(product)</span><br><span class="line">            products[product.category] = productsInCategory</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            products[product.category] = [product]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好消息是，通过创建我们自己的自定义集合，我们可以使上述两个示例变得更好更清晰。 而且，更好的消息是-借助 <code>Swift</code> 的面向协议的设计-创建这样的集合实际上非常容易！</p></br><h1 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a><strong>创建集合</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 标准库中的所有集合都遵循 <code>Collection</code> 协议，而 <code>Collection</code> 协议又继承自 <code>Sequence</code> 协议。 通过使自定义集合符合这两个协议，它可以完全免费地利用所有标准集合操作（例如，迭代和过滤）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从定义自定义 <code>ProductCollection</code> 的基础开始，这将使我们能够以更好的方式处理产品和类别。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProductCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">DictionaryType</span> = [<span class="type">Category</span> : [<span class="type">Product</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Underlying, private storage, that is the same type of dictionary</span></span><br><span class="line">    <span class="comment">// that we previously was using at the call site</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> products = <span class="type">DictionaryType</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable our collection to be initialized with a dictionary</span></span><br><span class="line">    <span class="keyword">init</span>(products: <span class="type">DictionaryType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.products = products</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们将通过实现协议要求使其符合 <code>Collection</code> 。 我们要做的大多数事情就是简单地将调用转发到基础 <code>products</code> 字典，然后让它进行“繁重的工作”：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span>: <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Required nested types, that tell Swift what our collection contains</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">DictionaryType</span>.<span class="type">Index</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">DictionaryType</span>.<span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The upper and lower bounds of the collection, used in iterations</span></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123; <span class="keyword">return</span> products.startIndex &#125;</span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123; <span class="keyword">return</span> products.endIndex &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Required subscript, based on a dictionary index</span></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Index</span>) -&gt; <span class="type">Iterator</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> products[index] &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method that returns the next index when iterating</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Index)</span></span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> products.index(after: i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码使用的是 <code>Swift 4</code> ，这归功于对通用约束的改进（使我们可以更仔细地研究这些改进以及如何在以后的文章中使用类型约束），从而使自定义集合的定义变得更加简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们有了一个自定义集合，可以将其用作内置集合之一。 例如，我们可以遍历它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (category, productsInCategory) <span class="keyword">in</span> products &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者在其上使用诸如 <code>map</code> 的操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> categories = productCollection.<span class="built_in">map</span> &#123; $<span class="number">0</span>.key &#125;</span><br></pre></td></tr></table></figure></br><h1 id="自定义集合-API"><a href="#自定义集合-API" class="headerlink" title="自定义集合 API"></a><strong>自定义集合 API</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们已经为我们的系列奠定了基础，让我们开始向其中添加一些 <code>API</code> ，使我们能够使我们的产品处理代码更好。 我们将从一个自定义的下标重载开始，该重载使我们无需处理可选项就可以获取或设置一系列产品：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(category: <span class="type">Category</span>) -&gt; [<span class="type">Product</span>] &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> products[category] ?? [] &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; products[category] = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还添加一个便捷的 <code>API</code> ，以轻松地将新 <code>product</code> 插入我们的收藏夹：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> product: Product)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> productsInCategory = <span class="keyword">self</span>[product.category]</span><br><span class="line">        productsInCategory.append(product)</span><br><span class="line">        <span class="keyword">self</span>[product.category] = productsInCategory</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以返回原始的 <code>product</code> 处理代码，并将其更新为更好的代码。 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dairyProducts = products[.dairy]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dairyProducts.isEmpty &#123;</span><br><span class="line">    renderEmptyView()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    render(dairyProducts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> products = <span class="type">ProductCollection</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(product: Product)</span></span> &#123;</span><br><span class="line">        products.insert(product)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="通过-Key-值获取"><a href="#通过-Key-值获取" class="headerlink" title="通过 Key 值获取"></a><strong>通过 Key 值获取</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，到了关键时候！ 由于我们的自定义集合基本上只是字典的包装，因此我们可以轻松地添加对使用字典文字进行初始化的支持。 这样做将使我们能够编写如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> products: <span class="type">ProductCollection</span> = [</span><br><span class="line">    .dairy: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Milk"</span>, category: .dairy),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Butter"</span>, category: .dairy)</span><br><span class="line">    ],</span><br><span class="line">    .vegetables: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Cucumber"</span>, category: .vegetables),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Lettuce"</span>, category: .vegetables)</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;太酷了！ 这不仅对减少生产代码中的冗长有用，而且还将使在我们的测试中设置产品集合模拟更加简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要做的就是遵守    <code>ExpressibleByDictionaryLiteral</code> ，它要求我们实现一个带有文字的初始化程序，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span>: <span class="title">ExpressibleByDictionaryLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Key</span> = <span class="type">Category</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Value</span> = [<span class="type">Product</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(dictionaryLiteral elements: (<span class="type">Category</span>, [<span class="type">Product</span>])...) &#123;</span><br><span class="line">        <span class="keyword">for</span> (category, productsInCategory) <span class="keyword">in</span> elements &#123;</span><br><span class="line">            products[category] = productsInCategory</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用自定义集合可能是一种非常强大的工具，可以以一种更加可预测且易于使用的方式来处理一组值。 当您处理多个值时，它不一定总是您的首选解决方案，但在正确的情况下，它确实可以帮助你编写更简洁的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在调试时，了解诸如集合之类的事物的工作方式也非常有帮助，或者使你了解如何优化与集合相关的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 &lt;code&gt;Swift&lt;/code&gt; 中创建对象或值的集合时，我们通常使用标准库提供的数据结构-例如 &lt;code&gt;Array&lt;/code&gt; ，&lt;code&gt;Dictionary&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; 。 尽管这三个案例涵盖了大多数用例，但有时创建自定义包装器集合可以使你使代码更可预测，并且更不易出错。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此次，让我们看看作为应用程序开发人员的我们如何在 &lt;code&gt;Swift&lt;/code&gt; 中定义此类自定义集合，以及结合枚举的强大功能，如何让我们为自己创建一些非常漂亮的 &lt;code&gt;API&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="迭代器设计模式" scheme="http://www.xuebaonline.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Collection" scheme="http://www.xuebaonline.com/tags/Collection/"/>
    
      <category term="Collections" scheme="http://www.xuebaonline.com/tags/Collections/"/>
    
  </entry>
  
  <entry>
    <title>Swift迭代器设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-26T01:13:26.000Z</published>
    <updated>2020-04-26T02:22:15.675Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用一些 <a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/" title="自定义序列"><code>自定义序列</code></a>（符合 <code>Swift</code> 标准库中的 <code>IteratorProtocol</code> ），学习迭代器设计模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在面向对象编程里，<a href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="迭代器模式">迭代器模式</a> 是一种设计模式，是一种最简单也最常见的设计模式。它可以让用户透过特定的接口访问容器中的每一个元素而不用了解底层的实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，我将重点介绍迭代器设计模式。 该模式在 <a href="https://developer.apple.com/documentation/swift/swift_standard_library" target="_blank" rel="noopener" title="Swift标准库"><code>Swift标准库</code></a> 中大量使用，如果你需要创建迭代器，有一些协议可以为你提供支持，但是老实说：我从来没有直接实现过这种模式。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实是，在99％的用例中，你将永远不必处理这种模式，因为对 <code>Swift</code> 中直接内置的迭代器提供了惊人的支持。 始终使用序列，数组，字典而不是直接实现此模式，但是很高兴知道事情是如何进行的。 🙃</p><a id="more"></a></br><h1 id="什么是迭代器设计模式？"><a href="#什么是迭代器设计模式？" class="headerlink" title="什么是迭代器设计模式？"></a><strong>什么是迭代器设计模式？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顾名思义，该模式使你可以迭代一组元素。 这是其中一种定义：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供一种在不暴露其基础表示的情况下顺序访问聚合对象的元素的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长话短说，迭代器为你提供了一个界面，无论你在后台如何实现这些集合，都可以使你对集合进行迭代。 这是上面使用字符串迭代器的理论的快速示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">StringIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStringIterator</span>: <span class="title">StringIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> values: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> index: <span class="type">Int?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> values: [<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.values = values</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">for</span> index: Int?)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = index, index &lt; <span class="keyword">self</span>.values.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="literal">nil</span>, !<span class="keyword">self</span>.values.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = <span class="keyword">self</span>.nextIndex(<span class="keyword">for</span>: <span class="keyword">self</span>.index) &#123;</span><br><span class="line">            <span class="keyword">self</span>.index = index</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.values[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Iterable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">StringIterator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataArray</span>: <span class="title">Iterable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> dataSource: [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataSource = [<span class="string">"🐶"</span>, <span class="string">"🐔"</span>, <span class="string">"🐵"</span>, <span class="string">"🦁"</span>, <span class="string">"🐯"</span>, <span class="string">"🐭"</span>, <span class="string">"🐱"</span>, <span class="string">"🐮"</span>, <span class="string">"🐷"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">StringIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ArrayStringIterator</span>(<span class="keyword">self</span>.dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="type">DataArray</span>()</span><br><span class="line"><span class="keyword">let</span> iterator = data.makeIterator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> next = iterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，它们有两个主要协议和一个非常简单的实现。 现在，我们的 <code>DataArray</code> 类的行为就像一个真实的数组，可以通过使用循环来迭代基础元素。 让我们抛开理论，通过使用实际的 <code>Swift标准库组件</code> 从上面重新实现示例。 😉</p></br><h1 id="Swift-中的自定义序列"><a href="#Swift-中的自定义序列" class="headerlink" title="Swift 中的自定义序列"></a><strong>Swift 中的自定义序列</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 具有内置的序列协议，可帮助你创建迭代器。 在 <code>Swift</code> 中实现自己的序列就是通过创建自定义迭代器对象来隐藏基础数据结构。 你只需存储当前索引，并在每次调用下一个函数时根据该索引返回下一个元素。 😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Emojis</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> animals: [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">EmojiIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">EmojiIterator</span>(<span class="keyword">self</span>.animals)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EmojiIterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> values: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> index: <span class="type">Int?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> values: [<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.values = values</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">for</span> index: Int?)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = index, index &lt; <span class="keyword">self</span>.values.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="literal">nil</span>, !<span class="keyword">self</span>.values.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = <span class="keyword">self</span>.nextIndex(<span class="keyword">for</span>: <span class="keyword">self</span>.index) &#123;</span><br><span class="line">            <span class="keyword">self</span>.index = index</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.values[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emojis = <span class="type">Emojis</span>(animals: [<span class="string">"🐶"</span>, <span class="string">"🐔"</span>, <span class="string">"🐵"</span>, <span class="string">"🦁"</span>, <span class="string">"🐯"</span>, <span class="string">"🐭"</span>, <span class="string">"🐱"</span>, <span class="string">"🐮"</span>, <span class="string">"🐷"</span>])</span><br><span class="line"><span class="keyword">for</span> emoji <span class="keyword">in</span> emojis &#123;</span><br><span class="line">    <span class="built_in">print</span>(emoji)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，<a href="https://developer.apple.com/documentation/swift/sequence" target="_blank" rel="noopener" title="Sequence protocol"><code>Sequence protocol</code></a> 与第一个示例中使用的自定义可迭代协议的通用对应项。   <a href="https://developer.apple.com/documentation/swift/iteratorprotocol" target="_blank" rel="noopener" title="IteratorProtocol"><code>IteratorProtocol</code></a> 有点像之前使用的字符串迭代器协议，但是更加迅捷，当然也更通用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，这很棒。 最后，你知道如何创建自定义序列。 如果你想隐藏数据结构并提供通用的可迭代接口，那么这很好。 想象一下，如果你将要开始使用字典而不是使用数组来存储命名的表情符号而没有用于包装它们的迭代器，将会发生什么。 🤔</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我想谈谈 <code>Swift标准库</code> 中还有另外一个超级有用的东西。 没错，一个抽象级别的应用，我们看这里：</p></br><h1 id="Swift-中的自定义集合"><a href="#Swift-中的自定义集合" class="headerlink" title="Swift 中的自定义集合"></a><strong>Swift 中的自定义集合</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://developer.apple.com/documentation/swift/collection" target="_blank" rel="noopener" title="Collections"><code>Collections</code></a> 是序列之外的第一步。 它们内部的元素可以通过下标访问，它们还定义了 <code>startIndex</code> 和 <code>endIndex</code> ，而且集合中的各个元素可以多次访问。 听起来不错？ 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时创建 <a href=""自定义集合类型""><code>自定义集合类型</code></a> 可能很有用。 例如，如果你想消除可选值。 想象一下分类的收藏夹机制，对于每个类别，您都有一系列的收藏夹，因此你必须处理空的和不存在的案例。 使用自定义集合，你可以将多余的代码隐藏在自定义数据结构中，并为应用程序的其余部分提供一个简洁的界面。 😍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">FavoriteType</span> = [<span class="type">String</span>: [<span class="type">String</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> list: <span class="type">FavoriteType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Favorites</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.list = <span class="type">FavoriteType</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Favorites</span>: <span class="title">Collection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">FavoriteType</span>.<span class="type">Index</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">FavoriteType</span>.<span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.startIndex</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.endIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Index</span>) -&gt; <span class="type">Iterator</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list[index]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Index)</span></span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.index(after: i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">String</span>) -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list[index] ?? []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> value: String, category: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> values = <span class="keyword">self</span>.list[category] &#123;</span><br><span class="line">            <span class="keyword">guard</span> !values.<span class="built_in">contains</span>(value) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            values.append(value)</span><br><span class="line">            <span class="keyword">self</span>.list[category] = values</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.list[category] = [value]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> value: String, category: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> values = <span class="keyword">self</span>.list[category] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        values = values.<span class="built_in">filter</span> &#123; $<span class="number">0</span> == value &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> values.isEmpty &#123;</span><br><span class="line">            <span class="keyword">self</span>.list.removeValue(forKey: category)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.list[category] = values</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Favorites</span>.shared.add(<span class="string">"apple"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.add(<span class="string">"pear"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.add(<span class="string">"apple"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Favorites</span>.shared[<span class="string">"fruits"</span>]</span><br><span class="line"></span><br><span class="line"><span class="type">Favorites</span>.shared.remove(<span class="string">"apple"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.remove(<span class="string">"pear"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.list</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我知道，这是一个非常简单的示例，但它说明了为什么集合比纯序列更高级。 此外，在下面的链接中，有很好的演示，演示了精心编写的收藏集。 随时了解有关隐藏在Swift标准库中（不是那么深）的这些超级协议和自定义数据类型的更多信息。 🤐</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过使用一些 &lt;a href=&quot;http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/&quot; title=&quot;自定义序列&quot;&gt;&lt;code&gt;自定义序列&lt;/code&gt;&lt;/a&gt;（符合 &lt;code&gt;Swift&lt;/code&gt; 标准库中的 &lt;code&gt;IteratorProtocol&lt;/code&gt; ），学习迭代器设计模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在面向对象编程里，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;迭代器模式&quot;&gt;迭代器模式&lt;/a&gt; 是一种设计模式，是一种最简单也最常见的设计模式。它可以让用户透过特定的接口访问容器中的每一个元素而不用了解底层的实现。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这次，我将重点介绍迭代器设计模式。 该模式在 &lt;a href=&quot;https://developer.apple.com/documentation/swift/swift_standard_library&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;Swift标准库&quot;&gt;&lt;code&gt;Swift标准库&lt;/code&gt;&lt;/a&gt; 中大量使用，如果你需要创建迭代器，有一些协议可以为你提供支持，但是老实说：我从来没有直接实现过这种模式。 😅&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;事实是，在99％的用例中，你将永远不必处理这种模式，因为对 &lt;code&gt;Swift&lt;/code&gt; 中直接内置的迭代器提供了惊人的支持。 始终使用序列，数组，字典而不是直接实现此模式，但是很高兴知道事情是如何进行的。 🙃&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="迭代器设计模式" scheme="http://www.xuebaonline.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift适配器设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T10:45:18.000Z</published>
    <updated>2020-04-26T01:15:53.944Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用真实示例和 <code>Swift</code> 中的适配器设计模式，将不兼容的对象转换为目标接口或类。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设计模式中，<a href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="适配器模式">适配器模式</a>（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。</p><a id="more"></a><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h1><p>有两种类型的适配器模式：</p><ul><li><p><strong>对象适配器模式</strong></p><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。</p><p>  <img src="http://q8wtfza4q.bkt.clouddn.com/adp-stp1.png" alt="对象适配器模式" title="对象适配器模式"></p></li></ul><br><ul><li><strong>类适配器模式</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种适配器模式下，适配器继承自已实现的类（一般多重继承）。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/adp-stp2.png" alt="类适配器模式" title="类适配器模式"></p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适配器是一种结构设计模式，允许具有不兼容接口的对象一起工作。 换句话说，它转换对象的接口以使其适应不同的对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，适配器可以将一件事转换为另一件事，有时也称为包装器，因为它可以包装对象并在其周围提供一个新接口。 就像特定接口或旧类的软件加密狗一样。 </p><br><h1 id="适配器设计模式的实现"><a href="#适配器设计模式的实现" class="headerlink" title="适配器设计模式的实现"></a><strong>适配器设计模式的实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建适配器实际上是一件非常容易的事情。 你只需要创建一个新对象，将旧对象“装箱”到其中，并在新类或结构上实现所需的接口即可。 换句话说，包装器对象将是我们的适配器，通过包装另一个适配器对象来实现目标接口。</p><h2 id="Adaptee"><a href="#Adaptee" class="headerlink" title="Adaptee"></a><strong>Adaptee</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们正在适应特定目标的对象（例如，老式的USB-A端口）。</p><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a><strong>Adapter</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个包装原始对象并产生由某些目标接口指定的新要求的对象（这完成了实际工作，也就是上面的小软件狗）。</p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们要与（我们的 <code>USB-C</code> 插座）适配器一起使用的对象。</p><br><h1 id="如何在Swift中使用适配器模式？"><a href="#如何在Swift中使用适配器模式？" class="headerlink" title="如何在Swift中使用适配器模式？"></a><strong>如何在Swift中使用适配器模式？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要在代码中集成第三方库，则可以使用适配器，但是其接口与你的要求不匹配。 例如，你可以围绕整个 <code>SDK</code>或后端 <code>API</code> 端点创建包装器，以创建一个公分母。 👽</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我的示例中，我将使用适配器类包装 <code>EKEvent</code> 对象，以实现全新的协议。 📆</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> EventKit</span><br><span class="line"></span><br><span class="line"><span class="comment">// our target protocol</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> startDate: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> endDate: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adapter (wrapper class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> dateFormatter: <span class="type">DateFormatter</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        dateFormatter.dateFormat = <span class="string">"yyyy. MM. dd. HH:mm"</span></span><br><span class="line">        <span class="keyword">return</span> dateFormatter</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> event: <span class="type">EKEvent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(event: <span class="type">EKEvent</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.event = event</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// actual adapter implementation</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">EventAdapter</span>: <span class="title">Event</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.event.title</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> startDate: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dateFormatter.string(from: event.startDate)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> endDate: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dateFormatter.string(from: event.endDate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let's create an EKEvent adaptee instance</span></span><br><span class="line"><span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()</span><br><span class="line">dateFormatter.dateFormat = <span class="string">"MM/dd/yyyy HH:mm"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> calendarEvent = <span class="type">EKEvent</span>(eventStore: <span class="type">EKEventStore</span>())</span><br><span class="line">calendarEvent.title = <span class="string">"Adapter tutorial deadline"</span></span><br><span class="line">calendarEvent.startDate = dateFormatter.date(from: <span class="string">"07/30/2018 10:00"</span>)</span><br><span class="line">calendarEvent.endDate = dateFormatter.date(from: <span class="string">"07/30/2018 11:00"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// now we can use the adapter class as an Event protocol, instead of an EKEvent</span></span><br><span class="line"><span class="keyword">let</span> adapter = <span class="type">EventAdapter</span>(event: calendarEvent)</span><br><span class="line"><span class="comment">// adapter.title</span></span><br><span class="line"><span class="comment">// adapter.startDate</span></span><br><span class="line"><span class="comment">// adapter.endDate</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个用例是当你必须使用几个现有的最终类或结构，但它们缺少某些功能，并且你想在它们之上构建一个新的目标接口时。 有时，实现包装程序来处理这种混乱情况是一个不错的选择。 🤷‍♂️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是适配器设计模式的全部内容。 通常，用 <code>Swift</code> 或任何其他编程语言实现它确实很容易，但是它非常有用，有时是不可避免的。 孩子们，请记住：不要在加密狗上太用力！😉</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过使用真实示例和 &lt;code&gt;Swift&lt;/code&gt; 中的适配器设计模式，将不兼容的对象转换为目标接口或类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在设计模式中，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;适配器模式&quot;&gt;适配器模式&lt;/a&gt;（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="适配器设计模式" scheme="http://www.xuebaonline.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift关于Dependency Injection (DI)</title>
    <link href="http://www.xuebaonline.com/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/"/>
    <id>http://www.xuebaonline.com/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/</id>
    <published>2020-04-25T09:13:51.000Z</published>
    <updated>2020-04-25T10:39:44.036Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 为我们许多人打开了函数式编程的世界。 但这仍然是面向对象的语言，而不是功能的语言。 我们的主要工具 <code>Cocoa frameworks</code> 是面向对象的。 因此，我们自己可能仍然会继续编写面向对象的代码。 这样做的问题是实际上很难编写设计良好的面向对象的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有很多不同的设计原则，例如 <code>SOLID</code> ，<code>KISS</code> ，<code>DRY</code> 等（ <code>YAGNI</code> ， <code>RAP</code> ，<code>CQS</code> ），甚至更多的设计模式。 至少对于我来说，有这么多不同的原理和模式这一事实意味着，即使有可能，良好的面向对象设计也很难。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖注入本身不是我刚才提到的 <code>SOLID</code> 原则的一部分。 但这与他们所有人息息相关。 不幸的是，依赖注入的概念被许多误解所包围。</p><a id="more"></a><blockquote><p>维基百科为我们提供了非常复杂的定义：<br>“在软件工程中，依赖性注入是一种软件设计模式，可实现控制反转以解决依赖性。”  - <code>Wikipedia</code></p></blockquote><blockquote><p>还有几句话……相反，一些开发人员说依赖注入只是传递一个实例变量。<br>“依赖注入实际上只是传递一个实例变量。”  - <code>James Shore</code></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他人则认为这是某种奇巧淫技，需要使用复杂而缓慢的框架，或者它仅与测试有关，只会使代码更难以理解。 我会说所有这些都是对依赖注入的误解。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将尽我所能使其更加清晰，并展示我对依赖注入的了解。 我将尝试展示如何进行依赖注入。 不仅如此，我们不应该这样做。</p></br><h1 id="为什么要依赖注射？"><a href="#为什么要依赖注射？" class="headerlink" title="为什么要依赖注射？"></a><strong>为什么要依赖注射？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，让我们看看依赖注入首先要解决的问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编程中，我们总是必须处理不同种类和级别的抽象。他们无处不在。接口，方法，闭包，甚至是具体的类型和变量名称-它们都是抽象的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了实现良好的代码设计，使用适当的抽象非常重要，因为它们会使我们的代码松散耦合。这意味着我们代码的不同组件可以替换为其他实现，而不会影响其他组件。当我们的代码松散耦合时，它变得更容易测试，更容易扩展，更容易重用，更容易并行开发。所有这些使维护变得更容易。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;松耦合代码是依赖注入的主要目标。它使我们能够编写松耦合的代码。因此，它使测试，扩展和重用代码变得更加容易。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多时候，仅在单元测试中讨论依赖注入。实际上，它极大地提高了可测试性，尤其是在 <code>Swift</code> 中。但是实际情况要广泛得多。如果我们的最终目标不仅是对某些类进行单元测试，还需要松散的耦合并使代码可维护，那么我们将需要付出更多的努力，而不仅仅是传递实例变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管从本质上讲，依赖注入实际上是关于传递实例变量，或者说将依赖传递给它们的使用者更好。这是第一步，也是每个第一步中最重要的一步。但这只是一个故事的一部分。还有第二步，甚至第三步。这些步骤使仅传递变量和依赖注入之间有所不同。</p></br><h1 id="依赖注射模式"><a href="#依赖注射模式" class="headerlink" title="依赖注射模式"></a><strong>依赖注射模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们从第一步开始。 有几种模式可以将依赖关系传递给消费者：</p><ul><li>构造函数注入</li><li>属性注入</li><li>方法注入</li><li>环境语境</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看看来自 <code>Cocoa frameworks</code> 的示例的使用。</p></br><h1 id="CONSTRUCTOR注入"><a href="#CONSTRUCTOR注入" class="headerlink" title="CONSTRUCTOR注入"></a><strong>CONSTRUCTOR注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是从 <strong><code>CoreData</code></strong> 注入构造函数的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NSPersistentStore</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(</span><br><span class="line">        persistentStoreCoordinator root: <span class="type">NSPersistentStoreCoordinator?</span>, </span><br><span class="line">        configurationName name: <span class="type">String?</span>, </span><br><span class="line">        <span class="type">URL</span> url: <span class="type">NSURL</span>, </span><br><span class="line">        options: [<span class="type">NSObject</span>: <span class="type">AnyObject</span>]?</span><br><span class="line">    )</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> persistentStoreCoordinator: <span class="type">NSPersistentStoreCoordinator?</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，持久性存储协调器的实例与其他一些参数一起传递给 <code>NSPersistentStore</code> 的构造函数。 然后，对协调器的引用将被存储，并且在运行时无法更改。</p><blockquote><p>通过构造函数注入，我们将依赖项作为构造函数参数传递并将其存储在只读属性中。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管在 <code>Cocoa frameworks</code> 中没有太多构造函数注入的示例，但这是注入依赖关系的首选方法。 因为它是最容易实现的，所以可以确保始终存在依赖项，并且在运行时不会更改依赖项，这使它更加安全。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在某些情况下，构造函数注入是不可能的或不合适的。 在这些情况下，我们应该使用属性注入。</p></br><h1 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a><strong>属性注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何 <code>iOS</code> 应用程序中到处都有这种模式。 例如，委托模式通常使用属性注入来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">public</span> <span class="keyword">var</span> transitioningDelegate: <span class="type">UIViewControllerTransitioningDelegate?</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，这里的视图控制器公开了用于转换委托的可写属性，如果要覆盖 <code>dafault</code> 行为，我们可以随时更改它。</p><blockquote><p>使用属性注入，消费者通过可写属性获得其依赖关系，该属性也具有一些默认值。</p></blockquote></br><h1 id="本地和外部默认设置"><a href="#本地和外部默认设置" class="headerlink" title="本地和外部默认设置"></a><strong>本地和外部默认设置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果存在良好的本地默认依赖关系，则应使用属性注入。 “本地”表示在同一模块中定义。 nil也是理想的本地默认值，它只是使依赖项成为可选项。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当实现来自单独的模块时，它是外来的。然后，我们不应将其用作默认值。而且我们不应该将属性注入用于这种依赖性。相反，我们应该使用构造函数注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象一下，传递委托的默认实现不是在 <code>UIKit</code> 中定义的，而是在其他框架中定义的。然后，即使我们从不使用此 <code>API</code> ，也始终需要链接到该框架。 <code>UIKit</code> 与该框架紧密结合。它拖延了这种无用的依赖性。我们自己的代码也会发生同样的情况，这将使重用变得更加困难。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与构造函数注入属性注入进行比较可能更容易理解，并且使我们的 <code>API</code> 看起来更灵活。但是与此同时，它可能更难以实现，并使我们的代码更脆弱。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要适当的默认实现或以适当的方式处理可选值，这可能会导致带有可选包装的可选代码混乱。其次，我们不能将属性定义为不可变的。因此，如果我们不想在设置后就对其进行更改，则需要确保在运行时而不是在编译时进行更改。另外，我们可能需要同步对其进行访问，以防止出现线程问题。由于这些原因，如果我们可以使用构造函数注入，那么我们应该首选属性注入。</p></br><h1 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a><strong>方法注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一个模式，方法注入，就像将参数传递给方法一样简单。 例如，这里是 <code>NSCoding</code> 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">NSCoding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encodeWithCoder</span><span class="params">(aCoder: NSCoder)</span></span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次将该方法称为不同的实例，甚至可以将 <code>NSCoder</code> 的实现作为参数传递。</p><blockquote><p>使用方法注入依赖关系作为参数传递给方法。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当依赖关系随每个方法调用而变化时，或者当依赖关系是暂时的并且不需要在方法范围之外保持对它的引用时，通常使用方法注入。</p><h1 id="AMBIENT-CONTEXT"><a href="#AMBIENT-CONTEXT" class="headerlink" title="AMBIENT CONTEXT"></a><strong>AMBIENT CONTEXT</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一种模式-环境上下文-在 <code>Cocoa</code> 中很难找到。 <code>NSURLCache</code> 可能是最接近的示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NSURLCache</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">setSharedURLCache</span>(<span class="title">cache</span>: <span class="title">NSURLCache</span>)</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">class</span> <span class="title">func</span> <span class="title">sharedURLCache</span>() -&gt; <span class="title">NSURLCache</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在这里我们可以将 <code>NSURLCach</code> 的任何子类设置为共享实例，然后使用静态 <code>getter</code> 访问它。 这是它与不可写的单例的主要区别。</p><blockquote><p>使用静态方法或具有某些默认值的静态可写属性来实现AMBIENT CONTEXT。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此模式仅应用于表示一些跨领域关注点的真正通用依赖项，例如日志记录，无性，访问时间和日期等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>AMBIENT CONTEXT</code> 有其自身的优势。 它使依赖关系始终可访问，并且不会污染 <code>API</code>。 非常适合跨领域的关注。 但是在其他情况下，它并不能证明其缺点。 它使依赖关系隐式化，并表示可能不是您想要的全局可变状态。</p><p>因此，如果依赖性不是真正通用的，那么我们应该考虑使用其他DI模式。</p><h1 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a><strong><em>关注点分离</em></strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会注意到，所有这些模式都非常简单，它们共享一个共同的原则-关注点分离。我们从依赖的使用者中消除了几项责任：使用什么具体实现，如何配置它以及如何管理其生命周期。这使我们可以轻松地在不同的上下文或测试中替换依赖关系，更改其生存期策略，例如使用共享或单独的实例，或更改依赖关系的构造方式。所有这些都无需改变其消费者。这使消费者不再依赖于它们，从而使它们更易于重用，扩展，开发和测试。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些模式的明显副作用是，现在我们代码的每个用户都需要提供其定义。但是他们如何得到它们？如果他们直接创建它们，那么它们将与那些依赖关系紧密地联系在一起。因此，我们只是将问题移到另一个地方。这个问题将我们带到了所谓的“合成根”（Compound Root）问题上。</p></br><h1 id="COMPOSITION-ROOT"><a href="#COMPOSITION-ROOT" class="headerlink" title="COMPOSITION ROOT"></a><strong>COMPOSITION ROOT</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>COMPOSITION ROOT</code> 是将应用程序不同层的组件连接在一起的地方。 拥有复合根的主要目的是将配置逻辑与我们其余的代码分开，并以通用的方式在定义明确的位置进行配置。 拥有一段代码，单个职责就是配置其他组件。 创建依赖关系并将其注入到构造函数或属性中只能在“合成根目录”中完成。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/di-stp1.png" alt="COMPOSITION ROOT"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 理想情况下，应用程序中应该有一个<code>COMPOSITION ROOT</code>，并且它应该靠近应用程序入口点。 就像这张图一样。 但是不必使用单个方法或类来实现。 它可以包含所需的多个类和方法，直到它们在同一组件层中在一起为止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是VIPER示例应用程序中 <code>COMPOSITION ROOT</code> 的示例实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDependencies</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        configureDependencies()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">configureDependencies</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Root Level Classes</span></span><br><span class="line">        <span class="keyword">let</span> coreDataStore = <span class="type">CoreDataStore</span>()</span><br><span class="line">        <span class="keyword">let</span> clock = <span class="type">DeviceClock</span>()</span><br><span class="line">        <span class="keyword">let</span> rootWireframe = <span class="type">RootWireframe</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// List Module Classes</span></span><br><span class="line">        <span class="keyword">let</span> listPresenter = <span class="type">ListPresenter</span>()</span><br><span class="line">        <span class="keyword">let</span> listDataManager = <span class="type">ListDataManager</span>()</span><br><span class="line">        <span class="keyword">let</span> listInteractor = <span class="type">ListInteractor</span>(dataManager: listDataManager, clock: clock)</span><br><span class="line">        ...    </span><br><span class="line">        listInteractor.output = listPresenter</span><br><span class="line">        listPresenter.listInteractor = listInteractor</span><br><span class="line">        listPresenter.listWireframe = listWireframe</span><br><span class="line">        listWireframe.addWireframe = addWireframe</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们有一些根类，仅管理窗口根视图控制器的根线框以及一些待办事项列表的单独组件，例如演示者，交互器，线框。 然后，我们将它们全部连接在一起。 它全部在一类中实现。 我们使用此类的唯一地方是应用程序委托：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> appDependencies = <span class="type">AppDependencies</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        application: UIApplication, </span></span></span><br><span class="line"><span class="function"><span class="params">        didFinishLaunchingWithOptions launchOptions: [NSObject : AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        appDependencies.installRootViewControllerIntoWindow(window!)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们首先创建依赖项类，它将配置所有组件并将它们连接在一起。 然后，我们只调用一个在窗口中设置根视图控制器的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，将通过一个调用在此处创建整个对象图，并且稍后将在运行时创建的唯一对象是视图控制器和视图。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，关于DI的文章或讨论中通常不会讨论不幸的成分根。 但这可能是依赖注入的最重要部分之一。 如果我们能够做到这一点，我们已经走了很长一段路。</p><blockquote><p>正确实现DI的最大挑战是将所有具有依赖项的类移至Composition Root。 - Mark Seeman</p></blockquote><h1 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a><strong>反模式</strong></h1><p>但是，由于在尝试正确实现某些模式时经常会发生这种情况，因此我们很容易以反模式结束。 因此，现在让我们进入黑暗的一面，看看什么是常见的DI反模式。</p><h1 id="控制怪胎"><a href="#控制怪胎" class="headerlink" title="控制怪胎"></a><strong>控制怪胎</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个是控制狂。 那就是当我们根本不使用DI的时候。 依赖项的使用者何时控制创建依赖项的方式和时间。 每当使用者在 <code>Composition Root</code> 之外的任何地方使用构造函数直接或间接获得依赖项时，都会发生这种情况。 例如，在其自己的构造函数中或仅在需要时使用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repository: <span class="type">RecipesRepository</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.repository = <span class="type">CoreDataRecipesRepository</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这是否意味着根本不允许我们使用构造函数？ 当然不是。 这取决于我们构建的依赖类型。</p><h1 id="稳定和波动的依赖"><a href="#稳定和波动的依赖" class="headerlink" title="稳定和波动的依赖"></a><strong>稳定和波动的依赖</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它们有两种-稳定的和易变的。当涉及到稳定的依赖关系时，我们不必担心直接在其使用者内部构造它们。但是我们应该避免对不稳定的依赖项这样做。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是易失性依赖项？需要某种特定环境设置（例如数据库或网络访问）的任何依赖项。实现不确定性行为的依赖项是易变的，例如，如果它们使用随机数，依赖于时间或实现加密，则它们是易变的。当我们期望依赖项将被替换或者由于它是并行开发而尚未准备就绪时，它也是易变的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易失性依赖项的症状是它们禁用了一些宽松的耦合好处。如果依赖关系不允许我们并行测试，扩展，重用或开发我们的代码，则应将其视为易变的。否则，它是一个稳定的依赖项。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，首先，我们需要了解依赖项是易失性还是​​稳定的，并在其易失性时使用“依赖项注入”模式注入它。</p><h1 id="Bastard-注入"><a href="#Bastard-注入" class="headerlink" title="Bastard 注入"></a><strong>Bastard 注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一个反模式称为 <code>Bastard</code> 注入。 当我们有让我们为测试提供依赖关系的构造函数以及在生产中使用默认实现的另一个构造函数时，就会发生这种情况。 在 <code>Swift</code> 中，我们可以使用以下示例中的默认参数轻松地做到这一点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repository: <span class="type">RecipesRepository</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(repository: <span class="type">RecipesRepository</span> = <span class="type">CoreDataRecipesRepository</span>()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.repository = repository</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从某一方面来看，这种模式提高了可测试性。 这种反模式的问题是使用默认的外部默认值-在其他模块中定义。 这使我们的代码可测试，但与另一个模块紧密耦合。 如果默认实现是本地的，则此反模式的影响会小得多。 也许最好将其重构为属性注入。 但是，当默认实现是外部实现时，我们应该使用构造函数注入，并且不要为此参数提供默认值。 相反，我们应该在 <code>“Composition Root”</code> 中提供它。 这样我们就不会失去任何灵活性，而是避免与另一个模块紧密耦合。</p><h1 id="服务定位器"><a href="#服务定位器" class="headerlink" title="服务定位器"></a><strong>服务定位器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要讨论的最后一个反模式是服务定位器。 服务定位器是某些服务的通用名称，我们可以查询以前在其中注册的不同对象。 这是最棘手的反模式，因为它可以使我们感到一切都很好。 许多开发人员甚至根本不认为它是反模式。 但是 <code>Service Locator</code> 实际上与依赖注入相反。</p><p>让我们看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locator = <span class="type">ServiceLocator</span>.sharedInstance</span><br><span class="line"></span><br><span class="line">locator.register( &#123; <span class="type">CoreDataRecipesRepository</span>() &#125;, </span><br><span class="line">                    forType: <span class="type">RecipesRepository</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repository: <span class="type">RecipesRepository</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> locator = <span class="type">ServiceLocator</span>.sharedInstance</span><br><span class="line">        <span class="keyword">self</span>.repository = locator.resolve(<span class="type">RecipesRepository</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此示例中，我们提供了一些可以使用静态属性访问的服务。然后，对于我们的依赖关系类型，我们注册一个产生一些具体实例的工厂。然后，我们在需要时向此服务询问我们的依赖关系，而不是使用构造函数或属性注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;似乎 <code>Service Locator</code> 提供了依赖注入的所有好处。它提高了可扩展性和可测试性，因为我们可以注册依赖的另​​一种实现而无需更改其使用者。它将配置与使用分开，还支持并行开发。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是它没有几个主要缺点。它使依赖项隐式而不是显式，从而隐藏了真实类的复杂性。为了能够使用此类，我们现在需要了解其内部详细信息。我们没有看到它的依赖关系，只会在运行时或通过检查其实现或文档来找到它们的依赖关系。借助服务定位器，我们的代码也与之紧密结合。这完全破坏了可重用性，并使代码的可维护性降低。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于这些原因，我倾向于认为 <code>Service Locator</code> 是一种反模式。而不是使用它，我们应该显式定义依赖项，使用 <code>DI</code> 模式注入它们，并使用 <code>Composition Root</code> 将它们连接在一起。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们总结一下到那时为止我们已经讨论过的内容。我们讨论了依赖注入用于实现松散耦合，这使我们的代码更易于维护。我们讨论了不同的 <code>DI</code> 模式，其中应该优先选择构造函数注入。我们讨论了什么是本地和外部依赖关系以及什么是稳定和易失性依赖关系。我们还讨论了应避免的常见 <code>DI</code> 反模式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这一点上，我们使用 <code>DI</code> 模式将依赖关系明确化，并将所有配置移到了 <code>Composition Root</code> 中，这已经是我们实现目标的一大步-松散耦合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们的代码还没有完全耦合。下一步是使用抽象对依赖关系进行建模。让我们记住 <code>SOLID</code> 原则之一。</p></br><h1 id="依赖反转原理（DIP）"><a href="#依赖反转原理（DIP）" class="headerlink" title="依赖反转原理（DIP）"></a><strong>依赖反转原理（DIP）</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖反转原则说，高级代码不应依赖于低级代码，它们都应依赖于抽象，而抽象不应依赖于细节。关键是该类及其依赖项应处于相同的抽象级别。如果我们有一些服务，它不应该依赖于具体的API存储库或数据库存储库，因为它们属于较低层。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，我们不应依赖通过 <code>Alamofire</code> 实现的 <code>API</code> 存储库或通过 <code>CoreData</code> 或 <code>Realm</code> 实现的数据库存储库。因为这将使我们的代码与特定的实现紧密结合。相反，我们应该依靠更高级别的抽象。服务和存储库都应依赖于该抽象。因此，较高和较低级别之间的依赖性方向是相反的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们应该遵循这一原则来松散耦合代码。依赖注入不仅是我们之前讨论的模式。它要求同时应用模式和依赖倒置原则。没有这些，我们将无法获得松耦合的所有好处。</p><blockquote><p><strong><em>DI = DI patterns + DIP</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常说，松散耦合是通过针对接口而不是针对实现进行编程来实现的。</p><blockquote><p><strong><em>编程到接口而不是实现（设计模式：可重用的面向对象软件的元素</em></strong>）</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是依赖倒置原则说它不是关于接口，而是关于抽象。 松耦合并不意味着到处都有接口或协议。 因为并非总是接口是好的和可重用的抽象。</p><blockquote><p><strong><em>编程为 <del>接口</del> 抽象</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口（或协议）只是一种我们可以用来对抽象进行建模的语言构造。 这是我们的代码与之通信的一种方式。 但这并不能保证良好和可重用的抽象，这是松散耦合的关键。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基类有时可以和协议一样好的抽象。 当然，大多数时候我们可能会使用协议对抽象进行建模。 但是在各处引入协议时要小心。 它可能是不需要的独立级别。 在Swift协议中，有时会比较麻烦。</p><blockquote><p><strong><em>Interfaces are not abstractions - Mark Seeman</em></strong> </p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/di-stp2.png" alt="Interfaces&amp;&amp;abstractions"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你在构造函数中传递依赖项或使用属性或方法注入时-您应将其作为抽象传递（同样，不必使用协议）。 如果使用 <code>ambinet</code>上下文，则相同。 它不仅是一些共享的静态实例，还应该是抽象的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，依赖注入和松散耦合不仅可以通过依赖注入模式来实现，而且可以通过依赖反转原理以及使用抽象对依赖关系进行建模来实现。</p></br><h1 id="控制和DI容器的反转"><a href="#控制和DI容器的反转" class="headerlink" title="控制和DI容器的反转"></a><strong>控制和DI容器的反转</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，使用另一种设计原则，我们还可以采取进一步的措施。该原理称为控制反转。通常将其视为框架的定义特征。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用库时，流程是“正常的”，我们从代码中调用库。但是在框架的情况下，它是倒置的-框架使用不同的回调方法调用我们的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并且我们可以将这一原理应用于使用特殊框架来管理依赖项。通常，这些框架称为依赖注入容器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有许多不同的容器可用。实际上，大多数人可能甚至不知道使用了一个DI容器。它是 <code>Interface Builder</code> 。在 <code>Interface Builder</code> 中，我们可以通过接口或基类使用 <code>@IBOutlet</code> 拖放任何 <code>NSObject</code> 并对其进行引用。与视图控制器相同。我们可以将情节提要和 <code>Xibs</code> 视为视图控制器的工厂。 <code>Interface Builder</code>是 <code>XML</code> 配置样式的示例。当然，它不是功能齐全的 <code>DI</code> 容器，也不是其主要目标，但仍然可以用于该目的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你访问 <code>CocoaPods</code> 并搜索“依赖注入”，则会发现很多不同的开源 <code>DI</code> 容器。也许甚至太多了。但是你会注意到，其中只有少数成功和流行。让我们简短地看一下其中的两个-一个来自 <code>Objective-C</code> ，另一个来自 <code>Swift</code> 。</p></br><h1 id="TYPHOON"><a href="#TYPHOON" class="headerlink" title="TYPHOON"></a><strong>TYPHOON</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个是 <strong><em><a href="http://typhoonframework.org" target="_blank" rel="noopener"><code>Typhoon</code></a></em></strong> ，它可能是 <code>Cocoa</code> 开发者中最受欢迎的DI容器。 它具有相对简单且文档齐全的 <code>API</code> ，具有许多强大的功能。 它得到了良好的维护和支持，并且仍将继续改进。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就 <code>API</code> <code>Typhoon</code> 而言，构件是称为程序集的对象。 这是此类装配接口的示例。 它看起来像一个简单的工厂。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIClientAssembly</span>: <span class="title">TyphoonAssembly</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">apiClient</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在实现中，不是返回某种类型的具体实例（如从工厂方法中返回），而是返回 <code>TyphoonDefinition</code> ，它描述了在请求实例时应如何创建该实例。 应该使用什么初始化以及使用什么参数，应该注入什么属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">apiClient</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">TyphoonDefinition</span>.withClass(<span class="type">APIClientImp</span>.<span class="keyword">self</span>) &#123; definition <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        definition.useInitializer(#selector(<span class="type">APIClientImp</span>.<span class="keyword">init</span>(session:))) &#123;</span><br><span class="line">            initializer <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            initializer.injectParameterWith(<span class="keyword">self</span>.session())</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        definition.injectProperty(<span class="string">"logger"</span>, with: <span class="keyword">self</span>.logger())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们定义 <code>API Client</code> 将使用 <code>init（session :)</code> 构造函数创建，并且其 <code>session</code> 参数将由同一程序集提供。 我们还定义了将由同样的程序集提供的 <code>logger</code> 实例注入 <code>logger</code> 属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以为组件定义不同的范围或生命周期策略。 例如，对于 <code>Singleton</code> 范围， <code>Typhoon</code> 将仅创建一个 <code>logger</code> 实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">TyphoonDefinition</span>.withClass(<span class="type">NSURLSession</span>.<span class="keyword">self</span>) &#123; definition <span class="keyword">in</span></span><br><span class="line">        definition.useInitializer(#selector(<span class="type">NSURLSession</span>.sharedSession))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">TyphoonDefinition</span>.withClass(<span class="type">ConsoleLogger</span>.<span class="keyword">self</span>) &#123; definition <span class="keyword">in</span></span><br><span class="line">        definition.scope = .<span class="type">Singleton</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要从程序集中获取某种类型的实例，我们首先将其激活，然后仅调用其接口方法。 激活后，组装方法将不返回 <code>TyphoonDefinitions</code> ，而是返回根据我们提供的规则创建的实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> assembly = <span class="type">APIClientAssembly</span>().activate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apiClient = assembly.apiClient() <span class="keyword">as</span>! <span class="type">APIClient</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使这项工作有效， <code>Typhoon</code> 大量使用了 <code>Objective-C</code> 运行时。 <code>在使用Objective-C</code> 运行时的 <code>Swift</code> 应用程序中看起来并不正确。 我们仍然可以在 <code>Swift</code> 以及 <code>Objective-C</code> 中使用 <code>Typhoon</code> 。 但是，我们将面临一些问题：</p><ul><li>需要子类 <code>NSObject</code> 并使用 <code>@objc</code> 定义协议</li><li>注射过程中调用的方法应该是动态的</li><li>需要类型转换</li><li>并非所有功能都可以在 <code>Swift</code> 中使用</li><li><code>Swift</code> 的 <code>API</code> 太冗长</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Typhoon</code> 团队最近宣布，他们开始着手于纯粹的 <code>Swift</code> 实施，而我迫不及待地想看看他们会提出什么建议。 但是现在我不会在纯 <code>Swift</code> 代码库中以当前状态使用 <code>Typhoon</code> 。 尤其是当本机解决方案已经很少时。</p><h1 id="DIP"><a href="#DIP" class="headerlink" title="DIP"></a><strong>DIP</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em><a href="https://github.com/AliSoftware/Dip" target="_blank" rel="noopener"><code>Dip</code></a></em></strong> 是其中之一。 它仅在 <code>Swift</code> 中工作，根本不需要 <code>Objective-C</code> 运行时。 实际上，它甚至没有对 <code>Foundation</code> 的引用，因此我们可以在可以使用 <code>Swift</code> 的任何平台上使用它。 它也是类型安全的，与 <code>Typhoon</code> 相比实现起来并不复杂。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 就 <code>API</code> 而言，它采用的方法对于其他平台上的 <code>DI</code> 容器而言更为传统，并遵循“注册解析”模式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们用于 <code>Typhoon</code> 的相同示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="type">DependencyContainer</span>()</span><br><span class="line"></span><br><span class="line">container.register &#123; </span><br><span class="line">    <span class="keyword">try</span> <span class="type">APIClientImp</span>(session: container.resolve()) <span class="keyword">as</span> <span class="type">APIClient</span> </span><br><span class="line">&#125;</span><br><span class="line">.resolveDependencies &#123; container, client <span class="keyword">in</span></span><br><span class="line">    client.logger = <span class="keyword">try</span> container.resolve()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.register &#123; <span class="type">NSURLSession</span>.sharedSession() <span class="keyword">as</span> <span class="type">NetworkSession</span> &#125;</span><br><span class="line">container.register(.<span class="type">Singleton</span>) &#123; <span class="type">ConsoleLogger</span>() <span class="keyword">as</span> <span class="type">Logger</span> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们将 <code>APIClientImp</code> 注册为 <code>APIClient</code> 协议的实现。 容器还将解析构造器参数，并且在创建实例时将设置 <code>logger</code> 属性。 对于会话参数容器，它将使用共享的 <code>URL</code> 会话，对于记录器，它将创建一个单例实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，当我们需要获取 <code>APIClient</code> 的实例时，我们只需调用容器的 <code>resolve</code> 方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apiClient = <span class="keyword">try</span>! container.resolve() <span class="keyword">as</span> <span class="type">APIClient</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会注意到，该 <code>API</code> 与我们在 <code>Service Locator</code> 中看到的几乎相同。 但这与 <code>API</code> 或实现无关，而与我们如何使用它有关。 如果您不想将容器用作服务定位器，请记住，只能在 <code>“Composition Root”</code> 中调用它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Dip</code> 还提供了一些很酷的功能，例如自动接线。 例如，我们可以定义要自动注入的 <code>logger</code> 属性。 容器将首先创建 <code>APIClient</code> 实例，然后使用其镜像查找 <code>logger</code> 属性并将真实实例注入其中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIClientImp</span>: <span class="title">APIClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _logger = <span class="type">Injected</span>&lt;<span class="type">Logger</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> logger: <span class="type">Logger?</span> &#123; <span class="keyword">return</span> _logger.value &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，当我们使用其构造函数注册 <code>APIClient</code> 而不是调用 <code>resolve</code> 获取 <code>NetworkSession</code> 参数时，我们只是说我们要使用传递给工厂闭包的第一个参数。 然后容器将推断出它的类型并为我们解决。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIClientImp</span>: <span class="title">APIClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">NetworkSession</span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.register &#123; <span class="type">APIClientImp</span>(session: $<span class="number">0</span>) <span class="keyword">as</span> <span class="type">APIClient</span> &#125;</span><br></pre></td></tr></table></figure><p>这样可以大大简化配置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们比较 <code>“Typhoon”</code> 和 <code>“Dip”</code> 的基本特征，我们会注意到它们共享大多数特征。 尽管它没有像 <code>Objective-C</code> 一样强大的运行时功能，但是在 <code>Swift</code> 中几乎可以实现相同的功能似乎令人惊讶。 但是，泛型和类型推断实际上是其中的重点。</p><table><thead><tr><th align="left"></th><th align="center">Typhoon</th><th align="right">Dip</th></tr></thead><tbody><tr><td align="left"><strong>Constructor, property, method injection</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Lifecycle management</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Circular dependencies</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Runtime arguments</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Named definitions</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Storyboards integration</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Auto-wiring</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Thread safety</strong></td><td align="center">✘</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Interception</strong></td><td align="center">✔︎</td><td align="right">✘</td></tr><tr><td align="left"><strong>Infrastructure</strong></td><td align="center">✔︎</td><td align="right">✘</td></tr></tbody></table></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会问，当我自己可以做时，为什么需要使用 <code>Typhoon</code> 或 <code>Dip</code> 或任何其他 <code>DI</code> 容器。 我可以建议的理由很少。 它们提供了与情节提要板的轻松集成，可以为您管理有时可能很棘手的组件生命周期，可以简化某些配置， <code>Typhoon</code> 还使用 <code>NSProxy</code> 和其他一些附加功能提供了轻松的拦截功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是请记住， <code>DI</code> 容器是可选的，并且依赖注入与使用 <code>DI</code> 容器不同。</p><blockquote><p><strong><em>DI ≠ DI Container</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在新项目中，我们可以根据需要从它开始，但是在旧代码库中，我们应该首先使用依赖注入模式，组合根和依赖反转原理对其进行重构，然后查看是否需要DI容器（在大多数情况下，回答将为“否”）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您具有复杂的配置，并且发现自己实现了一些类似 <code>DI</code> 容器的方法来简化它们，或者需要它提供的一些其他功能，那么可能会受益于使用现有的实现。但是，如果您对自己的工厂还可以的话-它的工厂很棒，请继续使用它们。不要仅仅为了使用 <code>DI</code> 容器而使用它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DI</code> 本身也是如此。对于在何处应用它以及需要解耦系统的哪些部分，要保持理性。不要尝试解决你尚未遇到的问题。也许你永远不会拥有它们，或者当你真正面对它们时，现在解决它们的方式将不合适。最后， <code>DI</code> 只是达到目的的一种手段，就像我们使用的任何其他模式或技术一样。它本身不是目标。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我想提到一些有用的资源，你可以在其中找到有关DI和一些相关主题的更多信息。</p></br><ul><li><a href="https://www.manning.com/books/dependency-injection-in-dot-net" target="_blank" rel="noopener"><code>“Dependency Injection in .Net” by Mark Seeman</code></a></li><li><a href="https://ilya.puchka.me/dependency-injection-in-swift/" target="_blank" rel="noopener"><code>Mark Seeman’s blog</code></a></li><li><a href="https://www.objc.io/issues/15-testing/dependency-injection/" target="_blank" rel="noopener"><code>objc.io Issue 15: Testing. Dependency Injection, by Jon Reid</code></a></li><li><a href="https://martinfowler.com/articles/dipInTheWild.html" target="_blank" rel="noopener"><code>“DIP in the wild”</code></a></li><li><a href="http://www.loosecouplings.com/2011/02/non-di-code-spaghetti-code.html" target="_blank" rel="noopener"><code>Non-DI code == spaghetti code?</code></a></li></ul><hr><hr><ul><li><p><a href="https://www.manning.com/books/dependency-injection-in-dot-net" target="_blank" rel="noopener"><code>&quot;Dependency Injection in .Net&quot; Mark Seeman</code></a> ↩︎</p></li><li><p><a href="https://github.com/mutualmobile/VIPER-SWIFT/blob/master/VIPER-SWIFT/Classes/AppDependencies.swift" target="_blank" rel="noopener"><code>https://github.com/mutualmobile/VIPER-SWIFT/blob/master/VIPER-SWIFT/Classes/AppDependencies.swift</code></a> ↩︎</p></li><li><p><a href="http://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/" target="_blank" rel="noopener"><code>http://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/</code></a> ↩︎</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Swift&lt;/code&gt; 为我们许多人打开了函数式编程的世界。 但这仍然是面向对象的语言，而不是功能的语言。 我们的主要工具 &lt;code&gt;Cocoa frameworks&lt;/code&gt; 是面向对象的。 因此，我们自己可能仍然会继续编写面向对象的代码。 这样做的问题是实际上很难编写设计良好的面向对象的代码。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有很多不同的设计原则，例如 &lt;code&gt;SOLID&lt;/code&gt; ，&lt;code&gt;KISS&lt;/code&gt; ，&lt;code&gt;DRY&lt;/code&gt; 等（ &lt;code&gt;YAGNI&lt;/code&gt; ， &lt;code&gt;RAP&lt;/code&gt; ，&lt;code&gt;CQS&lt;/code&gt; ），甚至更多的设计模式。 至少对于我来说，有这么多不同的原理和模式这一事实意味着，即使有可能，良好的面向对象设计也很难。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;依赖注入本身不是我刚才提到的 &lt;code&gt;SOLID&lt;/code&gt; 原则的一部分。 但这与他们所有人息息相关。 不幸的是，依赖注入的概念被许多误解所包围。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="依赖注入设计模式" scheme="http://www.xuebaonline.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Dependency Injection" scheme="http://www.xuebaonline.com/tags/Dependency-Injection/"/>
    
  </entry>
  
  <entry>
    <title>Swift依赖注入设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T08:52:06.000Z</published>
    <updated>2020-04-25T10:41:58.390Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用Swift学习依赖注入模式,使用DI编写松耦合代码。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我真的很喜欢James Shore的这句话：依赖注入意味着给对象一个实例变量，如此而已。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我看来，学习依赖注入要稍微复杂一点，但是如果你将问题弄清楚，你将意识到实现 <a href="http://www.xuebaonline.com/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/" title="DI模式">DI模式</a> 就像给对象实例变量一样简单。 别开玩笑，这确实是理所当然的，但是许多开发人员使它过于复杂，并在错误的位置使用了注入。 💉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习DI并不是关于实现细节，而是关于你将如何使用该模式。 依赖项注入有四个小变化，让我们通过使用真实的示例进行遍历，这些示例将帮助你了解何时使用依赖项注入。 现在抓住键盘！ 💻</p><a id="more"></a></br><h1 id="了解依赖注入-dependency-injection"><a href="#了解依赖注入-dependency-injection" class="headerlink" title="了解依赖注入(dependency injection)"></a><strong>了解依赖注入(dependency injection)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我之前提到的，DI是一个简单概念，你实际上并不需要外部库或框架来开始使用它。假设你有两个单独的对象。对象A要使用对象B。向你的第一个依赖发送一个消息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果将对象B硬编码为对象A，那将是不好的，因为从那时起，如果没有B，就无法使用A。现在将其扩展到约100个对象级别。如果你对此问题不采取任何措施，那么你会毫无头绪。 🍝</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，主要目标是创建尽可能多的独立对象，或者创建一些松散耦合的代码，以提高可重用性和可测试性。关注分离和去耦也是在这里使用，因为在大多数情况下，你应该从字面上将逻辑功能分离为独立的对象。 🤐</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，从理论上讲，两个对象都应该只做一件特定的事情，并且它们之间的依赖关系通常是通过通用描述符（协议）实现的，而无需对具体实例进行硬编码。为此，使用依赖注入可以提高代码质量，因为可以在不更改其他对象实现的情况下替换依赖。这对于模拟，测试，重用等很有用。</p></br><h1 id="如何在Swift中进行DI？"><a href="#如何在Swift中进行DI？" class="headerlink" title="如何在Swift中进行DI？"></a><strong>如何在Swift中进行DI？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 是一种了不起的编程语言，对协议和面向对象的原理都提供了出色的支持。 它也具有强大的功能，但是现在让我们忽略它。 依赖关系注入可以通过多种方式完成，但是在本教程中，我将只关注一些基本的，没有任何外部依赖关系注入的基础知识。 😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，让我们从一个协议开始，但这只是因为 <code>Swift</code> 不会向公众公开 <code>Encoder</code> ，但是我们在演示中需要类似的东西。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Encoder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span>&lt;T&gt;<span class="params">(<span class="number">_</span> value: T)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Encodable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">JSONEncoder</span>: <span class="title">Encoder</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PropertyListEncoder</span>: <span class="title">Encoder</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性列表和JSON编码器已经实现了此方法，我们只需要扩展对象以符合我们的全新协议即可。</p><h1 id="Custructor-注入"><a href="#Custructor-注入" class="headerlink" title="Custructor 注入"></a><strong>Custructor 注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖项注入的最常见形式是构造函数注入或基于初始化的注入。 主要的思路是通过初始化程序传递依赖关系，并将该对象存储在（私有只读/不可变）属性变量中。 这里的主要好处是，在对象创建之前，你的对象将具有所有依赖关系，以使其正常工作。 🔨</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> encoder: <span class="type">Encoder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> title</span><br><span class="line">        <span class="keyword">case</span> content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>, encoder: <span class="type">Encoder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">        <span class="keyword">self</span>.encoder = encoder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encoded</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Constructor injection"</span>, encoder: <span class="type">JSONEncoder</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encoded(), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以在构造函数中为编码器指定一个 <code>defult</code> 值，但是你应该担心恶意注入反模式！ 这意味着如果默认值来自另一个模块，则你的代码将与该模块紧密耦合。 所以请三思！ 🤔</p></br><h1 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a><strong>属性注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时很难进行初始化初始化注入，因为你的类必须从系统类继承。 如果你必须使用视图或控制器，这将使过程变得非常困难。 对于这种情况，一个好的解决方案是使用基于属性的注入设计模式。 也许你不能完全控制初始化，但是你始终可以控制属性。 唯一的缺点是，你必须先检查该属性是否已显示（已设置），然后再进行任何操作。 🤫</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> encoder: <span class="type">Encoder?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> title</span><br><span class="line">        <span class="keyword">case</span> content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encoded</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> encoder = <span class="keyword">self</span>.encoder <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Encoding is only supported with a valid encoder object."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Property injection"</span>)</span><br><span class="line">post.encoder = <span class="type">JSONEncoder</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encoded(), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>iOS</code> 框架中有很多属性注入模式，委托模式通常是这样实现的。 另外一个很大的好处是这些属性可以是可变的，因此你可以即时替换它们。 ✈️</p><h1 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a><strong>方法注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果只需要一次依赖关系，则实际上不需要将其存储为对象变量。 除了可以使用初始化参数或公开的可变属性，你还可以将依赖项作为方法参数传递，这种方法称为方法注入或基于参数的注入。 👍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(using encoder: Encoder)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Method injection"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encode(using: <span class="type">JSONEncoder</span>()), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次调用此方法时，你的依赖关系可能会有所不同，不需要从该依赖关系中保留引用，因此将仅在本地方法范围内使用它。</p></br><h1 id="上下文语境"><a href="#上下文语境" class="headerlink" title="上下文语境"></a><strong>上下文语境</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的最后一个模式非常危险。 它仅应用于与多个对象实例一起共享的通用依赖项。 日志，分析或缓存机制就是一个很好的例子。 🚧</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encoded</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">Post</span>.encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> _encoder: <span class="type">Encoder</span> = <span class="type">PropertyListEncoder</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setEncoder</span><span class="params">(<span class="number">_</span> encoder: Encoder)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._encoder = encoder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> encoder: <span class="type">Encoder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Post</span>._encoder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Ambient context"</span>)</span><br><span class="line"><span class="type">Post</span>.setEncoder(<span class="type">JSONEncoder</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encoded(), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上下文语境有一些缺点。 它可能很适合横切关注点，但会创建隐式依赖关系并表示全局可变状态。 强烈不建议这样做，你应该首先考虑其他依赖注入方式，但是有时它可能非常适合你。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用Swift学习依赖注入模式,使用DI编写松耦合代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先，我真的很喜欢James Shore的这句话：依赖注入意味着给对象一个实例变量，如此而已。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在我看来，学习依赖注入要稍微复杂一点，但是如果你将问题弄清楚，你将意识到实现 &lt;a href=&quot;http://www.xuebaonline.com/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/&quot; title=&quot;DI模式&quot;&gt;DI模式&lt;/a&gt; 就像给对象实例变量一样简单。 别开玩笑，这确实是理所当然的，但是许多开发人员使它过于复杂，并在错误的位置使用了注入。 💉&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;学习DI并不是关于实现细节，而是关于你将如何使用该模式。 依赖项注入有四个小变化，让我们通过使用真实的示例进行遍历，这些示例将帮助你了解何时使用依赖项注入。 现在抓住键盘！ 💻&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="依赖注入设计模式" scheme="http://www.xuebaonline.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift委托设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%A7%94%E6%89%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%A7%94%E6%89%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T08:39:15.000Z</published>
    <updated>2020-04-25T08:51:07.282Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;委托设计模式是通过 <code>Swift</code> 中的通用接口（协议）在两个对象之间进行通信的相对简单的方法。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="委托模式">委托模式</a>（delegation pattern）是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承。</p><a id="more"></a></br><h1 id="在Swift中实现委派"><a href="#在Swift中实现委派" class="headerlink" title="在Swift中实现委派"></a><strong>在Swift中实现委派</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你将需要一个委托协议，一个实际委托任务的委托人以及一个实现委托协议并完成 <strong>“老板”</strong> 所要求的实际工作的委托对象。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：客户端报告一个错误。 项目经理会创建一个问题，并告诉一位开发人员尽快解决问题。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的场景就是委托👆。 在某个时刻发生了事件，因此委托人（经理）使用外部资源（开发人员）使用一个公共接口（描述双方的问题）来完成某件事（修复🐛）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了演示委托在现实生活中的工作方式，我举了一个非常简单的例子。 我将使用类似的方法（因为Xcode游乐场仍然每1-5分钟冻结一次），就像我对命令模式所做的那样，但是此方法的目的几乎是完全不同的，因为我们正在谈论委托模式。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env swift</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InputDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldContinueListening: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didStartListening</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(input: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> delegate: <span class="type">InputDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate?.didStartListening()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> input = <span class="built_in">readLine</span>() <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.delegate?.didReceive(input: input)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.delegate?.shouldContinueListening ?? <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputReceiver</span>: <span class="title">InputDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldContinueListening: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didStartListening</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"👻 Please be nice and say \"hi\", if you want to leave just tell me \"bye\":"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(input: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> input &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"hi"</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"🌎 Hello world!"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"bye"</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"👋 Bye!"</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"🔍 Command not found! Please try again:"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inputHandler = <span class="type">InputHandler</span>()</span><br><span class="line"><span class="keyword">let</span> inputReceiver = <span class="type">InputReceiver</span>()</span><br><span class="line">inputHandler.delegate = inputReceiver</span><br><span class="line">inputHandler.listen()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是你可以在 <code>Swift</code> 中创建自己的委托模式的方式。 你可以想象，<code>Apple</code> 正在使用 <code>UICollectionViewDataSource</code> ，<code>UICollectionViewDelegate</code> 等在后台做同样的事情。你只需实现委托，它们将提供协议和委托人。 🤔</p></br><h1 id="弱属性，委托和类"><a href="#弱属性，委托和类" class="headerlink" title="弱属性，委托和类"></a><strong>弱属性，委托和类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存管理是非常重要的事情，因此值得一提的是，所有的类委托都应该是 <strong>弱引用</strong>，否则你将 <strong>很难管理器生命周期，易引起内存泄露</strong>，这一点必须注意。 😱</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InputDelegate</span>: <span class="title">class</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">InputDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputReceiver</span>: <span class="title">InputDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是修改后的 <code>Swift</code> 代码段，但是现在使用一个类作为委托。 你只需要稍微更改协议和委托者内部的属性即可。 如果要将类分配为委托，请始终使用弱引用该变量。 ⚠️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如代码中展示的，委托模式很容易，但是很危险。 它通过提供可以由实现委托（有时是数据源）协议的任何人使用的公共接口来帮助解耦。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;委托设计模式是通过 &lt;code&gt;Swift&lt;/code&gt; 中的通用接口（协议）在两个对象之间进行通信的相对简单的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;委托模式&quot;&gt;委托模式&lt;/a&gt;（delegation pattern）是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="委托设计模式" scheme="http://www.xuebaonline.com/tags/%E5%A7%94%E6%89%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift命令设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T08:12:58.000Z</published>
    <updated>2020-04-25T08:33:09.103Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令设计模式是众多设计模式中的一种，也比较常用。 这是用Swift编写的命令设计模板的一个小例子。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="命令模式">命令模式</a>（英语：Command pattern）是一种设计模式，它尝试以对象来代表实际行动。命令对象可以把行动(action) 及其参数封装起来，于是这些行动可以被：</p><ul><li>重复多次</li><li>取消（如果该对象有实现的话）</li><li>取消后又再重做</li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些都是现代大型应用程序所必须的功能，即“撤销”及“重复”。除此之外，可以用命令模式来实现的功能例子还有：</p><ul><li>交易行为</li><li>进度列</li><li>向导</li><li>用户界面按钮及功能表项目</li><li>线程 pool</li><li>宏收录</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想为稍后将要执行的不同操作提供一个通用界面，那么该命令模式将非常方便。 通常，它是一个对象，其中包含正确运行基础操作所需的所有信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令通常用于处理用户界面操作，创建撤消管理器或管理事务。 让我们通过使用表情符号创建命令行参数处理程序来查看 <code>Swift</code> 中的命令模式实现。 💾</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env swift</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelpCommand</span>: <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Help</span>().info()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Help</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">info</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">             🤖 Commander 🤖</span></span><br><span class="line"><span class="string">                  v1.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Available commands:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            👉 help      This command</span></span><br><span class="line"><span class="string">            👉 ls        List documents</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Bye! 👋</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListCommand</span>: <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">List</span>().homeDirectoryContents()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">homeDirectoryContents</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> documentsURL = fileManager.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask).first <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Could not open documents directory"</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> fileURLs = <span class="keyword">try</span> fileManager.contentsOfDirectory(at: documentsURL, includingPropertiesForKeys: <span class="literal">nil</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\n\t📁 Listing documents directory:\n"</span>)</span><br><span class="line">            <span class="built_in">print</span>(fileURLs.<span class="built_in">map</span> &#123; <span class="string">"\t\t💾 "</span> + $<span class="number">0</span>.lastPathComponent &#125;.joined(separator: <span class="string">"\n\n"</span>) + <span class="string">"\n"</span> )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> commands: [<span class="type">String</span>:<span class="type">Command</span>] = [:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.commands[<span class="string">"help"</span>] = <span class="type">HelpCommand</span>()</span><br><span class="line">        <span class="keyword">self</span>.commands[<span class="string">"ls"</span>] = <span class="type">ListCommand</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arguments = <span class="type">CommandLine</span>.arguments[<span class="number">1</span>...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> key = arguments.first, <span class="keyword">self</span>.commands[key] != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Usage: ./command.swift [\(self.commands.keys.joined(separator: "</span>|<span class="string">"))]"</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.commands[key]!.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">App</span>().run()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果保存此文件，只需在终端窗口中键入 <code>./file-name.swift</code> 即可运行它。 <code>Swift</code> 编译器将负责其余的工作。 ⚒</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令设计模式的实际用例：</p><ul><li>各种按钮动作</li><li>集合/表视图选择操作</li><li>在控制器之间导航</li><li>历史记录管理/撤消管理器</li><li>交易行为</li><li>进度管理</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如你所了解那样，该模式可以应用于多个区域。 苹果为此专门制作了一个名为 <code>NSInvocation</code> 的特定类，但不幸的是，由于它的动态行为，它在 <code>Swift</code> 中不可用。 没什么大不了的，你始终可以制定自己的协议和实现，在大多数情况下，你只需要一个包装基础命令逻辑的额外类即可。 😛</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;命令设计模式是众多设计模式中的一种，也比较常用。 这是用Swift编写的命令设计模板的一个小例子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;命令模式&quot;&gt;命令模式&lt;/a&gt;（英语：Command pattern）是一种设计模式，它尝试以对象来代表实际行动。命令对象可以把行动(action) 及其参数封装起来，于是这些行动可以被：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复多次&lt;/li&gt;
&lt;li&gt;取消（如果该对象有实现的话）&lt;/li&gt;
&lt;li&gt;取消后又再重做&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="命令设计模式" scheme="http://www.xuebaonline.com/tags/%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift原型设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T07:49:06.000Z</published>
    <updated>2020-04-25T08:03:11.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型设计模式用于创建基础对象的克隆，因此让我们看一些用Swift编写的实际示例。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式是 <a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="创建型模式">创建型模式</a> 的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这也是一种创新的设计模式，当你对一个对象进行非常基本的配置并且想要将这些预定义值提供（复制）给另一个对象时，这很有用。 基本上，你是从原型对象制作复制。 😊😊😊</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法有一些好处，例如，你不必继承子类，但可以单独配置复制。 这也意味着，如果你要使用原型，则可以删除一堆样板代码（配置）。 🤔</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paragraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> font: <span class="type">UIFont</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(font: <span class="type">UIFont</span> = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>),</span><br><span class="line">         color: <span class="type">UIColor</span> = .darkText,</span><br><span class="line">         text: <span class="type">String</span> = <span class="string">""</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = font</span><br><span class="line">        <span class="keyword">self</span>.color = color</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clone</span><span class="params">()</span></span> -&gt; <span class="type">Paragraph</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Paragraph</span>(font: <span class="keyword">self</span>.font, color: <span class="keyword">self</span>.color, text: <span class="keyword">self</span>.text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> base = <span class="type">Paragraph</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = base.clone()</span><br><span class="line">title.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">title.text = <span class="string">"This is the title"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = base.clone()</span><br><span class="line">first.text = <span class="string">"This is the first paragraph"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> second = base.clone()</span><br><span class="line">second.text = <span class="string">"This is the second paragraph"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上面的代码所示，实现只是几行代码。 你只需要一个默认的初始化程序和一个复制方法。 一切都将在 <code>init</code> 方法中针对原型对象进行预配置，并且你可以使用 <code>clone</code> 方法进行复制，但这时很明显……</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们再看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paragraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> font: <span class="type">UIFont</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(font: <span class="type">UIFont</span> = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>),</span><br><span class="line">         color: <span class="type">UIColor</span> = .darkText,</span><br><span class="line">         text: <span class="type">String</span> = <span class="string">""</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = font</span><br><span class="line">        <span class="keyword">self</span>.color = color</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clone</span><span class="params">()</span></span> -&gt; <span class="type">Paragraph</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Paragraph</span>(font: <span class="keyword">self</span>.font, color: <span class="keyword">self</span>.color, text: <span class="keyword">self</span>.text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> base = <span class="type">Paragraph</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = base.clone()</span><br><span class="line">title.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">title.text = <span class="string">"This is the title"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = base.clone()</span><br><span class="line">first.text = <span class="string">"This is the first paragraph"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> second = base.clone()</span><br><span class="line">second.text = <span class="string">"This is the second paragraph"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你打算获取已知对象状态的快照，则原型设计模式也很有用。 例如，在绘图应用程序中，你可以将形状类作为原型，可以开始向其添加路径，有时甚至可以从中创建快照。 你可以继续处理新对象，但这将使你能够在将来的任何时间返回到保存状态。 🎉</p><p>当你的应用程序不依赖于创建，合成和表示对象的方法时，应考虑选择它，以及至少下列各项之一：</p><ul><li>在运行时创建对象</li><li>你想避免工厂的复杂层次结构</li><li>对象只能有很少的状态</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，就是 <code>Swift</code> 中的原型设计模式。 🐿</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型设计模式用于创建基础对象的克隆，因此让我们看一些用Swift编写的实际示例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型模式是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;创建型模式&quot;&gt;创建型模式&lt;/a&gt; 的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="原型设计模式" scheme="http://www.xuebaonline.com/tags/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>比较工厂设计模式</title>
    <link href="http://www.xuebaonline.com/%E6%AF%94%E8%BE%83%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/%E6%AF%94%E8%BE%83%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T07:38:40.000Z</published>
    <updated>2020-04-25T07:49:56.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用Swift语言了解静态工厂，简单工厂，工厂方法和抽象工厂之间的区别。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为对所有工厂模式进行汇总比较会很高兴，所以这里是你应该了解的所有内容。 构造它们相对简单，在本示例中，我将使用一些用 <code>Swift</code> 编程语言编写的 <code>UIColor</code> 来向你展示基础知识。 🧙‍♂️</p><a id="more"></a><h1 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a><strong>静态工厂</strong></h1><ul><li>没有单独的工厂类别</li><li>命名静态方法来初始化对象</li><li>可以具有缓存并可以返回子类型</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> primary: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> .black &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> secondary: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> .white &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> primary = <span class="type">UIColor</span>.primary</span><br><span class="line"><span class="keyword">let</span> secondary = <span class="type">UIColor</span>.secondary</span><br></pre></td></tr></table></figure><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a><strong>简单工厂</strong></h1><ul><li>一个工厂类</li><li>枚举( <code>switch-case</code> )出其中的实例对象</li><li>封装各种代码</li><li>如果列表太大，请使用工厂方法</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> primary</span><br><span class="line">        <span class="keyword">case</span> secondary</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> style: Style)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style</span><br><span class="line">        <span class="keyword">case</span> .primary:</span><br><span class="line">            <span class="keyword">return</span> .black</span><br><span class="line">        <span class="keyword">case</span> .secondary:</span><br><span class="line">            <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primary = factory.create(.primary)</span><br><span class="line"><span class="keyword">let</span> secondary = factory.create(.secondary)</span><br></pre></td></tr></table></figure><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong>工厂方法</strong></h1><ul><li>多个（解耦的）工厂类</li><li>每个实例的工厂方法</li><li>为工厂创建一个简单的协议</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .black</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> primaryColorFactory = <span class="type">PrimaryColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> secondaryColorFactory = <span class="type">SecondaryColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primary = primaryColorFactory.create()</span><br><span class="line"><span class="keyword">let</span> secondary = secondaryColorFactory.create()</span><br></pre></td></tr></table></figure><h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a><strong>抽象工厂</strong></h1><ul><li>结合简单的工厂和工厂方法</li><li>对整个应用程序具有全局作用</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exact same factory method pattern from above</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .black</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple factory pattern from above using the factory methods</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> dark</span><br><span class="line">        <span class="keyword">case</span> light</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> theme: Theme)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> theme &#123;</span><br><span class="line">        <span class="keyword">case</span> .dark:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">PrimaryColorFactory</span>().create()</span><br><span class="line">        <span class="keyword">case</span> .light:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">SecondaryColorFactory</span>().create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">AppColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primaryColor = factory.create(.dark)</span><br><span class="line"><span class="keyword">let</span> secondaryColor = factory.create(.light)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，所有这些都是使用 <code>Swift</code> 编写的实际示例的工厂模式。 👍</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用Swift语言了解静态工厂，简单工厂，工厂方法和抽象工厂之间的区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我认为对所有工厂模式进行汇总比较会很高兴，所以这里是你应该了解的所有内容。 构造它们相对简单，在本示例中，我将使用一些用 &lt;code&gt;Swift&lt;/code&gt; 编程语言编写的 &lt;code&gt;UIColor&lt;/code&gt; 来向你展示基础知识。 🧙‍♂️&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂设计模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift抽象工厂设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T07:26:13.000Z</published>
    <updated>2020-04-25T07:39:20.965Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们将工厂方法与简单的工厂外观结合起来：这是用Swift语言编写的抽象工厂设计模式！</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82" target="_blank" rel="noopener" title="抽象工厂模式">抽象工厂模式</a>（英语：Abstract factory pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举个例子来说，比如一个抽象工厂类叫做DocumentCreator（文档创建器），此类提供创建若干种产品的接口，包括createLetter()（创建信件）和createResume()（创建简历）。其中，createLetter()返回一个Letter（信件），createResume()返回一个Resume（简历）。系统中还有一些DocumentCreator的具体实现类，包括FancyDocumentCreator和ModernDocumentCreator。这两个类对DocumentCreator的两个方法分别有不同的实现，用来创建不同的“信件”和“简历”（用FancyDocumentCreator的实例可以创建FancyLetter和FancyResume，用ModernDocumentCreator的实例可以创建ModernLetter和ModernResume）。这些具体的“信件”和“简历”类均继承自抽象类，即Letter和Resume类。客户端需要创建“信件”或“简历”时，先要得到一个合适的DocumentCreator实例，然后调用它的方法。一个工厂中创建的每个对象都是同一个主题的（“fancy”或者“modern”）。客户端程序只需要知道得到的对象是“信件”或者“简历”，而不需要知道具体的主题，因此客户端程序从抽象工厂DocumentCreator中得到了Letter或Resume类的引用，而不是具体类的对象引用。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“工厂”是创建产品（对象）的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够抵消这样的“额外工作”。</p></blockquote><h1 id="Swift抽象工厂"><a href="#Swift抽象工厂" class="headerlink" title="Swift抽象工厂"></a><strong>Swift抽象工厂</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂模式提供了一种封装一组具有共同主题的单个工厂而无需指定其具体类的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，抽象工厂可以为你创建相关对象的族。 该实现通常结合简单的工厂和工厂方法原理。 单个对象是通过工厂方法创建的，而整个对象都包装在一个“抽象”的简单工厂中。 现在检查代码！ 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service protocols</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StagingService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://dev.localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StagingServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">StagingService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// production</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://live.localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProductionService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// abstract factory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Environment</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> production</span><br><span class="line">        <span class="keyword">case</span> staging</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> env: <span class="type">Environment</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(env: <span class="type">Environment</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.env = env</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>.env &#123;</span><br><span class="line">        <span class="keyword">case</span> .production:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ProductionServiceFactory</span>().create()</span><br><span class="line">        <span class="keyword">case</span> .staging:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">StagingServiceFactory</span>().create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">AppServiceFactory</span>(env: .production)</span><br><span class="line"><span class="keyword">let</span> service = factory.create()</span><br><span class="line"><span class="built_in">print</span>(service.url)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上代码看到的，使用抽象工厂将影响整个应用程序逻辑，而工厂方法仅对本地部分产生影响。 实现可能会有所不同，例如你也可以为抽象工厂创建一个独立的协议，但是在此示例中，我想使事情尽可能简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂通常用于实现对象独立性。 例如，如果你使用通用接口用 <code>Swift</code> 编写了多个不同的 <code>SQL</code> 数据库连接器（ <code>PostgreSQL</code> ，<code>MySQL</code> 等），则可以随时使用此模式在它们之间轻松切换。 可以将类似的逻辑应用于具有类似情况的业务。 🤔</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;让我们将工厂方法与简单的工厂外观结合起来：这是用Swift语言编写的抽象工厂设计模式！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;抽象工厂模式&quot;&gt;抽象工厂模式&lt;/a&gt;（英语：Abstract factory pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="抽象工厂设计模式" scheme="http://www.xuebaonline.com/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift工厂方法设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T07:16:57.000Z</published>
    <updated>2020-04-25T07:23:43.529Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法设计模式是一种专用的非静态方法，用于隐藏对象的创建逻辑。 让我们用Swift做吧！</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p><a id="more"></a><h1 id="工厂方法只是一种非静态方法"><a href="#工厂方法只是一种非静态方法" class="headerlink" title="工厂方法只是一种非静态方法"></a><strong>工厂方法只是一种非静态方法</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面对现实，这种模式只是通常由简单协议和类支持的一种方法。 从一个非常简单的示例开始：想象一个可以为您的服务端点创建基本URL的类。 我们称之为服务工厂。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createProductionUrl</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ServiceFactory</span>()</span><br><span class="line">factory.createProductionUrl()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会想，这甚至不接近工厂方法模式，但请稍候…让我们通过为服务类创建协议以及返回 <code>URL</code> 的协议，使事情变得有些复杂。 现在，我们可以将基本生产环境url协议实现为一个单独的类，并从生产服务工厂类返回该特定实例。 只需检查一下代码即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProductionService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ProductionServiceFactory</span>()</span><br><span class="line"><span class="keyword">let</span> request = factory.create()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么我们将所有逻辑分为两类和协议？ 请相信我去耦是一件好事。 从现在开始，你可以轻松编写带有虚拟 <code>url</code> 的模拟服务。 显然，这需要一个匹配的工厂类。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些模拟实例还将实现服务协议，因此你可以以相对轻松的方式添加新类型，而无需更改原始代码库。 工厂方法解决了简单工厂模式的一个特定问题。 如果列表（ <code>switch-case</code> 的列表）太长，那么只有一个工厂就很难维护新对象。 工厂方法通过引入多个工厂对象来解决此问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工厂方法设计模式是一种专用的非静态方法，用于隐藏对象的创建逻辑。 让我们用Swift做吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂方法设计模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift中快速简单的工厂设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T05:15:16.000Z</published>
    <updated>2020-04-25T07:15:19.575Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，我们来讨论简单的工厂设计模式，该模式使用Swift以一种非常简单的方式封装对象创建。</p></blockquote><h1 id="使用-switch-case-实现简单的工厂模式"><a href="#使用-switch-case-实现简单的工厂模式" class="headerlink" title="使用 switch-case 实现简单的工厂模式"></a><strong>使用 switch-case 实现简单的工厂模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式的目标是封装一些经常变化的东西。 想象一下应用程序的调色板。 你可能必须每天根据设计师的最新习惯来更改颜色。 如果你不得不手动搜索和替换每个单独的颜色代码实例，那将给你带来极大的不便。 因此，让我们在Swift中创建一个简单的工厂，该工厂可以根据给定的样式返回颜色。 🎩</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> text</span><br><span class="line">        <span class="keyword">case</span> background</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> style: Style)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style &#123;</span><br><span class="line">        <span class="keyword">case</span> .text:</span><br><span class="line">            <span class="keyword">return</span> .black</span><br><span class="line">        <span class="keyword">case</span> .background:</span><br><span class="line">            <span class="keyword">return</span> .white</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> textColor = factory.create(.text)</span><br><span class="line"><span class="keyword">let</span> backgroundColor = factory.create(.background)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这真的很有用，尤其是涉及复杂的对象初始化过程时。 您还可以定义一个协议，并使用 <code>switch-case</code> 块返回实现所需接口的各种实例类型。 🚦</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevEnvironment</span>: <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"dev"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiveEnvironment</span>: <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"live"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnvironmentFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> dev</span><br><span class="line">        <span class="keyword">case</span> live</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> type: EnvType)</span></span> -&gt; <span class="type">Environment</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> type &#123;</span><br><span class="line">        <span class="keyword">case</span> .dev:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">DevEnvironment</span>()</span><br><span class="line">        <span class="keyword">case</span> .live:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">LiveEnvironment</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">EnvironmentFactory</span>()</span><br><span class="line"><span class="keyword">let</span> dev = factory.create(.dev)</span><br><span class="line"><span class="built_in">print</span>(dev.identifier)</span><br></pre></td></tr></table></figure><p>因此，有关简单工厂设计模式的几件事要记住：</p><ul><li>通过分离初始化和使用逻辑，有助于松耦合</li><li>它只是包装可以经常更改的东西的包装器</li><li>可以使用枚举和开关盒在Swift中实现简单的工厂</li><li>如果您计划返回不同的对象（POP🎉），请使用协议</li><li>保持简单🏭</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式将创建与实际用法分开，并将职责移至特定角色，因此，如果发生某些变化，你只需要修改工厂即可。 你可以保留所有测试，而其他所有功能则完全不受影响。 强大而简单！ 💪</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这次，我们来讨论简单的工厂设计模式，该模式使用Swift以一种非常简单的方式封装对象创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;使用-switch-case-实现简单的工厂模式&quot;&gt;&lt;a href=&quot;#使用-switch-case-实现简单的工厂模式&quot; class=&quot;headerlink&quot; title=&quot;使用 switch-case 实现简单的工厂模式&quot;&gt;&lt;/a&gt;&lt;strong&gt;使用 switch-case 实现简单的工厂模式&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这种模式的目标是封装一些经常变化的东西。 想象一下应用程序的调色板。 你可能必须每天根据设计师的最新习惯来更改颜色。 如果你不得不手动搜索和替换每个单独的颜色代码实例，那将给你带来极大的不便。 因此，让我们在Swift中创建一个简单的工厂，该工厂可以根据给定的样式返回颜色。 🎩&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="构造函数" scheme="http://www.xuebaonline.com/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="静态工厂方法" scheme="http://www.xuebaonline.com/tags/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift中构造函数与静态工厂方法的比较</title>
    <link href="http://www.xuebaonline.com/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>http://www.xuebaonline.com/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-04-25T04:19:43.000Z</published>
    <updated>2020-04-25T05:12:12.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当实例化对象时，哪个更好：构造函数还是静态工厂方法？ 我们来看一看。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我相信Joshua Bloch 在他的非常不错的书 《Effective Java》 中首先说了它：与构造函数相比，静态工厂方法是实例化对象的首选方法。 我不同意。 不仅因为我相信静态方法是纯粹的邪恶，而且主要是因为在这种特殊情况下，它们形成好的方法，使我们认为我们必须偏向使用它们。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从面向对象的角度分析推理并弄清楚其原因。这是一个具有一个主要构造函数和两个次要构造函数的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">Color</span>(<span class="type">String</span> rgb) &#123;</span><br><span class="line">        this(<span class="type">Integer</span>.parseInt(rgb, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Color</span>(int red, int green, int blue) &#123;</span><br><span class="line">        this(red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是带有三个静态工厂方法的类似类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromRGB(<span class="type">String</span> rgb) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(<span class="type">Integer</span>.parseInt(rgb, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromPalette(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromHex(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你更喜欢哪一个？</p><p>根据Joshua Bloch的说法，使用静态工厂方法而不是构造函数具有三个基本优点（实际上有四个优点，但是第四个不再适用于Java）：</p><ul><li>他们有名字。</li><li>他们可以缓存。</li><li>它们可以是子类型。</li></ul><p>我认为，如果设计错误，那么这三者都是很合理的。 它们是解决问题的好办法。 让我们一一介绍。</p><h1 id="命名存在"><a href="#命名存在" class="headerlink" title="命名存在"></a><strong>命名存在</strong></h1><p>这是使用构造函数制作 <code>red tomato</code> 颜色对象的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>这是使用静态工厂方法的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>makeFromPalette（）</code> 在语义上比新的 <code>Color（）</code> 更丰富。 如果我们将它们传递给构造函数，谁知道这三个数字意味着什么。 但是“palette”可以帮助我们立即解决所有问题。</p><p>但是，正确的解决方案是使用多态和封装，以将问题分解为几个语义丰富的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="type">Color</span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HexColor</span> <span class="title">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">HexColor</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RGBColor</span> <span class="title">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Color</span> origin;</span><br><span class="line">    <span class="type">RGBColor</span>(int red, int green, int blue) &#123;</span><br><span class="line">        this.origin = new <span class="type">HexColor</span>(</span><br><span class="line">            red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们使用类的构造函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">RGBColor</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure></br><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h1><p>假设我在应用程序中的多个位置需要一个 <code>red tomato</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// ... sometime later</span></span><br><span class="line"><span class="type">Color</span> red = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此创建两个对象，这显然是低效的，因为它们是相同的。 最好将第一个实例保留在内存中的某个位置，并在第二个调用到达时将其返回。 静态工厂方法可以解决这个问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// ... sometime later</span></span><br><span class="line"><span class="type">Color</span> red = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在 <code>Color</code> 内的某个地方，保存一个私有静态 <code>Map</code> ，其中已实例化了所有对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Map</span> &lt; <span class="type">Integer</span>, <span class="type">Color</span> &gt; <span class="type">CACHE</span> =</span><br><span class="line">        new <span class="type">HashMap</span> &lt; &gt; ();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromPalette(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">final</span> int hex = red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Color</span>.<span class="type">CACHE</span>.computeIfAbsent(</span><br><span class="line">            hex, h - &gt; new <span class="type">Color</span>(h)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是非常高效的。 对于像我们的 <code>Color</code> 这样的对象，问题可能不会那么明显，但是当对象较大时，其实例化和垃圾回收可能会浪费大量时间。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有一种面向对象的方法可以解决此问题。 我们只是介绍了一个新的类 <code>Palette</code> ，它将变成一个颜色存储区：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Palette</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Map</span> &lt; <span class="type">Integer</span>, <span class="type">Color</span> &gt; colors =</span><br><span class="line">        new <span class="type">HashMap</span> &lt; &gt; ();</span><br><span class="line">    <span class="type">Color</span> take(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">final</span> int hex = red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue;</span><br><span class="line">        <span class="keyword">return</span> this.computerIfAbsent(</span><br><span class="line">            hex, h - &gt; new <span class="type">Color</span>(h)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们一次创建一个 <code>Palette</code> 实例，并要求它在每次需要时向我们返回一种颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = palette.take(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// Later we will get the same instance:</span></span><br><span class="line"><span class="type">Color</span> red = palette.take(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p><strong>没有静态方法，没有静态属性。</strong></p></br><h1 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a><strong>子类型</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们的 <code>Color</code> 类具有 <code>lighter()</code> 方法，该方法应该将颜色转移到下一个可用的 <code>lighter</code> 上：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    protected <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(hex + <span class="number">0x111</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有时更希望通过一组可用的 <code>Pantone</code> 颜色选择下一种较浅的颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PantoneColor</span> <span class="title">extends</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">PantoneName</span> pantone;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">String</span> name) &#123;</span><br><span class="line">        this(new <span class="type">PantoneName</span>(name));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">PantoneName</span> name) &#123;</span><br><span class="line">        this.pantone = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">PantoneColor</span>(this.pantone.up());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建一个静态工厂方法，该方法将决定哪种 <code>Color</code> 实现最适合我们：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> code;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> make(int h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> new <span class="type">PantoneColor</span>(<span class="string">"19-1664 TPX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">RGBColor</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果要求使用真正的红色，我们将返回 <code>PantoneColor</code> 的一个实例。 在所有其他情况下，它只是标准的 <code>RGBColor</code> 。 该决定是通过静态工厂方法做出的。 这就是我们所说的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> color = <span class="type">Color</span>.make(<span class="number">0xBF1932</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于构造函数只能返回在其中声明的类，因此不可能对构造函数执行相同的 <code>“forking”</code> 。静态方法具有返回 <code>Color</code> 的任何子类型所需的所有自由。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是，在面向对象的世界中，我们可以而且必须以不同的方式去做。 首先，我们将 <code>Color</code> 设置为接口：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="type">Color</span> &#123;</span><br><span class="line">    <span class="type">Color</span> lighter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们将需要的构造方法移至其自己的类 <code>Colors</code> ，就像在上一个示例中所做的那样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colors</span> </span>&#123;</span><br><span class="line">    <span class="type">Color</span> make(int h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> new <span class="type">PantoneColor</span>(<span class="string">"19-1664-TPX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">RGBColor</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而且我们将使用 <code>Colors</code> 类的实例，而不是 <code>Color</code> 内部的静态方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colors.make(<span class="number">0xBF1932</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，这仍然不是真正的面向对象的思维方式，因为我们正在将决策权从它所属的对象上移开。 通过静态工厂方法 <code>make（</code>）或新类 <code>Colors</code> （实际上并不重要），我们将对象分成两部分。 第一部分是对象本身，第二部分是决策算法，它位于其他地方。<br>面向对象的设计是将逻辑放入 <code>PantoneColor</code> 类的对象中，该对象将装饰原始的RGBColor：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PantoneColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Color</span> origin;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">Color</span> color) &#123;</span><br><span class="line">        this.origin = color;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Color</span> next;</span><br><span class="line">        <span class="keyword">if</span> (this.origin.hex() == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            next = new <span class="type">RGBColor</span>(<span class="number">0xD12631</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next = this.origin.lighter();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">PantoneColor</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建一个 <code>RGBColor</code> 实例，并使用 <code>PantoneColor</code> 装饰它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> red = new <span class="type">PantoneColor</span>(</span><br><span class="line">    new <span class="type">RGBColor</span>(<span class="number">0xBF1932</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要求红色返回较浅的颜色，它返回 <code>Pantone</code> 调色板中的一种，而不是仅在 <code>RGB</code> 坐标中较浅的颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> lighter = red.lighter(); <span class="comment">// 0xD12631</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，这个示例是原始的，如果我们真的希望它适用于所有 <code>Pantone</code> 颜色，则需要进一步改进。 逻辑必须保留在类内部，而不是外部，静态工厂方法甚至其他补充类中。 当然，我在说的是属于这个特定类的逻辑。 如果与类实例的管理有关，则可以有容器和存储，就像上面的上一个示例一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总而言之，我强烈建议您不要使用静态方法，尤其是当它们要替换对象构造函数时。 通过其构造函数生成对象是任何面向对象软件中最“神圣”的时刻，请不要错过它的美丽。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当实例化对象时，哪个更好：构造函数还是静态工厂方法？ 我们来看一看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我相信Joshua Bloch 在他的非常不错的书 《Effective Java》 中首先说了它：与构造函数相比，静态工厂方法是实例化对象的首选方法。 我不同意。 不仅因为我相信静态方法是纯粹的邪恶，而且主要是因为在这种特殊情况下，它们形成好的方法，使我们认为我们必须偏向使用它们。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="构造函数" scheme="http://www.xuebaonline.com/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="静态工厂方法" scheme="http://www.xuebaonline.com/tags/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift静态工厂设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T03:48:39.000Z</published>
    <updated>2020-04-25T04:21:36.398Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，我们一起看一下有关 <a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95" target="_blank" rel="noopener" title="静态工厂设计模式">静态工厂设计模式</a> 的知识，并展示一些使用Swift编程语言的用例。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。” </p></blockquote><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个对象常常需要复杂的过程，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。</p></blockquote></br><h1 id="静态工厂模式示例"><a href="#静态工厂模式示例" class="headerlink" title="静态工厂模式示例"></a><strong>静态工厂模式示例</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象创建中的有些过程包括决定创建哪个对象、管理对象的生命周期，以及管理特定对象的创建和销毁的概念。</p></blockquote><h2 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a><strong>命名构造函数</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于静态装饰模式的第一个好处是，每个静态装饰方法都可以有一个名称。 <code>Apple</code> 在其 <code>UIColor</code> 类实现中使用此模式来创建诸如 <code>.red</code> ，<code>.yellow</code> 等的命名颜色。请注意，<code>Swift</code> 中的实现实际上不是方法，而是静态属性，它返回实际实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">TimeInterval</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> second: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> minute: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">60</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> hour: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">3_600</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> day: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">86_400</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> week: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">604_800</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果很难记住一天或一周是几秒钟，为什么不为它创建一个命名初始化器。 看到 <code>TimeInterval.week</code> 比 <code>604_800</code> 好得多。 😅</p></br><h2 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a><strong>缓存对象</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态工厂模式的下一个优点是，为了更好地使用内存，它可以支持缓存。 这样，如果你通过静态构造函数（也称为<a href="http://www.xuebaonline.com/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/" title="Swift中构造函数与静态工厂方法的比较">静态工厂方法</a>）对其进行初始化，则可以限制所创建对象的数量。 🏭</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - cache</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> cache: [<span class="type">String</span>:<span class="type">Service</span>] = [:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cached</span><span class="params">(name: String)</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">Service</span>.cache[name] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="type">Service</span>.cache[name] = <span class="type">Service</span>(named: name)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cache[name]!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - static factory</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> local: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cached(name: <span class="string">"local"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> remote: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cached(name: <span class="string">"remote"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(named name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h2 id="本地初始化范围"><a href="#本地初始化范围" class="headerlink" title="本地初始化范围"></a><strong>本地初始化范围</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于静态工厂方法的另一个好处是，你可以将类的初始化限制为私有作用域。 换句话说，只能通过静态工厂方法进行对象创建。 你只需要将 <code>init</code> 方法设为私有。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> local: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>(name: <span class="string">"local"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> remote: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>(name: <span class="string">"remote"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>请注意，您可以使用 <code>final＆static</code> 关键字限制子类化。 如果要允许子类化，则应删除 <code>final</code> 并为属性使用 <code>class</code> 关键字而不是 <code>static</code> ，这样子类可以覆盖工厂方法。</strong> 🤔</p></br><h2 id="静态返回任何数据"><a href="#静态返回任何数据" class="headerlink" title="静态返回任何数据"></a><strong>静态返回任何数据</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 静态工厂也可以返回给定对象的子类型，但是为什么我们不更进一步呢？ 你还可以从静态方法返回任何类型的数据，我知道这似乎是一种作弊，因为我不是在这里创建 <code>UIColor</code> 的实例，但是我相信在这里值得一提这个方法，静态工厂。 有时，这个技术可能非常有用。 😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span><span class="params">(with color: UIColor)</span></span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">1</span>, height: <span class="number">1</span>)</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(rect.size)</span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()!</span><br><span class="line">        context.setFillColor(color.cgColor)</span><br><span class="line">        context.fill(rect)</span><br><span class="line">        <span class="keyword">let</span> img = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> img!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> redImage: <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>.image(with: .red)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在本文中，我们一起看一下有关 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;静态工厂设计模式&quot;&gt;静态工厂设计模式&lt;/a&gt; 的知识，并展示一些使用Swift编程语言的用例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。” &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift生成器模式</title>
    <link href="http://www.xuebaonline.com/Swift%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T03:24:29.000Z</published>
    <updated>2020-04-25T03:49:52.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>了解如何在Swift中实现生成器模式，以隐藏创建具有许多单独属性的对象的复杂性。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>iOS</code> 开发中，会使用到很多设计模式，<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="生成器模式">生成器模式</a> 也叫构建器模式，我们也会经常用到。在以下的行文过程中均使用生成器模式来表述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成器模式（英：Builder Pattern）是一种设计模式，又名：建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p><a id="more"></a></br><h1 id="生成器模式如何工作？"><a href="#生成器模式如何工作？" class="headerlink" title="生成器模式如何工作？"></a><strong>生成器模式如何工作？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成器模式可以通过多种方式实现，但是如果你了解该模式的主要目标，那实际上就没有关系：</p><blockquote><p><strong>Builder设计模式的目的是将复杂对象的构造与其表示分开。</strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如果你有一个具有很多属性的对象，想隐藏初始化过程的复杂性，可以编写一个生成器并通过该生成器构造该对象。 它可以像控制整个构建过程的构建方法或外部类一样简单。 这完全取决于给定的环境。 🏗</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，我们对该设计模式有一个详细的认知，让我们来看一下使用实例和强大的 <code>Swift</code> 编程语言的生成器模式！ 💪</p></br><h1 id="简单的-Emitter-生成器"><a href="#简单的-Emitter-生成器" class="headerlink" title="简单的 Emitter 生成器"></a><strong>简单的 Emitter 生成器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SKEmitterNode</code> 是一个很好的例子。 如果要创建自定义 <code>Emitter</code> 并以编程方式设置属性（通常用于 <code>SpriteKit</code> 游戏），则像这样的 <code>Emitter</code> 生成器类可能是一个合理的解决方案。 👾</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmitterBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKEmitterNode</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> emitter = <span class="type">SKEmitterNode</span>()</span><br><span class="line">        emitter.particleTexture = <span class="type">SKTexture</span>(imageNamed: <span class="string">"MyTexture"</span>)</span><br><span class="line">        emitter.particleBirthRate = <span class="number">100</span></span><br><span class="line">        emitter.particleLifetime = <span class="number">60</span></span><br><span class="line">        emitter.particlePositionRange = <span class="type">CGVector</span>(dx: <span class="number">100</span>, dy: <span class="number">100</span>)</span><br><span class="line">        emitter.particleSpeed = <span class="number">10</span></span><br><span class="line">        emitter.particleColor = .red</span><br><span class="line">        emitter.particleColorBlendFactor = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> emitter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">EmitterBuilder</span>().build()</span><br></pre></td></tr></table></figure></br><h1 id="简单的-theme-生成器"><a href="#简单的-theme-生成器" class="headerlink" title="简单的 theme 生成器"></a><strong>简单的 theme 生成器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们远离游戏，想象一下你正在为UIKit应用程序创建一个主题引擎，该引擎具有许多自定义字体，颜色等。生成器对于构造独立主题可能很有用。 🔨</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> textColor: <span class="type">UIColor?</span></span><br><span class="line">    <span class="keyword">let</span> backgroundColor: <span class="type">UIColor?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> light</span><br><span class="line">        <span class="keyword">case</span> dark</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(<span class="number">_</span> style: Style)</span></span> -&gt; <span class="type">Theme</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style &#123;</span><br><span class="line">        <span class="keyword">case</span> .light:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Theme</span>(textColor: .black, backgroundColor: .white)</span><br><span class="line">        <span class="keyword">case</span> .dark:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Theme</span>(textColor: .white, backgroundColor: .black)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="type">ThemeBuilder</span>()</span><br><span class="line"><span class="keyword">let</span> light = builder.build(.light)</span><br><span class="line"><span class="keyword">let</span> dark = builder.build(.dark)</span><br></pre></td></tr></table></figure></br><h1 id="“Chained”-URL构建器"><a href="#“Chained”-URL构建器" class="headerlink" title="“Chained” URL构建器"></a><strong>“Chained” URL构建器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用这种方法，你可以通过多种方法配置对象，并且每个方法都将返回相同的生成器对象。 这样，您可以链接配置，并在最后一步构建最终对象实例。 ⛓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> components: <span class="type">URLComponents</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.components = <span class="type">URLComponents</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(scheme: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.scheme = scheme</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(host: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.host = host</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(port: Int)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.port = port</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(path: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> path = path</span><br><span class="line">        <span class="keyword">if</span> !path.hasPrefix(<span class="string">"/"</span>) &#123;</span><br><span class="line">            path = <span class="string">"/"</span> + path</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.components.path = path</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addQueryItem</span><span class="params">(name: String, value: String)</span></span> -&gt; <span class="type">URLBuilder</span>  &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.components.queryItems == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.components.queryItems = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.components.queryItems?.append(<span class="type">URLQueryItem</span>(name: name, value: value))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">URL?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.components.url</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URLBuilder</span>()</span><br><span class="line">    .<span class="keyword">set</span>(scheme: <span class="string">"https"</span>)</span><br><span class="line">    .<span class="keyword">set</span>(host: <span class="string">"localhost"</span>)</span><br><span class="line">    .<span class="keyword">set</span>(path: <span class="string">"api/v1"</span>)</span><br><span class="line">    .addQueryItem(name: <span class="string">"sort"</span>, value: <span class="string">"name"</span>)</span><br><span class="line">    .addQueryItem(name: <span class="string">"order"</span>, value: <span class="string">"asc"</span>)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure></br><h1 id="director-类的生成器模式"><a href="#director-类的生成器模式" class="headerlink" title="director 类的生成器模式"></a><strong>director 类的生成器模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们认识一下 <code>director</code> 实例。 使构建器与确切的配置部分解耦。 因此，举例来说，你可以制作带有圆圈的游戏，但是后来如果你改变主意并想使用正方形，那相对容易。 你只需要创建一个新的生成器，其他所有内容都可以相同。 🎬</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NodeBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">SKColor</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NodeDirector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> builder: <span class="type">NodeBuilder</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleNodeBuilder</span>: <span class="title">NodeBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">SKColor</span> = .clear</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="type">SKShapeNode</span>(circleOfRadius: <span class="keyword">self</span>.size)</span><br><span class="line">        node.name = <span class="keyword">self</span>.name</span><br><span class="line">        node.fillColor = <span class="keyword">self</span>.color</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerNodeDirector</span>: <span class="title">NodeDirector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> builder: <span class="type">NodeBuilder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(builder: <span class="type">NodeBuilder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.builder = builder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.builder.name = <span class="string">"Hello"</span></span><br><span class="line">        <span class="keyword">self</span>.builder.size = <span class="number">32</span></span><br><span class="line">        <span class="keyword">self</span>.builder.color = .red</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.builder.build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="type">CircleNodeBuilder</span>()</span><br><span class="line"><span class="keyword">let</span> director = <span class="type">PlayerNodeDirector</span>(builder: builder)</span><br><span class="line"><span class="keyword">let</span> player = director.build()</span><br></pre></td></tr></table></figure><h1 id="基于Block的构建器"><a href="#基于Block的构建器" class="headerlink" title="基于Block的构建器"></a><strong>基于Block的构建器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一种更快捷的方法是使用 <code>Block</code> 而不是生成器类来配置对象。 当然，我们可以争论这是否仍然是生成器模式…😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(block: <span class="params">(<span class="params">(UILabel)</span></span></span></span> -&gt; <span class="type">Void</span>)) -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        block(label)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> label = <span class="type">UILabel</span>.build &#123; label <span class="keyword">in</span></span><br><span class="line">    label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    label.text = <span class="string">"Hello wold!"</span></span><br><span class="line">    label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 请注意，生成器的实现可能会因具体实例而异。 有时，生成器模式与工厂模式结合在一起。 对此，几乎每个人都以不同的方式解释它，但是我认为这不是问题。 设计模式是精心设计的准则，但有时你必须这么做。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;了解如何在Swift中实现生成器模式，以隐藏创建具有许多单独属性的对象的复杂性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 &lt;code&gt;iOS&lt;/code&gt; 开发中，会使用到很多设计模式，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;生成器模式&quot;&gt;生成器模式&lt;/a&gt; 也叫构建器模式，我们也会经常用到。在以下的行文过程中均使用生成器模式来表述。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成器模式（英：Builder Pattern）是一种设计模式，又名：建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="生成器模式" scheme="http://www.xuebaonline.com/tags/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>在Swift中重构单例模式用法</title>
    <link href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/"/>
    <id>http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/</id>
    <published>2020-04-25T02:38:47.000Z</published>
    <updated>2020-04-25T03:52:42.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>清洁，模块化和可测试代码库的小技巧。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件开发中，不鼓励使用单例，并且对此表示反对，但这是有充分理由的。 它们很难测试或无法测试，并且在其他类中隐式使用它们时会纠缠你的代码库，从而使代码重用变得困难。 在大多数情况下，单例模式无非是对全局易变状态的保存。 每个人至少知道这是一个糟糕的主意。 但是，<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="单例模式">单例模式</a> 有时是不可避免和必要的错误。 我们如何以一种干净，模块化和可测试的方式将它们合并到我们的代码中？</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 </p></blockquote><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p></blockquote><h1 id="单例模式无处不在"><a href="#单例模式无处不在" class="headerlink" title="单例模式无处不在"></a><strong>单例模式无处不在</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 <code>Apple</code> 平台上，<code>Cocoa</code> 和 <code>Cocoa Touch</code> 框架中到处都有单例。 有 <code>UIApplication.shared</code>，<code>FileManager.default</code>，<code>NotificationCenter.default</code>，<code>UserDefaults.standard</code>，<code>URLSession.shared</code> 等。 设计模式甚至在 <code>Cocoa</code> 核心能力指南中都有自己的部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当你隐式引用这些（以及你自己的）单例时，将增加更改代码所需的工作量。 这也使测试代码变得困难或不可能，因为无法从使用它们的类之外更改或模拟这些单例。 这是你在iOS应用中都会看到的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentUser = <span class="type">CurrentUserManager</span>.shared.user</span><br><span class="line">        <span class="keyword">if</span> currentUser != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// do something with current user</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mySetting = <span class="type">UserDefaults</span>.standard.bool(forKey: <span class="string">"mySetting"</span>)</span><br><span class="line">        <span class="keyword">if</span> mySetting &#123;</span><br><span class="line">            <span class="comment">// do something with setting</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">URLSession</span>.shared.dataTask(with: <span class="type">URL</span>(string: <span class="string">"http://someResource"</span>)!) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// handle response</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这就是我所说 隐式引用 的意思-你只需在类中直接使用单例。 我们可以做得更好。 在Swift中，有一种轻量级，简便且影响小的方式来改善这一点。 Swift也使其使用起来更加优雅。</p><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简而言之，答案是 <a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener" title="依赖注入"><strong>依赖注入</strong></a> 。 该原则表明你应该设计类和函数，以使所有输入都是显式的。 如果你重构上面的代码片段以使用依赖项注入，它将看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> userManager: <span class="type">CurrentUserManager</span></span><br><span class="line">    <span class="keyword">let</span> defaults: <span class="type">UserDefaults</span></span><br><span class="line">    <span class="keyword">let</span> urlSession: <span class="type">URLSession</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userManager: <span class="type">CurrentUserManager</span>, defaults: <span class="type">UserDefaults</span>, urlSession: <span class="type">URLSession</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">        <span class="keyword">self</span>.defaults = defaults</span><br><span class="line">        <span class="keyword">self</span>.urlSession = urlSession</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentUser = userManager.user</span><br><span class="line">        <span class="keyword">if</span> currentUser != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// do something with current user</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mySetting = defaults.bool(forKey: <span class="string">"mySetting"</span>)</span><br><span class="line">        <span class="keyword">if</span> mySetting &#123;</span><br><span class="line">            <span class="comment">// do something with setting</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        urlSession.dataTask(with: <span class="type">URL</span>(string: <span class="string">"http://someResource"</span>)!) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// handle response</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此类不再隐式（或显式）依赖于任何单例。 它显式依赖于 <code>CurrentUserManager</code>， <code>UserDefaults</code> 和 <code>URLSession</code> ，但是有关这些依赖项的任何内容均表示它们是单例。 这个细节不再重要，但是功能保持不变。 视图控制器仅知道这些对象的实例存在。 在需要使用该对象时，你可以传递单例。 同样，从类的角度来看，此细节无关紧要。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>(userManager: .shared, defaults: .standard, urlSession: .shared)</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p><strong>特别提示：<code>Swift</code> 类型推断在这里起作用。 除了编写 <code>URLSession.shared</code>，您还可以编写 <code>.shared</code> 。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你需要提供其他默认值（例如，如果你需要与<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW6" target="_blank" rel="noopener" title="应用组内共享数据">应用组共享数据</a>），则更改起来很容易。 实际上，你不必更改此类中的任何代码。 而不传递 <code>UserDefaults.standard</code>，而是传递 <code>UserDefaults（suiteName：“ com.myApp”）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，在单元测试中，你现在可以传递这些类的其他实例。 在Swift中无法进行真正的模拟，但是有一些解决方法。 这取决于您要如何构造代码。 你可以为 <code>CurrentUserManager</code> 使用协议，然后可以在测试中“模拟”该协议。 你可以为 <code>UserDefaults</code> 提供构造的方法类进行测试。 你可以将 <code>URLSession</code> 设置为可选，并在测试中传递 <code>nil</code>。</p><h1 id="重构陷阱"><a href="#重构陷阱" class="headerlink" title="重构陷阱"></a><strong>重构陷阱</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能对这个想法很感兴趣，现在你想解开并解放陷入困境的代码库。尽管依赖注入是理想的选择，并且可以为你提供更纯净的对象模型，但是实现它通常很困难。更重要的是，在首次编写代码时，很少会设计出适应这种情况的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们上面重构的内容现在更具模块化和可测试性-但确实存在问题。 <code>MyViewController</code> 的初始值设定项曾经是空的 <code>（init（））</code> ，但现在需要三个参数。每个调用位置都必须更改。构造此方法的干净而正确的方法是将实例从上到下或从以前的视图控制器传递到此实例。这将需要将数据从对象图的根传递到所有子类。特别是在iOS中，当你将数据从视图控制器传递到视图控制器时，这可能会引起很多麻烦。尤其是传统代码库将难以立即实现如此大的更改。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大多数类（尤其是视图控制器）的初始化程序都需要更改。当你意识到必须重构整个应用程序时，这种更改变得异常困难。要么一切都将被破坏，要么仅某些类将被更新以进行依赖注入，而其他一些类将继续隐式引用单例。这种不一致可能在将来引起问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在复杂、大型的旧版代码库中，这样的重构可能根本不可行-至少不能同时进行，而且也不能没有回归。因此，你可能会争辩说，你根本不应该重构并忍受这种情况。然后需要几个月或几年的时间你您必须支持多个用户-现在在实现切换帐户时 <code>CurrentUserManager</code> 无法正常工作。你如何应对？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一种更为先进的方式，也有一种从一开始就设计你要使用的类以适应下一次此类变化的方法。</p><h1 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a><strong>默认参数值</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最喜欢的Swift功能之一是默认参数值。 它们非常有用，可以为你的代码带来很大的灵活性。 使用默认参数，你可以解决上述问题，而不必担心依赖注入问题，也不会在代码库中引入过多的复杂性。 也许你的应用程序实际上只有一个用户，所以实现所有这种依赖注入是不必要的开销。</p><p>你可以给单例设置默认参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userManager: <span class="type">CurrentUserManager</span> = .shared, defaults: <span class="type">UserDefaults</span> = .standard, urlSession: <span class="type">URLSession</span> = .shared) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">        <span class="keyword">self</span>.defaults = defaults</span><br><span class="line">        <span class="keyword">self</span>.urlSession = urlSession</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，从方法调用的角度来看，初始化程序没有改变。 但是类本身存在很大的差异，它现在使用依赖项注入，不再引用单例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>()</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你从此更改中学到了什么？你可以使用此模式重构每个类，而无需更新任何调用的地方。语义上或功能上都没有改变。但是，你的类也在使用依赖注入。他们只是在内部使用实例。你可以如上所述测试它们并维护一个灵活的模块化API，同时公共接口保持不变。本质上，你可以继续在代码库中工作，就好像什么都没有改变一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有时间传入自定义非空参数，你可以执行此操作而无需更改任何类。你只需要更新调用的位置即可。此外，如果你决定使用成熟的依赖关系注入并从上至下传递每个单个依赖关系，则只需删除默认参数并从上方传递依赖关系。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要，你甚至可以选择加入或选择退出任何默认值。在以下示例中，我们提供了自定义 <code>UserDefaults</code>，但保留了 <code>CurrentUserManager</code> 和 <code>URLSession</code> 的默认参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appGroupDefaults = <span class="type">UserDefaults</span>(suiteName: <span class="string">"com.myApp"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>(defaults: appGroupDefaults)</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></bar><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 使这种“部分”依赖注入变得很方便实用。通过为类添加新属性和带有默认值的初始化参数，你可以使你的代码具有更大的模块化和可测试性，而不必重构，也不必完全使用成熟的依赖项注入。如果从一开始就设计这样的类，那么你会发现自己写出 <code>bug</code> 的概率降低了很多-当你遇到 <code>bug</code> 是，将更容易定位和解决。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 除了此处的简单示例（类，结构，枚举，函数）之外，你还可以将这些概念和设计应用于代码的所有区域。 <code>Swift</code> 中的每个函数都可以采用默认参数值。通过花一些时间来思考未来可能发生的变化，我们可以创建可以轻松适应变化的类型和功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 构建和设计好的软件意味着编写<strong>易于更改</strong>但<strong>难以破解的代码</strong>。这就是依赖项注入的动机，而 <code>Swift</code> 的默认参数可以帮助你快速，轻松且优雅地实现这一目标。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;清洁，模块化和可测试代码库的小技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在软件开发中，不鼓励使用单例，并且对此表示反对，但这是有充分理由的。 它们很难测试或无法测试，并且在其他类中隐式使用它们时会纠缠你的代码库，从而使代码重用变得困难。 在大多数情况下，单例模式无非是对全局易变状态的保存。 每个人至少知道这是一个糟糕的主意。 但是，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;单例模式&quot;&gt;单例模式&lt;/a&gt; 有时是不可避免和必要的错误。 我们如何以一种干净，模块化和可测试的方式将它们合并到我们的代码中？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="单例模式" scheme="http://www.xuebaonline.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift单例模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T02:13:37.000Z</published>
    <updated>2020-04-25T03:13:50.738Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Singleto</code>n 是有史以来最受争议的设计模式。了解在 <code>iOS</code> 项目中使用 <code>Swift</code> 单例类的正确方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每个人都在批评的单例模式，大多数人都将其称为反模式。但是单例模式到底是什么，为什么这么差呢？</p><a id="more"></a><h1 id="Singleton-是什么"><a href="#Singleton-是什么" class="headerlink" title="Singleton 是什么?"></a><strong>Singleton 是什么?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于简单，这是一种非常流行且普遍采用的模式。在整个应用程序生命周期中，单例类只能有一个实例。单个实例只能通过静态属性访问，并且初始化后的对象通常在全局范围内共享。这就像一个全局变量。 🌏</p><h1 id="全局变量和状态"><a href="#全局变量和状态" class="headerlink" title="全局变量和状态"></a><strong>全局变量和状态</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式的声誉很差，因为他们共享全局可变的状态。即使在经验丰富的开发人员圈子中，始终会担心使用 <code>global</code> 关键字。全局状态和变量是副作用的温床。可以从程序的任何位置访问全局变量，因此使用它们的类将变为有状态，不安全，紧密耦合且难以调试。出于明显的原因，通过这种方式与对象共享状态不是一个好习惯。 🤮</p><h1 id="Singleton-的副作用"><a href="#Singleton-的副作用" class="headerlink" title="Singleton 的副作用"></a><strong>Singleton 的副作用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你应该尽可能确定范围和隔离变量，并最大程度地减少代码的状态性。这将消除副作用，使您的代码更安全地使用。考虑以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// method is written by someone else</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    global = x</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">global = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> result = square(<span class="number">5</span>)</span><br><span class="line">result += global <span class="comment">//we assume that global is 1</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">//wtf 30 it should be 26</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>square</code> 方法由其他人编写，由于某种原因，他们希望将输入存储在相同的全局变量中。现在，当您调用该函数时，除非您查看他的代码，否则您将一无所获。想象一下，在一个由多个代码作者编写的具有大量oop类的项目中的此类问题……GOOD LUCK! 🐛🐛🐛</p><h1 id="单例对象的生命周期"><a href="#单例对象的生命周期" class="headerlink" title="单例对象的生命周期"></a><strong>单例对象的生命周期</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 单例创建一次并永久存在，它们的工作几乎就像全局变量一样，这就是为什么你必须格外小心。你应该仅使用在应用程序整个生命周期内都能维持的单例状态来管理这些状态。例如，特定于用户的会话通常是不好的做法，你应该重新考虑设计。另外，默认情况下，Swift也不是线程安全的，因此，如果你使用单例，则还必须为多线程问题做好准备。但是，如果它们因此造成问题，我们难道不应该完全避免它们吗？答案是不。 🚫</p><h1 id="我们应该在什么时候使用单例类"><a href="#我们应该在什么时候使用单例类" class="headerlink" title="我们应该在什么时候使用单例类"></a><strong>我们应该在什么时候使用单例类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>UIApplication</code> 很可能是单例的，因为应该只有一个应用程序实例，并且该实例应该一直存在，直到你将其关闭为止。这就是单例的完美例子。另一个用例可以是 <code>Logger</code> 类。使用单例是安全的，因为无论记录器是否打开，你的应用程序的行为都不会有所不同。没有其他人会拥有或管理记录器，并且你只会将信息传递到记录器中，因此状态不会混乱。<strong>结论：对于单例模式的使用，控制台或记录器类是完全可以接受的方案。</strong> 👏</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Console</span>.<span class="keyword">default</span>.notice(<span class="string">"Hello I'm a singleton!"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apple 框架中有很多“单一”（并非一切都是真正的单例对象）用例，这是一个简短列表，因此您可以从中获得一些启发：</p><ul><li>HTTPCookieStorage.shared</li><li>URLCredentialStorage.shared</li><li>URLSessionConfiguration.default</li><li>URLSession.shared</li><li>FileManager.default</li><li>Bundle.main</li><li>UserDefaults.standard</li><li>NotificationCenter.default</li><li>UIScreen.main</li><li>UIDevice.current</li><li>UIApplication.shared</li><li>MPMusicPlayerController.systemMusicPlayer</li><li>GKLocalPlayer.localPlayer（）</li><li>SKPaymentQueue.default（）</li><li>WCSession.default</li><li>CKContainer.default（）</li><li>etc</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经看到许多管理器类以单例形式实现，例如网络，位置或核心数据管理器，但是这些对象通常不应该是单例，仅仅是因为它可以是多个单例。 💩</p><p><strong>单例模式可能非常有用，但应谨慎使用。</strong></p><p>如果要将某个类变成单例，请问自己以下问题：</p><ul><li>还有其他任何东西拥有，管理或负责吗？</li><li>是否将只有一个实例？</li><li>它会是一个全局状态变量吗？</li><li>我真的应该使用全局共享对象吗？</li><li>是否应该贯穿整个应用程序生命周期？</li><li>有其他选择吗？</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果以上所有内容的答案都是肯定的，那么您可以“安全地”使用单例或全局变量来存储数据。 🎉🎉🎉</p><h1 id="如何使用Swift创建一个单例"><a href="#如何使用Swift创建一个单例" class="headerlink" title="如何使用Swift创建一个单例?"></a><strong>如何使用Swift创建一个单例?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建单例对象确实很容易，但是在应用此设计模式之前，请务必三思而后行，并考虑其他选择。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Singleton</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// don't forget to make this private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> singleton = <span class="type">Singleton</span>.shared</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，我总是创建一个特定的单例对象，称为App。通过这种方式，我可以将与应用程序相关的全局状态属性连接到那个单例中。命名约定也有助于关联和理解其中的内容。 💡</p><h1 id="如何消除单例"><a href="#如何消除单例" class="headerlink" title="如何消除单例?"></a><strong>如何消除单例?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果还有其他方法，则应在大约90％的情况下使用该方法。单例模式最常见的替代解决方案是依赖注入。首先，你应该将单例方法抽象为协议，然后，如果仍然需要，可以将其用作默认实现。现在，您可以将单例或<a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/" title="重构对象">重构的对象</a>注入正确的位置。这样，你的代码就可以使用协议的模拟对象进行测试，甚至可以忽略单例本身。 😎</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">DataCompletionBlock</span> = (<span class="type">Data?</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. abstract away the required functions</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. make your "singleton" conform to the protocol</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSession</span>: <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> task = <span class="keyword">self</span>.dataTask(with: request) &#123; data, <span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            completionHandler(data)</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> session: <span class="type">Session</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. using dependency injection with the "singleton" object</span></span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">Session</span> = <span class="type">URLSession</span>.shared) &#123;</span><br><span class="line">        <span class="keyword">self</span>.session = session</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(<span class="number">_</span> request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.session.make(request: request, completionHandler: completionHandler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. create mock object</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockedSession</span>: <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        completionHandler(<span class="string">"Mocked data response"</span>.data(using: .utf8))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. write your tests</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> api = <span class="type">ApiService</span>(session: <span class="type">MockedSession</span>())</span><br><span class="line">    <span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)!)</span><br><span class="line">    api.load(request) &#123; data <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(data: data!, encoding: .utf8)!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像你看到的，单例模式非常容易实现，但是很难决定其应用程序形式。我并不是说这是一种反模式，因为显然不是这样，但是如果你打算使用单例模式，请当心。 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Singleto&lt;/code&gt;n 是有史以来最受争议的设计模式。了解在 &lt;code&gt;iOS&lt;/code&gt; 项目中使用 &lt;code&gt;Swift&lt;/code&gt; 单例类的正确方法。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 每个人都在批评的单例模式，大多数人都将其称为反模式。但是单例模式到底是什么，为什么这么差呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="单例模式" scheme="http://www.xuebaonline.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>NSCODER和SWIFT初始化</title>
    <link href="http://www.xuebaonline.com/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://www.xuebaonline.com/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2020-04-25T01:36:42.000Z</published>
    <updated>2020-04-25T01:53:24.699Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您正在使用 <code>Swift</code> 并想对实现 <code>NSCoding</code> 的东西进行子类化（例如 <code>UIView</code>，<code>UIViewController</code> 等），则可能会遇到麻烦的情况。即，<code>NSCoding</code> 协议需要 <code>init(coder：aDecoder)</code> 初始化程序，这意味着如果你为超类重写了指定的初始化程序，则需要实现该初始化程序。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那就好了，但是 <code>Swift</code> 在确保对类的所有属性进行超级严格的调用之前，都要确保在 <code>init()</code> 中分配了一个值。这意味着，如果您想提供自己的初始化程序，则无法执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    name = <span class="string">"Bar"</span></span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle:<span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>init（coder :)</code> 初始值设定项未设置 <code>name</code> 属性，因此不会进行编译。你可以在两个初始值设定项中都重复初始化和设置名称，但是当你在init中进行了很多工作时，这很糟糕（如果希望尽可能避免使用可选属性，则应该这样做）。</p><p>在 Objective-C 中，如果要在多个 <code>init</code> 方法之间共享初始化逻辑，则只需定义一个通用的 <strong>“setup”</strong> 方法即可执行所有共享的东西，并从两个初始化器中调用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype) <span class="keyword">init</span> &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span> <span class="keyword">self</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype) initWithCoder:(<span class="type">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span> <span class="keyword">self</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) setup &#123;</span><br><span class="line">  <span class="keyword">self</span>.name = @<span class="string">"Foo"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  这种方式不会立即就创建出你想要的对象。问题在于，在这两个初始化程序中，我们都在调用    <code>[super init]</code> 之前，先给 <code>self.name</code> 分配了一个值，但这在 <code>Swift</code> 语法中是不可行的。我们也不能将对 <code>self.setup</code> 的调用移到对 <code>super.init（）</code> 的调用之上，因为在类通过调用 <code>super.init（）</code> 完全初始化之后，才允许您引用 <code>self</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  那么，如何将这只鸡从鸡蛋中取出并放到盘子上呢？好吧，我们要等到初始化后才能对 <code>self</code> 调用方法，但是只要我们从 <strong>“convienience”</strong> 初始化程序中调用它，就可以调用另一个 <code>init</code> 。仅通过示例进行解释可能更容易：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> coder: <span class="type">NSCoder?</span> = <span class="literal">nil</span>) &#123;</span><br><span class="line">    name = <span class="string">"Bar"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> coder = coder &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle:<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(coder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在指定的初始化程序中添加了一个可选的 <code>NSCoder</code> 参数，并将其默认设置为 <code>nil</code> ，因此我们仍然可以像以前一样在没有任何参数的情况下调用它。但是，现在已将<code>NSCoding</code> 协议中要求的 <code>init（coder :)</code> 初始值设定项标记为<strong>convienience</strong>，这意味着它可以调用指定的初始值设定项并传入编码器。</p><p>在指定的 <code>init</code> 中，我们检查 <code>coder</code> 是否为非 <code>nil</code> （如果让coder = conditional为条件），如果是，则调用 <code>super.init（coder :)</code> 。如果为 <code>nil</code>，我们将执行本来应该做的事情，并调用 <code>super.init（nibName：nil，bundle：nil）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，编译器很高兴在调用 <code>super.init（）</code> 之前为属性分配值，并且可以将初始化逻辑放在一个地方。如果要在情节提要中使用 <code>ViewController</code> ，则框架将调用init（coder :)，如果要以编程方式创建一个，则可以说 <code>let fooVC = FooViewController（）</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果您正在使用 &lt;code&gt;Swift&lt;/code&gt; 并想对实现 &lt;code&gt;NSCoding&lt;/code&gt; 的东西进行子类化（例如 &lt;code&gt;UIView&lt;/code&gt;，&lt;code&gt;UIViewController&lt;/code&gt; 等），则可能会遇到麻烦的情况。即，&lt;code&gt;NSCoding&lt;/code&gt; 协议需要 &lt;code&gt;init(coder：aDecoder)&lt;/code&gt; 初始化程序，这意味着如果你为超类重写了指定的初始化程序，则需要实现该初始化程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>UIKit初始化模式</title>
    <link href="http://www.xuebaonline.com/UIKit%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/UIKit%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T00:05:14.000Z</published>
    <updated>2020-04-25T02:12:15.476Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>了解UIKit中两个常用类的初始化过程。了解UIViewcontroller和UIView初始化模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIKit</code> 是在iOS开发过程中必须也是使用频次最高的一个类库，里面包含了许多与用户直接交互的控件比如：<code>UIView</code>, <code>UITableView</code>, <code>UIScrollView</code> 等。在收到用户交互的设计图之后，我们要合理的使用这些控件，就能编写出交互良好的应用。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了类库中包含的基础控件之外，我们也能够对控件根据业务需要进行整合，也就是设计出一套适用于本公司的组件，提高开发速度。</p><h1 id="UIViewController-初始化"><a href="#UIViewController-初始化" class="headerlink" title="UIViewController 初始化"></a><strong>UIViewController 初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，<code>UIViewController</code> 的初始化非常简单。如果要完全控制，则只需要重写一些方法。这取决于你使用何种方式调用 <code>init</code> ，如果你使用一个 <code>storyboard</code> 初始化控制器，那么 <a href="http://www.xuebaonline.com/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/" title="NSCODER和SWIFT初始化">init(coder)</a> 是你所需要的。如果你尝试从外部 <code>nib</code> 文件启动控制器，则将调用 <code>init（nib，bundle）</code> 。你还有第三个选择，你可以通过代码以编程方式初始化控制器。简而言之，为了进行合理的初始化过程，这是你必须要做的。</p></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍两种 <code>UIViewControllers</code> 的初始化模式，第一种只是一个常见的init函数，在每种情况下都可以调用该函数来初始化控制器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(nibName nibNameOrNil: <span class="type">String?</span>, bundle nibBundleOrNil: <span class="type">Bundle?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do your stuff here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以在之后的子类中隐藏 <code>init（nib，bundle）</code> 和 <code>init（coder）</code> 方法。在子类中不必重写 <code>init（nib，bundle）</code>，并且可以将 <code>init（coder）</code> 标记为默认初始化程序。这个似乎是有点棘手的解决方案，使用起来不是很方便，但确实可以完成 <code>ViewController</code> 的初始化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do your stuff here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFutureViewController</span>: <span class="title">ViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> vc = <span class="type">MyFutureViewController</span>()</span><br></pre></td></tr></table></figure><hr></br><h1 id="UIView-初始化"><a href="#UIView-初始化" class="headerlink" title="UIView 初始化"></a><strong>UIView 初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通常为 <code>UIView</code> 创建一个通用的初始化程序，以使初始化过程更加轻松，使用起来更加方便。还会在该初始值设定项方法中将 <code>translate autoresizing mask</code> 属性设置为 <code>false</code> ，因为它是2017年，没有人再使用 <code>spring＆struts</code> 了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用自动布局助手也很不错，如果你想从nib文件中初始化视图，那么有一些便利的方法也很好。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(autolayout: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(autolayout: Bool = <span class="literal">true</span>)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _self = <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">let</span> view  = _self <span class="keyword">as</span> <span class="type">UIView</span></span><br><span class="line">        view.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">        <span class="keyword">return</span> _self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">createFromNib</span><span class="params">(owner: <span class="keyword">Any</span>? = <span class="literal">nil</span>, options: [AnyHashable: <span class="keyword">Any</span>]? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Bundle</span>.main.loadNibNamed(<span class="type">String</span>(describing: <span class="keyword">self</span>), owner: owner, options: options)?.last <span class="keyword">as</span>! <span class="type">UIView</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> view = <span class="type">UIView</span>(autolayout: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>使用这些代码片段，为所有 <code>UIKit</code> 类维护一个合理的初始化过程确实很容易，因为其中大多数都是从这两个 “主要” 类派生的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;了解UIKit中两个常用类的初始化过程。了解UIViewcontroller和UIView初始化模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;UIKit&lt;/code&gt; 是在iOS开发过程中必须也是使用频次最高的一个类库，里面包含了许多与用户直接交互的控件比如：&lt;code&gt;UIView&lt;/code&gt;, &lt;code&gt;UITableView&lt;/code&gt;, &lt;code&gt;UIScrollView&lt;/code&gt; 等。在收到用户交互的设计图之后，我们要合理的使用这些控件，就能编写出交互良好的应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>后端实践三:Ubuntu18.04安装Vapor4.0</title>
    <link href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89:Ubuntu18.04%E5%AE%89%E8%A3%85Vapor4.0/"/>
    <id>http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89:Ubuntu18.04%E5%AE%89%E8%A3%85Vapor4.0/</id>
    <published>2020-04-17T08:52:46.000Z</published>
    <updated>2020-04-25T01:11:06.910Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文章《<a href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/" title="后端实践二:Ubuntu18.04安装最新版Swift5.2">后端实践二:Ubuntu18.04安装最新版Swift5.2</a>》可以在 Ubuntu18.04 的服务器上顺利安装最新版本的 <code>Swift</code> 。我们参照 <a href="https://docs.vapor.codes/3.0/install/ubuntu/" target="_blank" rel="noopener">官网文档</a> 安装 <code>Vapor4.0</code> 的开发环境。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官网上的文档跟开发维护的速度有一定的版本误差，所以现在在官网上看到的安装方法是针对 <code>Vapor(&gt;3.0 &amp;&amp; &lt; 4.0)</code> 的版本。由于版本间差异比较大，在实践过程中，只会关注到 <code>Vapor(&gt;=4.0)</code> 以上版本的新特性。在创建工程和引入依赖库的过程中也会出现微小的差别，我们在后续的实践中会总结到。</p></blockquote><h1 id="验证-Swift-安装"><a href="#验证-Swift-安装" class="headerlink" title="验证 Swift 安装"></a><strong>验证 Swift 安装</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过访问 <code>Swift.org</code>，可以得到一份如何在 <code>Linux</code> 上安装 <code>Swift</code> 的文档。我们完成对 <code>Swift</code> 的安装之后，在终端中输入如下命令：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><a id="more"></a><p>如果在终端中输出如下信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Apple</span> <span class="type">Swift</span> version <span class="number">4.1</span>.<span class="number">0</span> (swiftlang-<span class="number">900.0</span>.<span class="number">69.2</span> clang-<span class="number">900.0</span>.<span class="number">38</span>)</span><br><span class="line"><span class="type">Target</span>: x86_64-apple-macosx10.<span class="number">9</span></span><br></pre></td></tr></table></figure><p>那么标识我们在 <code>Linux</code> 上成功安装 <code>Swift</code>。</p><h1 id="安装-Vapor-Toolbox"><a href="#安装-Vapor-Toolbox" class="headerlink" title="安装 Vapor Toolbox"></a><strong>安装 Vapor Toolbox</strong></h1><p>在 <code>Vapor 4.0</code> 发布之前，在 <code>Linux</code> 上安装，只需要在终端中敲入如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL apt.vapor.sh -o apt.vapor.sh</span><br></pre></td></tr></table></figure><p>这个执行安装的命令已经被废弃。</p><h2 id="Toolbox-源代码"><a href="#Toolbox-源代码" class="headerlink" title="Toolbox 源代码"></a><code>Toolbox</code> 源代码</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于之后的版本中，不在将该文件托管至软件源，所以我们在安装时需要做出如下操作获取到 <code>Toolbox</code> 源代码到本地文件夹中：</p><p>下载 <code>Toolbox</code> 源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vapor/toolbox.git</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-1stp.png" alt="Toolbox"></p><h2 id="编译-Vapor-可执行文件"><a href="#编译-Vapor-可执行文件" class="headerlink" title="编译 Vapor 可执行文件"></a>编译 <code>Vapor</code> 可执行文件</h2><p>进入到 <code>Toolbox</code> 工程的根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> toolbox/</span><br></pre></td></tr></table></figure><p>编译 <code>Toolbox</code>  发布版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build -<span class="built_in">c</span> release</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于获取的源代码中缺少部分文件，期间或存在报错发现 <code>Toolbox</code> 中没有 <code>LinuxMain.swift</code> 文件在 <code>Tests</code> 文件夹中，这时我们进入到 <code>XCTest</code> 文件夹中。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-2stp.png" alt="Vapor"></p><p>创建 <code>LinuxMain.swift</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch LinuxMain.swift</span><br></pre></td></tr></table></figure><p>编辑 <code>LinuxMain.swift</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim LinuxMain.swift</span><br></pre></td></tr></table></figure><p>向 <code>LinuxMain.swift</code> 文件中添加测试代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> AppTests</span><br><span class="line"></span><br><span class="line"><span class="type">XCTMain</span>([testCase(<span class="type">AppTests</span>.allTests)])</span><br></pre></td></tr></table></figure><p>保存修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq!</span><br></pre></td></tr></table></figure><p>重新执行如下命令，完成编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build -c release</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-3stp.png" alt="Vapor"></p><p>找到编译成功的 <code>Vapor</code> 文件</p><blockquote><p>执行完 <code>build</code> 命令之后，会在输出的文件中生成一个可执行的二进制文件。</p></blockquote><p>查找 <code>Vapor</code> 所在的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name vapor</span><br></pre></td></tr></table></figure><blockquote><p>这时会看到输出一个类似如下的文件夹 <code>.build/x86_64-unknown-linux/release/vapor</code> ,这个文件夹里就是我们要使用到的文件 <code>Vapor</code> 。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-4stp.png" alt="Vapor"></p><p>配置 <code>Vapor</code> 的环境变量</p><p>将包含可执行文件 <code>Vapor</code> 的文件目录添加在 <code>PATH</code> 中。</p><p>配置 <code>Vapor</code> 环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp vapor /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>验证是否配置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vapor --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-5stp.png" alt="Vaporhelp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此 <code>Vapor 4.0</code> 的环境配置已经完成。由于 <code>3.0</code> 和 <code>4.0</code> 版本差异比较大，在配置方面也有差异。在创建项目时更需要加上 <code>branch=4</code> 等。后续会加入：创建第一个 <code>Hello World</code> 工程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过文章《&lt;a href=&quot;http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/&quot; title=&quot;后端实践二:Ubuntu18.04安装最新版Swift5.2&quot;&gt;后端实践二:Ubuntu18.04安装最新版Swift5.2&lt;/a&gt;》可以在 Ubuntu18.04 的服务器上顺利安装最新版本的 &lt;code&gt;Swift&lt;/code&gt; 。我们参照 &lt;a href=&quot;https://docs.vapor.codes/3.0/install/ubuntu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网文档&lt;/a&gt; 安装 &lt;code&gt;Vapor4.0&lt;/code&gt; 的开发环境。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;官网上的文档跟开发维护的速度有一定的版本误差，所以现在在官网上看到的安装方法是针对 &lt;code&gt;Vapor(&amp;gt;3.0 &amp;amp;&amp;amp; &amp;lt; 4.0)&lt;/code&gt; 的版本。由于版本间差异比较大，在实践过程中，只会关注到 &lt;code&gt;Vapor(&amp;gt;=4.0)&lt;/code&gt; 以上版本的新特性。在创建工程和引入依赖库的过程中也会出现微小的差别，我们在后续的实践中会总结到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;验证-Swift-安装&quot;&gt;&lt;a href=&quot;#验证-Swift-安装&quot; class=&quot;headerlink&quot; title=&quot;验证 Swift 安装&quot;&gt;&lt;/a&gt;&lt;strong&gt;验证 Swift 安装&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们通过访问 &lt;code&gt;Swift.org&lt;/code&gt;，可以得到一份如何在 &lt;code&gt;Linux&lt;/code&gt; 上安装 &lt;code&gt;Swift&lt;/code&gt; 的文档。我们完成对 &lt;code&gt;Swift&lt;/code&gt; 的安装之后，在终端中输入如下命令：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/categories/Server/"/>
    
      <category term="Vapor4.0" scheme="http://www.xuebaonline.com/categories/Vapor4-0/"/>
    
      <category term="Ubuntu18.04" scheme="http://www.xuebaonline.com/categories/Ubuntu18-04/"/>
    
      <category term="Swift5.2" scheme="http://www.xuebaonline.com/categories/Swift5-2/"/>
    
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="Server" scheme="http://www.xuebaonline.com/tags/Server/"/>
    
      <category term="Ubuntu" scheme="http://www.xuebaonline.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>后端实践二:Ubuntu18.04安装最新版Swift5.2</title>
    <link href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/"/>
    <id>http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/</id>
    <published>2020-04-17T06:51:16.000Z</published>
    <updated>2020-04-25T01:06:57.345Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文章《<a href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/" title="后端实践一:开发环境搭建VMware下安装Ubuntu18.04">后端实践一:开发环境搭建VMware下安装Ubuntu18.04</a>》可以完成在  <code>mac</code> 上搭建起可用的 <code>Ubuntu 18.04</code> 的服务器。接下来我们要在此基础上完善 <code>Vapor 4.0</code> 的开发环境。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ubuntu 18.04 安装 Swift 5.2.2 ，可在 Vapor 官网的引导完成。这篇文章就是讲解如何完成在 Ubuntu 上安装最新版本 Swift，构建出一个强大的云端服务器。</p></blockquote><h1 id="Ubuntu-系统环境搭建"><a href="#Ubuntu-系统环境搭建" class="headerlink" title="Ubuntu 系统环境搭建"></a><strong><code>Ubuntu</code> 系统环境搭建</strong></h1><h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里使用的SecureCRT作为终端连接服务器，也可以使用 <code>iTerm2</code> 连接服务器。</p></blockquote><a id="more"></a><p>使用 <code>SecureCRT</code> 提供的远程登录功能连接 <code>Ubuntu</code> 服务器的配置信息：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-1stop.png" alt="SecureCRT"></p><p>使用 <code>SecureCRT</code> 终端使用系统自带的远程登录功能连接 <code>Ubuntu</code> 服务器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-2stp.png" alt="使用SecureCRT"></p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-3stp.png" alt="使用SecureCRT"></p><p>使用 <code>iTerm2</code> 终端使用系统自带的远程登录功能连接Ubuntu 服务器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-4stp.png" alt="iTerm2"></p><p>查看当前服务器系统版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><blockquote><p>Swift 依赖一些三方类库。</p></blockquote><p>必须安装的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install clang libicu-dev -y</span><br><span class="line">sudo apt-get install libcurl3 libpython2.7 libpython2.7-dev</span><br></pre></td></tr></table></figure><h2 id="安装-Swift"><a href="#安装-Swift" class="headerlink" title="安装 Swift"></a>安装 <code>Swift</code></h2><p>在 <a href="https://swift.org/download/#releases" target="_blank" rel="noopener">Swift.org</a> 查找我们要安装的Swift对应版本的Toolchain，复制下载链接。</p><blockquote><p>在写这篇文章时最新版的Swift是v5.2.2。</p></blockquote><p>找到对应系统以及对应版本<a href="https://swift.org/builds/swift-5.2.2-release/ubuntu1804/swift-5.2.2-RELEASE/swift-5.2.2-RELEASE-ubuntu18.04.tar.gz" target="_blank" rel="noopener">下载链接</a>：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-5stp.png" alt="下载链接"></p><p>可以采用两种下载方式：</p><ul><li>在本机上使用上方链接，下载 <code>Toolchain</code> ，上传到 <code>Ubuntu</code> 服务器上，完成后续安装；</li><li>在 <code>Ubuntu</code> 上使用 <code>wget url</code> 的方式直接在服务器上安装。</li></ul><p>接下来 使用  <code>wget url</code> 下载 <code>swift</code> 安装包，并解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://swift.org/builds/swift-5.2.2-release/ubuntu1804/swift-5.2.2-RELEASE/swift-5.2.2-RELEASE-ubuntu18.04.tar.gz</span><br></pre></td></tr></table></figure><p>解压 <code>swift</code> 到文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf swift-5.2.2-RELEASE-ubuntu18.04.tar.gz</span><br></pre></td></tr></table></figure><p>将解压的文件保存在 <code>share</code> 目录下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv swift-5.2.2-RELEASE-ubuntu18.04 /usr/share/swift</span><br></pre></td></tr></table></figure><h2 id="配置-Swift-环境变量"><a href="#配置-Swift-环境变量" class="headerlink" title="配置 Swift 环境变量"></a>配置 <code>Swift</code> 环境变量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成以上操作即完成了 <code>swift</code> 的的安装，为了更方便的使用 <code>Swift</code> ，需要配置其在全局任意目录下可使用。</p><p>配置 <code>Swift</code> 环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=/usr/share/swift/usr/bin:<span class="variable">$PATH</span>"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h2><p>检查当前系统的 <code>Swift</code> 版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift -version</span><br></pre></td></tr></table></figure><ul><li>如果出现 <code>Command &#39;swift&#39; not found ...</code> 该提示，关闭连接终端，重新连接服务器，再次执行上述命令。</li></ul><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-6stp.png" alt="installSuccess"></p><h1 id="运行-Swift-程序"><a href="#运行-Swift-程序" class="headerlink" title="运行 Swift 程序"></a><strong>运行 <code>Swift</code> 程序</strong></h1><h2 id="在终端运行程序，简单测试环境是否达建成功。"><a href="#在终端运行程序，简单测试环境是否达建成功。" class="headerlink" title="在终端运行程序，简单测试环境是否达建成功。"></a>在终端运行程序，简单测试环境是否达建成功。</h2><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift</span><br></pre></td></tr></table></figure><p>此时进入到终端界面。</p><p>编辑一段 <code>Swift</code> 程序代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>, b = <span class="number">13</span>, <span class="built_in">c</span> = a + b</span><br></pre></td></tr></table></figure><p>在终端输入以下命令退出编辑模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:exit</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-7stp.png" alt="Swift"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成 <code>Swift</code> 在 <code>Ubuntu</code> 环境下的配置，接下来可以配置 <code>Vapor 4.0</code> 的开发环境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过文章《&lt;a href=&quot;http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/&quot; title=&quot;后端实践一:开发环境搭建VMware下安装Ubuntu18.04&quot;&gt;后端实践一:开发环境搭建VMware下安装Ubuntu18.04&lt;/a&gt;》可以完成在  &lt;code&gt;mac&lt;/code&gt; 上搭建起可用的 &lt;code&gt;Ubuntu 18.04&lt;/code&gt; 的服务器。接下来我们要在此基础上完善 &lt;code&gt;Vapor 4.0&lt;/code&gt; 的开发环境。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Ubuntu 18.04 安装 Swift 5.2.2 ，可在 Vapor 官网的引导完成。这篇文章就是讲解如何完成在 Ubuntu 上安装最新版本 Swift，构建出一个强大的云端服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Ubuntu-系统环境搭建&quot;&gt;&lt;a href=&quot;#Ubuntu-系统环境搭建&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 系统环境搭建&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;code&gt;Ubuntu&lt;/code&gt; 系统环境搭建&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;连接服务器&quot;&gt;&lt;a href=&quot;#连接服务器&quot; class=&quot;headerlink&quot; title=&quot;连接服务器&quot;&gt;&lt;/a&gt;连接服务器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这里使用的SecureCRT作为终端连接服务器，也可以使用 &lt;code&gt;iTerm2&lt;/code&gt; 连接服务器。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/categories/Server/"/>
    
      <category term="Vapor4.0" scheme="http://www.xuebaonline.com/categories/Vapor4-0/"/>
    
      <category term="Ubuntu18.04" scheme="http://www.xuebaonline.com/categories/Ubuntu18-04/"/>
    
      <category term="Swift5.2" scheme="http://www.xuebaonline.com/categories/Swift5-2/"/>
    
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="Server" scheme="http://www.xuebaonline.com/tags/Server/"/>
    
      <category term="Ubuntu" scheme="http://www.xuebaonline.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04替换国内源</title>
    <link href="http://www.xuebaonline.com/Ubuntu18.04%E6%9B%BF%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"/>
    <id>http://www.xuebaonline.com/Ubuntu18.04%E6%9B%BF%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</id>
    <published>2020-04-17T04:58:13.000Z</published>
    <updated>2020-04-25T01:10:03.748Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再国内使用国外的软件源普遍会比较慢，但是国内也有很多的软件源可供选择。在修改软件源之前，查看系统软件源版本：</p><p><strong><em>查看版本：</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -c</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong><em>备份系统源配置文件：</em></strong></p><p>在修改之前要对系统的配置文件做好备份，这是个好习惯。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h1 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a><strong>阿里源</strong></h1><h2 id="更新源的配置文件"><a href="#更新源的配置文件" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multivers</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a><strong>中科大源</strong></h1><h2 id="更新源的配置文件-1"><a href="#更新源的配置文件-1" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="163源"><a href="#163源" class="headerlink" title="163源"></a><strong>163源</strong></h1><h2 id="更新源的配置文件-2"><a href="#更新源的配置文件-2" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-2"><a href="#更新-2" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a><strong>清华源</strong></h1><h2 id="更新源的配置文件-3"><a href="#更新源的配置文件-3" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-3"><a href="#更新-3" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Ubuntu18.04的配置中，更新了系统的软件源，国内源推荐使用清华源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;再国内使用国外的软件源普遍会比较慢，但是国内也有很多的软件源可供选择。在修改软件源之前，查看系统软件源版本：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;查看版本：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lsb_release -c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/categories/Server/"/>
    
      <category term="Vapor4.0" scheme="http://www.xuebaonline.com/categories/Vapor4-0/"/>
    
      <category term="Ubuntu18.04" scheme="http://www.xuebaonline.com/categories/Ubuntu18-04/"/>
    
      <category term="Ubuntu软件源" scheme="http://www.xuebaonline.com/categories/Ubuntu%E8%BD%AF%E4%BB%B6%E6%BA%90/"/>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/tags/Server/"/>
    
      <category term="Ubuntu" scheme="http://www.xuebaonline.com/tags/Ubuntu/"/>
    
      <category term="VMware" scheme="http://www.xuebaonline.com/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>后端实践一:开发环境搭建VMware下安装Ubuntu18.04</title>
    <link href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/"/>
    <id>http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/</id>
    <published>2020-04-17T01:17:13.000Z</published>
    <updated>2020-04-25T01:08:41.946Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Mac</code> 环境下使用 <code>VMware</code> 安装 <code>Ubuntu 18.04</code> 的主要目的是用于对后端开发框架：<code>Vapor 4.0</code> 的实践。由于 <code>Vapor 4.0</code> 框架支持 <code>MacOS</code> 和 <code>Ubuntu</code> ，所以实践时间，以使用 <code>Ubuntu</code> 为主。</p><a id="more"></a><blockquote><p>VMware  的下载和安装这里就不在赘述，自行下载安装即可。</p></blockquote><h1 id="下载-Ubuntu-的-ISO-文件"><a href="#下载-Ubuntu-的-ISO-文件" class="headerlink" title="下载 Ubuntu 的 ISO 文件"></a><strong>下载 <code>Ubuntu</code> 的 <code>ISO</code> 文件</strong></h1><h2 id="国内有很多镜像源，这里选用网易的镜像源。"><a href="#国内有很多镜像源，这里选用网易的镜像源。" class="headerlink" title="国内有很多镜像源，这里选用网易的镜像源。"></a>国内有很多镜像源，这里选用<a href="http://mirrors.163.com/ubuntu-releases/" target="_blank" rel="noopener" title="网易的镜像源">网易的镜像源</a>。</h2><p>这里建议使用 <code>Ubuntu 18.04</code> 版本，按照图示下载即可。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/163-source.png" alt="网易镜像源"></p><p>本次安装中使用的镜像为：<a href="http://mirrors.163.com/ubuntu-releases/18.04/ubuntu-18.04.4-live-server-amd64.iso" target="_blank" rel="noopener" title="Ubuntu18.04"><code>ubuntu-18.04.4-live-server-amd64.iso</code></a>。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/Ubuntu-1804-server.png" alt="Ubuntu1804"></p><h1 id="VMware-虚拟机配置"><a href="#VMware-虚拟机配置" class="headerlink" title="VMware 虚拟机配置"></a><strong><code>VMware</code> 虚拟机配置</strong></h1><p>在使用 <code>VMware</code> 安装 <code>Ubuntu</code>虚拟机时，按照引导安装即可。</p><h2 id="打开-VMware-软件"><a href="#打开-VMware-软件" class="headerlink" title="打开 VMware 软件"></a>打开 <code>VMware</code> 软件</h2><blockquote><p>根据提示我们在准备安装时，选择<strong>自定义安装</strong>。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-1stp.png" alt="自定义安装"></p><h2 id="选择虚拟的操作系统"><a href="#选择虚拟的操作系统" class="headerlink" title="选择虚拟的操作系统"></a>选择虚拟的操作系统</h2><p>这里选择 <code>Linux</code> -&gt; <code>Ubuntu</code> 64位。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们下载的系统就是 <code>Ubuntu 18.04</code> 64位。还有很重要的一点，因为安装这个操作系统的目的是作为 <code>Vapor 4.0</code> 的服务器，所以在选用操作系统时，我们不需要图形界面。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-2stp.png" alt="选择操作系统类型"></p><h2 id="选择固件类型"><a href="#选择固件类型" class="headerlink" title="选择固件类型"></a>选择固件类型</h2><p>选择固件类型其实就是选择磁盘引导方式。</p><blockquote><p>相对这两种方式进一步了解，可自行查资料。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-3stp.png" alt="选择引导方式"></p><h2 id="选择虚拟磁盘"><a href="#选择虚拟磁盘" class="headerlink" title="选择虚拟磁盘"></a>选择虚拟磁盘</h2><p>选择虚拟磁盘为虚拟操作系统在本机上开辟操作磁盘的空间。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为不会再虚拟机上做比较大的文件操作， <code>20G</code> 的磁盘空间已经够用。在开辟磁盘空间时，开辟的是空间使用上限，在虚拟操作系统文件所占用的空间以实际使用为准，并不是开辟了多少，就是用多少。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-4stp.png" alt="选择虚拟磁盘"></p><h2 id="完成配置"><a href="#完成配置" class="headerlink" title="完成配置"></a>完成配置</h2><p>点击继续即可完成虚拟机配置。</p><blockquote><p>虚拟机配置采用 <code>VMWare</code> 提供的默认配置即可，不用过多的操作。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-5stp.png" alt="完成配置"></p><h2 id="保存虚拟机文件"><a href="#保存虚拟机文件" class="headerlink" title="保存虚拟机文件"></a>保存虚拟机文件</h2><p>点击保存将虚拟机文件保存在默认文件夹中。</p><blockquote><p>文件的保存位置可以是默认位置，也可以是自定义的位置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-6stp.png" alt="完成配置"></p><h1 id="安装-Ubuntu-18-04"><a href="#安装-Ubuntu-18-04" class="headerlink" title="安装 Ubuntu 18.04"></a><strong>安装 <code>Ubuntu 18.04</code></strong></h1><p>在使用 <code>VMware</code> 完成对 <code>Ubuntu</code>虚拟机配置时，即会进入系统的安装界面。</p><h2 id="开启-CD-DVD-，并选取镜像"><a href="#开启-CD-DVD-，并选取镜像" class="headerlink" title="开启 CD/DVD ，并选取镜像"></a>开启 <code>CD/DVD</code> ，并选取镜像</h2><p>在完成对虚拟机配置之后，进入到引导界面，开启 <code>CD/DVD</code> ，并加载镜像。</p><blockquote><p>因为启动时未加载系统镜像，所在期初会出现引导出错的问题。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-7stp.png" alt="引导失败"></p><blockquote><p>开启CD/DVD，并加载镜像。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-8stp.png" alt="加载镜像"></p><h2 id="选择系统引导语言"><a href="#选择系统引导语言" class="headerlink" title="选择系统引导语言"></a>选择系统引导语言</h2><p>镜像加载完成，选择系统引导语言的默认语言。</p><blockquote><p>安装系统的提示比较简单，也见名知意，所以在安装的全过程，我们均会使用英文完成安装。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-9stp.png" alt="选择系统引导语言"></p><h2 id="选择系统语言"><a href="#选择系统语言" class="headerlink" title="选择系统语言"></a>选择系统语言</h2><p>镜像加载完成，选择操作系统的默认语言。</p><blockquote><p>因为是作为服务器使用，为了避免以后因为字符编码上造成不必要的麻烦，这里选择英文。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-10stp.png" alt="选择系统语言"></p><h2 id="选择键盘布局"><a href="#选择键盘布局" class="headerlink" title="选择键盘布局"></a>选择键盘布局</h2><p>选择键盘布局默认选择英文键盘。</p><blockquote><p>键盘布局选择英文，大部分的笔记本、台式电脑键盘采用英文布局。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-11stp.png" alt="选择键盘布局"></p><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>网络设置主要是设置操作系统的网络链接方式，这里采用默认跟随本机网络变化。</p><blockquote><p>因为是在虚拟软件中使用操作系统，网络配置采用默认配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-12stp.png" alt="网络设置"></p><h2 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h2><p>系统需要一个代理接口联网，默认网络链接走本机。</p><blockquote><p>代理网络可以设置链接特定的网络中，比如公司内网。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-13stp.png" alt="代理设置"></p><h2 id="设置系统镜像"><a href="#设置系统镜像" class="headerlink" title="设置系统镜像"></a>设置系统镜像</h2><p>这里的镜像是软件包的镜像源。</p><blockquote><p>在安装的过程中使用默认的软件包镜像源，后续推荐替换的国内镜像。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-14stp.png" alt="设置系统镜像"></p><h2 id="设置文件系统"><a href="#设置文件系统" class="headerlink" title="设置文件系统"></a>设置文件系统</h2><p>文件系统设置采用默认设置。</p><blockquote><p>选取使用整个磁盘空间。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-15stp.png" alt="设置文件系统"></p><blockquote><p>文件系统采用系统推荐的默认方式配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-16stp.png" alt="设置文件系统"></p><blockquote><p>文件系统分区采用默认的分区方式。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-17stp.png" alt="设置文件系统"></p><h2 id="个人信息设置"><a href="#个人信息设置" class="headerlink" title="个人信息设置"></a>个人信息设置</h2><p>个人信息设置主要是设置 <code>root</code> 账户密码，服务器名称，登录账户及密码。</p><blockquote><p>完成设置信息之后，建议对该信息进行备份保存。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-18stp.png" alt="个人信息设置"></p><h2 id="OpenSSH-设置"><a href="#OpenSSH-设置" class="headerlink" title="OpenSSH 设置"></a><code>OpenSSH</code> 设置</h2><p>OpenSSH可是系统支持远程登录，远程操作。</p><blockquote><p>建议安装，在以后的操作中会比较方便，远程操作软件推荐 <code>SecureCRT</code> 。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-19stp.png" alt="OpenSSH设置"></p><h2 id="服务软件"><a href="#服务软件" class="headerlink" title="服务软件"></a>服务软件</h2><p>这里可以选择性的安装。</p><blockquote><p>针对自己想用的软件进行安装，建议用到什么安装什么。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-20stp.png" alt="服务软件一览"></p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>完成所有的配置之后，系统机会进入安装界面，安装过程比较久。</p><blockquote><p>系统安装时间会长一些，具体看各自电脑配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-21stp.png" alt="安装系统"></p><h1 id="登录-Ubuntu18-04"><a href="#登录-Ubuntu18-04" class="headerlink" title="登录 Ubuntu18.04"></a><strong>登录 <code>Ubuntu18.04</code></strong></h1><p>完成安装之后，系统就会进入终端，输入用户名和密码进入系统。</p><h2 id="输入用户信息"><a href="#输入用户信息" class="headerlink" title="输入用户信息"></a>输入用户信息</h2><p>输入用户名和密码，按照提示输入。</p><blockquote><p>在 <code>2.9</code> 中的用户信息，就是需要的登录信息。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-22stp.png" alt="输入用户信息"></p><blockquote><p>成功进入 <code>Ubuntu</code> 系统中。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-23stp.png" alt="输入用户信息"></p><h1 id="Ubuntu-18-04-个性化配置"><a href="#Ubuntu-18-04-个性化配置" class="headerlink" title="Ubuntu 18.04 个性化配置"></a><strong><code>Ubuntu 18.04</code> 个性化配置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后续会加入一些实用的小技巧：国内的软件源，远程登录、配置数据库、安装 <code>Vapor 4.0</code> 开发环境等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Mac&lt;/code&gt; 环境下使用 &lt;code&gt;VMware&lt;/code&gt; 安装 &lt;code&gt;Ubuntu 18.04&lt;/code&gt; 的主要目的是用于对后端开发框架：&lt;code&gt;Vapor 4.0&lt;/code&gt; 的实践。由于 &lt;code&gt;Vapor 4.0&lt;/code&gt; 框架支持 &lt;code&gt;MacOS&lt;/code&gt; 和 &lt;code&gt;Ubuntu&lt;/code&gt; ，所以实践时间，以使用 &lt;code&gt;Ubuntu&lt;/code&gt; 为主。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/categories/Server/"/>
    
      <category term="Vapor4.0" scheme="http://www.xuebaonline.com/categories/Vapor4-0/"/>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/tags/Server/"/>
    
      <category term="Ubuntu" scheme="http://www.xuebaonline.com/tags/Ubuntu/"/>
    
      <category term="VMware" scheme="http://www.xuebaonline.com/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.xuebaonline.com/hello-world/"/>
    <id>http://www.xuebaonline.com/hello-world/</id>
    <published>2020-04-14T03:41:23.589Z</published>
    <updated>2020-04-18T13:42:59.685Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://www.xuebaonline.com/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
