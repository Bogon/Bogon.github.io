<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Char&#39;s Blog</title>
  
  <subtitle>如切如磋，如琢如磨。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xuebaonline.com/"/>
  <updated>2020-04-28T12:08:21.828Z</updated>
  <id>http://www.xuebaonline.com/</id>
  
  <author>
    <name>Char</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VIPER体系结构：我们的最佳实践，像老板一样构建应用程序</title>
    <link href="http://www.xuebaonline.com/VIPER%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E5%83%8F%E8%80%81%E6%9D%BF%E4%B8%80%E6%A0%B7%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.xuebaonline.com/VIPER%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E5%83%8F%E8%80%81%E6%9D%BF%E4%B8%80%E6%A0%B7%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-04-28T09:06:59.000Z</published>
    <updated>2020-04-28T12:08:21.828Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Cheesecake Labs</code> 的开发团队使用 <code>VIPER</code> 进行 <code>iOS</code> 和 <code>Android</code> 移动应用程序开发已有一年多了，我们喜欢这种简洁的架构！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文使用 <code>VIPER</code> 样板中的代码示例总结了关于 <code>VIPER</code> 架构的最佳实践。 这里使用的代码示例在 <code>Swift</code> 中，但是提到的所有概念都可以应用于使用 <code>Java</code> 或 <code>Kotlin</code> 用 <code>VIPER</code> 开发的 <code>Android</code> 项目。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您仍然需要熟悉基本的 <code>VIPER</code> 概念以及该体系结构如何使您的代码更具组织性和可伸缩性，建议您阅读以下文章：</p><ul><li><a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52" target="_blank" rel="noopener"><strong><em><code>最常见的移动应用程序设计模式之间的比较</code></em></strong></a></li><li><a href="https://www.ckl.io/blog/ios-project-architecture-using-viper" target="_blank" rel="noopener"><strong><em><code>在iOS上使用VIPER的第一步的绝佳指南</code></em></strong></a></li><li><a href="https://cheesecakelabs.com/blog/using-viper-architecture-android/" target="_blank" rel="noopener"><strong><em><code>适用于Android的VIPER架构上的独特内容</code></em></strong></a></li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，您准备好学习有关如何使用 <code>VIPER</code> 构建应用程序的最佳实践吗？</p></br><h1 id="真正的VIPER模块解耦的项目结构"><a href="#真正的VIPER模块解耦的项目结构" class="headerlink" title="真正的VIPER模块解耦的项目结构"></a><strong>真正的VIPER模块解耦的项目结构</strong></h1><p><img src="http://q8wtfza4q.bkt.clouddn.com/va-stp1.png" alt="真正的VIPER模块解耦的项目结构" title="VIPER的iOS文件夹结构"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您会看到，我们将所有 <code>VIPER</code> 的模块保持尽可能的分离，从而使我们免于在项目扩展或规格更改时遇到的麻烦。 如果删除其中任何一个，则仅在引用该模型的路由器上会出现一些错误，而在 <code>Views</code> , <code>Presenters</code>, <code>Interactors</code>,<code>Data Managers</code> , <code>Entity</code> 上则不会。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;帮助您真正分离模块的一个关键点是将所有实体保留在单独的文件夹中，将它们链接到项目本身而不是任何特定模块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，使用数据管理器执行 <code>API</code> 请求和操作本地数据库是增加项目组织的一种极好的方法，但需要注意以下几点：</p><ul><li>将数据管理器保留在 <code>Utils</code> 文件夹中，将其与模块分开；</li><li>将类似实体（例如用户，个人档案和公司档案）的方法分组到一个 <code>Data Manager</code> 中，以避免为每个实体创建一个 <code>Data Manager</code> 的开销；</li><li>将每个 <code>Data Manager</code> 分为 <code>Local</code> 和 <code>API</code> 类，以使 <code>Interactors</code> 上的代码更具可读性：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainSearchInteractor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Properties</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">MainSearchInteractorOutput?</span></span><br><span class="line">    <span class="keyword">var</span> apiDataManager = <span class="type">ProfileApiDataManager</span>()</span><br><span class="line">    <span class="keyword">var</span> localDataManager = <span class="type">ProfileLocalDataManager</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainSearchInteractor</span>: <span class="title">MainSearchUseCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Code below show how interactor get data from API and then saves it on local DB with separate data managers</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">searchProducts</span><span class="params">(with searchTerm: String, onPage page: Int)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.apiDataManager.searchProducts(with: searchTerm, forPage: page) &#123; (products) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> products = products &#123;</span><br><span class="line">                <span class="keyword">self</span>.localDataManager.updateSearchResultFavorites(products) &#123; (products) <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">self</span>.output?.onFetchProductsSuccess(<span class="type">Array</span>(products), shouldAppend: page != <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.output?.onFetchProductsSuccess(<span class="literal">nil</span>, shouldAppend: page != <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="生成VIPER的文件"><a href="#生成VIPER的文件" class="headerlink" title="生成VIPER的文件"></a><strong>生成VIPER的文件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您已经使用 <code>VIPER</code> 进行过开发，那么您将无法创建一个简单的屏幕（在导航栏上具有三个标签）所需的所有 <code>20+</code> 个 <code>Swift</code> 文件。 但是，隧道尽头有一个亮点：这个令人惊叹的 <code>Xcode插件</code> ，只需单击三下，即可自动为一个模块生成所有 <code>VIPER</code> 文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您认为太多，请使用 <a href="https://github.com/strongself/Generamba" target="_blank" rel="noopener"><strong><em><code>Generamba</code></em></strong></a> ： <code>Generamba</code> ：一种代码生成器，旨在从终端创建 <code>VIPER</code> 模块，非常容易为其他任何类定制。</p></br><h1 id="用协议定义-contracts"><a href="#用协议定义-contracts" class="headerlink" title="用协议定义 contracts"></a><strong>用协议定义 contracts</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像对我们人类一样，<code>VIPER contracts</code> 是两方（模块组件）之间关于协议所产生的权利（方法）和义务（论据）的自愿协议。 在 <code>Cheesecake Labs</code> ，我们使用协议定义模块组件可以从同一模块上的其他组件调用的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，例如，在开始为新的 <code>View</code> 或 <code>Presenter</code> 编写代码之前，请考虑两个组件之间的信息流，并首先在 <code>Contract</code> 上声明其方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainSearchContract.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchView</span>: <span class="title">BaseView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showCustomError</span><span class="params">(<span class="number">_</span> message: String?)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateVisibility</span><span class="params">(onSearchController willBeActive: Bool)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showSearchResult</span><span class="params">(<span class="number">_</span> products: [Product]?, shouldAppend: Bool)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchPresentation</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onViewDidLoad</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onWillPresentSearchController</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onSearchTermChanged</span><span class="params">(to searchTerm: String)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductFavoriteChanged</span><span class="params">(<span class="number">_</span> product: Product, to isFavorite: Bool)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductSelected</span><span class="params">(<span class="number">_</span> product: Product)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onInfiniteScrollTriggered</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchUseCase</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">searchProducts</span><span class="params">(with searchTerm: String, onPage page: Int)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateProductFavorited</span><span class="params">(<span class="number">_</span> product: Product, to newValue: Bool)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchInteractorOutput</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onFetchProductsSuccess</span><span class="params">(<span class="number">_</span> products: [Product]?, shouldAppend: Bool)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onFetchProductsFailure</span><span class="params">(message: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchWireframe</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showProductScreen</span><span class="params">(delegate: ProductScreenDelegate, product: Product?)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面提到的 <code>Xcode插件</code> 还将创建具有所有协议的 <code>ModuleNameContract.swift</code> 文件，等待您声明必要的方法。 一旦定义了这些协议，就可以完全控制 <code>VIPER</code> 模块各组件之间的信息流。</p></br><h1 id="在路由器上自动进行模块初始化"><a href="#在路由器上自动进行模块初始化" class="headerlink" title="在路由器上自动进行模块初始化"></a><strong>在路由器上自动进行模块初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在显示 <code>VIPER</code> 模块的视图之前，您需要确保所有组件均已正确初始化。 我可以想到至少三种非常不同的方法，但是下面的流程是我们想出的最佳选择。 这里的王牌是每个路由器上都有一个静态函数，用于初始化自己的模块以及一些 <code>UIViewController</code> 和 <code>UIStoryboard</code> 扩展。 然后，如果 <code>模块A</code> 要提供 <code>模块B</code> ：</p><ul><li><code>模块A</code> 的路由器将调用 <code>模块B</code> 的静态函数来初始化其所有组件，并返回一个视图。</li><li><code>模块A</code> 的路由器显示 <code>模块B</code> 的视图。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就如此容易。 在自己的路由器上拥有模块初始化代码将消除大量的代码重复，特别是对于大型项目。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您需要一次创建这些扩展：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReusableView.swift</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ReusableView</span>: <span class="title">class</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ReusableView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> reuseIdentifier: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UIViewController.swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span>: <span class="title">ReusableView</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">// UIStoryboard.swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIStoryboard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">instantiateViewController</span><span class="params">()</span></span> -&gt; <span class="type">T</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">ReusableView</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiateViewController(withIdentifier: <span class="type">T</span>.reuseIdentifier) <span class="keyword">as</span>! <span class="type">T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，在每个 <code>VIPER模块</code> 的 <code>路由器</code> 上保留初始化代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainSearchRouter.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainSearchRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: Properties</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">UIViewController?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: Static methods</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setupModule</span><span class="params">()</span></span> -&gt; <span class="type">MainSearchViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">UIStoryboard</span>(name: <span class="type">MainSearchViewController</span>.storyboardName, bundle: <span class="literal">nil</span>).instantiateViewController() <span class="keyword">as</span> <span class="type">MainSearchViewController</span></span><br><span class="line">        <span class="keyword">let</span> presenter = <span class="type">MainSearchPresenter</span>()</span><br><span class="line">        <span class="keyword">let</span> router = <span class="type">MainSearchRouter</span>()</span><br><span class="line">        <span class="keyword">let</span> interactor = <span class="type">MainSearchInteractor</span>()</span><br><span class="line"></span><br><span class="line">        viewController.presenter =  presenter</span><br><span class="line"></span><br><span class="line">        presenter.view = viewController</span><br><span class="line">        presenter.router = router</span><br><span class="line">        presenter.interactor = interactor</span><br><span class="line"></span><br><span class="line">        router.view = viewController</span><br><span class="line"></span><br><span class="line">        interactor.output = presenter</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> viewController</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看来似乎有很多步骤，但有个好消息：前述插件对我们也能实现自动化！ 🙂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果要将 <code>UITabBarController</code> 或 <code>UIPageViewController</code> 装入 <code>VIPER</code> 架构，则需要采取一些其他步骤。 如果您需要任何帮助，请在此信息上发表评论，我会为您准备一个特定的 <code>Gist</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;亲爱的读者，如果您到目前为止已经提出了建议，那么您确实渴望获得知识。 因此，我将为您提供3条建议，以确保您完全了解路由器的职责：</p><ul><li>如果您需要在用户单击按钮时打开 <code>URL</code> ，请在路由器上调用 <code>UIApplication.shared.openURL（url）</code> ，因为您正在导航（即路由）到当前模块之外；</li><li>社交媒体共享也使用相同的概念：从 <code>Router</code> 调用 <code>UIActivityViewController</code> ，因为 <code>iOS</code> 会将用户从当前模块发送到 <code>View</code> 或 <code>app</code> ；</li><li>如果您仅要调用操作表来获得用户输入，那就是添加到当前模块中的UI组件。 因此，您可以从 <code>View</code> 中调用它，并从 <code>UIAlertController</code> 享受直接的回调。</li></ul></br><h1 id="使用-delegates-在-VIPER-模块之间发送数据"><a href="#使用-delegates-在-VIPER-模块之间发送数据" class="headerlink" title="使用 delegates 在 VIPER 模块之间发送数据"></a><strong>使用 delegates 在 VIPER 模块之间发送数据</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您可能已经遇到了这样的情况： <code>模块A</code> 上的一个字段填充有 <code>模块B</code> 的所选项目。因此，当用户单击该字段时， <code>模块A</code> 调用 <code>模块B</code> ，而 <code>模块B</code> 通过以下方式将所选项目返回给现有的 <code>模块A</code> ： <code>delegates</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代表们是在 <code>VIPER</code> 模块之间来回发送信息的绝佳方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Declare which messages can be sent to the delegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ProductScreenDelegate.swift</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProductScreenDelegate</span> </span>&#123;</span><br><span class="line"><span class="comment">//Add arguments if you need to send some information</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductScreenDismissed</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductSelected</span><span class="params">(<span class="number">_</span> product: Product?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Call the delegate when you need to send him a message</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ProductPresenter.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: Properties</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">ProductView?</span></span><br><span class="line">    <span class="keyword">var</span> router: <span class="type">ProductWireframe?</span></span><br><span class="line">    <span class="keyword">var</span> interactor: <span class="type">ProductUseCase?</span></span><br><span class="line">    <span class="keyword">var</span> delegate: <span class="type">ProductScreenDelegate?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductPresenter</span>: <span class="title">ProductPresentation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//View tells Presenter that view disappeared</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onViewDidDisappear</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Presenter tells its delegate that the screen was dismissed</span></span><br><span class="line">        delegate?.onProductScreenDismissed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Implement the delegate protocol to do something when you receive the message</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ScannerPresenter.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScannerPresenter</span>: <span class="title">ProductScreenDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Presenter receives the message from the sender</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductScreenDismissed</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Presenter tells view what to do once product screen was dismissed</span></span><br><span class="line">        view?.startScanning()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Link the delegate from the Product presenter in order to proper initialize it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File ScannerRouter.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setupModule</span><span class="params">(delegate: ProductScreenDelegate?)</span></span> -&gt; <span class="type">ProductViewController</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">let</span> presenter = <span class="type">ScannerPresenter</span>()</span><br><span class="line"></span><br><span class="line">        presenter.view = view</span><br><span class="line">        presenter.interactor = interactor</span><br><span class="line">        presenter.router = router</span><br><span class="line">        presenter.delegate = delegate <span class="comment">// Add this line to link the delegate</span></span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="避免使用-dictionaries-在VIPER组件之间传递数据"><a href="#避免使用-dictionaries-在VIPER组件之间传递数据" class="headerlink" title="避免使用 dictionaries 在VIPER组件之间传递数据"></a><strong>避免使用 dictionaries 在VIPER组件之间传递数据</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您想 <code>100％</code> 兼容 <code>VIPER架构</code> ，最好使用 <code>POSO（普通老式Swift对象）</code> 在 <code>VIPER</code> 的组件之间发送信息。 但是在 <code>VIPER组件</code> 之间发送实体本身可以很好地工作，并且消除了创建 <code>POSO</code> 的开销。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，如果您不想在项目开始成长和变化时迷失键名，请避免使用字典发送此数据。</p><br><h1 id="专注于VIPER"><a href="#专注于VIPER" class="headerlink" title="专注于VIPER"></a><strong>专注于VIPER</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您想充分利用此架构，请务必让您的团队与 <code>VIPER模块</code> 中每个组件的职责保持完全同步。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使在了解了每个特定组件的作用之后，我们的团队仍然面临一些疑问，这主要是受以前在 <code>MVC</code> 方面的经验影响。</p><ul><li>视图是处理 UI元素 的视图：它导入 <code>UIKit</code> 并从其模块中实现有关 <code>UI元素</code> 的所有逻辑。 例如， <code>TableView</code> 逻辑是在视图上实现的。 如果要使代码更具可读性，请在扩展名上拆分 <code>TableView</code> 逻辑。 如果要使您的项目更加简洁，请使用 <code>TableViewDataManager</code> 。</li><li><code>presenter</code> 不会导入 <code>UIKit</code> ，也不会处理 <code>UI元素</code> ，但是会以视图所需的格式准备数据，并根据视图中的 <code>UI事件</code> 做出决定。 不要在 <code>presenter</code> 上操纵任何 <code>UI元素</code> ，它不应处理它们。</li><li><code>Interactor</code> 也可以准备数据，但要用于数据库。 例如，一旦 <code>ApiDataManager</code> 提取了一些数据， <code>Interactor</code> 就可以在要求 <code>LocalDataManager</code> 保存数据之前进行一些排序或过滤。 但是请注意， <code>Interactor</code> 不了解 <code>视图</code> ，因此不知道应如何为视图准备数据。</li></ul></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;产品团队决定从您的项目中删除功能吗？ 还是您的小型项目开始变得庞大？ 使用正确的 <code>VIPER架构</code> ，避免将来出现麻烦！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动化 <code>VIPER文件</code> 创建和模块初始化将消除使用该工具的开销（乍看之下很复杂），但架构清晰而出色。 <code>Android开发人员</code> 也可以使用它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经看到，我们的 VIPER架构 方法实际上是由 <code>VIPRC模块</code> <strong><em>（View-Interactor-Presenter-Router-Contract）</em></strong> 组成的，而实体与模块以及数据管理器是分离的。 我知道 <code>VIPRC</code> 这个名字一点也不性感，但是它可以让您像老板一样构建应用程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Cheesecake Labs&lt;/code&gt; 的开发团队使用 &lt;code&gt;VIPER&lt;/code&gt; 进行 &lt;code&gt;iOS&lt;/code&gt; 和 &lt;code&gt;Android&lt;/code&gt; 移动应用程序开发已有一年多了，我们喜欢这种简洁的架构！&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文使用 &lt;code&gt;VIPER&lt;/code&gt; 样板中的代码示例总结了关于 &lt;code&gt;VIPER&lt;/code&gt; 架构的最佳实践。 这里使用的代码示例在 &lt;code&gt;Swift&lt;/code&gt; 中，但是提到的所有概念都可以应用于使用 &lt;code&gt;Java&lt;/code&gt; 或 &lt;code&gt;Kotlin&lt;/code&gt; 用 &lt;code&gt;VIPER&lt;/code&gt; 开发的 &lt;code&gt;Android&lt;/code&gt; 项目。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果您仍然需要熟悉基本的 &lt;code&gt;VIPER&lt;/code&gt; 概念以及该体系结构如何使您的代码更具组织性和可伸缩性，建议您阅读以下文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;code&gt;最常见的移动应用程序设计模式之间的比较&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ckl.io/blog/ios-project-architecture-using-viper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;code&gt;在iOS上使用VIPER的第一步的绝佳指南&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cheesecakelabs.com/blog/using-viper-architecture-android/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;code&gt;适用于Android的VIPER架构上的独特内容&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="VIPER" scheme="http://www.xuebaonline.com/categories/VIPER/"/>
    
      <category term="架构设计" scheme="http://www.xuebaonline.com/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="VIPER" scheme="http://www.xuebaonline.com/tags/VIPER/"/>
    
      <category term="架构设计" scheme="http://www.xuebaonline.com/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目架构：使用VIPER</title>
    <link href="http://www.xuebaonline.com/iOS%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BD%BF%E7%94%A8VIPER/"/>
    <id>http://www.xuebaonline.com/iOS%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BD%BF%E7%94%A8VIPER/</id>
    <published>2020-04-28T08:58:57.000Z</published>
    <updated>2020-04-28T10:48:16.737Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发 <code>iOS</code> 应用时，请务必考虑应使用哪种 <code>iOS项目架构</code> 。 大多数开发人员使用 <code>Apple</code> 建议的模式：所谓的<code>MVC（模型-视图-控制器）架构</code>。 但是， <code>MVC</code> 本身已经建立了完善的缺陷。 一方面，由于其简单性，它甚至可以使最有经验的工程师将不属于视图或模型的任何代码放入控制器的逻辑中–在控制器中生成大量代码，并真正压缩视图和模型 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这篇文章中，我们将介绍 <code>VIPER</code> ，这是 <code>MVC</code> 的一种流行替代品，它可以帮助你克服其限制，同时保持代码模块化和组织良好，从而改善开发过程。</p><a id="more"></a></br><h1 id="什么是VIPER？"><a href="#什么是VIPER？" class="headerlink" title="什么是VIPER？"></a><strong>什么是VIPER？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>VIPER</code> 是 <code>View</code> ， <code>Interactor</code> ， <code>Presenter</code> ， <code>Entity</code> 和 <code>Router</code> 的反义词。 基本上，这是一种实施 <code>“单一责任原则”</code> 的方法，可以为你的 <code>iOS</code> 项目创建更简洁，更模块化的结构。 这种模式背后的思想是隔离应用程序的依赖关系，以平衡实体之间的职责委派。 这是通过使用以下体系结构来实现的：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/vu-stp1.png" alt="什么是VIPER？"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图说明了 <code>VIPER</code> 体系结构，其中每个块对应于具有特定任务，输入和输出的对象。 将这些块视为装配线中的工人：工人完成对某个对象的工作后，该对象将传递给下一个工人，直到完成产品为止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;块之间的连接表示对象之间的关系，以及它们之间传递的信息类型。 从一个实体到另一个实体的通信是通过协议进行的，我们将在本文中进一步说明。</p></br><h1 id="iOS项目架构"><a href="#iOS项目架构" class="headerlink" title="iOS项目架构"></a><strong>iOS项目架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到 <code>VIPER</code> 架构的真正目的，现在重要的是要多了解每个部分以及它们的职责。 为此，我们将开发一个基本应用程序（代码也可在 <a href="https://github.com/pedrohperalta/Articles-iOS-VIPER" target="_blank" rel="noopener"><strong><em><code>GitHub</code></em></strong></a> 上找到），该应用程序从 <code>REST API</code> 中获取文章列表，并在用户屏幕上显示这些文章。</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a><strong><em>View</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>iOS</code> 应用程序中的 <code>VIPER</code> <code>View</code> 是一个 <code>UIViewController</code> ，其中包含一个子视图，该子视图可以通过编程方式实现，也可以使用接口生成器 <code>（IB）</code> 来实现。 它的唯一责任是显示演示者要告诉的内容，并处理用户与屏幕的交互。 当用户触发任何需要处理的事件时， <code>View</code> 会简单地将其委托给 <code>Presenter</code> ，并等待响应以告知下一步应显示什么。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们的商品可视化应用程序的 <code>“View”</code> 在 <code>Swift</code> 中的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the view input methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesViewInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showArticlesData</span><span class="params">(articles: [Article])</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showNoContentScreen</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A view responsible for displaying a list</span></span><br><span class="line"><span class="comment"> * of articles fetched from some source.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlesViewController</span> : <span class="title">UIViewController</span>, <span class="title">ArticlesViewInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Reference to the Presenter's interface.</span></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">ArticlesModuleInterface!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Once the view is loaded, it sends a command</span></span><br><span class="line"><span class="comment">     * to the presenter asking it to update the UI.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.presenter.updateView()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesViewInterface</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showArticlesData</span><span class="params">(articles: [Article])</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.articles = articles</span><br><span class="line">        <span class="keyword">self</span>.tableView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showNoContentScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Show custom empty screen.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a><strong><em>Presenter</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Presenter</code> 的工作就像 <code>VIPER</code> 模块主要部分之间的桥梁。 一种方式是，它接收来自 <code>View</code> 的输入事件，并通过向 <code>Interactor</code> 请求数据来对它们做出反应。 另一方面，它接收来自 <code>Interactor</code> 的数据结构，在该数据上应用视图逻辑以准备内容，最后告诉视图显示什么。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们的文章可视化应用程序的 <code>Presenter</code> 的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the commands sent from the View to the Presenter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesModuleInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateView</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showDetailsForArticle</span><span class="params">(article: Article)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the commands sent from the Interactor to the Presenter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesInteractorOutput</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">articlesFetched</span><span class="params">(articles: [Article])</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Presenter is also responsible for connecting</span></span><br><span class="line"><span class="comment"> * the other objects inside a VIPER module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlesPresenter</span> : <span class="title">ArticlesModuleInterface</span>, <span class="title">ArticlesInteractorOutput</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Reference to the View (weak to avoid retain cycle).</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">ArticlesViewInterface!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the Interactor's interface.</span></span><br><span class="line">    <span class="keyword">var</span> interactor: <span class="type">ArticlesInteractorInput!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the Router</span></span><br><span class="line">    <span class="keyword">var</span> wireframe: <span class="type">ArticlesWireframe!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesModuleInterface</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.interactor.fetchArticles()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showDetailsForArticle</span><span class="params">(article: Article)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.wireframe.presentDetailsInterfaceForArticle(article)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesInteractorOutput</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">articlesFetched</span><span class="params">(articles: [Article])</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> articles.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.articles = articles</span><br><span class="line">            <span class="keyword">self</span>.view.showArticlesData(articles)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.view.showNoContentScreen()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Interactor"><a href="#Interactor" class="headerlink" title="Interactor"></a><strong><em>Interactor</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以将此对象视为特定模块内用例的集合。  <code>Interactor</code> 包含与实体相关的所有业务逻辑，并且应完全独立于用户界面 <code>（UI）</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的 <code>Article Visualization</code> 应用程序中，一个用例示例是从服务器获取文章列表。 进行请求，处理响应并将其转换为实体（在本例中为商品对象）是 <code>Interactor</code> 的责任。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦 <code>Interactor</code> 完成运行某些任务，它将通知 <code>Presenter</code> 获得的结果。 要牢记的一件重要事情是，发送给 <code>Presenter</code> 的数据不应实现任何业务逻辑，因此 <code>Interactor</code> 提供的数据应整洁并可以使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的文章可视化应用程序中， <code>Interactor</code> 将负责从 <code>API</code> 提取文章：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the Interactor's use case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesInteractorInput</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fetchArticles</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Interactor responsible for implementing</span></span><br><span class="line"><span class="comment"> * the business logic of the module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlesInteractor</span> : <span class="title">ArticlesInteractorInput</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Url to the desired API.</span></span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">"https://www.myendpoint.com"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the Presenter's output interface.</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">ArticlesInteractorOutput!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesInteractorInput</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fetchArticles</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Alamofire</span>.request(.<span class="type">GET</span>, url).responseArray &#123; (response: <span class="type">Response</span>) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> articlesArray = response.result.value</span><br><span class="line">            <span class="keyword">self</span>.output.articlesFetched(articlesArray!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a><strong><em>Entity</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Entity</code> 可能是 <code>VIPER</code> 结构中最简单的元素。 它封装了不同类型的数据，通常在其他 <code>VIPER</code> 组件中被视为有效负载。 需要注意的一件事是实体与数据访问层不同，后者应由交互器处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的 <code>Article Visualization</code>应用程序中， <code>Article</code> 类将是 <code>Entity</code> 的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> website: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> authors: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> imageUrl: <span class="type">String?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a><strong><em>Router</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>VIPER</code> 架构中的最后一个，也许是最特殊的元素是 <code>Router</code> ，它负责模块之间的导航逻辑，以及模块的发生方式（例如，定义用于呈现屏幕的动画，或者应如何完成两个屏幕之间的转换） ）。它从 <code>Presenters</code> 接收输入命令，说出应该路由到哪个屏幕。另外， <code>Router</code> 应负责将数据从一个屏幕传递到另一个屏幕。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Router</code> 应实施一个协议，该协议定义特定模块的所有导航可能性。很好，因为它可以仅查看 <code>Router</code> 的协议即可快速概览应用程序可以采用的所有路径。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>iOS</code> 框架的限制，只有 <code>ViewController</code> 可以在屏幕之间执行转换，因此 <code>Router</code> 必须包含对模块控制器或其任何子级的引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们的 <code>Router</code> 在“文章可视化”应用程序中的外观（请注意，该路由器被广泛称为 <code>“Wireframe”</code> ）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the possible routes from the Articles module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesWireframeInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">presentDetailsInterfaceForArticle</span><span class="params">(article: Article)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Router responsible for navigation between modules.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlesWireframe</span> : <span class="title">NSObject</span>, <span class="title">ArticlesWireframeInput</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Reference to the ViewController (weak to avoid retain cycle).</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> articlesViewController: <span class="type">ArticlesViewController!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the Router of the next VIPER module.</span></span><br><span class="line">    <span class="keyword">var</span> detailsWireframe: <span class="type">DetailsWireframe!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesWireframeInput</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">presentDetailsInterfaceForArticle</span><span class="params">(article: Article)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Create the Router for the upcoming module.</span></span><br><span class="line">        <span class="keyword">self</span>.detailsWireframe = <span class="type">DetailsWireframe</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sends the article data to the next module's Presenter.</span></span><br><span class="line">        <span class="keyword">self</span>.sendArticleToDetailsPresenter(<span class="keyword">self</span>.detailsWireframe.detailsPresenter, article: article)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Presents the next View.</span></span><br><span class="line">        <span class="keyword">self</span>.detailsWireframe.presentArticleDetailsInterfaceFromViewController(<span class="keyword">self</span>.articlesViewController)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: Private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">sendArticleToDetailsPresenter</span><span class="params">(detailsPresenter: DetailsPresenter, article: Article)</span></span> &#123;</span><br><span class="line">        detailsPresenter.article = article</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="什么时候应该使用VIPER？"><a href="#什么时候应该使用VIPER？" class="headerlink" title="什么时候应该使用VIPER？"></a><strong>什么时候应该使用VIPER？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在创建具有发展潜力的项目时，重要的是要考虑一个可以很好地扩展并允许许多开发人员同时无缝地进行工作的结构- <code>MVC</code> 结构可能不足以保持你的项目充分组织 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发人员发现自己调试大型类确实很常见，例如试图在大海捞针中找针。 通过 <code>VIPER</code> 建议的对象之间的松散耦合，你会注意到：</p><ul><li>通过崩溃报告更容易跟踪问题（由于“单一责任原则”）</li><li>添加新功能更容易</li><li>源代码将更加干净，紧凑和可重用</li><li>与其他开发团队的冲突更少</li><li>由于你的 <code>UI</code> 逻辑与业务逻辑是分开的，因此编写自动化测试（！）更容易。</li></ul></br><h1 id="什么时候不应该使用VIPER？"><a href="#什么时候不应该使用VIPER？" class="headerlink" title="什么时候不应该使用VIPER？"></a><strong>什么时候不应该使用VIPER？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于你要解决的每个问题，你都应使用最适合你需求的工具。 由于涉及的元素数量众多，因此该体系结构在启动新项目时会产生开销（尽管从长远来看，这在很大程度上会得到回报），因此 <code>VIPER</code> 对于不打算扩展的小型项目而言可能是一个过大的杀伤力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果团队不完全保持 <code>VIPER</code> 结构的一致性，那么你最终会遇到 <code>MVC-VIPER</code> 混合问题，这可能会令人头疼–因此在继续使用 <code>VIPER</code> 之前，请确保团队完全同步。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>VIPER</code> 是一种非常酷的 <code>iOS</code> 项目架构模式，例如 <code>MVP</code> 和 <code>MVVM</code> 。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;开发 &lt;code&gt;iOS&lt;/code&gt; 应用时，请务必考虑应使用哪种 &lt;code&gt;iOS项目架构&lt;/code&gt; 。 大多数开发人员使用 &lt;code&gt;Apple&lt;/code&gt; 建议的模式：所谓的&lt;code&gt;MVC（模型-视图-控制器）架构&lt;/code&gt;。 但是， &lt;code&gt;MVC&lt;/code&gt; 本身已经建立了完善的缺陷。 一方面，由于其简单性，它甚至可以使最有经验的工程师将不属于视图或模型的任何代码放入控制器的逻辑中–在控制器中生成大量代码，并真正压缩视图和模型 。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在这篇文章中，我们将介绍 &lt;code&gt;VIPER&lt;/code&gt; ，这是 &lt;code&gt;MVC&lt;/code&gt; 的一种流行替代品，它可以帮助你克服其限制，同时保持代码模块化和组织良好，从而改善开发过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="VIPER" scheme="http://www.xuebaonline.com/categories/VIPER/"/>
    
      <category term="架构设计" scheme="http://www.xuebaonline.com/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="VIPER" scheme="http://www.xuebaonline.com/tags/VIPER/"/>
    
      <category term="架构设计" scheme="http://www.xuebaonline.com/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>iOS VIPER架构深入实践</title>
    <link href="http://www.xuebaonline.com/iOS%20VIPER%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.xuebaonline.com/iOS%20VIPER%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-04-28T08:52:14.000Z</published>
    <updated>2020-04-28T10:29:46.621Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>VIPER</code> 架构编写可伸缩的 <code>iOS</code> 代码，并牢记一些 <code>MVVM</code> 和 <code>MVC</code> 技巧和协调器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件工程中，<a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener"><strong><em><code>设计模式（design pattern）</code></em></strong></a> 是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。</p><a id="more"></a></br><h1 id="Swift-设计模式和-iOS-架构"><a href="#Swift-设计模式和-iOS-架构" class="headerlink" title="Swift 设计模式和 iOS 架构"></a><strong>Swift 设计模式和 iOS 架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;软件设计模式基本上是关于如何解决特定（但通常是结合业务场景）情况的通用模板。 结构模式对整个代码库影响更大，它们是高级通用模板。 请记住一件事：</p><blockquote><p>架构没有好坏之分。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择的武器仅取决于情况，但你知道一切都是相对的。 让我们快速快速地了解所有 <code>iOS</code> 设计模式和体系结构，并开始学习 <a href="http://www.xuebaonline.com/iOS%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BD%BF%E7%94%A8VIPER/"><strong><em><code>VIPER</code></em></strong></a> 。 🐍</p></br><h2 id="Swift-设计模式"><a href="#Swift-设计模式" class="headerlink" title="Swift 设计模式"></a><strong><em>Swift 设计模式</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从基础开始吧？ 如果不熟悉 <code>UIKit</code> ，我们会发现发明了许多设计模式，也许你已经知道其中一些。 但是，嘿，由于我们没有太多时间，我想谈谈 <a href="http://www.xuebaonline.com/VIPER%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E5%83%8F%E8%80%81%E6%9D%BF%E4%B8%80%E6%A0%B7%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"><strong><em><code>VIPER</code></em></strong></a> ，让我们看看使用 <code>MVC</code> 模式构建 <code>UIKit</code> 应用程序的基本原理。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a><strong><em>MVC</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模型-视图-控制器（Massive-View-Controller）模式是一个基本概念。 通常，你有一个庞大的UIViewController子类，该子类控制所有视图并收集需要为最终用户显示的每个模型。 例如，你从控制器使用URLSession或Alamofire调用API终结点，进行响应数据验证和格式化，然后在视图控制器上实现表或集合视图委托，因此基本上所有应用程序逻辑都在该单一的，装满了悲惨的视图控制器中 类。 这会为你敲响钟声吗？ 🙄</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a><strong><em>MVVM</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;意识到问题之后，你可以做的第一件事就是将数据转换或绑定部分外包给单独的类。 这就是 <code>Miscrosoft</code> 的聪明人发明了 <code>Model-View-ViewModel</code> 体系结构模式的方式。 现在，你已经接近了一步，你的数据模型和视图可以在距离控制器域很远的闪亮新文件中的一个全新的高度上“聚在一起”。 但是，此模式不会清除视图控制器内部的所有剩余内容。 请记住，你仍然必须向视图控制器提供数据，处理所有不同的状态。</p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a><strong><em>MVP</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们从视图控制器中移走所有数据加载和演示文稿的东西，然后将它们放到神奇地称为 <code>Presenter</code> 的新类中，该怎么办？ 听起来不错，视图控制器可以拥有新的 <code>presenter</code> 实例，从此以后我们可以过上幸福的生活。 来吧，我们真的应该将其重命名为有史以来最有价值的模式！ 😉</p><h2 id="协调器模式"><a href="#协调器模式" class="headerlink" title="协调器模式"></a><strong><em>协调器模式</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还是应该简单地将其称为“逆模型视图展示者”模式？ 看起来，这很重要，协调员在这个演进过程中处于一个全新的高度，但是他们还有很多事情要做。 这违反了“单一职责”原则，因为现在你必须管理表示上下文，数据存储，路由以及协调器或子协调器中的所有 <code>differnet</code> 状态。但是，最后，你的视图控制器没有任何剩余的负担 它可以直接专注于工作，这是什么？ 🙃<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用与 <code>UIKit</code> 相关的内容呈现视图，并转发事件。</p></br><h1 id="VIPER架构"><a href="#VIPER架构" class="headerlink" title="VIPER架构"></a><strong>VIPER架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，不要仅仅因为有人滥用而认为VIPER不好。我认为这是一个令人惊讶的惊人建筑！你只需要适当地学习它，这很困难，因为缺少好的教程。每个人都在比较架构，但这不是人们应该做的。据我所知，<code>MVP</code> 适用于带有几个屏幕的小型应用程序，你永远不要对这些应用程序使用 <code>VIPER</code> 。如果你的应用不断增长，越来越多的组件加入游戏，那么真正的问题就开始了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你打算编写一个小型应用程序，则从 <code>MVC</code> 开始。稍后，你可以使用 <code>MVVM</code> 解决大型视图控制器的问题，但是如果你想将其进一步发展，可以始终使用MVP或协调器模式来保持可维护性。完全没问题，直到有一天你意识到代码中塞满了实用程序类，管理器，处理程序和所有废话对象。听起来很熟悉？ 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我之前提到的那样，没有糟糕的架构之类的东西。只有错误的选择，这导致我们难以维护的代码库。因此，让我指导你完成你想知道的最有用的设计模式，以编写真正可扩展的 <code>iOS</code> 应用程序：具有模块构建器的 <code>VIPER = VIPER（B）</code>。</p></br><h1 id="了解VIPER"><a href="#了解VIPER" class="headerlink" title="了解VIPER"></a><strong>了解VIPER</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>VIPER</code> 体系结构基于单一责任原则 <code>（S.O.L.I.D.）</code>，这使我们进入了干净体系结构的理论。 假设 <code>VIPERB</code> 模块的核心组件为以下组件：</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a><strong><em>View</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是接口层，表示 <code>UIKit</code> 文件，主要是 <code>UIViewController</code> 子类和所有其他内容。 视图不执行与业务逻辑相关的任何操作，只是演示者使用的演示和事件转发层。 由于视图只是纯视图控制器，因此你可以使用 <code>MVVM</code> 原理或数据管理器来使你的项目更加简洁。</p><h2 id="Interactor-互动者"><a href="#Interactor-互动者" class="headerlink" title="Interactor(互动者)"></a><strong><em>Interactor(互动者)</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;交互器负责从模型层检索数据，其实现完全独立于用户界面。 重要的是要记住，数据管理器（网络，数据库，传感器）不是 <code>VIPER</code> 的一部分，因此它们被视为独立的组件（服务），它们来自 <code>VIPER</code> 模块领域，可以作为交互器的依赖项注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Interactor</code> 可以准备或转换来自服务层的数据。 例如，它可以在要求正确的网络服务实现请求或保存数据之前进行一些排序或过滤。 但是请记住，交互器不了解视图，因此它不知道应如何为视图准备数据，这就是 <code>Presenter</code> 的作用。 🙄</p><h2 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a><strong><em>Presenter</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>UIKit</code> 独立类，以视图所需的格式准备数据并基于视图中的 <code>UI</code> 事件做出决定，这就是为什么有时将其称为事件处理程序的原因。 这是 <code>VIPER</code> 模块的核心类，因为它还与 <code>Interactor</code> 通信并调用路由器进行线框图（也就是提供一个新模块或关闭当前模块）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是唯一与几乎所有其他组件进行通信的类。 那只是演示者的工作，因此它不应该对 <code>UIKit</code> 或低级数据模型一无所知。 基本上，这是应用程序的核心，或者有人会说这是实现所有业务逻辑的地方。 💜</p><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a><strong><em>Entity</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;普通模型类，主要由交互器使用。 通常，我在 <code>VIPER</code> 模块结构之外（在服务层中）定义它们，因为这些实体在系统中共享。 我们可以按模块将它们分开，但是通常我不喜欢这种方法，因为例如。 所有 <code>CoreData</code> 模型都可以生成到一个地方。 如果使用 <code>Swagger</code> 或类似工具，则同样适用。</p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a><strong><em>Router</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>UIKit</code> 类的应用程序的导航逻辑。 例如，如果在 <code>iPad</code> 应用程序中使用相同的iPhone视图，则唯一可能改变的是路由器如何构建结构。 这使你可以保留所有其他内容，但路由器保持不变。 它还会监听来自演示者的导航流更改，因此，如果需要，它将显示正确的屏幕。 同样，如果你需要在路由器内部打开一个外部 <code>URL</code> 调用 <code>UIApplication.shared.openURL（url）</code> ，因为这也是一个路由操作，那么使用 <code>UIActivityViewControlle</code> r进行社交媒体共享的逻辑也相同。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样，如果你必须在 <code>VIPER</code> 模块之间传递数据，则感觉是在路由器中执行此操作的正确位置。 我通常使用委托模式在两个模块之间进行通信，因此我养成了在路由器中调用委托函数的习惯。 📲</p><h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a><strong><em>Builder</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有些人正在使用路由器来构建整个模块，但是我不喜欢这种方法。 这就是为什么我总是使用单独的模块构建器类的原因。 唯一的责任是通过对所有外部服务使用依赖注入来构建完整的模块。 它还可以构建同一模块的模拟或其他版本。 如果涉及单元测试，那将非常有帮助。 完全有道理。 👍</p><h2 id="并非一切都是-VIPER-模块"><a href="#并非一切都是-VIPER-模块" class="headerlink" title="并非一切都是 VIPER 模块"></a><strong><em>并非一切都是 VIPER 模块</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，如果要从 <code>UIView</code> 创建通用子类，请不要尝试将其填充到上面的组件中。 你应该在 <code>VIPER modules</code> 文件夹之外创建一个位置，并将其放置在该位置。 有些用例具有特定的类，最好不要进行 <code>VIPERized</code> ！ 😉</p><h2 id="服务和应用程序代码"><a href="#服务和应用程序代码" class="headerlink" title="服务和应用程序代码"></a><strong><em>服务和应用程序代码</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的应用程序通常有3个单独的层。 模块，服务和应用程序。 所有 <code>VIPER</code> 模块都位于 <code>“Modules”</code> 文件夹中。 与网络或数据相关的所有内容都转到 <code>“Services”</code> 文件夹（ <code>api服务</code> ，<code>核心数据服务</code>，<code>位置服务</code>等），然后根据当前环境在模块构建器中使用（例如，用于测试的模拟实现）。 其余所有东西（例如视图子类和其他与 <code>UI</code> 相关的对象，特定于应用程序的样式或设计方面的东西）都放在 <code>App</code> 目录中。</p></br><h1 id="如何编写VIPER代码？"><a href="#如何编写VIPER代码？" class="headerlink" title="如何编写VIPER代码？"></a><strong>如何编写VIPER代码？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开始使用该体系结构之前，我无法充分强调学习这种体系结构的重要性。 我认为，如果有人误解了 <code>VIPER</code> 并开始将视图逻辑放到演示者中，事情就会变得很糟糕。 如果你以前在 <code>VIPER</code> 方面有过糟糕的经验，请考虑一下这句话：不要怪工具，怪木匠。 🔨</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你遵循 <code>VIPER</code> 的规则，那么非常单一的组件将进入正确的位置。</p></blockquote><h2 id="模块生成"><a href="#模块生成" class="headerlink" title="模块生成"></a><strong><em>模块生成</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;永远不要开始手动创建 <code>VIPER</code> 模块，你应该始终使用代码生成器，因为（不幸的）每个模块都需要大量样板代码。乍一看似乎很不幸，但这才是该架构真正的力量所在。如果发生特定问题，开发人员团队的所有成员都将知道在哪里寻找。如果是视图问题，则必须修复视图；如果涉及导航问题，则是路由器问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现有许多代码生成器解决方案（其中一个著名的是 <code>Generamba</code> ），但是我制作了自己的小 <code>Swift</code> 工具来生成 <code>VIPER</code> 模块。这真是该死的轻量级，但确实非常有用（它利用模板来生成新模块），我称之为：<code>VIPERA</code> 。 （毒蛇蛇的匈牙利名字…哈哈😂）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你只需克隆/下载存储库并运行 <code>swift run install --with-templates</code> 即可使其工作。从现在开始，你只需运行<code>vipera MyModule</code> 即可基于默认模板生成新模块。作为第二个参数，你可以传递自己的模板目录名称（可以在<code>〜/ .vipera</code>文件夹下创建自己的模板，也可以更改默认模板）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本模板的结构非常简单，我没有为每一层创建子文件夹，而是在不同位置分离了接口和默认实现。这让我有点理智，因为大多数 <code>VIPER</code> 模板似乎只是由于项目结构而具有很大的威慑力。</p><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a><strong><em>命名约定</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几乎为每个 <code>VIPER</code> 组件都定义了协议。 每个协议都将以模块名称作为前缀，并且除了层名称（例如 <code>MyModuleRouter</code> ， <code>MyModulePresenter</code> ）外，它将没有任何其他后缀。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认实现用于基本方案，每个协议实现均遵循 <code>ModuleName + Default + Layer</code> 命名约定。 因此，例如 <code>MyModuleDefaultRouter</code> 或 <code>MyModuleDefaultPresenter</code> 。</p><h2 id="使用-delegates-进行模块间通信"><a href="#使用-delegates-进行模块间通信" class="headerlink" title="使用 delegates 进行模块间通信"></a><strong><em>使用 delegates 进行模块间通信</em></strong></h2><p>流程是这样的：</p><p><strong>Router / Presenter</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Presenter</code> 可以使用路由器协议定义发送路由器事件。</p><p><strong>Presenter / Interactor</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Interactor</code> 可以通过演示者的界面通知演示者，并且演示者可以使用 <code>Interactor</code> 协议内部定义的方法来调用交互者。</p><p><strong>Presenter / View</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;视图通常具有 <code>setter</code> 方法来更新其在视图协议上定义的内容。 它还可以通过演示者协议将传入或加载事件通知 <code>Presenter</code> 。</p><h2 id="模块之间的数据传输"><a href="#模块之间的数据传输" class="headerlink" title="模块之间的数据传输"></a><strong><em>模块之间的数据传输</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象一个列表，你选择一个项目并转到新的控制器场景。 为了使之成为可能，你必须在 <code>VIPER</code> 模块之间至少传递一个唯一的标识符。</p><p>通常这样做是这样的：</p><ul><li>该视图使用 <code>ID</code> 调用 <code>Presenter</code> 上的 <code>didSelect</code> 方法</li><li><code>Presenter</code> 使用 <code>routeFor（id）</code> 方法将 <code>ID</code> 转发到路由器</li><li>路由器调用构建器使用 <code>ID</code> 来构建新模块</li><li>生成器使用 <code>id</code> 生成新模块</li><li>路由器使用其视图显示新模块（控制器）</li><li>新模块将ID传递给需要它的每个人（路由器，演示者）</li><li>新模块的演示者获取ID</li><li>新模块的 <code>Interactor</code> 加载数据并将其提供给 <code>Presenter</code></li><li>新模块的 <code>Presenter</code> 为视图提供数据并进行展示</li><li>出现详细信息屏幕，其中包含适当的数据。</li></ul><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你以模态形式显示控制器，则还可以将原始路由器作为委托传递，因此可以在需要时正确关闭它。 😎</p></blockquote><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong><em>内存管理</em></strong></h2><p>长话短说：</p><ul><li><code>builder</code> 不持有任何对象。</li><li><code>Router</code> 对 <code>Views</code> 和 <code>Presenter</code> 保持弱引用。</li><li><code>Presenter</code> 强持有 <code>Router</code>和  <code>Interactor</code> </li><li><code>Interactor</code> 对<code>Presenter</code> 的 弱引用</li><li>该 <code>Views</code> 对 <code>Presenter</code> 强引用</li><li><code>UIKit</code> 持有 <code>views</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该在提供的示例中进行检查，没有泄漏-希望如此-在你返回或关闭模块后，所有内容都会顺利顺利地释放。 🤞</p></br><h1 id="结论：我应该学习VIPER吗？"><a href="#结论：我应该学习VIPER吗？" class="headerlink" title="结论：我应该学习VIPER吗？"></a><strong>结论：我应该学习VIPER吗？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管 <code>VIPER</code> 因其复杂性而备受批评，但我只能说值得努力学习正确的原理。 你会发现使用 <code>VIPER</code> 而不是忽略它会有更多的好处。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong><em>优点</em></strong></h2><ul><li><strong>简单性</strong> -适用于大型团队的复杂项目</li><li><strong>可扩展性</strong> -无缝同时工作</li><li><strong>可重用性</strong> -根据角色分离应用程序组件</li><li><strong>一致性</strong> -模块框架，关注点分离</li><li><strong>清晰度</strong> -单一职责（SOLID）</li><li><strong>可测试性</strong> -分离的小类，TDD，更好的代码覆盖率</li><li><strong>接口</strong> -模块独立性，定义明确的范围</li><li><strong>错误修复</strong> -更容易跟踪问题，查找错误和问题</li><li><strong>源代码控制</strong> -文件更小，冲突更少，代码更简洁</li><li><strong>容易</strong> -代码库看起来很相似，熟悉项目代码更快</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong><em>缺点</em></strong></h2><ul><li><strong>详细程度</strong> -每个模块很多文件</li><li><strong>复杂性</strong> -许多协议和委托</li><li><strong>On-boarding</strong> -缺乏适当的VIPER知识</li><li><strong>Engagement</strong> -VIPER很糟糕，因为它很复杂！</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我写了一篇后续文章，介绍了我在此过程中学到的VIPER最佳实践。👨💻</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何使用 &lt;code&gt;VIPER&lt;/code&gt; 架构编写可伸缩的 &lt;code&gt;iOS&lt;/code&gt; 代码，并牢记一些 &lt;code&gt;MVVM&lt;/code&gt; 和 &lt;code&gt;MVC&lt;/code&gt; 技巧和协调器。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在软件工程中，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;code&gt;设计模式（design pattern）&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; 是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="VIPER" scheme="http://www.xuebaonline.com/categories/VIPER/"/>
    
      <category term="架构设计" scheme="http://www.xuebaonline.com/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="VIPER" scheme="http://www.xuebaonline.com/tags/VIPER/"/>
    
      <category term="架构设计" scheme="http://www.xuebaonline.com/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Swift 如何学习现代UIKit？</title>
    <link href="http://www.xuebaonline.com/Swift%20%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%8E%B0%E4%BB%A3UIKit%EF%BC%9F/"/>
    <id>http://www.xuebaonline.com/Swift%20%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%8E%B0%E4%BB%A3UIKit%EF%BC%9F/</id>
    <published>2020-04-28T08:31:06.000Z</published>
    <updated>2020-04-28T08:48:47.003Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与我一起采取第一步，学习如何使用 <code>UIKit</code> 框架构建用户界面。 在 <code>Swift</code> 中以编程方式编写，不适用 <code>storyboards</code> 。</p></br><h1 id="UI-frameworks-in-2020"><a href="#UI-frameworks-in-2020" class="headerlink" title="UI frameworks in 2020"></a><strong>UI frameworks in 2020</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我总是告诉所有人，工作中最困难的部分是建立适当的用户界面。 提供最佳的用户体验可能是一项挑战，因为设计师必须遵循人机界面指南，设计出美观的设计，有时还要与客户打交道，以为最终用户找到最佳解决方案。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>Swift</code> 实现图形用户界面的可用选项有哪些？</p><a id="more"></a></br><h1 id="SwiftUI"><a href="#SwiftUI" class="headerlink" title="SwiftUI"></a><strong>SwiftUI</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果在 <code>2019年</code> 发布了<code>SwiftUI</code>，该框架仍然热脆，或者我应该说半熟吗？ 在 <code>WWDC</code> 宣布之后，很多人立即开始使用 <code>SwiftUI</code> ，我对最初的反馈感到非常不满意。 <code>SwiftUI</code> 是未来，这是肯定的。 我相信 <code>Apple</code> 会在框架上做出很多努力，以使其更好。 从概念上讲，它已经很不错了，实现很简单，但是我仍然面临的最大问题是，我还没有看到 <code>SwiftUI</code> 如何改善我的日常工作。 🤔</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声明性接口定义是当今的热门话题，但是我们真的需要它吗？ 我的意思是，基本原型制作速度非常快，但是，如果你必须解决复杂的问题（甚至是一些琐碎的问题，例如设置滚动视图的偏移），则必须与系统抗争或提出自己的 <code>UIViewRepresentable</code> 对象。</p><p><strong><em><code>The truth is: if you choose SwiftUI you still have to interact a LOT with UIKit as well.</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，人们有各种各样的需求。 由于 <code>Flutter</code> ＆ <code>React Native</code>，恕我直言 <code>SwiftUI</code> 在这里。 开发人员喜欢这些框架。 苹果必须想出一种新的解决方案来与他们抗衡，因为他们希望越来越多的有才华的 <code>Swift</code> 编码器能够在 <code>iOS</code> 应用程序上本机工作，而不是在混合应用程序上工作。 从新手的角度来看，选择 <code>SwiftUI</code> 确实很迷人。 即使在这个早期阶段，我仍然可以给你留下深刻的印象。</p><h2 id="是否可以学习-SwiftUI"><a href="#是否可以学习-SwiftUI" class="headerlink" title="是否可以学习 SwiftUI?"></a><strong><em>是否可以学习 SwiftUI?</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是的，绝对可以，如果你已经熟悉 <code>UIKit</code> ，那就去学习 <code>SwiftUI</code> 。 如果你完全没有 <code>UIKit</code> 的经验，你仍然可以精通 <code>SwiftUI</code> ，但是你可能会发现自己在寻找很多与 <code>UIKit</code> 相关的问题。 🔍</p><h2 id="你应该学习SwiftUI还是UIKit？"><a href="#你应该学习SwiftUI还是UIKit？" class="headerlink" title="你应该学习SwiftUI还是UIKit？"></a><strong><em>你应该学习SwiftUI还是UIKit？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，知道我所知道的我将从UIKit开始。 “和这个酷孩子在一起”确实很诱人，但是值得跳过整个课程吗？这也是我的想法：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要说的是 <code>SwiftUI</code> 的存在并没有以某种方式使 <code>UIKit</code> 变得过时：如果你打算在未来三年内获得 <code>iOS</code> 开发工作，那么知道如何使用 <code>UIKit</code> 将会是一项必然的要求。</p></blockquote></br><h1 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a><strong>UIKit</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>UIKit</code> 现在可在以下平台上使用：<code>iOS（iPadOS）</code>，<code>tvOS</code>，<code>macOS（Catalyst）</code>。 除了<code>watchOS</code> 以外，几乎所有这些都已包含在内。 该框架本身是一个巨大的框架，因为它包含了你可以在 <code>iOS</code> 上看到和使用的每个基本构建块。 它不仅是视图，还包括控制器，导航，响应器等等。</p><h2 id="你应该从哪里开始学习UIKit？"><a href="#你应该从哪里开始学习UIKit？" class="headerlink" title="你应该从哪里开始学习UIKit？"></a><strong><em>你应该从哪里开始学习UIKit？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是否正在寻找现代 <code>UIKit</code> 教程？ 好吧，这可能非常困难，因为大多数书籍和课程都已过时。 但是，我必须推荐一个 <code>肖恩·艾伦（Sean Allen）</code> 真正有用的视频课程。 他正在构建一个完整的应用程序，向你教授网络基础知识，集合视图，搜索控制器的适当状态管理以及许多小型实践，如果你想开始作为 <code>iOS</code> 开发人员的职业，这些实践将非常有用。 这就像一个面试的外卖项目教程。 真的很有用！ 🎬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以选择加入我的行列，并每周学习UIKit的工作原理。 我将发布有关过去学习的所有最佳实践的文章。 这将是100％用最新版本的Swift编写的，没有 <code>storyboards</code> 或 <code>nibs</code> 。 这些将是更长的文章，每一次我将专注于对现实项目有用的实践课程。 有什么计划？</p><p><strong>我即将发布的UIKit教程*</strong></p><ul><li><p>如何使用UIKit启动iOS项目？</p><p>  项目设置，基本UIKit概念，AppDelegate，SceneDelegate</p></li><li><p>了解UIKit导航的工作方式</p><p>  UINavigationController，UITabBarController，UISplitViewController，UIPageViewController</p></li><li><p>关于UIViewController类的所有信息</p><p>  UIViewController生命周期，子类化，使用子视图控制器的合成</p></li><li><p>UIView基础知识，使用自定义视图</p><p> UIView生命周期，布局系统，自定义UIView子类，有关图层的一些知识</p></li><li><p>具有UILabel，UIButton，UIImageView的布局锚点</p><p>  了解如何通过使用布局锚点和基本的UIKit组件来构建屏幕</p></li><li><p>使用不同的数据源修改UITableView</p><p>  使用搜索字段，远程图像加载等。</p></li><li><p>UI堆栈，状态，警报，过渡，动画</p><p> UIAlertController，UIActivityIndi​​catorView和一些奇特的效果</p></li><li><p>使用UICollectionView构建复杂的用户界面</p><p>  合成布局，再加上我对基于SwiftUI的可重用单元格有了新的疯狂想法…</p></li><li><p>使用UIStackView和UIScrollView创建复杂的输入表单</p><p>  使用：UITextField，UISlider，UIStepper，UIDatePicker，UISegmentedControl，UISwitch</p></li><li><p>支持更大的屏幕，iPad，macOS（Catalyst）和黑暗模式</p><p>  Windows，适应性，拖放基础，触摸识别器</p></li></ul><p>*请注意：这只是一个基本框架，将来内容可能会有所不同。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我计划在今年晚些时候发布第一期。 当我准备好内容之后，每个星期你都应该期待有一篇新的 <code>UIKit</code> 文章，其中包含一些可以自己解决的小任务（也许你需要做一些研究工作）。</p></br><h1 id="你首选的学习方法是什么？"><a href="#你首选的学习方法是什么？" class="headerlink" title="你首选的学习方法是什么？"></a><strong>你首选的学习方法是什么？</strong></h1><ul><li><strong><em>图书</em></strong></li><li><strong><em><code>Swift playground books</code></em></strong></li><li><strong><em>视频课程</em></strong></li><li><strong><em>撸代码实践</em></strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;与我一起采取第一步，学习如何使用 &lt;code&gt;UIKit&lt;/code&gt; 框架构建用户界面。 在 &lt;code&gt;Swift&lt;/code&gt; 中以编程方式编写，不适用 &lt;code&gt;storyboards&lt;/code&gt; 。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;UI-frameworks-in-2020&quot;&gt;&lt;a href=&quot;#UI-frameworks-in-2020&quot; class=&quot;headerlink&quot; title=&quot;UI frameworks in 2020&quot;&gt;&lt;/a&gt;&lt;strong&gt;UI frameworks in 2020&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我总是告诉所有人，工作中最困难的部分是建立适当的用户界面。 提供最佳的用户体验可能是一项挑战，因为设计师必须遵循人机界面指南，设计出美观的设计，有时还要与客户打交道，以为最终用户找到最佳解决方案。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 &lt;code&gt;Swift&lt;/code&gt; 实现图形用户界面的可用选项有哪些？&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="SwiftUI" scheme="http://www.xuebaonline.com/categories/SwiftUI/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="SwiftUI" scheme="http://www.xuebaonline.com/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>Swift 唯一识别的视图</title>
    <link href="http://www.xuebaonline.com/Swift%20%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%9A%84%E8%A7%86%E5%9B%BE/"/>
    <id>http://www.xuebaonline.com/Swift%20%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%9A%84%E8%A7%86%E5%9B%BE/</id>
    <published>2020-04-28T08:24:22.000Z</published>
    <updated>2020-04-28T08:35:22.581Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用基于字符串的 <code>UIView</code> 标识符而不是标签。 如果你厌倦了标记视图，请查看这些替代解决方案。</p></br><h1 id="第一种方法：accessibility-to-the-rescue"><a href="#第一种方法：accessibility-to-the-rescue" class="headerlink" title="第一种方法：accessibility to the rescue!"></a><strong>第一种方法：accessibility to the rescue!</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长话短说，我很讨厌用愚蠢的数字值标记视图，因此我寻求一种更好的替代解决方案来解决我的问题。 事实证明，有一个名为 <code>accessibilityIdentifier</code> 的属性可以完成这项工作。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.accessibilityIdentifier</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.accessibilityIdentifier = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">view</span><span class="params">(withId id: String)</span></span> -&gt; <span class="type">UIView?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.id == id &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> view <span class="keyword">in</span> <span class="keyword">self</span>.subviews &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> view = view.view(withId: id) &#123;</span><br><span class="line">                <span class="keyword">return</span> view</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对 <code>UIView</code> 类进行了简单的扩展，因此现在我可以使用适当的字符串值来唯一地标识视图层次结构中的任何视图对象。 这是一个很好的解决方案，现在我可以以一种非常不错的方式命名我的 <code>views</code> 。 免费将名称存储在 <code>accessibilityIdentifier</code> 下将对 <code>UI</code> 测试带来好处。 😉</p></br><h1 id="第二种方法：using-enums"><a href="#第二种方法：using-enums" class="headerlink" title="第二种方法：using enums"></a><strong>第二种方法：using enums</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要思想是为每个视图标识符都具有一个基于 <code>Int</code> 的枚举，因此基本上你可以使用 <code>tag</code> 属性存储枚举的 <code>rawValue</code> 。 它仍然不如上面的那个好，但是比依赖纯整数更安全。 😬</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ViewIdentifier</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> submitButton</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">ViewIdentifier?</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> value = newValue &#123;</span><br><span class="line">                <span class="keyword">self</span>.tag = value.rawValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ViewIdentifier</span>(rawValue: <span class="keyword">self</span>.tag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">view</span><span class="params">(withId id: ViewIdentifier)</span></span> -&gt; <span class="type">UIView?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.viewWithTag(id.rawValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;老实说，在我将第一个代码片段复制并粘贴到本文之后，我只是想出了第二种方法，但是到底是什么，也许有人会喜欢它。 😂</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何使用基于字符串的 &lt;code&gt;UIView&lt;/code&gt; 标识符而不是标签。 如果你厌倦了标记视图，请查看这些替代解决方案。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;第一种方法：accessibility-to-the-rescue&quot;&gt;&lt;a href=&quot;#第一种方法：accessibility-to-the-rescue&quot; class=&quot;headerlink&quot; title=&quot;第一种方法：accessibility to the rescue!&quot;&gt;&lt;/a&gt;&lt;strong&gt;第一种方法：accessibility to the rescue!&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;长话短说，我很讨厌用愚蠢的数字值标记视图，因此我寻求一种更好的替代解决方案来解决我的问题。 事实证明，有一个名为 &lt;code&gt;accessibilityIdentifier&lt;/code&gt; 的属性可以完成这项工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="Uniquely identifying views" scheme="http://www.xuebaonline.com/categories/Uniquely-identifying-views/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="Uniquely identifying views" scheme="http://www.xuebaonline.com/tags/Uniquely-identifying-views/"/>
    
  </entry>
  
  <entry>
    <title>iOS子类化样式</title>
    <link href="http://www.xuebaonline.com/iOS%E5%AD%90%E7%B1%BB%E5%8C%96%E6%A0%B7%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/iOS%E5%AD%90%E7%B1%BB%E5%8C%96%E6%A0%B7%E5%BC%8F/</id>
    <published>2020-04-28T08:03:15.000Z</published>
    <updated>2020-04-28T08:20:27.596Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何通过使用 <code>Swift</code> 中的 <code>UIKit</code> 框架中的自定义视图子类来设计和构建 <strong><em>可重用</em></strong> 的用户界面元素。</p></br><h1 id="问题：UI，UX，设计"><a href="#问题：UI，UX，设计" class="headerlink" title="问题：UI，UX，设计"></a><strong>问题：UI，UX，设计</strong></h1><p><strong><em><code>建立用户界面是工作中最难的部分！</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之：设计是找出适合特定问题的最佳解决方案的过程。图形设计通常是指在画布或纸上的物理图形。 <code>UX</code> 实际上就是用户与应用程序交互的方式，换句话说：“客户”旅程的整体虚拟体验。 <code>UI</code> 是他/她将通过触摸屏幕看到并与之交互的可见界面。 👆</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我不得不戴上设计师的帽子（甚至是开发者的帽子），我必须告诉你，在大多数情况下，弄清和实现适当的用户界面是最具挑战性的问题。如今的前端系统（移动，平板电脑甚至台式机应用程序）只是来自 <code>service</code> / <code>API</code>的一些 <code>JSON</code> 数据之上的漂亮叠加层。 🤷‍♂️</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么这么难？好吧，我相信，如果你想成为一名优秀的设计师，那么你也需要适当的工程思维。你必须能够观察整个系统（大图），构造一致的 <code>UI</code> 元素（实际上到处看起来都是一样的），基于功能规范计划所需的体验等等。成为艺术家，跳出思维框框，并能够向他人解释（描述）你的想法也是一个基本要求。 🤯</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在告诉我，哪个行业的工作最艰辛？是的，如今免费提供的每个人都是设计师，有些公司根本不雇用这类专家，而只是让开发人员完成工作。无论如何，让我们专注于如何通过使用 <code>Swift</code> 中的子类来创建漂亮且可重用的设计实现。 👍</p></br><h1 id="外观，主题和样式"><a href="#外观，主题和样式" class="headerlink" title="外观，主题和样式"></a><strong>外观，主题和样式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我几乎没有使用 <code>UIAppearance API</code> 。 这是个人喜好，但是我想直接在视图实例上设置设计属性，例如 <code>font</code>，<code>textColor</code>，<code>backgroundColor</code>。 尽管在某些情况下，我发现外观代理非常好，但是仍然存在一些问题。 也许这将随着 <code>iOS 13</code> 以及期待已久的 <code>dark mode</code> 的到来而改变。</p><blockquote><p><strong><em><code>Dear Apple please make an auto switch based on day / night cycles (you know like the sunset, sunrise option in the home app). 🌙</code></em></strong></p></blockquote><ul><li><strong><em>样式</em></strong> 是指定单个视图外观的属性的集合。</li><li><strong><em>主题</em></strong> 是应用于整个应用程序的一组外观相似的视图样式。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，我通常会创建一些预定义的样式元素集，最可能是字体，颜色，但有时还会是图标等。我喜欢采用以下结构：</p><p><strong>Fonts</strong></p><ul><li>title</li><li>heading</li><li>subheading</li><li>body</li><li>small</li></ul><p><strong>Colors</strong></p><ul><li>title</li><li>heading</li><li>background</li></ul><p><strong>Icons</strong></p><ul><li>back</li><li>share</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以有更多的元素，但是为了简单起见，让我们使用嵌套结构通过一个非常简单的 <code>Swift</code> 解决方案来实现这些元素：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fonts</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> title = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> heading = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">24</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> subheading = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> body = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> small = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Colors</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> title = <span class="type">UIColor</span>.blue</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> heading = <span class="type">UIColor</span>.black</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> background = <span class="type">UIColor</span>.white</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Icons</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> back = <span class="type">UIImage</span>(named: <span class="string">"BackIcon"</span>)!</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> share = <span class="type">UIImage</span>(named: <span class="string">"ShareIcon"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//usage example:</span></span><br><span class="line"><span class="type">App</span>.<span class="type">Fonts</span>.title</span><br><span class="line"><span class="type">App</span>.<span class="type">Colors</span>.background</span><br><span class="line"><span class="type">App</span>.<span class="type">Icons</span>.back</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，我得到了一个非常简单的语法，这很好，虽然这不会让我进行动态样式设置，所以我无法在浅色/深色主题之间切换，但是我真的不介意，因为在大多数情况下 这不是必需的。 😅</p><p><strong><em>Structs vs enums:</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我可以使用枚举代替具有静态属性的结构，但是在这种情况下，我喜欢这种方法的简单性。 我不想弄乱接受枚举的原始值或扩展名。 这只是个人喜好。</p><p><strong>如果你必须支持多个主题怎么办？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这不是什么大问题，你可以根据需要定义协议，并根据需要实施所需的主题协议。 真正的问题是，当你必须在主题之间切换时，因为必须刷新/重新加载整个UI。 ♻️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一些最佳做法，例如，可以使用 <code>NSNotificationCenter</code> 类来通知应用程序中的每个视图/控制器在发生主题更改时进行刷新。 另一个解决方案是简单地重新初始化应用程序的整个 <code>UI</code> ，因此这意味着你基本上从头开始使用全新的 <code>rootViewController</code> 。 😱</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，如果你需要这样的内容，请查看下面的链接，但是如果你只想在应用程序中支持暗模式，建议你等到第一个 <code>iOS 13 beta</code> 发布。 也许 <code>Apple</code> 会提供一些新颖的 <code>API</code> 来简化事情。</p></br><h1 id="自定义视图作为样式元素"><a href="#自定义视图作为样式元素" class="headerlink" title="自定义视图作为样式元素"></a><strong>自定义视图作为样式元素</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们有了定义字体，颜色和其他基本构建块的好方法，是时候将这些样式应用于实际的 <code>UI</code> 元素了。 当然，你可以使用 <code>UIAppearance API</code> ，但是例如，你不能简单地通过外观代理设置自定义字体。 😢</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一件事是我喜欢设计的一致性。 因此，如果标题是我的应用程序中某处的蓝色 <code>32pt</code> 粗体系统字体，我也希望该元素在其他地方都遵循相同的准则。 我通过为每个应用了自定义样式的单个 <code>view</code> 元素创建子类来解决此问题。 因此，例如：</p><ul><li>TitleLabel (blue color, 32pt system font)</li><li>HeadingLabel (blue color, 24pt system font)</li><li>StandardButton (blue background)</li><li>DestructiveButton (red background)</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你有子类，并且正在使用代码中的自动布局约束，则另一件好事是，你可以将所有约束创建逻辑直接放入子类本身。 让我给你看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleLabel</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.textColor = <span class="type">App</span>.<span class="type">Colors</span>.title</span><br><span class="line">        <span class="keyword">self</span>.font = <span class="type">App</span>.<span class="type">Fonts</span>.title</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">constraints</span><span class="params">(<span class="keyword">in</span> view: UIView)</span></span> -&gt; [<span class="type">NSLayoutConstraint</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="keyword">self</span>.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: <span class="number">16</span>),</span><br><span class="line">            <span class="keyword">self</span>.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -<span class="number">16</span>),</span><br><span class="line">            <span class="keyword">self</span>.centerYAnchor.constraint(equalTo: view.centerYAnchor),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我只需要设置一次 <code>font＆textColor</code> 属性，因此在完成视图初始化之后，我可以确保 <code>TitleLabel</code> 的每个实例看起来都完全相同。 用法也很简单，你只需要在接口构建器中设置类名，或者可以像这样简单地创建视图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadView method in a view controller...</span></span><br><span class="line"><span class="keyword">let</span> titleLabel = <span class="type">TitleLabel</span>()</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(titleLabel)</span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate(titleLabel.constraints(<span class="keyword">in</span>: <span class="keyword">self</span>.view))</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最喜欢这种方法的地方是我的约束将在正确的位置，因此它们不会膨胀我的视图控制器的 <code>loadView</code> 方法。 你还可以根据当前情况使用额外的参数创建多个约束变量，因此它可以针对每种情况进行扩展。 👍</p></br><h1 id="视图初始化很难"><a href="#视图初始化很难" class="headerlink" title="视图初始化很难"></a><strong>视图初始化很难</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该解决方案的缺点是，由于界面构建器的支持，视图初始化有点混乱。 你必须子类化每种视图类型（按钮，标签等），并一次又一次地复制并粘贴初始化方法。 我已经有一些有关此的文章，请查看下面的链接。 👇</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决这个问题，我通常以为自己的样式视图创建一个父类来结束。 这是我的标签的抽象基类的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以从现在开始，我只需要重写 <code>initialize</code> 方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleLabel</span>: <span class="title">Label</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.initialize()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = <span class="type">App</span>.<span class="type">Fonts</span>.title</span><br><span class="line">        <span class="keyword">self</span>.textColor = <span class="type">App</span>.<span class="type">Colors</span>.title</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看，它好多了，因为我不再需要处理所需的视图初始化方法，默认情况下，自动调整大小功能也将关闭。 ❤️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我从本课程中学到的最后一点是，如果涉及到 <code>UIKit</code> 框架，则不必担心类和面向对象的编程。 如果在正确的地方使用面向协议的编程（也就是函数式编程），那将是很好的选择，但是由于 <code>UIKit</code> 确实是一个 <code>OOP</code> 框架，所以我相信遵循这些范式而不是选择某些笨拙的方式还是更好的。 🤪</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何通过使用 &lt;code&gt;Swift&lt;/code&gt; 中的 &lt;code&gt;UIKit&lt;/code&gt; 框架中的自定义视图子类来设计和构建 &lt;strong&gt;&lt;em&gt;可重用&lt;/em&gt;&lt;/strong&gt; 的用户界面元素。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;问题：UI，UX，设计&quot;&gt;&lt;a href=&quot;#问题：UI，UX，设计&quot; class=&quot;headerlink&quot; title=&quot;问题：UI，UX，设计&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题：UI，UX，设计&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;code&gt;建立用户界面是工作中最难的部分！&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;简而言之：设计是找出适合特定问题的最佳解决方案的过程。图形设计通常是指在画布或纸上的物理图形。 &lt;code&gt;UX&lt;/code&gt; 实际上就是用户与应用程序交互的方式，换句话说：“客户”旅程的整体虚拟体验。 &lt;code&gt;UI&lt;/code&gt; 是他/她将通过触摸屏幕看到并与之交互的可见界面。 👆&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果我不得不戴上设计师的帽子（甚至是开发者的帽子），我必须告诉你，在大多数情况下，弄清和实现适当的用户界面是最具挑战性的问题。如今的前端系统（移动，平板电脑甚至台式机应用程序）只是来自 &lt;code&gt;service&lt;/code&gt; / &lt;code&gt;API&lt;/code&gt;的一些 &lt;code&gt;JSON&lt;/code&gt; 数据之上的漂亮叠加层。 🤷‍♂️&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="子类化样式" scheme="http://www.xuebaonline.com/categories/%E5%AD%90%E7%B1%BB%E5%8C%96%E6%A0%B7%E5%BC%8F/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="子类化样式" scheme="http://www.xuebaonline.com/tags/%E5%AD%90%E7%B1%BB%E5%8C%96%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift 选择和播放视频</title>
    <link href="http://www.xuebaonline.com/Swift%20%E9%80%89%E6%8B%A9%E5%92%8C%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/"/>
    <id>http://www.xuebaonline.com/Swift%20%E9%80%89%E6%8B%A9%E5%92%8C%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/</id>
    <published>2020-04-28T07:30:44.000Z</published>
    <updated>2020-04-28T08:01:57.021Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用视频选择器控制器和 <code>AVPlayer</code> 类（完全用 <code>Swift 5</code> 编写）来记录或选择视频文件。</p></br><h1 id="让我们挑选一些视频！"><a href="#让我们挑选一些视频！" class="headerlink" title="让我们挑选一些视频！"></a><strong>让我们挑选一些视频！</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你还记得我以前有关 <a href="http://www.xuebaonline.com/Swift%205%E4%BD%BF%E7%94%A8UIImagePickerController%E6%8B%BE%E5%8F%96%E5%9B%BE%E5%83%8F/"><strong><em><code>《iOS中图像拾取》</code></em></strong></a> 的教程，那么你知道我已经在 <code>UIKit</code> 的基础上建立了一个可重用的选择器类。 如果你不知道 <code>UIImagePickerController</code> 类的工作方式，请先阅读该教程，因为它为你提供了有关基础知识的出色概述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，你需要在 <code>Info.plist</code> 文件中添加一些密钥，因为你想访问一些个人数据。 你知道：隐私非常重要。 🤫</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;<span class="type">NSCameraUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to take pictures &amp; videos.&lt;/string&gt;</span><br><span class="line">&lt;key&gt;<span class="type">NSPhotoLibraryUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to use your picture &amp; video library.&lt;/string&gt;</span><br><span class="line">&lt;key&gt;<span class="type">NSMicrophoneUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to record sound.&lt;/string&gt;</span><br><span class="line">&lt;key&gt;<span class="type">NSPhotoLibraryAddUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to save pictures &amp; videos to your library.&lt;/string&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于我们不会捕获无声视频，因此我们还必须添加“隐私-麦克风使用说明”字段。 准备，开始，行动！ 🎬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我不会对你说谎，但是这次我有点懒，所以我们的 <code>VideoPicker</code> 类和 <code>ImagePicker</code> 类是90％。 你可以创建一个抽象类，无论如何，我将向你展示最终代码，然后我们可以讨论它们之间的区别。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">VideoPickerDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didSelect</span><span class="params">(url: URL?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoPicker</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> pickerController: <span class="type">UIImagePickerController</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> presentationController: <span class="type">UIViewController?</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">VideoPickerDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(presentationController: <span class="type">UIViewController</span>, delegate: <span class="type">VideoPickerDelegate</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.pickerController = <span class="type">UIImagePickerController</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presentationController = presentationController</span><br><span class="line">        <span class="keyword">self</span>.delegate = delegate</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.pickerController.delegate = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController.allowsEditing = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController.mediaTypes = [<span class="string">"public.movie"</span>]</span><br><span class="line">        <span class="keyword">self</span>.pickerController.videoQuality = .typeHigh</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(<span class="keyword">for</span> type: UIImagePickerController.SourceType, title: String)</span></span> -&gt; <span class="type">UIAlertAction?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="type">UIImagePickerController</span>.isSourceTypeAvailable(type) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIAlertAction</span>(title: title, style: .<span class="keyword">default</span>) &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.pickerController.sourceType = type</span><br><span class="line">            <span class="keyword">self</span>.presentationController?.present(<span class="keyword">self</span>.pickerController, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(from sourceView: UIView)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="literal">nil</span>, message: <span class="literal">nil</span>, preferredStyle: .actionSheet)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .camera, title: <span class="string">"Take video"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .savedPhotosAlbum, title: <span class="string">"Camera roll"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .photoLibrary, title: <span class="string">"Video library"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        alertController.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"Cancel"</span>, style: .cancel, handler: <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="type">UIDevice</span>.current.userInterfaceIdiom == .pad &#123;</span><br><span class="line">            alertController.popoverPresentationController?.sourceView = sourceView</span><br><span class="line">            alertController.popoverPresentationController?.sourceRect = sourceView.bounds</span><br><span class="line">            alertController.popoverPresentationController?.permittedArrowDirections = [.down, .up]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presentationController?.present(alertController, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">pickerController</span><span class="params">(<span class="number">_</span> controller: UIImagePickerController, didSelect url: URL?)</span></span> &#123;</span><br><span class="line">        controller.dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.delegate?.didSelect(url: url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">VideoPicker</span>: <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pickerController(picker, didSelect: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: <span class="keyword">Any</span>])</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url = info[.mediaURL] <span class="keyword">as</span>? <span class="type">URL</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.pickerController(picker, didSelect: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //uncomment this if you want to save the video file to the media library</span></span><br><span class="line"><span class="comment">//        if UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(url.path) &#123;</span></span><br><span class="line"><span class="comment">//            UISaveVideoAtPathToSavedPhotosAlbum(url.path, self, nil, nil)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController(picker, didSelect: url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">VideoPicker</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅有一些小的变化。 第一个是 <code>mediaTypes</code> 属性，你这次可以使用 <code>“public.movie”</code> 值。 另外，你还应该在 <code>pickerController</code> 上设置 <code>videoQuality</code> 属性，因为 <code>4k</code> 始终优于 <code>320</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;委托是最后一点改变的事情。 选择器完成工作后，你可以获取 <code>.mediaURL</code> 属性，该属性是获取媒体文件（也就是捕获/选定的视频文件）的 <code>URL</code> 。 如果记录了一个新文件，你也可以将其保存到媒体库中，这只是两行额外的代码。</p><p>恭喜，播放时间到了！ 📹</p></br><h1 id="使用AVPlayer和UIView播放视频文件"><a href="#使用AVPlayer和UIView播放视频文件" class="headerlink" title="使用AVPlayer和UIView播放视频文件"></a><strong>使用AVPlayer和UIView播放视频文件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当网页的标题背景中有一些主题很好的视频时，这不是很好吗？好吧，通过使用 <code>AVFoundation</code> ， <code>UIKit</code> 和一些底层魔术，你可以在 <code>iOS</code> 中获得完全相同的东西。不用担心，这并不困难。 😬</p><p>你可以使用常规的 <code>UIView</code> 子类，然后将其默认层替换为 <code>AVPlayerLayer</code> 。这样你就可以在视图中直接播放视频。同样， <code>AVPlayer</code> 只是一个简单的控制器对象，可以管理媒体文件的播放和定时。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最困难的部分是检查媒体文件的状态更改。例如，当我第一次尝试录制新视频时，播放器视图的回报在第二秒后不断停止。我必须搜索答案，因为我根本不是 <code>AVFoundation</code> 专家，但是事实证明，你应该注意 <code>rate</code> 属性，因为系统正在尝试缓冲视频，这可能会引起一些问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，我能够将一个相当不错的 <code>VideoView</code> 与一些不错的附加功能放在一起，例如不断循环播放视频或在填充/适合纵横比内容模式之间进行选择。我并不是在告诉你这是 <code>100％</code> 的防弹解决方案，但这是一个很好的起点，而且在某些情况下还绰绰有余。 👻</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Repeat</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> once</span><br><span class="line">        <span class="keyword">case</span> loop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">layerClass</span>: <span class="title">AnyClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AVPlayerLayer</span>.<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> playerLayer: <span class="type">AVPlayerLayer</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.layer <span class="keyword">as</span>! <span class="type">AVPlayerLayer</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> player: <span class="type">AVPlayer?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.playerLayer.player</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.playerLayer.player = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="keyword">var</span> contentMode: <span class="type">UIView</span>.<span class="type">ContentMode</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> <span class="keyword">self</span>.contentMode &#123;</span><br><span class="line">            <span class="keyword">case</span> .scaleAspectFit:</span><br><span class="line">                <span class="keyword">self</span>.playerLayer.videoGravity = .resizeAspect</span><br><span class="line">            <span class="keyword">case</span> .scaleAspectFill:</span><br><span class="line">                <span class="keyword">self</span>.playerLayer.videoGravity = .resizeAspectFill</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">self</span>.playerLayer.videoGravity = .resize</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> `<span class="keyword">repeat</span>`: <span class="type">Repeat</span> = .once</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> url: <span class="type">URL?</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="keyword">self</span>.url <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.teardown()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.setup(url: url)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(*, unavailable)</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(*, unavailable)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.teardown()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">(url: URL)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player = <span class="type">AVPlayer</span>(playerItem: <span class="type">AVPlayerItem</span>(url: url))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player?.currentItem?.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                              forKeyPath: <span class="string">"status"</span>,</span><br><span class="line">                                              options: [.old, .new],</span><br><span class="line">                                              context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player?.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"rate"</span>, options: [.old, .new], context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                               selector: #selector(<span class="keyword">self</span>.itemDidPlayToEndTime(<span class="number">_</span>:)),</span><br><span class="line">                                               name: .<span class="type">AVPlayerItemDidPlayToEndTime</span>,</span><br><span class="line">                                               object: <span class="keyword">self</span>.player?.currentItem)</span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                               selector: #selector(<span class="keyword">self</span>.itemFailedToPlayToEndTime(<span class="number">_</span>:)),</span><br><span class="line">                                               name: .<span class="type">AVPlayerItemFailedToPlayToEndTime</span>,</span><br><span class="line">                                               object: <span class="keyword">self</span>.player?.currentItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.player?.pause()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player?.currentItem?.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"status"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player?.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"rate"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>,</span><br><span class="line">                                                  name: .<span class="type">AVPlayerItemDidPlayToEndTime</span>,</span><br><span class="line">                                                  object: <span class="keyword">self</span>.player?.currentItem)</span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>,</span><br><span class="line">                                                  name: .<span class="type">AVPlayerItemFailedToPlayToEndTime</span>,</span><br><span class="line">                                                  object: <span class="keyword">self</span>.player?.currentItem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">itemDidPlayToEndTime</span><span class="params">(<span class="number">_</span> notification: NSNotification)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span>.<span class="keyword">repeat</span> == .loop <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.player?.seek(to: .zero)</span><br><span class="line">        <span class="keyword">self</span>.player?.play()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">itemFailedToPlayToEndTime</span><span class="params">(<span class="number">_</span> notification: NSNotification)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.teardown()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          of object: <span class="keyword">Any</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> keyPath == <span class="string">"status"</span>, <span class="keyword">let</span> status = <span class="keyword">self</span>.player?.currentItem?.status, status == .failed &#123;</span><br><span class="line">            <span class="keyword">self</span>.teardown()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">            keyPath == <span class="string">"rate"</span>,</span><br><span class="line">            <span class="keyword">let</span> player = <span class="keyword">self</span>.player,</span><br><span class="line">            player.rate == <span class="number">0</span>,</span><br><span class="line">            <span class="keyword">let</span> item = player.currentItem,</span><br><span class="line">            !item.isPlaybackBufferEmpty,</span><br><span class="line">            <span class="type">CMTimeGetSeconds</span>(item.duration) != <span class="type">CMTimeGetSeconds</span>(player.currentTime())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">self</span>.player?.play()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我为你制作了一个示例项目，说实话，我的视图控制器很简单。 它演示了图像拾取和视频捕获功能。 ❤️</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何使用视频选择器控制器和 &lt;code&gt;AVPlayer&lt;/code&gt; 类（完全用 &lt;code&gt;Swift 5&lt;/code&gt; 编写）来记录或选择视频文件。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;让我们挑选一些视频！&quot;&gt;&lt;a href=&quot;#让我们挑选一些视频！&quot; class=&quot;headerlink&quot; title=&quot;让我们挑选一些视频！&quot;&gt;&lt;/a&gt;&lt;strong&gt;让我们挑选一些视频！&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你还记得我以前有关 &lt;a href=&quot;http://www.xuebaonline.com/Swift%205%E4%BD%BF%E7%94%A8UIImagePickerController%E6%8B%BE%E5%8F%96%E5%9B%BE%E5%83%8F/&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;code&gt;《iOS中图像拾取》&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; 的教程，那么你知道我已经在 &lt;code&gt;UIKit&lt;/code&gt; 的基础上建立了一个可重用的选择器类。 如果你不知道 &lt;code&gt;UIImagePickerController&lt;/code&gt; 类的工作方式，请先阅读该教程，因为它为你提供了有关基础知识的出色概述。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先，你需要在 &lt;code&gt;Info.plist&lt;/code&gt; 文件中添加一些密钥，因为你想访问一些个人数据。 你知道：隐私非常重要。 🤫&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="UIImagePickerController" scheme="http://www.xuebaonline.com/categories/UIImagePickerController/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="UIImagePickerController" scheme="http://www.xuebaonline.com/tags/UIImagePickerController/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5使用UIImagePickerController拾取图像</title>
    <link href="http://www.xuebaonline.com/Swift%205%E4%BD%BF%E7%94%A8UIImagePickerController%E6%8B%BE%E5%8F%96%E5%9B%BE%E5%83%8F/"/>
    <id>http://www.xuebaonline.com/Swift%205%E4%BD%BF%E7%94%A8UIImagePickerController%E6%8B%BE%E5%8F%96%E5%9B%BE%E5%83%8F/</id>
    <published>2020-04-28T07:22:56.000Z</published>
    <updated>2020-04-28T07:58:20.027Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>Swift 5</code> 中的 <code>UIImagePickerController</code> 类从照片库或直接从相机获取图像。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还在寻找视频选择器吗？ 🍿查看我的另一篇有关在 <a href="http://www.xuebaonline.com/Swift%20%E9%80%89%E6%8B%A9%E5%92%8C%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/"><strong><em><code>《iOS中选择和播放视频文件》</code></em></strong></a> 的文章。</p></blockquote></br><h1 id="适用于iOS的可重用图像选择器类"><a href="#适用于iOS的可重用图像选择器类" class="headerlink" title="适用于iOS的可重用图像选择器类"></a><strong>适用于iOS的可重用图像选择器类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在本教程中，我们将创建一个在 <code>UIKit</code> 之上构建的可重用类，以使图像选择对于你的应用程序而言更加愉悦，所有内容均以 <code>Swift 5</code> 编写。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文的灵感来自于我以前尝试以面向协议的方式解决图像拾取问题，但是如今该文章有些过时，而且我不再使用该技术。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;人们总是从过去中学到东西，所以这次我不使用面向协议的方法，而只是使用 <code>ImagePicker</code> 类。 没有单例，没有额外的库，只有一个可以在适当位置实例化的小型帮助程序类可以完成它的工作。 🌄</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我只专注于选择编辑后的图像，如果你想使用实时照片或电影，则始终可以自定义 <code>ImagePicker</code> 类，或创建一个抽象类并为每种媒体类型实现子类。 我也会这样做。 😅</p></blockquote><p>因此，让我们深入研究。</p></br><h1 id="获取隐私权限"><a href="#获取隐私权限" class="headerlink" title="获取隐私权限"></a><strong>获取隐私权限</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，隐私非常重要，因此你必须在应用程序 <code>Info.plist</code> 文件中添加两个重要的键，否则最终将导致可怕的崩溃！ ⚠️</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp1.jpg" alt="Info.plist"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于你要获取一些私人数据，因此必须向用户（和 <code>Apple</code> ）提供说明消息，说明该应用为何要求访问相机和照片库。  <code>NSCameraUsageDescription</code> 用于相机， <code>NSPhotoLibraryUsageDescription</code> 键用于照片库访问。 这两个值都应该是一个简单的字符串，该字符串将向用户解释你为什么需要他/她的裸照。 谨慎很重要！ 🔒</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;<span class="type">NSCameraUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to take pictures.&lt;/string&gt;</span><br><span class="line">&lt;key&gt;<span class="type">NSPhotoLibraryUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to use your photos.&lt;/string&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，如果你想使用直接从相机拍摄的照片，但又不想访问照片库，则只需添加适当的密钥即可。 就是这样，现在我们准备进行一些实际的编码。 ⌨️</p></br><h1 id="剖析-UIImagePickerController"><a href="#剖析-UIImagePickerController" class="headerlink" title="剖析 UIImagePickerController"></a><strong>剖析 UIImagePickerController</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIPickerController</code> 的结构非常简单。 基本上，它是一个常规的视图控制器，你只需设置一些额外的属性即可使其工作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pickerController = <span class="type">UIImagePickerController</span>()</span><br><span class="line">pickerController.delegate = <span class="keyword">self</span></span><br><span class="line">pickerController.allowsEditing = <span class="literal">true</span></span><br><span class="line">pickerController.mediaTypes = [<span class="string">"public.image"</span>, <span class="string">"public.movie"</span>]</span><br><span class="line">pickerController.sourceType = .camera</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许编辑是一个标志，指示在选择和拍照后是否应显示调整大小和裁剪界面，如果为 <code>true</code> ，则应使用 <code>.editedImage</code> 而不是 <code>.originalImage</code> 键（在选择器委托中），以从中获取正确的图像。图片信息字典。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本上有两种媒体类型可用：图像和电影。你可以通过在选择器上调用类方法来获取每种源类型的可用媒体类型字符串： <code>UIImagePickerController.availableMediaTypes（for：.camera）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共有3种可用的源类型：<code>.camera</code>（即相机），还有另外两个选项可从照片库中获取图片。 <code>.photoLibrary</code> 枚举例将为你提供完全访问权限，但如果选择 <code>.savedPhotosAlbum</code> ，则只能限制相机胶卷的选择范围。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该委托应同时实现 <code>UIImagePickerControllerDelegate</code> 和 <code>UINavigationControllerDelegate</code> 协议，但是通常我的导航控制器委托只是一个空的实现。如果你需要额外的导航相关逻辑，则可能还需要在其中创建一些方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;噢，让我们把所有东西放在一起…</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ImagePickerDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didSelect</span><span class="params">(image: UIImage?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ImagePicker</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> pickerController: <span class="type">UIImagePickerController</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> presentationController: <span class="type">UIViewController?</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">ImagePickerDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(presentationController: <span class="type">UIViewController</span>, delegate: <span class="type">ImagePickerDelegate</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.pickerController = <span class="type">UIImagePickerController</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presentationController = presentationController</span><br><span class="line">        <span class="keyword">self</span>.delegate = delegate</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.pickerController.delegate = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController.allowsEditing = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController.mediaTypes = [<span class="string">"public.image"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(<span class="keyword">for</span> type: UIImagePickerController.SourceType, title: String)</span></span> -&gt; <span class="type">UIAlertAction?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="type">UIImagePickerController</span>.isSourceTypeAvailable(type) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIAlertAction</span>(title: title, style: .<span class="keyword">default</span>) &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.pickerController.sourceType = type</span><br><span class="line">            <span class="keyword">self</span>.presentationController?.present(<span class="keyword">self</span>.pickerController, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(from sourceView: UIView)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="literal">nil</span>, message: <span class="literal">nil</span>, preferredStyle: .actionSheet)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .camera, title: <span class="string">"Take photo"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .savedPhotosAlbum, title: <span class="string">"Camera roll"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .photoLibrary, title: <span class="string">"Photo library"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        alertController.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"Cancel"</span>, style: .cancel, handler: <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="type">UIDevice</span>.current.userInterfaceIdiom == .pad &#123;</span><br><span class="line">            alertController.popoverPresentationController?.sourceView = sourceView</span><br><span class="line">            alertController.popoverPresentationController?.sourceRect = sourceView.bounds</span><br><span class="line">            alertController.popoverPresentationController?.permittedArrowDirections = [.down, .up]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presentationController?.present(alertController, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">pickerController</span><span class="params">(<span class="number">_</span> controller: UIImagePickerController, didSelect image: UIImage?)</span></span> &#123;</span><br><span class="line">        controller.dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.delegate?.didSelect(image: image)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImagePicker</span>: <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pickerController(picker, didSelect: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: <span class="keyword">Any</span>])</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = info[.editedImage] <span class="keyword">as</span>? <span class="type">UIImage</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.pickerController(picker, didSelect: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.pickerController(picker, didSelect: image)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImagePicker</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不需要从源类型中进行选择，那么事情就非常简单了，你只需展示你的选择器视图控制器，处理委托中的所有内容即可。 但是，如果你需要从输入源中进行选择，那会涉及更多的逻辑，尤其是在 <code>iPad</code> 上。 📱</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我正在使用 <code>UIAlertController</code> 来组成源类型选择对话框。 我试图添加3个动作（基于选择源类型），但前提是该源类型在给定设备上可用（例如，<code>.camera</code> 在模拟器中不可用）。 你可以通过以下方式检查可用性：<code>UIImagePickerController.isSourceTypeAvailable（type）</code> 。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIAlertController</code> 在 <code>iPad</code> 上需要一些额外的东西，这就是为什么我要在本方法中设置 <code>popoverPresentationController</code> 属性的原因。 通常只需设置 <code>sourceView</code> 和 <code>sourceRect</code> 属性即可，但是你也可以自定义箭头方向。 ⬅️➡️⬆️⬇️</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检查设备是否为 ··· 并设置正确的源代码视图并根据需要进行调整一直是你的任务，否则你的应用将在 <code>iPad</code> 上崩溃。 另一件事是，在选择器完成工作后，你必须弹出 ··· ！ ⚠️</p></br><h1 id="如何使用图像选择器类？"><a href="#如何使用图像选择器类？" class="headerlink" title="如何使用图像选择器类？"></a><strong>如何使用图像选择器类？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，现在你可以拍照了。 我做了一个简单的视图控制器，向你展示了一个真正的快速示例。 你只需要一个 <code>UIImageView</code> 和一个 <code>UIButton</code> 。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp2-1.jpg" alt="UIImageView"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，这是示例视图控制器的代码。 没什么了不起的，我只是将控制器作为 <code>ImagePicker</code> 的 <code>presentationController</code> 进行传递，因此它可以在此之上呈现 <code>UIImagePickerController</code> 。 我将代表从表示控制器中分离出来，因为有时会派上用场。 🤷‍♂️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> imagePicker: <span class="type">ImagePicker!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imagePicker = <span class="type">ImagePicker</span>(presentationController: <span class="keyword">self</span>, delegate: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">showImagePicker</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.imagePicker.present(from: sender)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">ImagePickerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didSelect</span><span class="params">(image: UIImage?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下， <code>ImagePickerDelegate</code> 委托是我能想到的最简单的委托。 它只是给出选择的图像，因此你可以使用它。 但是，在某些情况下，你可能需要图像选择器提供一些附加信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想进一步采取这种方法，则可以创建定义基本功能的抽象类或协议，并在此基础上实现各种媒体选择器控制器以满足你的需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何使用 &lt;code&gt;Swift 5&lt;/code&gt; 中的 &lt;code&gt;UIImagePickerController&lt;/code&gt; 类从照片库或直接从相机获取图像。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;提示:&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;你还在寻找视频选择器吗？ 🍿查看我的另一篇有关在 &lt;a href=&quot;http://www.xuebaonline.com/Swift%20%E9%80%89%E6%8B%A9%E5%92%8C%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;code&gt;《iOS中选择和播放视频文件》&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; 的文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/br&gt;

&lt;h1 id=&quot;适用于iOS的可重用图像选择器类&quot;&gt;&lt;a href=&quot;#适用于iOS的可重用图像选择器类&quot; class=&quot;headerlink&quot; title=&quot;适用于iOS的可重用图像选择器类&quot;&gt;&lt;/a&gt;&lt;strong&gt;适用于iOS的可重用图像选择器类&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此，在本教程中，我们将创建一个在 &lt;code&gt;UIKit&lt;/code&gt; 之上构建的可重用类，以使图像选择对于你的应用程序而言更加愉悦，所有内容均以 &lt;code&gt;Swift 5&lt;/code&gt; 编写。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="UIImagePickerController" scheme="http://www.xuebaonline.com/categories/UIImagePickerController/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="UIImagePickerController" scheme="http://www.xuebaonline.com/tags/UIImagePickerController/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的UITableView教程</title>
    <link href="http://www.xuebaonline.com/Swift%E4%B8%AD%E7%9A%84UITableView%E6%95%99%E7%A8%8B/"/>
    <id>http://www.xuebaonline.com/Swift%E4%B8%AD%E7%9A%84UITableView%E6%95%99%E7%A8%8B/</id>
    <published>2020-04-28T03:46:56.000Z</published>
    <updated>2020-04-28T04:13:04.590Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本指南是供初学者通过 <code>Swift</code> 中的自动布局以编程方式学习 <code>UITableView</code> 类的基础的。</p></br><h1 id="如何以代码方式创建表视图？"><a href="#如何以代码方式创建表视图？" class="headerlink" title="如何以代码方式创建表视图？"></a><strong>如何以代码方式创建表视图？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们直接进入编码部分，但首先：启动 <code>Xcode</code> ，创建一个新的 <code>iOS</code> 单视图应用程序项目，像往常一样输入该项目的名称和详细信息，使用 <code>Swift</code> ，最后立即打开 <code>ViewController.swift</code> 文件。 现在抓住键盘！ ⌨️</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本教程中，我不会使用 <code>Interface Builder</code> ，那么我们如何以代码方式创建视图？ 有一个称为 <code>loadView</code> 的方法，你应该在其中将自定义视图添加到视图层次结构中。 你可以选择+单击Xcode中的方法名称并阅读有关 <code>loadView</code> 方法的讨论，但让我总结一下整个过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将使用弱属性来保存对表格视图的引用。 接下来，我们重写 <code>loadView</code> 方法并调用 <code>super</code> ，以使用视图对象（如果有控制器的话，在 <code>nib or a storyboard</code> 文件中）加载控制器的 <code>self.view</code> 属性。 之后，我们将全新的视图分配给本地属性，关闭系统提供的布局，然后将表视图插入到视图层次结构中。 最后，我们使用锚创建一些实际的约束，并保存指向弱属性的指针。 简单！ 🤪</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tableView: <span class="type">UITableView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> tableView = <span class="type">UITableView</span>(frame: .zero, style: .plain)</span><br><span class="line">        tableView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(tableView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">        <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor.constraint(equalTo: tableView.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: tableView.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.leadingAnchor.constraint(equalTo: tableView.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.trailingAnchor.constraint(equalTo: tableView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.tableView = tableView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;始终使用自动布局锚来指定视图约束，如果你不知道如何使用它们，请查看 <a href="http://www.xuebaonline.com/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/"><strong><em><code>《Swift使用布局锚点添加约束》</code></em></strong></a>，学习此 <code>API</code> 仅需15分钟，并且你不会后悔。 对于任何 <code>iOS</code> 开发者来说，这都是一个非常有用的工具！ 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会问：我应该使用弱属性还是强属性作为视图引用？ 我会说，在大多数情况下，如果你不压制 <code>self.view</code> ，则应使用弱项！ 视图层次结构将通过强大的参考来保存你的自定义视图，因此不需要愚蠢的保留周期和内存泄漏。 相信我！ 🤥</p></br><h1 id="UITableView-DataSource"><a href="#UITableView-DataSource" class="headerlink" title="UITableView DataSource"></a><strong>UITableView DataSource</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，我们有一个空的表格视图，让我们显示一些单元格！ 为了用真实数据填充表格视图，我们必须遵守 <code>UITableViewDataSource</code> 协议。 通过简单的委托模式，我们可以为 <code>UITableView</code> 类提供各种信息，因此它将知道需要多少节和行，应该为每行显示哪种单元格以及更多的小细节。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一件事是，<code>UITableView</code> 是一个非常有效的类。 它会重用当前屏幕上未显示的所有单元格，因此，如果你需要处理数百或数千个项目，它将消耗比 <code>UIScrollView</code> 更少的内存。 为了支持这种行为，我们必须使用重用标识符注册我们的单元格类，因此基础系统将知道特定位置需要哪种单元格。 ⚙️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">String</span>] = [</span><br><span class="line">        <span class="string">"👽"</span>, <span class="string">"🐱"</span>, <span class="string">"🐔"</span>, <span class="string">"🐶"</span>, <span class="string">"🦊"</span>, <span class="string">"🐵"</span>, <span class="string">"🐼"</span>, <span class="string">"🐷"</span>, <span class="string">"💩"</span>, <span class="string">"🐰"</span>,</span><br><span class="line">        <span class="string">"🤖"</span>, <span class="string">"🦄"</span>, <span class="string">"🐻"</span>, <span class="string">"🐲"</span>, <span class="string">"🦁"</span>, <span class="string">"💀"</span>, <span class="string">"🐨"</span>, <span class="string">"🐯"</span>, <span class="string">"👻"</span>, <span class="string">"🦖"</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.tableView.register(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"UITableViewCell"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"UITableViewCell"</span>, <span class="keyword">for</span>: indexPath)</span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.items[indexPath.item]</span><br><span class="line">        cell.textLabel?.text = item</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的视图控制器文件中添加几行代码后，表格视图现在可以显示一个漂亮的表情符号列表！ 我们正在使用 <code>UIKit</code> 的内置 <code>UITableViewCell</code> 类，如果你很好地使用 <code>“iOS-system-like”</code> 的单元格设计，那么它将非常方便。 通过告诉我们的节中有多少项（目前只有一个节），我们还符合数据源协议，并在 <code>indexPath</code> 委托方法的行中为行配置了我们的单元格。 😎</p></br><h1 id="自定义UItableViewCell"><a href="#自定义UItableViewCell" class="headerlink" title="自定义UItableViewCell"></a><strong>自定义UItableViewCell</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UITableViewCell</code> 可以提供一些基本元素来显示数据（标题，详细信息，不同样式的图像），但是通常你需要自定义设计的单元格。 这是自定义单元格子类的基本模板，在代码之后，我将解释所有方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>, reuseIdentifier: <span class="type">String?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    override func awakeFromNib() &#123;</span></span><br><span class="line"><span class="comment">        super.awakeFromNib()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>如果要以编程方式使用默认的UITableViewCell</code> ，但使用不同的样式（在初始化单元格后没有设置 <code>cellStyle</code> 的选项），则 <code>init（style：reuseIdentifier</code>） 方法是重写单元格样式属性的好地方。 例如，如果你需要一个 <code>.value1</code> 样式的单元格，只需将参数直接传递给超级调用即可。 这样，你可以使用 <code>4</code> 种预定义的单元格样式。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还必须实现 <code>init（coder :)</code>，所以你应该创建一个通用的 <code>initialize（）</code> 函数，在其中你可以在视图层次结构中添加自定义视图，就像我们在上面的 <code>loadView</code> 方法中所做的那样。 如果使用的是 <code>xib</code> 文件和 <code>IB</code> ，则可以使用 <code>awakeFromNib</code> 方法通过标准 <code>@IBOutlet</code> 属性为视图添加额外的样式（或向层次结构中添加额外的视图）。 👍</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要讨论的最后一个方法是 <code>prepareForReuse</code> 。 正如我之前提到的，单元格被重用，因此，如果要重置某些属性（例如单元格的背景），可以在此处进行操作。 在单元将被重用之前将调用此方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们创建两个新的单元格子类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>, reuseIdentifier: <span class="type">String?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(style: .subtitle, reuseIdentifier: reuseIdentifier)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// nothing to do here :)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel?.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel?.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.imageView?.image = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的自定义单元格将具有大的图像背景，并在视图的中心添加一个带有自定义大小的系统字体的标题标签。 另外，我已将 S<code>wift logo</code> 作为 <code>asset</code> 添加到项目中，因此我们可以得到一个不错的演示图像。 🖼</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> coverView: <span class="type">UIImageView!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> titleLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>, reuseIdentifier: <span class="type">String?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> coverView = <span class="type">UIImageView</span>(frame: .zero)</span><br><span class="line">        coverView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(coverView)</span><br><span class="line">        <span class="keyword">self</span>.coverView = coverView</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> titleLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        titleLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(titleLabel)</span><br><span class="line">        <span class="keyword">self</span>.titleLabel = titleLabel</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.coverView.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.coverView.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.coverView.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.coverView.trailingAnchor),</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.contentView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.titleLabel.centerXAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.titleLabel.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.titleLabel.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.coverView.image = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，让我们开始使用这些新单元格。 我什至会告诉你如何为给定单元格设置自定义高度，以及如何正确处理单元格选择，但是首先我们需要了解另一个委托协议。 🤝</p></br><h1 id="UITableViewDelegate-使用"><a href="#UITableViewDelegate-使用" class="headerlink" title="UITableViewDelegate 使用"></a><strong>UITableViewDelegate 使用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UITableViewDelegate</code> 负责很多事情，但是现在，我们将只讨论一些有趣的方面，例如如何处理单元格选择以及为表格中的每个项目提供自定义单元格高度。 示例代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.tableView.register(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"UITableViewCell"</span>)</span><br><span class="line">            <span class="keyword">self</span>.tableView.register(<span class="type">DetailCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"DetailCell"</span>)</span><br><span class="line">            <span class="keyword">self</span>.tableView.register(<span class="type">CustomCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"CustomCell"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">            <span class="keyword">self</span>.tableView.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"CustomCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">CustomCell</span></span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.items[indexPath.item]</span><br><span class="line">        cell.titleLabel.text = item</span><br><span class="line">        cell.coverView.image = <span class="type">UIImage</span>(named: <span class="string">"Swift"</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">128</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        tableView.deselectRow(at: indexPath, animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.items[indexPath.item]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: item, message: <span class="string">"is in da house!"</span>, preferredStyle: .alert)</span><br><span class="line">        <span class="keyword">let</span> action = <span class="type">UIAlertAction</span>(title: <span class="string">"Ok"</span>, style: .<span class="keyword">default</span>) &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;</span><br><span class="line">        alertController.addAction(action)</span><br><span class="line">        <span class="keyword">self</span>.present(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我正在 <code>viewDidLoad</code> 方法中注册全新的自定义单元格类。 我还更改了 <code>cellForRowAt indexPath</code> 方法中的代码，因此我们可以使用 <code>CustomCell</code> 类代替 <code>UITableViewCells</code> 。 不必担心强制转换，如果此时出现问题，你的应用程序应该崩溃。 🙃</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在这里使用两种委托方法。 在第一个中，我们必须返回一个数字，系统将使用该高度作为单元格。 如果要在每行中使用不同的单元格高度，则也可以通过检查 <code>indexPath</code> 属性或类似属性来实现。 第二个是选择的处理程序。 如果有人点击某个单元格，则将调用此方法，你可以执行一些操作。</p></br><h1 id="带标题和页脚的-Section"><a href="#带标题和页脚的-Section" class="headerlink" title="带标题和页脚的 Section"></a><strong>带标题和页脚的 Section</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表格视图中可能有多个部分，我不会赘述，因为它非常简单。 你只需要使用 <code>indexPaths</code> 即可获取/设置/返回每个节和单元格的正确数据。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tableView: <span class="type">UITableView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> placeholderView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">    <span class="keyword">var</span> isPullingDown = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> `<span class="keyword">default</span>`</span><br><span class="line">        <span class="keyword">case</span> subtitle</span><br><span class="line">        <span class="keyword">case</span> custom</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> style = <span class="type">Style</span>.<span class="keyword">default</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">String</span>: [<span class="type">String</span>]] = [</span><br><span class="line">        <span class="string">"Originals"</span>: [<span class="string">"👽"</span>, <span class="string">"🐱"</span>, <span class="string">"🐔"</span>, <span class="string">"🐶"</span>, <span class="string">"🦊"</span>, <span class="string">"🐵"</span>, <span class="string">"🐼"</span>, <span class="string">"🐷"</span>, <span class="string">"💩"</span>, <span class="string">"🐰"</span>,<span class="string">"🤖"</span>, <span class="string">"🦄"</span>],</span><br><span class="line">        <span class="string">"iOS 11.3"</span>: [<span class="string">"🐻"</span>, <span class="string">"🐲"</span>, <span class="string">"🦁"</span>, <span class="string">"💀"</span>],</span><br><span class="line">        <span class="string">"iOS 12"</span>: [<span class="string">"🐨"</span>, <span class="string">"🐯"</span>, <span class="string">"👻"</span>, <span class="string">"🦖"</span>],</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> tableView = <span class="type">UITableView</span>(frame: .zero, style: .plain)</span><br><span class="line">        tableView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(tableView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor.constraint(equalTo: tableView.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: tableView.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.leadingAnchor.constraint(equalTo: tableView.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.trailingAnchor.constraint(equalTo: tableView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.tableView = tableView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.tableView.register(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"UITableViewCell"</span>)</span><br><span class="line">        <span class="keyword">self</span>.tableView.register(<span class="type">DetailCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"DetailCell"</span>)</span><br><span class="line">        <span class="keyword">self</span>.tableView.register(<span class="type">CustomCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"CustomCell"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.tableView.delegate = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.tableView.separatorStyle = .singleLine</span><br><span class="line">        <span class="keyword">self</span>.tableView.separatorColor = .lightGray</span><br><span class="line">        <span class="keyword">self</span>.tableView.separatorInset = .zero</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.navigationItem.rightBarButtonItem = .<span class="keyword">init</span>(barButtonSystemItem: .refresh, target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.toggleCells))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">toggleCells</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>.style &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">self</span>.style = .subtitle</span><br><span class="line">        <span class="keyword">case</span> .subtitle:</span><br><span class="line">            <span class="keyword">self</span>.style = .custom</span><br><span class="line">        <span class="keyword">case</span> .custom:</span><br><span class="line">            <span class="keyword">self</span>.style = .<span class="keyword">default</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">self</span>.tableView.reloadData()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - helpers</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">key</span><span class="params">(<span class="keyword">for</span> section: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> keys = <span class="type">Array</span>(<span class="keyword">self</span>.items.keys).sorted &#123; first, last -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> first == <span class="string">"Originals"</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> first &lt; last</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> key = keys[section]</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">items</span><span class="params">(<span class="keyword">in</span> section: Int)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> key = <span class="keyword">self</span>.key(<span class="keyword">for</span>: section)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.items[key]!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">item</span><span class="params">(at indexPath: IndexPath)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> items = <span class="keyword">self</span>.items(<span class="keyword">in</span>: indexPath.section)</span><br><span class="line">        <span class="keyword">return</span> items[indexPath.item]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.items.keys.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.items(<span class="keyword">in</span>: section).<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.item(at: indexPath)</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"CustomCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">CustomCell</span></span><br><span class="line">        cell.titleLabel.text = item</span><br><span class="line">        cell.coverView.image = <span class="type">UIImage</span>(named: <span class="string">"Swift"</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, titleForHeaderInSection section: Int)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.key(<span class="keyword">for</span>: section)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">128</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        tableView.deselectRow(at: indexPath, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.item(at: indexPath)</span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: item, message: <span class="string">"is in da house!"</span>, preferredStyle: .alert)</span><br><span class="line">        <span class="keyword">let</span> action = <span class="type">UIAlertAction</span>(title: <span class="string">"Ok"</span>, style: .<span class="keyword">default</span>) &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;</span><br><span class="line">        alertController.addAction(action)</span><br><span class="line">        <span class="keyword">self</span>.present(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管上面的代码片段中添加了一个有趣的内容。 你可以为每个部分都有一个自定义标题，只需添加 <code>titleForHeaderInSection</code> 数据源方法即可。 是的，看起来像狗屎一样，但这与 <code>UI / UX</code> 无关。 😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果你对部分标题的布局不满意，可以创建一个自定义类并使用它来代替内置类。 这是执行自定义节标题视图的方法。 这是可重用视图的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeaderView</span>: <span class="title">UITableViewHeaderFooterView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> titleLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(reuseIdentifier: <span class="type">String?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(reuseIdentifier: reuseIdentifier)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> titleLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        titleLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(titleLabel)</span><br><span class="line">        <span class="keyword">self</span>.titleLabel = titleLabel</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.titleLabel.centerXAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.titleLabel.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.contentView.backgroundColor = .black</span><br><span class="line">        <span class="keyword">self</span>.titleLabel.font = <span class="type">UIFont</span>.boldSystemFont(ofSize: <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">self</span>.titleLabel.textAlignment = .center</span><br><span class="line">        <span class="keyword">self</span>.titleLabel.textColor = .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只剩下几件事要做，你必须注册标题视图，就像你为单元格所做的一样。 完全相同，只是页眉和页脚视图有一个单独的注册“池”。 最后，你必须实现两个其他但相对简单（和熟悉）的委托方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This goes to viewDidLoad, but I don't want to embedd that much code... :)</span></span><br><span class="line"><span class="comment">// self.tableView.register(HeaderView.self, forHeaderFooterViewReuseIdentifier: "HeaderView")</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">32</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, viewForHeaderInSection section: Int)</span></span> -&gt; <span class="type">UIView?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view = tableView.dequeueReusableHeaderFooterView(withIdentifier: <span class="string">"HeaderView"</span>) <span class="keyword">as</span>! <span class="type">HeaderView</span></span><br><span class="line">        view.titleLabel.text = <span class="keyword">self</span>.key(<span class="keyword">for</span>: section)</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>页脚的工作原理与页眉完全相同，只需支持相应的数据源和委托方法即可。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据行或节的索引或任何特定的业务需求，你甚至可以在同一张表视图中具有多个单元格。 我不会在这里进行演示，因为我有一个更好的解决方案，用于混合和重用 <a href="https://gitlab.com/corekit/CoreKit" target="_blank" rel="noopener"><strong><em><code>CoreKit</code></em></strong></a> 框架中的单元格。  🤓</p></br><h1 id="Section-titles-amp-indexes"><a href="#Section-titles-amp-indexes" class="headerlink" title="Section titles &amp; indexes"></a><strong>Section titles &amp; indexes</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，如果你的大脑还没有融化，我将向你展示另外两个对于初学者来说可能很有趣的小东西。 第一个基于两种其他数据源方法，对于长列表而言，这是一个非常令人愉快的添加。 （我更喜欢搜索栏！）🤯</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sectionIndexTitles</span><span class="params">(<span class="keyword">for</span> tableView: UITableView)</span></span> -&gt; [<span class="type">String</span>]? &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要在上面实现这些方法，则可以在表视图的右侧为各节提供一个小的索引视图，因此最终用户将能够在各节之间快速跳转。 就像在官方联系人应用程序中一样。 📕</p></br><h1 id="Selection-vs-highlight"><a href="#Selection-vs-highlight" class="headerlink" title="Selection vs highlight"></a><strong>Selection vs highlight</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你用手指按住单元格时，单元格高亮。 如果你从单元格中松开手指，则将选择该单元格。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要过于复杂。 你只需在自定义单元格类中实现两个方法即可使所有工作正常进行。 我更喜欢立即取消选择我的单元格（如果某些数据选择器布局未使用它们）。 这是代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setSelected</span><span class="params">(<span class="number">_</span> selected: Bool, animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.coverView.backgroundColor = selected ? .red : .clear</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setHighlighted</span><span class="params">(<span class="number">_</span> highlighted: Bool, animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.coverView.backgroundColor = highlighted ? .blue : .clear</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，这非常简单，但是大多数初学者都不知道该怎么做。 此外，他们通常会在重用逻辑发生之前忘记重置单元格，因此列表会不断弄乱单元格状态。 不必太担心这些问题，它们会消失，因为你将对 <code>UITableView API</code> 更有经验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本指南是供初学者通过 &lt;code&gt;Swift&lt;/code&gt; 中的自动布局以编程方式学习 &lt;code&gt;UITableView&lt;/code&gt; 类的基础的。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;如何以代码方式创建表视图？&quot;&gt;&lt;a href=&quot;#如何以代码方式创建表视图？&quot; class=&quot;headerlink&quot; title=&quot;如何以代码方式创建表视图？&quot;&gt;&lt;/a&gt;&lt;strong&gt;如何以代码方式创建表视图？&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;让我们直接进入编码部分，但首先：启动 &lt;code&gt;Xcode&lt;/code&gt; ，创建一个新的 &lt;code&gt;iOS&lt;/code&gt; 单视图应用程序项目，像往常一样输入该项目的名称和详细信息，使用 &lt;code&gt;Swift&lt;/code&gt; ，最后立即打开 &lt;code&gt;ViewController.swift&lt;/code&gt; 文件。 现在抓住键盘！ ⌨️&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="UITableView" scheme="http://www.xuebaonline.com/categories/UITableView/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="UITableView" scheme="http://www.xuebaonline.com/tags/UITableView/"/>
    
  </entry>
  
  <entry>
    <title>Swift结合Xib文件自定义UIView</title>
    <link href="http://www.xuebaonline.com/Swift%E7%BB%93%E5%90%88Xib%E6%96%87%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89UIView/"/>
    <id>http://www.xuebaonline.com/Swift%E7%BB%93%E5%90%88Xib%E6%96%87%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89UIView/</id>
    <published>2020-04-28T03:02:25.000Z</published>
    <updated>2020-04-28T03:18:18.105Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是否想学习如何加载 <code>xib</code> 文件以创建自定义视图对象？ 好吧，这个 <code>UIKit</code> 教程只适合你用 <code>Swift</code> 编写。</p><p><strong><em>使用界面生成器创建自定义视图。🤷‍♂️</em></strong></p></br><h1 id="加载-Xib-文件"><a href="#加载-Xib-文件" class="headerlink" title="加载 Xib 文件"></a><strong>加载 <code>Xib</code> 文件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>xib</code> 文件的内容是一件非常容易的事。 你可以使用以下两种方法来加载文件的内容（也称为视图层次结构）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view = <span class="type">UINib</span>(nibName: <span class="string">"CustomView"</span>, bundle: .main).instantiate(withOwner: <span class="literal">nil</span>, options: <span class="literal">nil</span>).first <span class="keyword">as</span>! <span class="type">UIView</span></span><br><span class="line"><span class="comment">// let view = Bundle.main.loadNibNamed("CustomView", owner: nil, options: nil)!.first as! UIView // does the same as above</span></span><br><span class="line">view.frame = <span class="keyword">self</span>.view.bounds</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(view)</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码片段将简单地从 <code>xib</code> 文件中实例化视图对象。 你可以在视图层次结构中拥有多个根对象，但是这次让我们选择第一个并使用它。 我假设在 <code>99％</code> 的情况下，这是获取定制设计视图所需的条件。 你还可以使用上述任何解决方案扩展 <code>UIView</code> 对象，以创建通用视图加载器。 以后再说吧…😊</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法非常简单且便宜，但是有一个小缺点。 你无法获取视图的命名指针（出口），而只能获取根对象。 如果你将设计元素放到屏幕上，那很好，但是如果你需要显示动态数据，那么你可能还希望伸手去拿基础视图。 😃</p></br><h1 id="Outlets-amp-Actions-自定义视图"><a href="#Outlets-amp-Actions-自定义视图" class="headerlink" title="Outlets &amp; Actions 自定义视图"></a><strong><code>Outlets &amp; Actions</code> 自定义视图</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，从 <code>xib</code> 文件加载自定义视图的正确方法如下所示：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你的自定义视图对象中，你实例化 <code>xib</code> 文件的方式与我在此处告诉你的方式完全相同。 👆唯一的区别是你不需要使用方法返回的对象数组，而必须通过接口构建器连接视图对象，使用文件所有者作为参考点，再加上自定义容器视图出口， 它将包含你需要的一切。 🤨</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note: view object is from my previous tutorial, with autoresizing masks disabled</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this is going to be our container object</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> containerView: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// other usual outlets</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.initialize()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first: load the view hierarchy to get proper outlets</span></span><br><span class="line">        <span class="keyword">let</span> name = <span class="type">String</span>(describing: type(of: <span class="keyword">self</span>))</span><br><span class="line">        <span class="keyword">let</span> nib = <span class="type">UINib</span>(nibName: name, bundle: .main)</span><br><span class="line">        nib.instantiate(withOwner: <span class="keyword">self</span>, options: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next: append the container to our view</span></span><br><span class="line">        <span class="keyword">self</span>.addSubview(<span class="keyword">self</span>.containerView)</span><br><span class="line">        <span class="keyword">self</span>.containerView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.containerView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.containerView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.containerView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.containerView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，这里的 <code>initialize</code> 方法只是将 <code>self</code> 的所有者加载到 <code>nib</code> 文件中。 加载过程完成后，将使用 <code>xib文件</code> 中的适当值填充出口指针。 我们需要做的最后一件事。 甚至 <code>xib文件</code> 中的视图都 <code>“以编程方式”</code> 连接到我们的自定义视图对象，但从视觉上看并不是这样。 因此，我们必须将容器视图添加到视图层次结构中。 🤐</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xu-stp1.jpg" alt="xib文件"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要使用自定义视图对象，只需在视图控制器内部从该对象创建一个新实例，最后随意将其添加为子视图！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建议使用自动布局。😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> customView: <span class="type">CustomView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> customView = <span class="type">CustomView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(customView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            customView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.topAnchor),</span><br><span class="line">            customView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.bottomAnchor),</span><br><span class="line">            customView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.leadingAnchor),</span><br><span class="line">            customView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.customView = customView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.customView.textLabel.text = <span class="string">"Lorem ipsum"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，现在你有了一个可以正常工作的自定义 <code>UIView</code> 对象，该对象可以加载 <code>xib</code> 文件以使用其内容。  🤪</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一件事。 如果你不喜欢以编程方式处理视图，或者只是不想弄乱 <code>loadView</code> 方法，只需将其完全删除即可。 接下来，将 <code>@IBOutlet</code> 关键字放在自定义视图类变量之前。 使用 <code>IB</code> 打开情节提要，然后将新的 <code>UIView</code> 元素拖放到控制器上并连接自定义视图插座。 💫</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xu-stp2.png" alt="xib文件"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们来谈谈 <code>IBAction</code> ，它们的工作原理与你期望使用控制器时完全相同。 你可以简单地将按钮连接到自定义视图，然后将操作委派给自定义视图类。 如果要将触摸或特定操作转发给控制器，则应使用委托模式或使用简单的块。 😎</p></br><h1 id="所有权-容器视图"><a href="#所有权-容器视图" class="headerlink" title="所有权/容器视图"></a><strong>所有权/容器视图</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以从视图实例中省略所有 <code>xib</code> 加载机制。 我们可以创建一组扩展，以便拥有一个漂亮的视图加载器，并带有来自 <code>xib</code> 文件的自定义视图类。 这样，你就不再需要容器视图，文件所有者也可以从游戏中删除，这与 <code>Apple</code> 创建的表和集合的可重用单元格大致相同。 🍎</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该知道，以这种方式你将无法再以编程方式使用默认的 <code>UIView</code> 初始化方法，因为xib文件将负责初始化过程。 同样，如果你尝试使用情节提要或 <code>xib</code> 文件中的这种自定义视图，则将无法使用出口，因为不会加载视图类的对应 <code>xib</code> 。 否则，如果你尝试多次加载它，则会陷入无限循环，最终你的应用程序将崩溃。 😈</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UINib</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">instantiate</span><span class="params">()</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.instantiate(withOwner: <span class="literal">nil</span>, options: <span class="literal">nil</span>).first</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nib: <span class="type">UINib</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UINib</span>(nibName: <span class="type">String</span>(describing: <span class="keyword">self</span>), bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">instantiate</span><span class="params">(autolayout: Bool = <span class="literal">true</span>)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="comment">// generic helper function</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">instantiateUsingNib</span>&lt;T: UIView&gt;<span class="params">(autolayout: Bool)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> view = <span class="keyword">self</span>.nib.instantiate() <span class="keyword">as</span>! <span class="type">T</span></span><br><span class="line">            view.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">            <span class="keyword">return</span> view</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingNib(autolayout: autolayout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage (inside a view controller for example)</span></span><br><span class="line"><span class="comment">// let view = CustomView.instantiate()</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像这次使用表或集合视图单元格一样，你必须在视图对象而不是文件所有者上设置自定义视图类。 你必须连接网点，基本上你已完成了所有工作。 🤞</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xu-stp3.png" alt="xib文件"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从现在开始，你应该始终在自定义视图对象上使用实例化方法。 好消息是该函数是通用的，返回正确的实例类型，并且高度可重用。 哦，顺便说一句。 我已经提到了坏消息…🤪</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过重写 <code>awakeAfter</code> 还有另一种技术，但是我不再依赖该解决方案了。 在大多数情况下，你只需将“文件的所有者”设置为自定义视图，然后使用一个容器，这是一个安全的选择。 如果你有特殊需要，则可能需要第二种方法，但是请谨慎使用。 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;你是否想学习如何加载 &lt;code&gt;xib&lt;/code&gt; 文件以创建自定义视图对象？ 好吧，这个 &lt;code&gt;UIKit&lt;/code&gt; 教程只适合你用 &lt;code&gt;Swift&lt;/code&gt; 编写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;使用界面生成器创建自定义视图。🤷‍♂️&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;加载-Xib-文件&quot;&gt;&lt;a href=&quot;#加载-Xib-文件&quot; class=&quot;headerlink&quot; title=&quot;加载 Xib 文件&quot;&gt;&lt;/a&gt;&lt;strong&gt;加载 &lt;code&gt;Xib&lt;/code&gt; 文件&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 &lt;code&gt;xib&lt;/code&gt; 文件的内容是一件非常容易的事。 你可以使用以下两种方法来加载文件的内容（也称为视图层次结构）。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; view = &lt;span class=&quot;type&quot;&gt;UINib&lt;/span&gt;(nibName: &lt;span class=&quot;string&quot;&gt;&quot;CustomView&quot;&lt;/span&gt;, bundle: .main).instantiate(withOwner: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, options: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;).first &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;! &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// let view = Bundle.main.loadNibNamed(&quot;CustomView&quot;, owner: nil, options: nil)!.first as! UIView // does the same as above&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;view.frame = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.bounds&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.addSubview(view)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自定义UIView" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89UIView/"/>
    
  </entry>
  
  <entry>
    <title>UICollectionView data source and delegates</title>
    <link href="http://www.xuebaonline.com/UICollectionView%20data%20source%20and%20delegates/"/>
    <id>http://www.xuebaonline.com/UICollectionView%20data%20source%20and%20delegates/</id>
    <published>2020-04-28T02:31:38.000Z</published>
    <updated>2020-04-28T02:58:07.879Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个快速的 <code>UIKit</code> 教程中，我将向你展示如何在不使用 <code>Interface Builder</code> 而是仅使用 <code>Swift</code> 的情况下创建简单的 <code>UICollectionView</code> 。</p></br><h1 id="UICollectionViewCell-纯代码实现"><a href="#UICollectionViewCell-纯代码实现" class="headerlink" title="UICollectionViewCell 纯代码实现"></a><strong><code>UICollectionViewCell</code> 纯代码实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要向单元格中添加视图，则应使用 <code>init（frame :)</code> 方法，并在那里设置视图层次结构。 而不是 <code>awakeFromNib</code> ，你也应该在 <code>init</code> 方法中设置视图的样式。 你可以在常规的 <code>prepareForReuse</code> 方法中重置所有内容。 如你所见，有时使用锚点值得完全抛弃 <code>IB</code> 。 🎉</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> identifier: <span class="type">String</span> = <span class="string">"Cell"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> textLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        textLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(textLabel)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerXAnchor.constraint(equalTo: textLabel.centerXAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerYAnchor.constraint(equalTo: textLabel.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.textLabel = textLabel</span><br><span class="line">        <span class="keyword">self</span>.reset()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line">        <span class="keyword">self</span>.reset()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.textLabel.textAlignment = .center</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="UICollectionView-纯代码创建"><a href="#UICollectionView-纯代码创建" class="headerlink" title="UICollectionView 纯代码创建"></a><strong><code>UICollectionView</code> 纯代码创建</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅使用 <code>Swift</code> 代码创建集合视图控制器仅需要几行。 你可以实现 <code>loadView</code> 并在那里创建你的 <code>UICollectionView</code> 对象。 将其的弱引用存储在控制器内部，其余部分相同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data: [<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">0</span>..&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> collectionView = <span class="type">UICollectionView</span>(frame: .zero, collectionViewLayout: <span class="type">UICollectionViewFlowLayout</span>())</span><br><span class="line">        collectionView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(collectionView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.view.topAnchor.constraint(equalTo: collectionView.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.bottomAnchor.constraint(equalTo: collectionView.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.leadingAnchor.constraint(equalTo: collectionView.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.trailingAnchor.constraint(equalTo: collectionView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView = collectionView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView.dataSource = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.delegate = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.register(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="type">Cell</span>.identifier)</span><br><span class="line">        <span class="keyword">self</span>.collectionView.alwaysBounceVertical = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.backgroundColor = .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.data.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="type">Cell</span>.identifier, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">self</span>.data[indexPath.item]</span><br><span class="line">        cell.textLabel.text = <span class="type">String</span>(data)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegateFlowLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        sizeForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.bounds.width, height: <span class="number">44</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        insetForSectionAt section: Int)</span></span> -&gt; <span class="type">UIEdgeInsets</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIEdgeInsets</span>(top: <span class="number">0</span>, <span class="keyword">left</span>: <span class="number">0</span>, bottom: <span class="number">0</span>, <span class="keyword">right</span>: <span class="number">0</span>) <span class="comment">//.zero</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumInteritemSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumLineSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那很简单。 <code>Anchors</code> 确实非常强大， <code>Interface Builder</code> 很有帮助，但是有时从代码创建视图只是更快。 选择是你的，但请不要担心对用户界面进行编码！ 😅</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在这个快速的 &lt;code&gt;UIKit&lt;/code&gt; 教程中，我将向你展示如何在不使用 &lt;code&gt;Interface Builder&lt;/code&gt; 而是仅使用 &lt;code&gt;Swift&lt;/code&gt; 的情况下创建简单的 &lt;code&gt;UICollectionView&lt;/code&gt; 。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;UICollectionViewCell-纯代码实现&quot;&gt;&lt;a href=&quot;#UICollectionViewCell-纯代码实现&quot; class=&quot;headerlink&quot; title=&quot;UICollectionViewCell 纯代码实现&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;code&gt;UICollectionViewCell&lt;/code&gt; 纯代码实现&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果要向单元格中添加视图，则应使用 &lt;code&gt;init（frame :)&lt;/code&gt; 方法，并在那里设置视图层次结构。 而不是 &lt;code&gt;awakeFromNib&lt;/code&gt; ，你也应该在 &lt;code&gt;init&lt;/code&gt; 方法中设置视图的样式。 你可以在常规的 &lt;code&gt;prepareForReuse&lt;/code&gt; 方法中重置所有内容。 如你所见，有时使用锚点值得完全抛弃 &lt;code&gt;IB&lt;/code&gt; 。 🎉&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
      <category term="UICollectionView" scheme="http://www.xuebaonline.com/categories/UICollectionView/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="UICollectionView" scheme="http://www.xuebaonline.com/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>Swift中UIColor最佳实践</title>
    <link href="http://www.xuebaonline.com/Swift%E4%B8%ADUIColor%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.xuebaonline.com/Swift%E4%B8%ADUIColor%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-04-28T02:02:18.000Z</published>
    <updated>2020-04-28T02:28:41.151Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解什么是颜色模型，如何将十六进制值转换为 <code>UIColor</code> 并返回，如何生成随机颜色，以及在哪里可以找到漂亮的调色板。</p></br><h1 id="什么是色彩模型和色彩空间？"><a href="#什么是色彩模型和色彩空间？" class="headerlink" title="什么是色彩模型和色彩空间？"></a><strong>什么是色彩模型和色彩空间？</strong></h1><p>色彩模型是描述颜色的方法。</p><ul><li>RGB-红色+绿色+蓝色</li><li>HSB-色相+饱和度+亮度</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有其他几种颜色模型，但是如果你要处理 <code>iOS</code> 颜色，则应该熟悉上面的两种。 通常，你将使用 <code>RGBA</code> 和 <code>HSBA</code> 颜色模型，这些颜色模型基本上与上面的扩展相同，其中字母A代表字母 <code>Alpha</code> 。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色彩空间是可以在介质中显示或复制的一组颜色（无论是存储，打印还是显示）。 例如，<code>sRGB</code> 是红色，绿色和蓝色的一组特定强度，它定义了可以通过混合红色，绿色和蓝色的这些范围来再现的颜色。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从理论上已经足够，让我们做一些色彩魔术吧！ 💫💫💫</p><a id="more"></a></br><h1 id="如何在-Swift-中使用-RGBA-和-HSBA-值处理-UIColor-对象？"><a href="#如何在-Swift-中使用-RGBA-和-HSBA-值处理-UIColor-对象？" class="headerlink" title="如何在 Swift 中使用 RGBA 和 HSBA 值处理 UIColor 对象？"></a><strong>如何在 <code>Swift</code> 中使用 <code>RGBA</code> 和 <code>HSBA</code> 值处理 <code>UIColor</code> 对象？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还记得旧的 <code>Windows</code> 时代的旧 <code>Paint</code> 程序吗？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我经常使用 <code>Microsoft Paint</code> ，并且喜欢它。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那时，在没有任何 <code>CS</code> 知识的情况下，我一直想知道必须选择的0到255之间的数字。 如果你使用 <code>RGB</code> 颜色，通常会以相同的方式定义颜色，除了在 <code>iOS</code> 中，值介于0和1之间，但这只是 <code>255</code> 的一部分的不同表示。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，你可以使用相同的逻辑使用 <code>RGB</code> 代码制作颜色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIColor</span>(red: <span class="type">CGFloat</span>(<span class="number">128</span>)/<span class="type">CGFloat</span>(<span class="number">255</span>),</span><br><span class="line">        green: <span class="type">CGFloat</span>(<span class="number">128</span>)/<span class="type">CGFloat</span>(<span class="number">255</span>),</span><br><span class="line">        blue: <span class="type">CGFloat</span>(<span class="number">128</span>)/<span class="type">CGFloat</span>(<span class="number">255</span>),</span><br><span class="line">        alpha: <span class="number">1</span>)</span><br><span class="line"><span class="comment">// this is just about the same gray color but it's more readable</span></span><br><span class="line"><span class="type">UIColor</span>(red: <span class="number">0.5</span>, green: <span class="number">0.5</span>, blue: <span class="number">0.5</span>, alpha: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，你也可以使用HSB值，几乎相同的逻辑适用于这些值，除了色相从 <code>0&#39;</code> 到 <code>360</code>（由于实际的色轮）之外，但是饱和度和亮度以“百分比百分比”格式 <code>0-100</code> 进行测量 ，因此，如果将它们映射到浮点值，则必须考虑这些数字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIColor</span>(hue: <span class="type">CGFloat</span>(<span class="number">120</span>)/<span class="type">CGFloat</span>(<span class="number">360</span>), saturation: <span class="number">0.5</span>, brightness: <span class="number">0.5</span>, alpha: <span class="number">1</span>)</span><br><span class="line"><span class="type">UIColor</span>(hue: <span class="number">0.3</span>, saturation: <span class="number">0.5</span>, brightness: <span class="number">0.5</span>, alpha: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在让我们扭转这种情况，让我向你展示如何在扩展的帮助下从实际的 <code>UIColor</code> 实例取回这些组件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> rgba: (red: <span class="type">CGFloat</span>, green: <span class="type">CGFloat</span>, blue: <span class="type">CGFloat</span>, alpha: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> r: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> g: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> b: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> a: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)</span><br><span class="line">        <span class="keyword">return</span> (r, g, b, a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> hsba: (hue: <span class="type">CGFloat</span>, saturation: <span class="type">CGFloat</span>, brightness: <span class="type">CGFloat</span>, alpha: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> h: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> s: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> b: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> a: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.getHue(&amp;h, saturation: &amp;s, brightness: &amp;b, alpha: &amp;a)</span><br><span class="line">        <span class="keyword">return</span> (h, s, b, a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，这里是如何从 <code>UIColor</code> 读取红色，绿色蓝色斜线色调饱和度亮度和 <code>alpha</code> 分量的方法。 通过这个小巧的扩展名，你可以简单地获取组件值并通过其专有名称使用它们。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIColor</span>.yellow.rgba.red</span><br><span class="line"><span class="type">UIColor</span>.yellow.hsba.hue</span><br></pre></td></tr></table></figure></br><h1 id="如何在-Swift-中将-UIColor-对象的十六进制颜色转换为-RGB-，反之亦然？"><a href="#如何在-Swift-中将-UIColor-对象的十六进制颜色转换为-RGB-，反之亦然？" class="headerlink" title="如何在 Swift 中将 UIColor 对象的十六进制颜色转换为 RGB ，反之亦然？"></a><strong>如何在 <code>Swift</code> 中将 <code>UIColor</code> 对象的十六进制颜色转换为 <code>RGB</code> ，反之亦然？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iOS开发人员101课程，第一个问题：</p><ul><li>我该如何从十六进制字符串创建UIColor？</li><li>如何将十六进制颜色转换为UIColor？</li><li>如何使用十六进制字符串制作UIColor？</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，也许这些不是第一个问题，但是绝对是常见问题。 答案很简单：通过扩展。 对于你的需求，我有一个非常好的解决方案，它将处理大多数情况，例如仅使用1、2、3或6个十六进制值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(hex: <span class="type">Int</span>, alpha: <span class="type">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> red = <span class="type">CGFloat</span>((hex &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>) / <span class="number">255.0</span></span><br><span class="line">        <span class="keyword">let</span> green = <span class="type">CGFloat</span>((hex &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>) / <span class="number">255.0</span></span><br><span class="line">        <span class="keyword">let</span> blue = <span class="type">CGFloat</span>((hex &amp; <span class="number">0xFF</span>)) / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(red: red, green: green, blue: blue, alpha: alpha)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(hex string: <span class="type">String</span>, alpha: <span class="type">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> hex = string.trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines).uppercased()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hex.hasPrefix(<span class="string">"#"</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> index = hex.index(hex.startIndex, offsetBy: <span class="number">1</span>)</span><br><span class="line">            hex = <span class="type">String</span>(hex[index...])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hex.<span class="built_in">count</span> &lt; <span class="number">3</span> &#123;</span><br><span class="line">            hex = <span class="string">"\(hex)\(hex)\(hex)"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hex.range(of: <span class="string">"(^[0-9A-Fa-f]&#123;6&#125;$)|(^[0-9A-Fa-f]&#123;3&#125;$)"</span>, options: .regularExpression) != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> hex.<span class="built_in">count</span> == <span class="number">3</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> startIndex = hex.index(hex.startIndex, offsetBy: <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">let</span> endIndex = hex.index(hex.startIndex, offsetBy: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> redHex = <span class="type">String</span>(hex[..&lt;startIndex])</span><br><span class="line">                <span class="keyword">let</span> greenHex = <span class="type">String</span>(hex[startIndex..&lt;endIndex])</span><br><span class="line">                <span class="keyword">let</span> blueHex = <span class="type">String</span>(hex[endIndex...])</span><br><span class="line"></span><br><span class="line">                hex = redHex + redHex + greenHex + greenHex + blueHex + blueHex</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> startIndex = hex.index(hex.startIndex, offsetBy: <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> endIndex = hex.index(hex.startIndex, offsetBy: <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">let</span> redHex = <span class="type">String</span>(hex[..&lt;startIndex])</span><br><span class="line">            <span class="keyword">let</span> greenHex = <span class="type">String</span>(hex[startIndex..&lt;endIndex])</span><br><span class="line">            <span class="keyword">let</span> blueHex = <span class="type">String</span>(hex[endIndex...])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> redInt: <span class="type">CUnsignedInt</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> greenInt: <span class="type">CUnsignedInt</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> blueInt: <span class="type">CUnsignedInt</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span>(string: redHex).scanHexInt32(&amp;redInt)</span><br><span class="line">            <span class="type">Scanner</span>(string: greenHex).scanHexInt32(&amp;greenInt)</span><br><span class="line">            <span class="type">Scanner</span>(string: blueHex).scanHexInt32(&amp;blueInt)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(red: <span class="type">CGFloat</span>(redInt) / <span class="number">255.0</span>,</span><br><span class="line">                      green: <span class="type">CGFloat</span>(greenInt) / <span class="number">255.0</span>,</span><br><span class="line">                      blue: <span class="type">CGFloat</span>(blueInt) / <span class="number">255.0</span>,</span><br><span class="line">                      alpha: <span class="type">CGFloat</span>(alpha))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(red: <span class="number">0.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.0</span>, alpha: <span class="number">0.0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hexValue: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> color = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> color.cgColor.numberOfComponents &lt; <span class="number">4</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="built_in">c</span> = color.cgColor.components!</span><br><span class="line">            color = <span class="type">UIColor</span>(red: <span class="built_in">c</span>[<span class="number">0</span>], green: <span class="built_in">c</span>[<span class="number">0</span>], blue: <span class="built_in">c</span>[<span class="number">0</span>], alpha: <span class="built_in">c</span>[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> color.cgColor.colorSpace!.model != .rgb &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#FFFFFF"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">c</span> = color.cgColor.components!</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: <span class="string">"#%02X%02X%02X"</span>, <span class="type">Int</span>(<span class="built_in">c</span>[<span class="number">0</span>]*<span class="number">255.0</span>), <span class="type">Int</span>(<span class="built_in">c</span>[<span class="number">1</span>]*<span class="number">255.0</span>), <span class="type">Int</span>(<span class="built_in">c</span>[<span class="number">2</span>]*<span class="number">255.0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是如何与多种输入形式一起使用的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"#cafe00"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"cafe00"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"c"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"ca"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"caf"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="number">0xcafe00</span>),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> values = colors.<span class="built_in">map</span> &#123; $<span class="number">0</span>.hexValue &#125;</span><br><span class="line"><span class="built_in">print</span>(values) <span class="comment">//["#CAFE00", "#CAFE00", "#CCCCCC", "#CACACA", "#CCAAFF", "#CAFE00"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我已经尝试过复制 <code>CSS</code> 规则的行为，因此，如果像 <code>#ffffff</code> 这样的后继字符串（你可以仅使用f，因为＃是可选的），你将可以减少字符的自由度。 你还可以提供整数，这只是一个简单的“重载”便捷初始化方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样，<code>.hexValue</code> 将返回 <code>UIColor</code> 实例的字符串表示形式。 👏👏👏</p></br><h1 id="如何在-Swift-中生成随机的-UIColor-？"><a href="#如何在-Swift-中生成随机的-UIColor-？" class="headerlink" title="如何在 Swift 中生成随机的 UIColor ？"></a><strong>如何在 <code>Swift</code> 中生成随机的 <code>UIColor</code> ？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于初学者来说，这也是一个非常普遍的问题，我真的不想通过深入的说明在这里浪费时间，<code>arc4random（）</code>只是在做它的工作，输出是一种很好的随机生成的颜色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> random: <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">max</span> = <span class="type">CGFloat</span>(<span class="type">UInt32</span>.<span class="built_in">max</span>)</span><br><span class="line">        <span class="keyword">let</span> red = <span class="type">CGFloat</span>(arc4random()) / <span class="built_in">max</span></span><br><span class="line">        <span class="keyword">let</span> green = <span class="type">CGFloat</span>(arc4random()) / <span class="built_in">max</span></span><br><span class="line">        <span class="keyword">let</span> blue = <span class="type">CGFloat</span>(arc4random()) / <span class="built_in">max</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>(red: red, green: green, blue: blue, alpha: <span class="number">1.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="如何在-Swift-中用单色创建一个-1x1-像素的大-UIImage-对象？"><a href="#如何在-Swift-中用单色创建一个-1x1-像素的大-UIImage-对象？" class="headerlink" title="如何在 Swift 中用单色创建一个 1x1 像素的大 UIImage 对象？"></a><strong>如何在 <code>Swift</code> 中用单色创建一个 <code>1x1</code> 像素的大 <code>UIImage</code> 对象？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我正在使用此技巧来设置 <code>UIButton</code> 对象的背景颜色。 原因是状态管理。 如果按下按钮，则背景图像将变暗，因此用户将获得视觉反馈。 但是，通过直接设置 <code>UIButton</code> 实例的背景颜色将无法正常工作，并且事件上的颜色也不会发生任何变化。 👆</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> imageValue: <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(origin: .zero, size: <span class="type">CGSize</span>(width: <span class="number">1</span>, height: <span class="number">1</span>))</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(rect.size)</span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()!</span><br><span class="line">        context.setFillColor(<span class="keyword">self</span>.cgColor)</span><br><span class="line">        context.fill(rect)</span><br><span class="line">        <span class="keyword">let</span> newImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> newImage!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码段将根据源颜色生成一个 <code>1x1</code> 像素的图像对象。 你可以使用它，但这是带有按钮背景的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setBackgroundImage(<span class="type">UIColor</span>.red.imageValue, <span class="keyword">for</span>: .normal)</span><br></pre></td></tr></table></figure></br><h1 id="在线调色板"><a href="#在线调色板" class="headerlink" title="在线调色板"></a><strong>在线调色板</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你找不到合适的颜色吗？ 没问题，这些链接将帮助你选择合适的链接并获得一些启发。 另外，如果你正在寻找平面UI颜色或材料设计颜色，这些是应该首先前往的正确链接。</p><ul><li><a href="https://www.w3schools.com/colors/colors_names.asp" target="_blank" rel="noopener"><strong><em><code>HTML Color Names</code></em></strong></a></li><li><a href="http://colorhunt.co/" target="_blank" rel="noopener"><strong><em><code>Color Hunt</code></em></strong></a></li><li><a href="https://flatuicolors.com/" target="_blank" rel="noopener"><strong><em><code>Flat UI Colors</code></em></strong></a></li><li><a href="http://www.flatuicolorpicker.com/" target="_blank" rel="noopener"><strong><em><code>flatuicolorpicker</code></em></strong></a></li><li><a href="https://www.materialui.co/colors" target="_blank" rel="noopener"><strong><em><code>Material Design Colors</code></em></strong></a></li></ul><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很重要的事情：亲爱的设计师，请永远不要尝试对 <code>iOS</code> 应用程序使用 <code>material design principles</code> 。 谢谢。</p></blockquote></br><h1 id="在线转换颜色"><a href="#在线转换颜色" class="headerlink" title="在线转换颜色"></a><strong>在线转换颜色</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，有一些很棒的在线颜色转换器工具，如果你正在寻找一个很棒的工具，则应该首先尝试这些工具。</p><ul><li><a href="uicolor.xyz"><strong><em><code>uicolor.xyz</code></em></strong></a></li><li><a href="rgb.to"><strong><em><code>rgb.to</code></em></strong></a></li><li><a href="colorizer.org"><strong><em><code>colorizer.org</code></em></strong></a></li></ul></br><h1 id="管理-UIColors"><a href="#管理-UIColors" class="headerlink" title="管理 UIColors"></a><strong>管理 <code>UIColors</code></strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你的应用程序目标是 <code>iOS 11+</code> ，则可以使用 <code>asset catalogs</code> 来组织你的调色板，但是如果你需要低于 <code>iOS 11</code> ，我建议你使用带有静态 <code>UIColor</code> 属性的枚举或结构。 如今，我通常在做这样的事情。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> green: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> <span class="type">UIColor</span>(hex: <span class="number">0x4cd964</span>) &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> yellow: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> <span class="type">UIColor</span>(hex: <span class="number">0xffcc00</span>) &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> red: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> <span class="type">UIColor</span>(hex: <span class="number">0xff3b30</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">App</span>.<span class="type">Color</span>.yellow</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，我将结构中的字体，颜色等分组在一起，但这只是一种处理方式。 你也可以使用 <a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener"><strong><em><code>R.swift</code></em></strong></a> 之类的东西或你喜欢的任何东西。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，我想我已经涵盖了有关UIColor的大多数基本问题。 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解什么是颜色模型，如何将十六进制值转换为 &lt;code&gt;UIColor&lt;/code&gt; 并返回，如何生成随机颜色，以及在哪里可以找到漂亮的调色板。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;什么是色彩模型和色彩空间？&quot;&gt;&lt;a href=&quot;#什么是色彩模型和色彩空间？&quot; class=&quot;headerlink&quot; title=&quot;什么是色彩模型和色彩空间？&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是色彩模型和色彩空间？&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;色彩模型是描述颜色的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RGB-红色+绿色+蓝色&lt;/li&gt;
&lt;li&gt;HSB-色相+饱和度+亮度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;还有其他几种颜色模型，但是如果你要处理 &lt;code&gt;iOS&lt;/code&gt; 颜色，则应该熟悉上面的两种。 通常，你将使用 &lt;code&gt;RGBA&lt;/code&gt; 和 &lt;code&gt;HSBA&lt;/code&gt; 颜色模型，这些颜色模型基本上与上面的扩展相同，其中字母A代表字母 &lt;code&gt;Alpha&lt;/code&gt; 。 😉&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;色彩空间是可以在介质中显示或复制的一组颜色（无论是存储，打印还是显示）。 例如，&lt;code&gt;sRGB&lt;/code&gt; 是红色，绿色和蓝色的一组特定强度，它定义了可以通过混合红色，绿色和蓝色的这些范围来再现的颜色。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从理论上已经足够，让我们做一些色彩魔术吧！ 💫💫💫&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="UIColor" scheme="http://www.xuebaonline.com/tags/UIColor/"/>
    
  </entry>
  
  <entry>
    <title>iOS自定义转场(By Swift)</title>
    <link href="http://www.xuebaonline.com/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA(By%20Swift)/"/>
    <id>http://www.xuebaonline.com/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA(By%20Swift)/</id>
    <published>2020-04-27T03:50:09.000Z</published>
    <updated>2020-04-28T02:00:03.142Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，你将学习如何使用自定义转场和百分比驱动的交互来替换 <code>Push</code> ，<code>pop</code> 和模式动画。</p></br><h1 id="UIKit自定义过渡API-理论知识"><a href="#UIKit自定义过渡API-理论知识" class="headerlink" title="UIKit自定义过渡API-理论知识"></a><strong>UIKit自定义过渡API-理论知识</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在进行 <a href="https://developer.apple.com/videos/play/wwdc2013/218/" target="_blank" rel="noopener"><strong><code>自定义转换</code></strong></a> 的过程中涉及许多类和委托，让我们快速地完成这些项目，然后再进行一些编码。</p></br><h2 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a><strong><em>UIViewControllerTransitioningDelegate</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个视图控制器都可以有一个过渡委托，在该委托实现中，你可以提供自定义动画和交互控制器。 这些对象将负责实际的动画处理，并且可以在此委托中将代码“注入” <code>UIKit</code> 框架。 💉💉💉</p><a id="more"></a></br><h2 id="UINavigationControllerDelegate"><a href="#UINavigationControllerDelegate" class="headerlink" title="UINavigationControllerDelegate"></a><strong><em>UINavigationControllerDelegate</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导航控制器委托还具有两种方法，用于自定义推送和弹出动画。 它与视图控制器的过渡委托几乎相同，但是稍后你将看到它的作用。 💥</p></br><h2 id="UINavigationController-Operation"><a href="#UINavigationController-Operation" class="headerlink" title="UINavigationController.Operation"></a><strong><em>UINavigationController.Operation</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导航控制器操作只是一个枚举，其中包含导航动画的“方向”。 通常按下或弹出。</p><blockquote><p><strong><code>提示:</code></strong> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以模态方式呈现和关闭某些内容与在导航堆栈中推送和弹出视图控制器并不完全相同。 稍后再详细介绍。</p></blockquote></br><h2 id="UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerAnimatedTransitioning"></a><strong><em>UIViewControllerAnimatedTransitioning</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些对象由过渡委托返回，因此基本上这是实现精美的自定义视图动画的地方。 😉</p></br><h2 id="UIViewControllerContextTransitioning"><a href="#UIViewControllerContextTransitioning" class="headerlink" title="UIViewControllerContextTransitioning"></a><strong><em>UIViewControllerContextTransitioning</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该上下文封装了有关过渡的所有信息，你可以从该对象获取参与的视图，控制器以及更多其他信息。 过渡上下文可供你在动画期间使用。</p></br><h2 id="UIPercentDrivenInteractiveTransition"><a href="#UIPercentDrivenInteractiveTransition" class="headerlink" title="UIPercentDrivenInteractiveTransition"></a><strong><em>UIPercentDrivenInteractiveTransition</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个视图控制器和另一个视图控制器之间驱动交互式动画的对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，这是一种神奇的功能，使你能够神奇地用手指从屏幕边缘向后（如果你改变主意了）来回滑动导航控制器。 📱</p></br><h1 id="编码自定义过渡动画"><a href="#编码自定义过渡动画" class="headerlink" title="编码自定义过渡动画"></a><strong>编码自定义过渡动画</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们做一些实际的编码！ 我将向你展示如何在导航堆栈内的视图控制器之间制作基本的淡入淡出动画。 首先，我们将从推动画开始。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">FadePushAnimator</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> toViewController = transitionContext.viewController(forKey: .to)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        transitionContext.containerView.addSubview(toViewController.view)</span><br><span class="line">        toViewController.view.alpha = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> duration = <span class="keyword">self</span>.transitionDuration(using: transitionContext)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class="line">            toViewController.view.alpha = <span class="number">1</span></span><br><span class="line">        &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，创建自定义过渡动画非常简单。 你只需要实现两个委托方法。 其中一个将返回动画的持续时间，而另一个将包含实际的过渡。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过渡上下文提供了一个自定义 <code>containterView</code> 对象，你可以在动画中使用它，也可以像我之前提到的那样从该对象中获取参与的视图和控制器。 现在，让我们反转该动画。 👈</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">FadePopAnimator</span>: <span class="title">CustomAnimator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> fromViewController = transitionContext.viewController(forKey: .from),</span><br><span class="line">            <span class="keyword">let</span> toViewController = transitionContext.viewController(forKey: .to)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transitionContext.containerView.insertSubview(toViewController.view, belowSubview: fromViewController.view)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> duration = <span class="keyword">self</span>.transitionDuration(using: transitionContext)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class="line">            fromViewController.view.alpha = <span class="number">0</span></span><br><span class="line">        &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，你只需要实现导航控制器的委托方法即可替换内置的UIKit系统动画。 🛠</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainViewController</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(<span class="number">_</span> navigationController: UINavigationController,</span></span></span><br><span class="line"><span class="function"><span class="params">                              animationControllerFor operation: UINavigationController.Operation,</span></span></span><br><span class="line"><span class="function"><span class="params">                              from fromVC: UIViewController,</span></span></span><br><span class="line"><span class="function"><span class="params">                              to toVC: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> operation &#123;</span><br><span class="line">        <span class="keyword">case</span> .push:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">FadePushAnimator</span>()</span><br><span class="line">        <span class="keyword">case</span> .pop:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">FadePopAnimator</span>()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，你不必制作两个单独的类（ <code>pop</code> 和 <code>push</code> ），也可以通过操作并在单个动画 <code>tarnsitioning</code> 类中实现动画。</p></br><h1 id="Percent-Driven-Interactive-Transition"><a href="#Percent-Driven-Interactive-Transition" class="headerlink" title="Percent Driven Interactive Transition"></a><strong>Percent Driven Interactive Transition</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，现在你知道了如何实现自定义过渡，但现在该使其具有交互性了！ 该过程非常简单，你只需要一个手势识别器和适当的委托方法即可使事情正常进行。 ⌨️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> interactionController: <span class="type">UIPercentDrivenInteractiveTransition?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.view.backgroundColor = .lightGray</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> edge = <span class="type">UIScreenEdgePanGestureRecognizer</span>(target: <span class="keyword">self</span>,</span><br><span class="line">                                                    action: #selector(<span class="keyword">self</span>.handleEdgePan(<span class="number">_</span>:)))</span><br><span class="line">        edge.edges = .<span class="keyword">left</span></span><br><span class="line">        <span class="keyword">self</span>.view.addGestureRecognizer(edge)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.navigationController?.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">handleEdgePan</span><span class="params">(<span class="number">_</span> gesture: UIScreenEdgePanGestureRecognizer)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> translate = gesture.translation(<span class="keyword">in</span>: gesture.view)</span><br><span class="line">        <span class="keyword">let</span> percent = translate.x / gesture.view!.bounds.size.width</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> gesture.state &#123;</span><br><span class="line">        <span class="keyword">case</span> .began:</span><br><span class="line">            <span class="keyword">self</span>.interactionController = <span class="type">UIPercentDrivenInteractiveTransition</span>()</span><br><span class="line">            <span class="keyword">self</span>.navigationController?.popViewController(animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">case</span> .changed:</span><br><span class="line">            <span class="keyword">self</span>.interactionController?.update(percent)</span><br><span class="line">        <span class="keyword">case</span> .ended:</span><br><span class="line">            <span class="keyword">let</span> velocity = gesture.velocity(<span class="keyword">in</span>: gesture.view)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> percent &amp;gt; <span class="number">0.5</span> || velocity.x &amp;gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.interactionController?.finish()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.interactionController?.cancel()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.interactionController = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DetailViewController</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(<span class="number">_</span> navigationController: UINavigationController,</span></span></span><br><span class="line"><span class="function"><span class="params">                              interactionControllerFor animationController: UIViewControllerAnimatedTransitioning)</span></span></span><br><span class="line">        -&gt; <span class="type">UIViewControllerInteractiveTransitioning?</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.interactionController</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在将要弹出的控制器内部，你可以拥有导航控制器的委托的所有权，并使用左屏幕边缘平移手势识别器实现交互式过渡控制器。 整个代码通常进入 <code>UIPercentDrivenInteractiveTransition</code> 的新子类中，但是为了简单起见，这次我们将跳过该部分，并使用这个非常简单的解决方案。  😅</p></br><h1 id="Navigation-vs-modal-presentation"><a href="#Navigation-vs-modal-presentation" class="headerlink" title="Navigation vs modal presentation"></a><strong>Navigation vs modal presentation</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，让我们快速介绍另一件事：为视图控制器自定义模式演示动画。 自定义导航堆栈动画和模式表示样式之间存在微小差异。 如果要自定义视图控制器转换，通常会执行以下操作。 👍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">(<span class="keyword">for</span> segue: UIStoryboardSegue, sender: <span class="keyword">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepare(<span class="keyword">for</span>: segue, sender: sender)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> controller = segue.destination <span class="keyword">as</span>? <span class="type">ModalViewController</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        controller.transitioningDelegate = <span class="keyword">self</span></span><br><span class="line">        controller.modalPresentationStyle = .custom</span><br><span class="line">        controller.modalPresentationCapturesStatusBarAppearance = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用我们已经拥有的相同对象的过渡委托来了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DetailViewController</span>: <span class="title">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forPresented presented: UIViewController,</span></span></span><br><span class="line"><span class="function"><span class="params">                             presenting: UIViewController,</span></span></span><br><span class="line"><span class="function"><span class="params">                             source: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FadePushAnimator</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forDismissed dismissed: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FadePopAnimator</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你运行代码并提供模态视图控制器，则可以正常工作。 当你尝试关闭显示的视图控制器时，会发生此问题。 整个应用程序将转为死亡黑屏（BSOD）。 🖥</p><p><strong><em><code>(pop != dismiss) &amp;&amp; (push != present)</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你必须修改pop动画才能支持模态解雇动画。 简而言之：问题在于放置视图和内存管理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">FadePopAnimator</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TransitionType</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> navigation</span><br><span class="line">        <span class="keyword">case</span> modal</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> type: <span class="type">TransitionType</span></span><br><span class="line">    <span class="keyword">let</span> duration: <span class="type">TimeInterval</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(type: <span class="type">TransitionType</span>, duration: <span class="type">TimeInterval</span> = <span class="number">0.25</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.type = type</span><br><span class="line">        <span class="keyword">self</span>.duration = duration</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.duration</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> fromViewController = transitionContext.viewController(forKey: .from)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.type == .navigation, <span class="keyword">let</span> toViewController = transitionContext.viewController(forKey: .to) &#123;</span><br><span class="line">            transitionContext.containerView.insertSubview(toViewController.view, belowSubview: fromViewController.view)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> duration = <span class="keyword">self</span>.transitionDuration(using: transitionContext)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class="line">            fromViewController.view.alpha = <span class="number">0</span></span><br><span class="line">        &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最简单的解决方案是引入一个新属性，以便你可以基于该标志来决定是否弹出视图控制器。 现在，你也可以安全地将相同的动画器用于模态显示的视图控制器。 😬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，导航栏将始终使用淡入淡出的动画，但遗憾的是无法自定义。 另外，我进行了自定义的模态演示，并且所有内容都在使用交互式过渡。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，如果你不想手动实现自定义动画效果，则可以使用 <a href="https://github.com/lkzhao/Hero" target="_blank" rel="noopener"><strong><em><code>Hero</code></em></strong></a> 优雅的过渡库。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在本文中，你将学习如何使用自定义转场和百分比驱动的交互来替换 &lt;code&gt;Push&lt;/code&gt; ，&lt;code&gt;pop&lt;/code&gt; 和模式动画。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;UIKit自定义过渡API-理论知识&quot;&gt;&lt;a href=&quot;#UIKit自定义过渡API-理论知识&quot; class=&quot;headerlink&quot; title=&quot;UIKit自定义过渡API-理论知识&quot;&gt;&lt;/a&gt;&lt;strong&gt;UIKit自定义过渡API-理论知识&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在进行 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2013/218/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;&lt;code&gt;自定义转换&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; 的过程中涉及许多类和委托，让我们快速地完成这些项目，然后再进行一些编码。&lt;/p&gt;
&lt;/br&gt;

&lt;h2 id=&quot;UIViewControllerTransitioningDelegate&quot;&gt;&lt;a href=&quot;#UIViewControllerTransitioningDelegate&quot; class=&quot;headerlink&quot; title=&quot;UIViewControllerTransitioningDelegate&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;UIViewControllerTransitioningDelegate&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;每个视图控制器都可以有一个过渡委托，在该委托实现中，你可以提供自定义动画和交互控制器。 这些对象将负责实际的动画处理，并且可以在此委托中将代码“注入” &lt;code&gt;UIKit&lt;/code&gt; 框架。 💉💉💉&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自定义转场" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA/"/>
    
      <category term="transition" scheme="http://www.xuebaonline.com/tags/transition/"/>
    
  </entry>
  
  <entry>
    <title>Swift UICollectionView使用指南</title>
    <link href="http://www.xuebaonline.com/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://www.xuebaonline.com/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2020-04-27T02:56:48.000Z</published>
    <updated>2020-04-27T03:45:35.328Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>UICollectionView</code> ，具有高度可重用性的 <code>UIKit</code> 组件和一些 <code>MVVM</code> 模式，而不会费力地进行索引路径计算。</p></br><h1 id="UICollectionView类的剖析"><a href="#UICollectionView类的剖析" class="headerlink" title="UICollectionView类的剖析"></a><strong>UICollectionView类的剖析</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您不熟悉 <code>UICollectionView</code> ，建议立即熟悉此类。 它们是 <code>Apple</code> 和其他第三方开发人员提供的许多应用程序的基本构建块。 就像 <code>UITableView</code> 一样。 结合 <code>IB</code> 和 <code>Swift</code> 代码快速了解和使用它们。 💻</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp1.png" alt="UICollectionView"></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将仅使用强大的 <code>UICollectionView</code> 类来构建 <code>Apple Music</code> 目录，例如从零开始的外观。 标头，水平和垂直滚动，圆形图像，因此，基本上，构建强大的用户界面所需的几乎所有内容。 🤘🏻</p></br><h1 id="如何使用Xcode中的Interface-Builder（IB）创建-UICollectionView-？"><a href="#如何使用Xcode中的Interface-Builder（IB）创建-UICollectionView-？" class="headerlink" title="如何使用Xcode中的Interface Builder（IB）创建 UICollectionView ？"></a><strong>如何使用Xcode中的Interface Builder（IB）创建 UICollectionView ？</strong></h1><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要使用 <code>IB</code> ！</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您仍然想使用 <code>IB</code> ，这是绝对入门的真正快速教程：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp2.png" alt="IB"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建第一个基于 <code>UICollectionView</code> 的屏幕的主要步骤如下：</p><ul><li>将 <code>UICollectionView</code> 对象拖到您的视图控制器</li><li>在集合视图上设置适当的约束</li><li>设置数据源和集合视图的委托</li><li>在控制器内部对单元布局进行原型设计</li><li>在单元格内的视图中添加约束</li><li>设置原型单元格类和重用标识符</li><li>做一些编码：</li></ul></br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">            flowLayout.itemSize = <span class="type">CGSize</span>(width: <span class="keyword">self</span>.collectionView.bounds.width, height: <span class="number">120</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> collectionView: UICollectionView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">"MyCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">MyCell</span></span><br><span class="line">        cell.textLabel.text = <span class="type">String</span>(indexPath.row + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(indexPath.item + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，数据源将提供有关如何填充集合视图的所有必需数据，并且委托将处理用户事件，例如在单元格上轻按。 您应该对数据源和委托方法有清楚的了解，因此请稍候片刻。 ⌨️</p></br><h1 id="如何在-Swift-5-中使用代码设置创建-UICollectionView"><a href="#如何在-Swift-5-中使用代码设置创建-UICollectionView" class="headerlink" title="如何在 Swift 5 中使用代码设置创建 UICollectionView?"></a><strong>如何在 <code>Swift 5</code> 中使用代码设置创建 <code>UICollectionView</code>?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您可能已经注意到，单元格是集合视图的核心组件。 它们是从可重用的视图派生的，这意味着，如果您有1000个元素的列表，则不会为每个元素创建一千个单元格，而只有少数几个可以填充屏幕大小，并且当您向下滚动列表时 这些项目将被重复使用以显示您的元素。 这仅仅是出于内存方面的考虑，因此与 <code>UIScrollView</code> 不同， <code>UICollectionView</code> （和 <code>UITableView</code> ）类是一个非常聪明且高效的类，但这也是每次显示之前都必须准备（重置内容）单元格的原因。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化也由系统处理，但是值得一提的是，如果使用 <code>Interface Builder</code> ，则应该在 <code>awakeFromNib</code> 方法内进行自定义，但是如果使用代码，则 <code>init（frame :)</code> 是您的地方。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> textLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        textLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(textLabel)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            textLabel.topAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.topAnchor),</span><br><span class="line">            textLabel.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.bottomAnchor),</span><br><span class="line">            textLabel.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.leadingAnchor),</span><br><span class="line">            textLabel.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.textLabel = textLabel</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.contentView.backgroundColor = .lightGray</span><br><span class="line">        <span class="keyword">self</span>.textLabel.textAlignment = .center</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Interface Builder is not supported!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Interface Builder is not supported!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel.text = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们必须实现负责管理集合视图的视图控制器，因为我们没有使用 <code>IB</code> ，所以必须在 <code>loadView</code> 方法内部使用自动布局锚点（如单元格中的 <code>textLabel</code> ）手动创建它。 在视图层次结构准备就绪后，我们还设置了数据源并委托并注册了我们的单元格类以供进一步重用。 请注意，如果您使用 <code>IB</code> ，则此操作由系统自动完成，但是如果您喜欢代码，则必须通过调用适当的注册方法来完成。 您可以注册 <code>nibs</code> 和 <code>classes</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> collectionView = <span class="type">UICollectionView</span>(frame: .zero, collectionViewLayout: <span class="type">UICollectionViewFlowLayout</span>())</span><br><span class="line">        collectionView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(collectionView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            collectionView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.topAnchor),</span><br><span class="line">            collectionView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.bottomAnchor),</span><br><span class="line">            collectionView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.leadingAnchor),</span><br><span class="line">            collectionView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView = collectionView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView.backgroundColor = .white</span><br><span class="line">        <span class="keyword">self</span>.collectionView.dataSource = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView.register(<span class="type">MyCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"MyCell"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> collectionView: UICollectionView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">"MyCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">MyCell</span></span><br><span class="line">        cell.textLabel.text = <span class="type">String</span>(indexPath.row + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(indexPath.row + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegateFlowLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        sizeForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.bounds.size.width - <span class="number">16</span>, height: <span class="number">120</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumLineSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumInteritemSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        insetForSectionAt section: Int)</span></span> -&gt; <span class="type">UIEdgeInsets</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIEdgeInsets</span>.<span class="keyword">init</span>(top: <span class="number">8</span>, <span class="keyword">left</span>: <span class="number">8</span>, bottom: <span class="number">8</span>, <span class="keyword">right</span>: <span class="number">8</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，您应该注意流布局委托方法。 您可以使用这些方法为布局系统提供支持。 流布局将基于这些数字和大小显示所有单元格。  <code>sizeForItemAt</code> 负责单元格的大小，<code>minimumInteritemSpacingForSectionAt</code> 是水平填充，<code>minimumLineSpacingForSectionAt</code> 是垂直填充，<code>insetForSectionAt</code> 是集合视图部分的边距。</p></br><h1 id="section-headers-and-footers"><a href="#section-headers-and-footers" class="headerlink" title="section headers and footers"></a><strong>section headers and footers</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在本节中，我将同时使用 <code>storyboards</code>，<code>nibs</code> 和一些 <code>Swift</code> 代码。 由于某些原因，这是我通常的方法。 虽然我很喜欢用代码进行约束，但大多数人更喜欢视觉编辑器，因此所有单元格都在笔尖内部创建。 为什么是笔尖？ 因为如果您有多个集合视图，这几乎是在它们之间共享单元格的唯一好方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您可以像创建 <code>section headers</code> 一样完全地创建 <code>section footers</code> ，因此这就是我这次只关注 <code>section headers</code> 的原因，因为从字面上看，您只需要更改一个字即可使用 <code>section footers</code> 。 ⚽️</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp3.png" alt="footers"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您只需要创建两个 <code>xib</code> 文件，一个用于单元格，一个用于头文件。 请注意，您可以使用完全相同的集合视图单元格来在 <code>section</code> 标题中显示内容，但这是一个演示，因此让我们处理两个不同的项目。 您甚至不必从 <code>IB</code> 设置重用标识符，因为我们必须在源代码中注册我们的可重用视图，因此只需设置单元类并连接您的 <code>outlets</code> 即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单元格的注册和 <code>section headers and footers</code> 的注册略有不同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cellNib = <span class="type">UINib</span>(nibName: <span class="string">"Cell"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.collectionView.register(cellNib, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sectionNib = <span class="type">UINib</span>(nibName: <span class="string">"Section"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.collectionView.register(sectionNib, forSupplementaryViewOfKind: <span class="type">UICollectionView</span>.elementKindSectionHeader, withReuseIdentifier: <span class="string">"Section"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现 <code>section header</code> 的数据源如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        viewForSupplementaryElementOfKind kind: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                        at indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionReusableView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> kind == <span class="type">UICollectionView</span>.elementKindSectionHeader <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UICollectionReusableView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> view = collectionView.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: <span class="string">"Section"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">Section</span></span><br><span class="line"></span><br><span class="line">    view.textLabel.text = <span class="type">String</span>(indexPath.section + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供流布局委托的大小也非常简单，但是有时我并没有得到 <code>Apple</code> 的命名约定。 一旦必须切换一种类型，而其他时候则有针对特定类型的确切方法。 🤷‍♂️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                    layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                    referenceSizeForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.bounds.size.width, height: <span class="number">64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 <code>iOS9</code> 开始，可以将 <code>section headers and footers</code> 固定在集合视图可见范围的顶部或底部。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">    flowLayout.sectionHeadersPinToVisibleBounds = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，现在您知道了如何使用集合视图构建基本布局。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复杂的情况怎么样，例如在同一集合视图中使用多种单元格呢？ 索引路径会使事情变得很混乱，所以这就是为什么我基于一种技术来重新发明更好的方法，该技术如何使用 <code>Apple</code> 在 <code>WWDC 2014</code> 上展示的 <a href="https://developer.apple.com/videos/wwdc2014" target="_blank" rel="noopener"><strong><code>集合视图来构建高级用户界面</code></strong></a> 。</p></br><h1 id="基于-CollectionView-的-UI-Framework"><a href="#基于-CollectionView-的-UI-Framework" class="headerlink" title="基于 CollectionView 的 UI Framework"></a><strong>基于 <code>CollectionView</code> 的 <code>UI Framework</code></strong></h1><blockquote><p>CollectionView + ViewModel pattern = ❤️ .</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将快速解释这些组件，然后，您将学习如何使用它们来构建起初我所谈论的 <code>Apple</code> 音乐风格的布局。 🎶</p><h2 id="网格系统"><a href="#网格系统" class="headerlink" title="网格系统"></a><strong><em>网格系统</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集合视图的第一个问题是大小计算。您必须提供集合视图中每个单元的大小（宽度和高度）。</p><ul><li>如果在集合视图中所有内容都具有固定的大小，则只需在流布局本身上设置大小属性</li><li>如果您需要每个项目的动态尺寸，则可以实施流布局委托。 <code>UICollectionViewDelegateFlowLayout</code>（为什么在名称中间使用委托词？？？）并返回布局系统的确切大小</li><li>如果您需要更多控制权，则可以创建一个从 <code>CollectionView（Flow）Layout</code> 派生的新布局子类，并在那里进行所有尺寸计算</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很好，但是您仍然必须弄乱索引路径，特征集合，框架等，以使简单的2、4，n列布局适用于所有设备。这就是为什么我创建了一个非常基本的网格系统进行尺寸计算的原因。使用我的网格类，您可以设置列数并获取x列数的大小，就像在基于 <code>Web</code> 的 <code>CSS</code> 网格系统中一样。 🕸</p><h2 id="单元格重用"><a href="#单元格重用" class="headerlink" title="单元格重用"></a><strong><em>单元格重用</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单元格的注册和重用应该并且可以以类型安全的方式自动化。 您只想使用单元，而根本不关心重用标识符和单元注册。 我做了一些辅助方法，以使进步更加愉快。 重用标识符是从单元格类的名称派生的，因此您不必担心。 大多数开发人员都使用这种做法。</p><h2 id="View-model"><a href="#View-model" class="headerlink" title="View model"></a><strong><em>View model</em></strong></h2><blockquote><p><strong><code>view model = cell (view) + data (model)</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用实际数据填充“模板”单元应该是视图模型的任务。 这就是 <code>MVVM</code> 发挥作用的地方。 我做了一个通用的基本视图模型类，应该将其子类化。 借助协议，您可以在单个集合视图中使用各种单元，而不必担心行和节的计算，并且您可以专注于一项简单的任务：将视图与模型联系起来。 😛</p><h2 id="Section"><a href="#Section" class="headerlink" title="Section"></a><strong><em>Section</em></strong></h2><blockquote><p><strong><code>section = header + footer + cells</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要强调的是，您不想弄乱索引路径，只想将数据放在一起就可以了。 过去，我对“不必要的索引路径计算”进行了充分的努力，因此，我将 <code>section</code> 对象作为一个简单的容器来包装标题，页脚和该部分中的所有项目。 结果？ 通用数据源类，可以与多个单元格一起使用，而无需任何行或节索引计算。 👏👏👏</p><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a><strong><em>数据源</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，为了使我上面提到的所有事情都能起作用，我需要实现集合视图委托，数据源和流布局委托方法。 这就是我的源代码类的诞生。 一切都在这里实现，我正在使用各部分，通过视图模型对网格系统进行建模以建立集合视图。 但是，从理论上讲，足够了，让我们在实践中进行观察。 👓</p></br><h1 id="CollectionView-框架创建示例"><a href="#CollectionView-框架创建示例" class="headerlink" title="CollectionView 框架创建示例"></a><strong>CollectionView 框架创建示例</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何使任何列表或网格布局轻松自如？ 好吧，作为第一步，只需将我的 <code>CollectionView</code> 框架添加为依赖项。 它已经支持<code>Xcode 11</code> ，因此您可以直接从文件菜单使用 <code>Swift</code> 软件包管理器来集成此软件包。</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需在 <code>AppDelegate</code> 文件中添加 <code>@_exported import CollectionView</code> 行，那么您不必担心逐个文件导入框架。</p></blockquote><h2 id="创建-Cell"><a href="#创建-Cell" class="headerlink" title="创建 Cell"></a><strong><em>创建 Cell</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此步骤与常规设置相同，除了您的单元必须是我的 <code>Cell</code> 类的子类。 添加您自己的单元并像往常一样执行所有操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumCell</span>: <span class="title">Cell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> detailTextLabel: <span class="type">UILabel!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">self</span>.textLabel.textColor = .black</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel.textColor = .darkGray</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="number">8</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.reset()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.image = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-Model"><a href="#创建-Model" class="headerlink" title="创建 Model"></a><strong><em>创建 Model</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需选择一个模型对象。 可以是任何东西，但是我的方法是使用 <code>Model</code> 后缀创建新的结构或类。 这样，我知道模型正在引用可重用组件文件夹中的集合视图模型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlbumModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> artist: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> image: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-ViewModel"><a href="#创建-ViewModel" class="headerlink" title="创建 ViewModel"></a><strong><em>创建 ViewModel</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，不用在委托内部或在某些地方的 <code>configure</code> 方法中配置单元格，而是为单元格和将通过视图表示的数据模型创建一个真实的视图模型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumViewModel</span>: <span class="title">ViewModel</span>&lt;<span class="title">AlbumCell</span>, <span class="title">AlbumModel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">updateView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view?.textLabel.text = <span class="keyword">self</span>.model.artist</span><br><span class="line">        <span class="keyword">self</span>.view?.detailTextLabel.text = <span class="keyword">self</span>.model.name</span><br><span class="line">        <span class="keyword">self</span>.view?.imageView.image = <span class="type">UIImage</span>(named: <span class="keyword">self</span>.model.image)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">(grid: Grid)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">            (<span class="keyword">self</span>.collectionView.traitCollection.userInterfaceIdiom == .phone &amp;&amp;</span><br><span class="line">             <span class="keyword">self</span>.collectionView.traitCollection.verticalSizeClass == .compact) ||</span><br><span class="line">            <span class="keyword">self</span>.collectionView?.traitCollection.userInterfaceIdiom == .pad</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> grid.size(<span class="keyword">for</span>: <span class="keyword">self</span>.collectionView, ratio: <span class="number">1.2</span>, items: grid.columns / <span class="number">4</span>, gaps: grid.columns - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> grid.columns == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> grid.size(<span class="keyword">for</span>: <span class="keyword">self</span>.collectionView, ratio: <span class="number">1.1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid.size(<span class="keyword">for</span>: <span class="keyword">self</span>.collectionView, ratio: <span class="number">1.2</span>, items: grid.columns / <span class="number">2</span>, gaps: grid.columns - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置数据源"><a href="#设置数据源" class="headerlink" title="设置数据源"></a><strong><em>设置数据源</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，使用您的真实数据并使用视图模型填充您的集合视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> grid = <span class="type">Grid</span>(columns: <span class="number">1</span>, margin: <span class="type">UIEdgeInsets</span>(all: <span class="number">8</span>))</span><br><span class="line"><span class="keyword">self</span>.collectionView.source = .<span class="keyword">init</span>(grid: grid, [</span><br><span class="line">    [</span><br><span class="line">        <span class="type">HeaderViewModel</span>(.<span class="keyword">init</span>(title: <span class="string">"Albums"</span>))</span><br><span class="line">        <span class="type">AlbumViewModel</span>(<span class="keyword">self</span>.album)</span><br><span class="line">    ],</span><br><span class="line">])</span><br><span class="line"><span class="keyword">self</span>.collectionView.reloadData()</span><br></pre></td></tr></table></figure><h2 id="🍺🤘🏻🎸"><a href="#🍺🤘🏻🎸" class="headerlink" title="🍺🤘🏻🎸"></a>🍺🤘🏻🎸</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恭喜，您已完成第一个 <code>collection</code> 视图。 仅需几行代码，您便拥有了 <code>ROCK SOLID</code>代码，可在大多数情况下为您提供帮助！ 😎</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp4.png" alt="collection"></p></br><h1 id="垂直滚动内的水平滚动"><a href="#垂直滚动内的水平滚动" class="headerlink" title="垂直滚动内的水平滚动"></a><strong>垂直滚动内的水平滚动</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们制作一个包含集合视图的单元格并使用与上述相同的方法怎么办？ 包含 <code>collectionview</code> 的 <code>collection</code> 视图… <code>UICollectionViewception</code> !!! 😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全有可能并且确实很容易做到，为视图模型提供数据的将是一个集合视图源对象，您已经完成了。 示例应用程序中还包括轻松，神奇和超好实现的内容。</p></br><h1 id="带有圆角图片的-Section"><a href="#带有圆角图片的-Section" class="headerlink" title="带有圆角图片的 Section"></a><strong>带有圆角图片的 Section</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多个部分？这也是小菜一碟，如果您阅读了我先前有关 <a href="http://www.xuebaonline.com/UICollectionView%20Cells%EF%BC%9A%E5%9C%86%E5%BD%A2%E5%9B%BE%E5%83%8F%E3%80%81%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC/"><strong><code>设置圆形Collection视图单元</code></strong></a> 的文章，您将知道该如何做，但是请从gitlab中查看源代码，并亲自进行操作。</p></br><h1 id="Callbacks-amp-amp-Actions"><a href="#Callbacks-amp-amp-Actions" class="headerlink" title="Callbacks &amp;&amp; Actions"></a><strong>Callbacks &amp;&amp; Actions</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户事件可以非常容易地处理，因为视图模型可以具有委托或回调块，这仅取决于您喜欢哪一个。 该示例包含一个 <code>onSelect</code> 处理程序，该处理程序超级好并且内置于框架中。 😎</p></br><h1 id="重新计算动态单元大小"><a href="#重新计算动态单元大小" class="headerlink" title="重新计算动态单元大小"></a><strong>重新计算动态单元大小</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我也有一个关于<a href="http://www.xuebaonline.com/Swift%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%85%83%E6%A0%BC/"><strong><code>UICollection视图自动调整大小单元格</code></strong></a> 的文章。 在制作完网格系统并开始使用视图模型之后，我自己可以轻松计算出单元格的高度，大约需要两行额外的代码。 我相信这是值得的，因为就自动旋转而言，自定尺寸的单元格有点麻烦。</p></br><h1 id="支持旋转，自适应"><a href="#支持旋转，自适应" class="headerlink" title="支持旋转，自适应"></a><strong>支持旋转，自适应</strong></h1><p>不必担心太多，您可以根据需要简单地更改网格或检查视图模型中的特征集合。 我想说几乎所有事情都可以立即完成。 那就是它的美，可以随意做任何您想做的事情，并以自己喜欢的方式使用它。 📦</p></br><h1 id="如果我告诉你…又一件事：SwiftUI"><a href="#如果我告诉你…又一件事：SwiftUI" class="headerlink" title="如果我告诉你…又一件事：SwiftUI"></a><strong>如果我告诉你…又一件事：SwiftUI</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您喜欢这种方法很酷，但是如果我告诉您还有更多方法呢？ 您是否想在所有地方都使用相同的模式？ 我的意思是在 <code>iOS</code> ，<code>tvOS</code>，<code>macOS</code>甚至 <code>watchOS</code> 上。  我已经在 <code>CoreKit</code> 框架中创建了所有内容。 还支持 <code>UITableViews</code> ， <code>WKInterfaceTables</code> 。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我真的相信苹果今年会采用类似的方式处理下一代<code>UIKit / AppKit / UXKit</code>框架（当然是用<code>Swift</code>编写的）。 我不是在谈论视图模型模式，而是在每个平台上思考相同的<code>API</code>。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何使用 &lt;code&gt;UICollectionView&lt;/code&gt; ，具有高度可重用性的 &lt;code&gt;UIKit&lt;/code&gt; 组件和一些 &lt;code&gt;MVVM&lt;/code&gt; 模式，而不会费力地进行索引路径计算。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;UICollectionView类的剖析&quot;&gt;&lt;a href=&quot;#UICollectionView类的剖析&quot; class=&quot;headerlink&quot; title=&quot;UICollectionView类的剖析&quot;&gt;&lt;/a&gt;&lt;strong&gt;UICollectionView类的剖析&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果您不熟悉 &lt;code&gt;UICollectionView&lt;/code&gt; ，建议立即熟悉此类。 它们是 &lt;code&gt;Apple&lt;/code&gt; 和其他第三方开发人员提供的许多应用程序的基本构建块。 就像 &lt;code&gt;UITableView&lt;/code&gt; 一样。 结合 &lt;code&gt;IB&lt;/code&gt; 和 &lt;code&gt;Swift&lt;/code&gt; 代码快速了解和使用它们。 💻&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q8wtfza4q.bkt.clouddn.com/ug-stp1.png&quot; alt=&quot;UICollectionView&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自适应布局" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"/>
    
      <category term="UICollectionView" scheme="http://www.xuebaonline.com/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>UICollectionView Cells：圆形图像、支持旋转</title>
    <link href="http://www.xuebaonline.com/UICollectionView%20Cells%EF%BC%9A%E5%9C%86%E5%BD%A2%E5%9B%BE%E5%83%8F%E3%80%81%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC/"/>
    <id>http://www.xuebaonline.com/UICollectionView%20Cells%EF%BC%9A%E5%9C%86%E5%BD%A2%E5%9B%BE%E5%83%8F%E3%80%81%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC/</id>
    <published>2020-04-27T02:37:04.000Z</published>
    <updated>2020-04-27T02:53:13.821Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何通过旋转支持为包装在 <code>UICollectionView</code> 单元格内的 <code>UIImageView</code> 项制作圆角。</p></br><h1 id="UICollectionView-中的圆形单元格"><a href="#UICollectionView-中的圆形单元格" class="headerlink" title="UICollectionView 中的圆形单元格"></a><strong>UICollectionView 中的圆形单元格</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现目标相对容易，但是如果你不知道后台发生了什么，那可能会比你最初想的要难。 因此，让我们创建一个新项目，添加带有 <code>UICollectionViewController</code> 的情节提要，将 <code>UIImageView</code> 拖动到单元格内，调整其大小，添加一些约束，设置单元格标识符。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp1.png" alt="UICollectionViewController"></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它看起来应该像上面的图像。 对于我们的示例应用程序而言，没有什么特别的简单的 <code>UI</code> 。 现在搜索一些随机图像，将其添加到项目中，让我们进行一些实际的编码。 首先，我将向你展示单元子类内部的小技巧。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.layoutIfNeeded()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.setCircularImageView()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setCircularImageView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="type">CGFloat</span>(roundf(<span class="type">Float</span>(<span class="keyword">self</span>.imageView.frame.size.width / <span class="number">2.0</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你能看见它吗？ 是的，你应该重写 <code>bounds</code> 属性。 下一步，我们必须为控制器类编写一些用于收集视图的基本数据源，并为旋转方法提供适当的支持。 🤓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">"Cell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></span><br><span class="line"></span><br><span class="line">        cell.imageView.image = <span class="type">UIImage</span>(named: <span class="string">"Example.jpg"</span>)</span><br><span class="line">        cell.imageView.backgroundColor = .lightGray</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">traitCollectionDidChange</span><span class="params">(<span class="number">_</span> previousTraitCollection: UITraitCollection?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> previousTraitCollection = previousTraitCollection,</span><br><span class="line">            <span class="keyword">self</span>.traitCollection.verticalSizeClass != previousTraitCollection.verticalSizeClass ||</span><br><span class="line">            <span class="keyword">self</span>.traitCollection.horizontalSizeClass != previousTraitCollection.horizontalSizeClass</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">        <span class="keyword">self</span>.collectionView?.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillTransition</span><span class="params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillTransition(to: size, with: coordinator)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line"></span><br><span class="line">        coordinator.animate(alongsideTransition: &#123; context <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">        &#125;, completion: &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.collectionView?.visibleCells.forEach &#123; cell <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> cell = cell <span class="keyword">as</span>? <span class="type">Cell</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                cell.setCircularImageView()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegateFlowLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        sizeForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.frame.size.width/<span class="number">3.0</span> - <span class="number">8</span>,</span><br><span class="line">                      height: collectionView.frame.size.width/<span class="number">3.0</span> - <span class="number">8</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，如果没有重写的 <code>bounds</code> 属性，则该示例在左侧看起来像这样。 😢</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp2.jpg" alt="UICollectionViewController2"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好笑吧？ 右侧的图像是带有超出范围的实际结果，这是预期的行为。 如果你不覆盖边界并且不为可见视图重设 <code>cornerRadius</code> 属性，那么滚动和旋转将真的很奇怪。 你可能会问：但是为什么呢？ 🤔</p></br><h1 id="Layers-springs-amp-struts-说明"><a href="#Layers-springs-amp-struts-说明" class="headerlink" title="Layers, springs &amp; struts 说明"></a><strong>Layers, springs &amp; struts</strong> 说明</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Apple</code> 在 <code>UIKit</code> 中仍然具有基于 <code>“ Springs＆Struts”</code> 的代码。 这意味着框架和边界计算正在底层系统中进行，并且约束系统也在努力工作以找出适当的措施。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当有一个 <code>init（frame :)</code> 方法或一个必需的 <code>init（coder :)</code> 方法时，这些布局会糟透了。 我真的很喜欢 <code>Interface Builder</code> ，但是直到我们没有一个好的工具来创建出色的用户界面， <code>IB</code> 才可能是潜在错误的另一层。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果仅使用自动布局约束或布局锚从代码创建单元，则甚至不会出现此问题！ 这是因为IB根据你在设计原型时提供的框架来创建单元。 但是，如果你忘记了 <code>init（frame :)</code> ，而只是创建了一个新的 <code>UIImageView</code> 实例并让自动布局完成了艰苦的工作，则布局系统将解决所有其他问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> imageView = <span class="type">UIImageView</span>()</span><br><span class="line">        imageView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.addSubview(imageView)</span><br><span class="line">        <span class="keyword">self</span>.imageView = imageView</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.topAnchor)</span><br><span class="line">        <span class="keyword">self</span>.imageView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.bottomAnchor)</span><br><span class="line">        <span class="keyword">self</span>.imageView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.leadingAnchor)</span><br><span class="line">        <span class="keyword">self</span>.imageView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.trailingAnchor)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="type">CGFloat</span>(roundf(<span class="type">Float</span>(<span class="keyword">self</span>.imageView.frame.size.width/<span class="number">2.0</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，你必须编写更多代码，在控制器类中手动注册单元格类，并且还必须重写单元格中的 <code>layoutSubviews</code> 方法，但是它将按预期执行。 🙄</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.collectionView?.register(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，在注册以编程方式创建的单元格之后，你将有一种很好的方式来显示圆形图像。 使用这种技术非常棘手，但是在每种情况下它肯定都有效。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何通过旋转支持为包装在 &lt;code&gt;UICollectionView&lt;/code&gt; 单元格内的 &lt;code&gt;UIImageView&lt;/code&gt; 项制作圆角。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;UICollectionView-中的圆形单元格&quot;&gt;&lt;a href=&quot;#UICollectionView-中的圆形单元格&quot; class=&quot;headerlink&quot; title=&quot;UICollectionView 中的圆形单元格&quot;&gt;&lt;/a&gt;&lt;strong&gt;UICollectionView 中的圆形单元格&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;实现目标相对容易，但是如果你不知道后台发生了什么，那可能会比你最初想的要难。 因此，让我们创建一个新项目，添加带有 &lt;code&gt;UICollectionViewController&lt;/code&gt; 的情节提要，将 &lt;code&gt;UIImageView&lt;/code&gt; 拖动到单元格内，调整其大小，添加一些约束，设置单元格标识符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://q8wtfza4q.bkt.clouddn.com/uc-stp1.png&quot; alt=&quot;UICollectionViewController&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自适应布局" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"/>
    
      <category term="UICollectionView" scheme="http://www.xuebaonline.com/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>Swift支持旋转的自适应单元格</title>
    <link href="http://www.xuebaonline.com/Swift%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%85%83%E6%A0%BC/"/>
    <id>http://www.xuebaonline.com/Swift%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%85%83%E6%A0%BC/</id>
    <published>2020-04-27T02:12:39.000Z</published>
    <updated>2020-04-27T02:39:32.786Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何在Swift中为表格视图和集合视图制作自定义大小的单元格，以支持方向更改和动态字体类型。</p></br><h1 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a><strong>UITableView</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们从 <code>iOS</code> 的标准单视图模板开始。 命名项目，然后直接转到 <code>Main.storyboard</code> 文件。 选择你的 <code>ViewController</code> ，将其删除并创建一个新的 <code>UITableViewController</code> <code>scene</code> 。</p><a id="more"></a><p><img src="http://q8wtfza4q.bkt.clouddn.com/sc-stp1.jpg" alt="Main.storyboard"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将表视图控制器场景设置为初始视图控制器，并使用相应的类创建 <code>TableViewController.swift</code> 文件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dataSource: [<span class="type">String</span>] = [</span><br><span class="line">        <span class="string">"Donec id elit non mi porta gravida at eget metus."</span>,</span><br><span class="line">        <span class="string">"Integer posuere erat a ante venenatis dapibus posuere velit aliquet. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus."</span>,</span><br><span class="line">        <span class="string">"Duis mollis, est non commodo luctus, nisi erat porttitor ligula, eget lacinia odio sem nec elit. Vestibulum id ligula porta felis euismod semper. Nullam id dolor id nibh ultricies vehicula ut id elit. Nullam quis risus eget urna mollis ornare vel eu leo."</span>,</span><br><span class="line">        <span class="string">"Maecenas faucibus mollis interdum."</span>,</span><br><span class="line">        <span class="string">"Donec ullamcorper nulla non metus auctor fringilla. Aenean lacinia bibendum nulla sed consectetur. Cras mattis consectetur purus sit amet fermentum."</span>,</span><br><span class="line">        <span class="string">"Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Maecenas faucibus mollis interdum."</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TableViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dataSource.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"Cell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">TableViewCell</span></span><br><span class="line"></span><br><span class="line">        cell.dynamicLabel?.text = <span class="keyword">self</span>.dataSource[indexPath.row]</span><br><span class="line">        cell.dynamicLabel.font  = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该设置实际上是自我描述的。 你已经有了一个字符串数组作为数据源，以及 <code>UITableViewDataSource</code> 协议的必需实现。</p><p>唯一缺少的是 <code>TableViewCell</code> 类:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> dynamicLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，创建类本身，然后使用界面构建器选择表视图控制器场景并将标签拖到原型单元中。 将原型单元格的类设置为 <code>TableViewCell</code> 。 可重复使用的标识符可以简单地是 <code>“ Cell”</code>。 将 <code>dynamicLabel</code> 插座连接到视图。 将标签的上，下，前，尾约束赋予父视图，默认值为8。选择标签，将字体设置为主体样式，并将 <code>lines</code> 属性设置为零。 就是这么简单。 😂</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sc-stp2.jpg" alt="TableViewCell"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在你已经准备好了。 你只需要在表格视图上设置估计的行高。 在 <code>TableViewController</code> 类内部，更改 <code>viewDidLoad</code> 方法，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">44</span></span><br><span class="line">    <span class="keyword">self</span>.tableView.rowHeight = <span class="type">UITableView</span>.automaticDimension</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>EstimateRowHeight</code> 属性将告诉系统 <code>tableview</code> 应该尝试动态计算每个单元格的高度。 你还应该将 <code>rowHeight</code> 属性更改为自动尺寸，如果不这样做，则系统将使用静态单元格高度-你可以在单元格上设置的界面生成器高度。 现在构建并运行。 你将拥有一个带有自定义尺寸单元格的绝佳表格视图。 你甚至可以旋转设备，它将在两个方向上都能正常工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你在 <code>iOS</code> 辅助功能设置下更改了文字大小，表格视图将反映这些更改，因此它将使布局适应新值。 表格视图的字体大小将使 <code>comcorint</code> 更改为滑块值。 你可能想要订阅 <code>UIContentSizeCategory.didChangeNotification</code> 以便检测大小更改并重新加载 <code>UI</code> 。 此功能称为动态类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>.tableView, selector: #selector(<span class="type">UITableView</span>.reloadData), name: <span class="type">UIContentSizeCategory</span>.didChangeNotification,, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></br><h1 id="UICollectionView"><a href="#UICollectionView" class="headerlink" title="UICollectionView"></a><strong>UICollectionView</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，我们完成了简单的部分。 现在，让我们尝试通过集合视图实现相同的功能。 <code>UICollectionView</code> 是一个通用类，旨在创建自定义布局，因为这种通用行为，你将无法从界面生成器创建自定义单元格。 你必须通过代码来完成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开始之前，我们仍然可以使用 <code>IB</code> 。 创建一个新的集合视图控制器场景，然后将一个推键从上一个表视图单元格拖到这个新的控制器上。 最后，将整个内容嵌入导航控制器中。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sc-stp3.jpg" alt="UICollectionView"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该单元将与我们用于表视图的单元完全相同，但是它是 <code>UICollectionViewCell</code> 的子类，并且我们将直接从代码构造布局。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionViewCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> dynamicLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="keyword">self</span>.bounds)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line">        label.backgroundColor = <span class="type">UIColor</span>.darkGray</span><br><span class="line">        label.numberOfLines = <span class="number">0</span></span><br><span class="line">        label.preferredMaxLayoutWidth = frame.size.width</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(label)</span><br><span class="line">        <span class="keyword">self</span>.dynamicLabel = label</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.dynamicLabel.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setPreferred</span><span class="params">(width: CGFloat)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.dynamicLabel.preferredMaxLayoutWidth = width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们为单元格提供了一个子类，现在让我们创建视图控制器类。 在 <code>viewDidLoad</code> 方法内部，你必须在集合视图上设置 <code>EstimatedItemSize</code> 属性。 如果输入的尺寸错误，自动旋转将无法正常工作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.navigationItem.rightBarButtonItem = <span class="type">UIBarButtonItem</span>(barButtonSystemItem: .refresh, target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.toggleColumns))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.register(<span class="type">CollectionViewCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView?.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">        flowLayout.itemSize = <span class="type">CGSize</span>(width: <span class="number">64</span>, height: <span class="number">64</span>)</span><br><span class="line">        flowLayout.minimumInteritemSpacing = <span class="number">10</span></span><br><span class="line">        flowLayout.minimumLineSpacing = <span class="number">20</span></span><br><span class="line">        flowLayout.sectionInset = <span class="type">UIEdgeInsets</span>(top: <span class="number">10</span>, <span class="keyword">left</span>: <span class="number">10</span>, bottom: <span class="number">10</span>, <span class="keyword">right</span>: <span class="number">10</span>)</span><br><span class="line">        flowLayout.estimatedItemSize = <span class="type">CGSize</span>(width: <span class="keyword">self</span>.preferredWith(forSize: <span class="keyword">self</span>.view.bounds.size), height: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.reloadData()</span><br><span class="line"></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>.collectionView!, selector: #selector(<span class="type">UICollectionView</span>.reloadData), name: <span class="type">UIContentSizeCategory</span>.didChangeNotification, object: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在旋转方法内部，必须使集合视图布局无效，并在发生过渡时重新计算可见的单元格大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">traitCollectionDidChange</span><span class="params">(<span class="number">_</span> previousTraitCollection: UITraitCollection?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span></span><br><span class="line">        <span class="keyword">let</span> previousTraitCollection = previousTraitCollection,</span><br><span class="line">        <span class="keyword">self</span>.traitCollection.verticalSizeClass != previousTraitCollection.verticalSizeClass ||</span><br><span class="line">        <span class="keyword">self</span>.traitCollection.horizontalSizeClass != previousTraitCollection.horizontalSizeClass</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">    <span class="keyword">self</span>.collectionView?.reloadData()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillTransition</span><span class="params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewWillTransition(to: size, with: coordinator)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">    <span class="keyword">self</span>.estimateVisibleCellSizes(to: size)</span><br><span class="line"></span><br><span class="line">    coordinator.animate(alongsideTransition: &#123; context <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    &#125;, completion: &#123; context <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有两种辅助方法可以计算估计的项目大小的首选宽度并重新计算可见的单元格大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preferredWith</span><span class="params">(forSize size: CGSize)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> columnFactor: <span class="type">CGFloat</span> = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.twoColumns &#123;</span><br><span class="line">        columnFactor = <span class="number">2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (size.width - <span class="number">30</span>) / columnFactor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">estimateVisibleCellSizes</span><span class="params">(to size: CGSize)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> collectionView = <span class="keyword">self</span>.collectionView <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView?.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">        flowLayout.estimatedItemSize = <span class="type">CGSize</span>(width: <span class="keyword">self</span>.preferredWith(forSize: size), height: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    collectionView.visibleCells.forEach(&#123; cell <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cell = cell <span class="keyword">as</span>? <span class="type">CollectionViewCell</span> &#123;</span><br><span class="line">            cell.setPreferred(width: <span class="keyword">self</span>.preferredWith(forSize: size))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果进行适当的计算，甚至可以包含多列。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我只有一件事无法解决，但这只是一条日志消息。 如果向后旋转设备，则某些单元格将不可见，布局引擎将无法对这些单元格进行快照。</p><p><strong><em>快照尚未渲染的视图将导致快照为空。 确保在快照之前或屏幕更新后快照至少已渲染一次视图。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你可以通过某种方式使此消息消失 <code>OS_ACTIVITY_MODE = disable</code> 。 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如何在Swift中为表格视图和集合视图制作自定义大小的单元格，以支持方向更改和动态字体类型。&lt;/p&gt;
&lt;/br&gt;

&lt;h1 id=&quot;UITableView&quot;&gt;&lt;a href=&quot;#UITableView&quot; class=&quot;headerlink&quot; title=&quot;UITableView&quot;&gt;&lt;/a&gt;&lt;strong&gt;UITableView&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此，让我们从 &lt;code&gt;iOS&lt;/code&gt; 的标准单视图模板开始。 命名项目，然后直接转到 &lt;code&gt;Main.storyboard&lt;/code&gt; 文件。 选择你的 &lt;code&gt;ViewController&lt;/code&gt; ，将其删除并创建一个新的 &lt;code&gt;UITableViewController&lt;/code&gt; &lt;code&gt;scene&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自适应布局" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"/>
    
      <category term="UITableView" scheme="http://www.xuebaonline.com/tags/UITableView/"/>
    
  </entry>
  
  <entry>
    <title>Swift使用布局锚点添加约束</title>
    <link href="http://www.xuebaonline.com/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/"/>
    <id>http://www.xuebaonline.com/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/</id>
    <published>2020-04-26T12:12:24.000Z</published>
    <updated>2020-04-27T01:30:53.037Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Auto Layout</code> 经常引起抱怨的是，语法以编程方式创建约束的方式多么繁琐和难以理解。 幸运的是，<code>iOS 9</code> 做了很多改进。 <code>堆栈视图</code> 消除了我们在典型布局中创建许多约束的需要。 相比较而言，布局锚点和布局指南的引入却被忽略了，但同样有用。 从《 Apple自动版面指南》中：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以编程方式创建约束时，你有三个选择：可以使用 <code>layout anchors</code> ，可以使用 <code>NSLayoutConstraint</code> 类，或者可以使用可视格式语言。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将再次看一下布局指南，但是现在这里是我关于使用布局锚点在代码中轻松创建约束的说明：</p><a id="more"></a></br><h1 id="创建约束"><a href="#创建约束" class="headerlink" title="创建约束"></a><strong>创建约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先提醒一下使用 <code>NSLayoutConstraint</code> 类方法创建约束的方式。 假设我们有一个堆栈视图，我们想要固定到视图控制器顶级视图的左右边距：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLayoutConstraint</span>(item: stackView,</span><br><span class="line">  attribute: .leading,</span><br><span class="line">  relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">  toItem: view,</span><br><span class="line">  attribute: .leadingMargin,</span><br><span class="line">  multiplier: <span class="number">1</span>,</span><br><span class="line">  constant: <span class="number">0</span>).isActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="type">NSLayoutConstraint</span>(item: stackView,</span><br><span class="line">  attribute: .trailing,</span><br><span class="line">  relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">  toItem: view,</span><br><span class="line">  attribute: .trailingMargin,</span><br><span class="line">  multiplier: <span class="number">1</span>,</span><br><span class="line">  constant: <span class="number">0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以将堆栈视图固定在顶部布局指南下方，以免被导航栏隐藏：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLayoutConstraint</span>(item: stackView,</span><br><span class="line">attribute: .top,</span><br><span class="line">relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">toItem: topLayoutGuide,</span><br><span class="line">attribute: .bottom,</span><br><span class="line">multiplier: <span class="number">1</span>,</span><br><span class="line">constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为我们可以同意，这既不美观也不容易理解（ <code>Objective-C</code> 版本更糟）。 在我看来，使用 <strong><em>Visual Format Language</em></strong> 并不是更好：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> views: [<span class="type">String</span>: <span class="type">AnyObject</span>] =</span><br><span class="line">  [<span class="string">"stackView"</span> : stackView,</span><br><span class="line">   <span class="string">"topLayoutGuide"</span> : topLayoutGuide]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="type">NSLayoutConstraint</span>.constraints(</span><br><span class="line">  withVisualFormat: <span class="string">"|-[stackView]-|"</span>,</span><br><span class="line">  options: [],</span><br><span class="line">  metrics: <span class="literal">nil</span>,</span><br><span class="line">  views: views)</span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate(h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="type">NSLayoutConstraint</span>.constraints(</span><br><span class="line">  withVisualFormat: <span class="string">"V:|[topLayoutGuide]-[stackView]"</span>,</span><br><span class="line">  options: [],</span><br><span class="line">  metrics: <span class="literal">nil</span>,</span><br><span class="line">  views: views)</span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate(v)</span><br></pre></td></tr></table></figure></br><h1 id="使用-Layout-Anchors-创建约束"><a href="#使用-Layout-Anchors-创建约束" class="headerlink" title="使用 Layout Anchors 创建约束"></a><strong>使用 <code>Layout Anchors</code> 创建约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布局锚点使创建约束更加容易。 从文档中：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>NSLayoutAnchor</code> 类是用于使用流畅的 <code>API</code> 创建 <code>NSLayoutConstraint</code> 对象的工厂类。 使用这些约束可以使用“自动布局”以编程方式定义你的布局。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布局锚点是 <code>UIView</code>（或<code>UILayoutGuide</code> ）上的属性。 每个属性都是 <code>NSLayoutAnchor</code> 的子类，其方法可直接为其他相同类型的布局锚创建约束。 <code>UIView</code> 具有十二种不同的布局锚点属性，可用于创建水平，垂直或基于大小的约束：</p><h2 id="水平约束"><a href="#水平约束" class="headerlink" title="水平约束"></a><strong><em>水平约束</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于创建水平约束的  <code>NSLayoutXAxisAnchor</code> 类型的布局锚点：</p><ul><li><code>centerXAnchor</code></li><li><code>leadingAnchor</code> 和 <code>trailingAnchor</code></li><li><code>leftAnchor</code> 和 <code>rightAnchor</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，创建约束以使两个视图居中对齐：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">myView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.centerXAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.centerXAnchor].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><p><strong><em>请注意如何从一个视图上的锚点开始并为另一个视图上的锚点创建约束。</em></strong></p><h2 id="垂直约束"><a href="#垂直约束" class="headerlink" title="垂直约束"></a><strong><em>垂直约束</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于创建垂直约束的 <code>NSLayoutYAxisAnchor</code> 类型的布局锚点：</p><ul><li><code>centerYAnchor</code></li><li><code>bottomAnchor</code> 和 <code>topAnchor</code></li><li><code>firstBaselineAnchor</code> 和 <code>lastBaselineAnchor</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，要在间距恒定的两个视图的顶部和底部锚点之间创建约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swift</span><br><span class="line">myView.bottomAnchor.constraint(equalTo: view.topAnchor,</span><br><span class="line">       constant: 8).isActive&#x3D;true</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.bottomAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.topAnchor</span><br><span class="line">      constant:<span class="number">8.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="基于-Size-的约束"><a href="#基于-Size-的约束" class="headerlink" title="基于 Size 的约束"></a><strong><em>基于 Size 的约束</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>NSLayoutDimension</code> 类型的布局锚，用于创建基于 <code>Size</code> 的约束：</p><ul><li><code>heightAnchor</code> 和 <code>widthAnchor</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，为视图创建宽度约束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">myView.widthAnchor.constraint(equalToConstant: <span class="number">50.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.widthAnchor constraintEqualToConstant:<span class="number">50.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个示例，使用 <code>multiplier</code> 使一个视图的高度是另一个视图的高度的两倍：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">myView.heightAnchor.constraint(equalTo: otherView.heightAnchor,</span><br><span class="line">       multiplier: <span class="number">2.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.heightAnchor constraintEqualToAnchor:<span class="keyword">self</span>.otherView.heightAnchor </span><br><span class="line">      multiplier:<span class="number">2.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="视图边距"><a href="#视图边距" class="headerlink" title="视图边距"></a><strong><em>视图边距</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIView</code> 没有用于创建堆栈视图约束时使用的前，后边距的布局锚。 相反，<code>iOS 9</code> 添加了两个新属性， <code>layoutMarginGuide</code> 和可读 <code>readableContentGuide</code> ，它们又具有布局锚点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，要将子视图的前沿约束到父视图的前面：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="keyword">let</span> margins = view.layoutMarginsGuide    </span><br><span class="line">myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line"><span class="type">UILayoutGuide</span> *margins = <span class="keyword">self</span>.view.layoutMarginsGuide;</span><br><span class="line">[<span class="keyword">self</span>.myView.leadingAnchor constraintEqualToAnchor:</span><br><span class="line">      margins.leadingAnchor].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="顶部和底部布局"><a href="#顶部和底部布局" class="headerlink" title="顶部和底部布局"></a><strong><em>顶部和底部布局</em></strong></h2><blockquote><p><strong><code>提示:</code></strong> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顶部和底部布局指南已由 <code>iOS 11</code> 中的 <code>“Safe Area Layout Guide ”</code> 代替。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你要相对于顶部或底部 <code>UIKit</code> 工具栏定位内容时，视图控制器具有 <code>topLayoutGuide</code> 和 <code>bottomLayoutGuide</code> 属性。 从 <code>iOS 9</code> 开始，这两个属性均符合 <code>UILayoutSupport</code>  协议，该协议为 <code>bar</code> 提供了 <code>bottomAnchor</code> ， <code>topAnchor</code> 和 <code>heightAnchor</code> 属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，要将视图放置在顶部布局指南底部下方8个点处：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">    myView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor,</span><br><span class="line">       constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">    [<span class="keyword">self</span>.stackView.topAnchor constraintEqualToAnchor:<span class="keyword">self</span>.topLayoutGuide.bottomAnchor</span><br><span class="line">       constant:<span class="number">8.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="控件组合布局"><a href="#控件组合布局" class="headerlink" title="控件组合布局"></a><strong><em>控件组合布局</em></strong></h2><p><strong>那么我们如何使用布局锚创建堆栈视图约束？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们获得父视图的 <code>leading</code> 和 <code>trailing</code> 边距：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> margins = view.layoutMarginsGuide</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建 <code>leading</code> 和 <code>trailing</code>  水平约束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = <span class="literal">true</span></span><br><span class="line">stackView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我们使用视图控制器的 <code>topLayoutGuide</code> 属性将堆栈视图固定在导航栏下方的8点处：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor,</span><br><span class="line">          constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Objective-C</code> 版本稍微冗长一些，但仍有很大改进：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UILayoutGuide</span> *margins = <span class="keyword">self</span>.view.layoutMarginsGuide;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.stackView.leadingAnchor</span><br><span class="line">      constraintEqualToAnchor:margins.leadingAnchor].active = <span class="type">YES</span>;</span><br><span class="line">[<span class="keyword">self</span>.stackView.trailingAnchor</span><br><span class="line">      constraintEqualToAnchor:margins.trailingAnchor].active = <span class="type">YES</span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.stackView.topAnchor</span><br><span class="line">      constraintEqualToAnchor:<span class="keyword">self</span>.topLayoutGuide.bottomAnchor</span><br><span class="line">      constant:<span class="number">8.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与以前的代码相比，我发现更容易理解这些约束的意图。</p></br><h1 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a><strong>了解更多</strong></h1><ul><li><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ProgrammaticallyCreatingConstraints.html" target="_blank" rel="noopener"><strong><code>Programmatically Creating Constraints (Apple Auto Layout Guide)</code></strong></a></li><li><a href="https://developer.apple.com/videos/play/wwdc2015/219/" target="_blank" rel="noopener"><strong><code>WWDC 2015 Session 219 Mysteries of Auto Layout, Part 2</code></strong></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Auto Layout&lt;/code&gt; 经常引起抱怨的是，语法以编程方式创建约束的方式多么繁琐和难以理解。 幸运的是，&lt;code&gt;iOS 9&lt;/code&gt; 做了很多改进。 &lt;code&gt;堆栈视图&lt;/code&gt; 消除了我们在典型布局中创建许多约束的需要。 相比较而言，布局锚点和布局指南的引入却被忽略了，但同样有用。 从《 Apple自动版面指南》中：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在以编程方式创建约束时，你有三个选择：可以使用 &lt;code&gt;layout anchors&lt;/code&gt; ，可以使用 &lt;code&gt;NSLayoutConstraint&lt;/code&gt; 类，或者可以使用可视格式语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我将再次看一下布局指南，但是现在这里是我关于使用布局锚点在代码中轻松创建约束的说明：&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自动化布局" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>Swift掌握iOS自动布局锚点</title>
    <link href="http://www.xuebaonline.com/Swift%E6%8E%8C%E6%8F%A1iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9/"/>
    <id>http://www.xuebaonline.com/Swift%E6%8E%8C%E6%8F%A1iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9/</id>
    <published>2020-04-26T12:10:50.000Z</published>
    <updated>2020-04-27T01:59:09.032Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;寻找使用布局锚点的最佳实践吗？ 让我们学习如何使用 <code>Swift</code> 以正确的方式使用 <code>iOS</code> 自动布局系统。</p><h1 id="以代码方式创建视图和约束"><a href="#以代码方式创建视图和约束" class="headerlink" title="以代码方式创建视图和约束"></a><strong>以代码方式创建视图和约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我想回顾一下 <code>UIViewController</code> 生命周期方法，你可能对其中一些方法很熟悉。 它们按以下顺序被调用：</p><ul><li><code>loadView</code></li><li><code>viewDidLoad</code></li><li><code>viewWillAppear</code></li><li><code>viewWillLayoutSubviews</code></li><li><code>viewDidLayoutSubviews</code></li><li><code>viewDidAppear</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在自动布局之前，你必须在 <code>viewDidLayoutSubviews</code> 方法内进行布局计算，但是由于这是专业的自动布局教程，因此我们仅关注 <code>loadView</code> 和 <code>viewDidLoad</code> 方法。 🤓</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些是使用自动布局创建视图层次结构的基本规则：</p><ul><li>永远不要自己手动计算帧！</li><li>使用 <code>.zero</code> 初始化视图 <code>frame</code></li><li>将 <code>translatesAutoresizing</code>, <code>MaskIntoConstraints</code> 设置为 <code>false</code></li><li>使用 <code>addSubview</code> 将视图添加到视图层次结构</li><li>创建并激活你的布局约束 <code>NSLayoutConstraint.activate</code></li><li>使用 <code>loadView</code> 代替 <code>viewDidLoad</code> 创建具有约束的视图</li><li>通过使用弱引用来管理内存管理</li><li>在 <code>viewDidLoad</code> 中设置所有其他属性，例如背景色等。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理论足够，下面是一个简短的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> testView: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">        testView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(testView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            testView.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            testView.widthAnchor.constraint(equalTo: testView.heightAnchor),</span><br><span class="line">            testView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">            testView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.testView = testView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView.backgroundColor = .red</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很简单吧？ 只需几行代码，你就可以得到一个大小固定的中心对齐视图，并带有专用的类属性引用。 如果通过接口构建器创建完全相同的对象，则调用 <code>loadView</code> 方法，但是你必须设置对该视图的 <code>@IBOutlet</code> 引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没关系，请随意选择。 有时我喜欢和 <code>IB</code> 一起玩，但是在大多数情况下，我更喜欢编程的做事方式。 😛</p></br><h1 id="常见的UIKit自动布局约束用例"><a href="#常见的UIKit自动布局约束用例" class="headerlink" title="常见的UIKit自动布局约束用例"></a><strong>常见的UIKit自动布局约束用例</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我只使用布局锚。 你可能会浪费时间使用 <code>visual format language</code> ，但这绝对是死胡同。 因此，请记住我的话：仅使用锚点或堆栈视图，请勿使用其他任何视图！ 😇</p><p>这是我用来创建漂亮布局的最常见模式。 😉</p><h2 id="设置固定宽度或高度"><a href="#设置固定宽度或高度" class="headerlink" title="设置固定宽度或高度"></a><strong><em>设置固定宽度或高度</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个是最简单的一个：将视图的高度或宽度设置为固定点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.widthAnchor.constraint(equalToConstant: <span class="number">320</span>),</span><br><span class="line">testView.heightAnchor.constraint(equalToConstant: <span class="number">240</span>),</span><br></pre></td></tr></table></figure><h2 id="设定长宽比"><a href="#设定长宽比" class="headerlink" title="设定长宽比"></a><strong><em>设定长宽比</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置视图的纵横比只是将宽度限制为高度，反之亦然，你可以通过 <code>multiplier</code> 简单地定义倍数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">testView.widthAnchor.constraint(equalTo: testView.heightAnchor, multiplier: <span class="number">16</span>/<span class="number">9</span>),</span><br></pre></td></tr></table></figure><h2 id="水平和垂直居中"><a href="#水平和垂直居中" class="headerlink" title="水平和垂直居中"></a><strong><em>水平和垂直居中</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将视图居中放置在另一个视图中是一件很简单的事情，为此需要特定的锚点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">testView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br></pre></td></tr></table></figure><h2 id="伸展-用边距填充内部视图"><a href="#伸展-用边距填充内部视图" class="headerlink" title="伸展 | 用边距填充内部视图"></a><strong><em>伸展 | 用边距填充内部视图</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里唯一棘手的部分是，对于常量，尾部约束和底部约束的行为与顶部和前部约束略有不同。 通常，你必须使用负值，但经过几次尝试，你将在这里理解逻辑。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.topAnchor, constant: <span class="number">32</span>),</span><br><span class="line">testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.leadingAnchor, constant: <span class="number">32</span>),</span><br><span class="line">testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.trailingAnchor, constant: -<span class="number">32</span>),</span><br><span class="line">testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.bottomAnchor, constant: -<span class="number">32</span>),</span><br></pre></td></tr></table></figure><h2 id="比例宽度或高度"><a href="#比例宽度或高度" class="headerlink" title="比例宽度或高度"></a><strong><em>比例宽度或高度</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不想使用常量值，可以使用 <code>multiplier</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.widthAnchor.constraint(equalTo: <span class="keyword">self</span>.view.widthAnchor, multiplier: <span class="number">1</span>/<span class="number">3</span>),</span><br><span class="line">testView.heightAnchor.constraint(equalTo: <span class="keyword">self</span>.view.heightAnchor, multiplier: <span class="number">2</span>/<span class="number">3</span>),</span><br></pre></td></tr></table></figure><h2 id="使用-safe-area-layout"><a href="#使用-safe-area-layout" class="headerlink" title="使用 safe area layout"></a><strong><em>使用 safe area layout</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用最新的 <code>iPhone</code> ，你将需要一些指南，以确保你安全无虞。 这就是视图具有 <code>safeAreaLayoutGuide</code> 属性的原因。 调出安全区域指南后，即可获得所有常用锚。 💪</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor),</span><br><span class="line">testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.leadingAnchor),</span><br><span class="line">testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.trailingAnchor),</span><br><span class="line">testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor),</span><br></pre></td></tr></table></figure></br><h1 id="带有动画的布局约束"><a href="#带有动画的布局约束" class="headerlink" title="带有动画的布局约束"></a><strong>带有动画的布局约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有约束的动画很容易，你不应该相信别人会说什么。 我制定了一些规则和示例，可以帮助你理解为约束的常量值设置动画效果以及切换各种约束的基本原理。 👍</p><p><strong>规则</strong>：</p><ul><li>将标准 <code>UIView</code> 动画与 <code>layoutIfNeeded</code> 一起使用</li><li>始终先停用约束</li><li>遵守停用的约束</li><li>玩得开心！ 😛</li></ul><p>约束动画示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> testView: <span class="type">UIView!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> topConstraint: <span class="type">NSLayoutConstraint!</span></span><br><span class="line">    <span class="keyword">var</span> bottomConstraint: <span class="type">NSLayoutConstraint!</span></span><br><span class="line">    <span class="keyword">var</span> heightConstraint: <span class="type">NSLayoutConstraint!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">        testView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(testView)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> topConstraint = testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor)</span><br><span class="line">        <span class="keyword">let</span> bottomConstraint = testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor)</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            topConstraint,</span><br><span class="line">            testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.leadingAnchor),</span><br><span class="line">            testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.trailingAnchor),</span><br><span class="line">            bottomConstraint,</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> heightConstraint = testView.heightAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.heightAnchor, multiplier: <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView = testView</span><br><span class="line">        <span class="keyword">self</span>.topConstraint = topConstraint</span><br><span class="line">        <span class="keyword">self</span>.bottomConstraint = bottomConstraint</span><br><span class="line">        <span class="keyword">self</span>.heightConstraint = heightConstraint</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView.backgroundColor = .red</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> tap = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.tapped))</span><br><span class="line">        <span class="keyword">self</span>.view.addGestureRecognizer(tap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">tapped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.topConstraint.constant != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.topConstraint.constant = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.topConstraint.constant = <span class="number">64</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.bottomConstraint.isActive &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.deactivate([<span class="keyword">self</span>.bottomConstraint])</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate([<span class="keyword">self</span>.heightConstraint])</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.deactivate([<span class="keyword">self</span>.heightConstraint])</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate([<span class="keyword">self</span>.bottomConstraint])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: <span class="number">0.25</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.view.layoutIfNeeded()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，还算不错：适应性强并且支持多种设备屏幕尺寸。 🤔</p></br><h1 id="如何为iOS创建自适应布局？"><a href="#如何为iOS创建自适应布局？" class="headerlink" title="如何为iOS创建自适应布局？"></a><strong>如何为iOS创建自适应布局？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果公司内置的 <code>iOS</code> 应用程序中都难以适应自适应布局。 如果你查看使用收藏夹视图制作的应用程序（例如照片），则在每个设备上的布局都可以。 但是，还有其他一些-我认为-在更大的屏幕上是可怕的经历。 <code>#just use collectionview</code> 所有内容。 🤐</p><h2 id="支持旋转"><a href="#支持旋转" class="headerlink" title="支持旋转"></a><strong><em>支持旋转</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自适应布局的第一步是支持多种设备方向。 你可以查看我以前有关iOS自动布局的文章，其中有很多关于旋转支持，在自动布局区域内使用图层等方面的好文章。</p><h2 id="特征集合"><a href="#特征集合" class="headerlink" title="特征集合"></a><strong><em>特征集合</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步是调整特征集合。  <code>UITraitCollection</code> 可以为你分组所有特定于环境的特征，例如尺寸类别，显示比例，用户界面 <code>idom</code> 等。 大多数时候，你将不得不检查垂直和水平尺寸类别。 有设备尺寸类别的参考以及 <code>Apple</code> 所做的所有可能的变化，请参阅下面的外部资源部分。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的这个小段 <code>Swift</code> 代码示例演示了如何检查尺寸类别，以便为紧凑型和常规屏幕设置不同的布局。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> testView: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> regularConstraints: [<span class="type">NSLayoutConstraint</span>] = []</span><br><span class="line">    <span class="keyword">var</span> compactConstraints: [<span class="type">NSLayoutConstraint</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">        testView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(testView)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.regularConstraints = [</span><br><span class="line">            testView.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            testView.widthAnchor.constraint(equalTo: testView.heightAnchor),</span><br><span class="line">            testView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">            testView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.compactConstraints = [</span><br><span class="line">            testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor),</span><br><span class="line">            testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.leadingAnchor),</span><br><span class="line">            testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.trailingAnchor),</span><br><span class="line">            testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.activateCurrentConstraints()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView = testView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">activateCurrentConstraints</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.deactivate(<span class="keyword">self</span>.compactConstraints + <span class="keyword">self</span>.regularConstraints)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.traitCollection.verticalSizeClass == .regular &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate(<span class="keyword">self</span>.regularConstraints)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate(<span class="keyword">self</span>.compactConstraints)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView.backgroundColor = .red</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - rotation support</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .allButUpsideDown</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .portrait</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - trait collections</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">traitCollectionDidChange</span><span class="params">(<span class="number">_</span> previousTraitCollection: UITraitCollection?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.activateCurrentConstraints()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设备检测"><a href="#设备检测" class="headerlink" title="设备检测"></a><strong><em>设备检测</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以通过 <code>UIDevice</code> 类检查用户界面 <code>idom</code> （是 <code>iPhone</code> 还是 <code>iPad</code> ？），以基于该设备设置例如字体大小。 📱</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIDevice</span>.current.userInterfaceIdiom == .pad</span><br></pre></td></tr></table></figure><h2 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a><strong><em>屏幕尺寸</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定你的环境的另一个选项是检查屏幕的大小。 你可以检查原始像素数或以 <code>points</code> 为单位的相对大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iPhone X</span></span><br><span class="line"><span class="type">UIScreen</span>.main.nativeBounds   <span class="comment">// 1125x2436</span></span><br><span class="line"><span class="type">UIScreen</span>.main.bounds         <span class="comment">// 375x812</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常我会尽力遵守这些规则。 我真的不记得一个场景，在这种情况下，我需要的不只是上面列出的所有内容。 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;寻找使用布局锚点的最佳实践吗？ 让我们学习如何使用 &lt;code&gt;Swift&lt;/code&gt; 以正确的方式使用 &lt;code&gt;iOS&lt;/code&gt; 自动布局系统。&lt;/p&gt;
&lt;h1 id=&quot;以代码方式创建视图和约束&quot;&gt;&lt;a href=&quot;#以代码方式创建视图和约束&quot; class=&quot;headerlink&quot; title=&quot;以代码方式创建视图和约束&quot;&gt;&lt;/a&gt;&lt;strong&gt;以代码方式创建视图和约束&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先，我想回顾一下 &lt;code&gt;UIViewController&lt;/code&gt; 生命周期方法，你可能对其中一些方法很熟悉。 它们按以下顺序被调用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;loadView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewDidLoad&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewWillAppear&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewWillLayoutSubviews&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewDidLayoutSubviews&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewDidAppear&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在自动布局之前，你必须在 &lt;code&gt;viewDidLayoutSubviews&lt;/code&gt; 方法内进行布局计算，但是由于这是专业的自动布局教程，因此我们仅关注 &lt;code&gt;loadView&lt;/code&gt; 和 &lt;code&gt;viewDidLoad&lt;/code&gt; 方法。 🤓&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="自动化布局" scheme="http://www.xuebaonline.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>iOS自动化布局编程</title>
    <link href="http://www.xuebaonline.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.xuebaonline.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80%E7%BC%96%E7%A8%8B/</id>
    <published>2020-04-26T11:42:40.000Z</published>
    <updated>2020-04-26T12:14:39.344Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个出色的 <code>iOS Auto Layout</code> 教程中，我将教你如何支持旋转，使用约束，使用图层以及设置拐角半径的动画。</p><br><h1 id="支持旋转"><a href="#支持旋转" class="headerlink" title="支持旋转"></a><strong>支持旋转</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你的应用程序要支持多种设备方向，则应在视图控制器内部实现以下方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .portrait</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .portrait</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，你可以更改返回值以不仅支持纵向，还支持横向模式。 这很容易，但是，如果你的控制器嵌入在导航或选项卡栏控制器内部，则旋转将停止工作。 在这种情况下，你必须继承 <code>UINavigationController</code> 的子类，并且必须从顶视图控制器返回正确的值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NavigationController</span>: <span class="title">UINavigationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> shouldRotate = <span class="keyword">self</span>.topViewController?.shouldAutorotate &#123;</span><br><span class="line">            <span class="keyword">return</span> shouldRotate</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldAutorotate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> orientation = <span class="keyword">self</span>.topViewController?.supportedInterfaceOrientations &#123;</span><br><span class="line">            <span class="keyword">return</span> orientation</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.supportedInterfaceOrientations</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> orientation = <span class="keyword">self</span>.topViewController?.preferredInterfaceOrientationForPresentation &#123;</span><br><span class="line">            <span class="keyword">return</span> orientation</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preferredInterfaceOrientationForPresentation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果具有 <code>UITabBarController</code> ，则适用相同的逻辑，但必须使用 <code>selectedIndex</code> 并基于所选视图控制器返回属性，而不是顶视图控制器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabBarController</span>: <span class="title">UITabBarController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewController = <span class="keyword">self</span>.viewControllers?[<span class="keyword">self</span>.selectedIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> viewController.shouldAutorotate</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldAutorotate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewController = <span class="keyword">self</span>.viewControllers?[<span class="keyword">self</span>.selectedIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> viewController.supportedInterfaceOrientations</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.supportedInterfaceOrientations</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewController = <span class="keyword">self</span>.viewControllers?[<span class="keyword">self</span>.selectedIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> viewController.preferredInterfaceOrientationForPresentation</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preferredInterfaceOrientationForPresentation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，你的嵌入式控制器就可以控制支持的方向。 哦，顺便说一句，你可以使用此方法更改状态栏样式。</p></br><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a><strong>约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了 <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/" target="_blank" rel="noopener"><code>了解约束</code></a> 和 <a href="https://www.raywenderlich.com/160527/auto-layout-tutorial-ios-11-getting-started" target="_blank" rel="noopener"><code>Auto Layout engine</code></a> 的当前状态，我们应该回到过去并从头开始。</p><h2 id="Springs-and-struts"><a href="#Springs-and-struts" class="headerlink" title="Springs and struts"></a><strong><em>Springs and struts</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还记得第一部 <code>iPhone</code> 吗？ 一屏统治一切！ <code>320x480</code>，没有限制，没有适应性，只有帧和边界。 在固定大小的画布上放置视图绝对是理所当然的，这是一个示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> squareFrame: <span class="type">CGRect</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> midX = <span class="keyword">self</span>.view.bounds.midX</span><br><span class="line">        <span class="keyword">let</span> midY = <span class="keyword">self</span>.view.bounds.midY</span><br><span class="line">        <span class="keyword">let</span> size: <span class="type">CGFloat</span> = <span class="number">64</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGRect</span>(x: midX-size/<span class="number">2</span>, y: midY-size/<span class="number">2</span>, width: size, height: size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.frame = <span class="keyword">self</span>.squareFrame</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>viewDidLayoutSubviews</code> 方法可以非常方便地支持旋转，如果边界矩形发生变化，我每次都必须重新计算视图的框架。 你可能会想，这很容易，但是如果你必须支持许多设备尺寸会怎样？</p><blockquote><p><strong><em>算一算！</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于单个对象，进行计算非常容易，但是通常你在屏幕上有多个视图。 这些视图可以相互联系，简单的数学技巧可以使你完全陷入帧计算的混乱之中，你还会喜欢数学吗？ 肯定有更好的办法！</p></br><h1 id="Auto-Layout"><a href="#Auto-Layout" class="headerlink" title="Auto Layout"></a><strong>Auto Layout</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果通过<code>iOS6</code>为我们带来了布局技术的圣杯。 它是先前系统的完美继承者。 每个人都很快采用了它，这就是为什么苹果工程师在下一版本中完全删除了基于框架的布局<code>API</code>的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了开玩笑之外，这是一个新时代的开始，越来越多的设备诞生了，并且由于自动版式的限制，维护视图非常容易。 现在，我们应该使用布局约束来重构前面的示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        square.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addConstraints([</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .width, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="literal">nil</span>, attribute: .width, multiplier: <span class="number">1.0</span>, constant: <span class="number">64</span>),</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .height, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="literal">nil</span>, attribute: .height, multiplier: <span class="number">1.0</span>, constant: <span class="number">64</span>),</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .centerX, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="keyword">self</span>.view, attribute: .centerX, multiplier: <span class="number">1.0</span>, constant: <span class="number">0</span>),</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .centerY, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="keyword">self</span>.view, attribute: .centerY, multiplier: <span class="number">1.0</span>, constant: <span class="number">0</span>),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我们不需要手动计算视图的框架，但是以编程方式创建约束并不是那么方便。 这就是为什么 <code>Apple</code> 制定了限制格式 <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html" target="_blank" rel="noopener"><code>Visual Format Language</code></a>。</p><blockquote><p><strong><code>VFL = WTF?</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，这个<code>VFL</code>非常糟糕，我什至不想演示它，但是无论如何…</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        square.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> views: [<span class="type">String</span>:<span class="type">Any</span>] = [<span class="string">"view"</span>: <span class="keyword">self</span>.view, <span class="string">"subview"</span>: square]</span><br><span class="line">        <span class="keyword">let</span> vertical = <span class="type">NSLayoutConstraint</span>.constraints(withVisualFormat: <span class="string">"V:[view]-(&lt;=1)-[subview(==64)]"</span>, options: .alignAllCenterX, metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> horizontal = <span class="type">NSLayoutConstraint</span>.constraints(withVisualFormat: <span class="string">"H:[view]-(&lt;=1)-[subview(==64)]"</span>, options: .alignAllCenterY, metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line">        <span class="keyword">self</span>.view.addConstraints(vertical)</span><br><span class="line">        <span class="keyword">self</span>.view.addConstraints(horizontal)</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>God forbid the engineer who invented this black magic. :)</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如你所见，我们肯定存在约束方面的问题。 创建所有约束很糟糕，至少要花很多行代码。 当然，你可以使用神奇的界面生成器，但是如果只是拖动线，那么有趣的地方在哪里呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以编程方式创建约束并不比计算框架好，它会导致你达到相同的复杂度甚至更糟，这就是为什么这么多第三方框架活跃起来并最终由<code>Apple</code>发出问题的原因。</p><blockquote><p><strong><code>提示:</code></strong><br>我有一篇<a href="http://www.xuebaonline.com/Swift%E6%8E%8C%E6%8F%A1iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9/"><code>关于掌握自动布局锚点</code></a>的出色文章，如果你想熟悉锚点，强烈建议阅读。 📖</p></blockquote></br><h1 id="锚点-Anchors"><a href="#锚点-Anchors" class="headerlink" title="锚点(Anchors)"></a><strong>锚点(Anchors)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.xuebaonline.com/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/"><code>锚点(Anchors)</code></a>的诞生是因为“自动布局”存在一些构造缺陷。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>NSLayoutAnchor</code> 类是用于使用流畅的 <code>API</code> 创建 <code>NSLayoutConstraint</code> 对象的工厂类。 使用这些约束可以使用“自动布局”以编程方式定义你的布局。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        square.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            square.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            square.heightAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            square.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">            square.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>锚点是用于自动布局约束的最佳方法。</em></strong></p></br><h1 id="自适应布局-Adaptive-layout"><a href="#自适应布局-Adaptive-layout" class="headerlink" title="自适应布局(Adaptive layout)"></a><strong>自适应布局(Adaptive layout)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果查看 <code>Apple</code> 提供的内置应用程序的当前状态，你会发现只有其中一些是响应式/自适应的。 通常，使用集合视图的应用更容易适应更大的屏幕或不同的设备方向。</p><p><strong><em>始终使用 <code>collection views</code>。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了只是屏幕中心的一个视图之外，你都应该使用集合视图来构建用户界面。 它将为你提供可重用性，更低的内存开销，滚动以及更多好处。 如果你使用的是我的 <code>CollectionView</code> 微型框架，则甚至不必计算愚蠢的索引位置。</p></br><h1 id="基于图层的自动化布局"><a href="#基于图层的自动化布局" class="headerlink" title="基于图层的自动化布局"></a><strong>基于图层的自动化布局</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动布局很棒，但有时你必须直接处理图层。 现在在这种情况下，你仍然必须进行一些计算。 如果要处理视图子类，则可以轻松覆盖 <code>bounds</code> 属性并更新 <code>didSet</code> 块中的框架。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.gradientLayer.frame = <span class="keyword">self</span>.bounds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个选项是在视图控制器中重写 <code>viewDidLayoutSubviews</code> 方法，并根据新边界设置图层的框架。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.gradientView.gradientLayer.frame = <span class="keyword">self</span>.gradientView.bounds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以使用普通的键值监听来观察对象的 <code>bounds</code> 属性，并根据该属性来更新图层的框架。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// somewhere in the init method</span></span><br><span class="line"><span class="keyword">self</span>.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"bounds"</span>, options: .new, context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: <span class="keyword">Any</span>?, change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> keyPath == <span class="string">"bounds"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.gradientLayer.frame = <span class="keyword">self</span>.bounds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"bounds"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="带有动画的圆角设置"><a href="#带有动画的圆角设置" class="headerlink" title="带有动画的圆角设置"></a><strong>带有动画的圆角设置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，如果要在使用基于约束的布局时为视图设置动画，则必须执行类似的操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.widthConstraint.constant = <span class="number">64</span></span><br><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.view.layoutIfNeeded()</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，如果要为视图的拐角半径设置动画，则可以始终使用传统方式，并在边界更改上设置图层的 <code>cornerRadius</code> 属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，自<code>iOS 10</code>以来，我们有了这个精美的新 <code>UIViewPropertyAnimator API</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="number">16</span></span><br><span class="line"><span class="type">UIViewPropertyAnimator</span>(duration: <span class="number">2.5</span>, curve: .easeInOut) &#123;</span><br><span class="line">    <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="number">32</span></span><br><span class="line">&#125;.startAnimation()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这非常简单，你甚至可以应用 <code>cornerMask</code> 来仅对某些角进行倒圆。 基于图层的布局示例位于本文提供的源代码中，以及每种自动布局技术的完整示例。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在这个出色的 &lt;code&gt;iOS Auto Layout&lt;/code&gt; 教程中，我将教你如何支持旋转，使用约束，使用图层以及设置拐角半径的动画。&lt;/p&gt;
&lt;br&gt;

&lt;h1 id=&quot;支持旋转&quot;&gt;&lt;a href=&quot;#支持旋转&quot; class=&quot;headerlink&quot; title=&quot;支持旋转&quot;&gt;&lt;/a&gt;&lt;strong&gt;支持旋转&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你的应用程序要支持多种设备方向，则应在视图控制器内部实现以下方法。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewController&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; shouldAutorotate: &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; supportedInterfaceOrientations: &lt;span class=&quot;type&quot;&gt;UIInterfaceOrientationMask&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; .portrait&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; preferredInterfaceOrientationForPresentation: &lt;span class=&quot;type&quot;&gt;UIInterfaceOrientation&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; .portrait&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>产品开发的幕后花絮</title>
    <link href="http://www.xuebaonline.com/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E7%9A%84%E5%B9%95%E5%90%8E%E8%8A%B1%E7%B5%AE/"/>
    <id>http://www.xuebaonline.com/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E7%9A%84%E5%B9%95%E5%90%8E%E8%8A%B1%E7%B5%AE/</id>
    <published>2020-04-26T10:50:21.000Z</published>
    <updated>2020-04-26T11:41:43.062Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍产品专业人员用来定义问题，创建概念和选择最佳解决方案的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与关于设计师职务的争论类似，对于设计师是否应该编码，这是一个永无止境的讨论。 首先，我们谈论的是根本不同的心态。 尽管开发人员对技术流程的思考更多，但设计人员专注于用户执行的一系列操作，因为他们的目的是提出解决客户问题的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，产品设计师（或UX设计师，但正如我之前提到的那样，我不喜欢该职位）通常不做任何编码，仅因为我们从事的活动是专职职责。 设计师的大部分工作实际上甚至没有建立图形用户界面，而是进行了大量的交流和研究。 🔍</p><a id="more"></a></br><h1 id="我们有一个问题"><a href="#我们有一个问题" class="headerlink" title="我们有一个问题"></a><strong>我们有一个问题</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，当我拿到设计图时，该过程已经开始。 我们的产品经理来找我解决问题。 有几种定义问题的方法，例如根据数据分析或竞争对手的活动做出的假设； 技术改进为我们提供了更多空间； 或客户的直接要求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步（也是最重要的一步）是了解问题。 假设我们盯着分析，看到用户在流程的某个特定点下降，放弃它而没有完成任务。 问题是：为什么？ 提供解决方案之前，你需要确定要解决的问题。 你需要了解动机，目标，需求以及用户当前解决问题的方式。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接来自客户的想法可以对你的系统进行非常好的改进，但是你需要谨慎。 系统越大，用户对系统一无所知的机会就越大，这可能导致错误的假设。 他们可能不知道某些“隐藏”的细节，但是如果知道的话，他们会问一个完全不同的问题。 用户对现有系统的信念称为心理模型。 这仅表示他们基于对当前工具的了解，相信他们可以或不能使用你的工具。 心理模型可能会因教育或经验而改变，因此在你开始编写代码之前，你可能需要了解他们为什么想要特定的东西。 也许解决方案不是他们想要的，但是你可以给他们更好的解决方案。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有几种方法可以收集有关原因的信息，而我最喜欢的两个是调查和访谈。 你可以收集所有听众提出的一些高级问题，然后发送表格。 找到适合你的问卷调查的最佳平台并不总是容易的：虽然一个渠道可以为你提供大量的答案，但另一个渠道将是死路一条。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间安排也很重要：你应该注意听众的时间表。 当他们太忙甚至不工作时，他们将没有时间或精力来帮助你。 进行良好调查的秘诀还有很多，但重点是你需要耐心，尝试几种方法来吸引受众，直到找到最适合你的案例。</p></br><h1 id="与用户的真正联系：用户访谈"><a href="#与用户的真正联系：用户访谈" class="headerlink" title="与用户的真正联系：用户访谈"></a><strong>与用户的真正联系：用户访谈</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我喜欢的另一种做法是进行用户访谈。 听起来就是这样：你与用户（最好是一对一）坐下并与他们交谈。 你需要再次准备问题，但是调查虽然可以帮助你了解很多事情，但是面试仅可以帮助你解决一些问题，但范围更广。 重要的是进行实际对话而不是询问客户：你收集的问题是面试的基础，但是当客户回答时，你可以侧身甚至完全劫持讨论（只要你谈论的是你所遇到的问题） 都想解决）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你随身携带一个记事本，这将很有帮助，这样你就可以在伴侣写下最重要的要点时全神贯注于对话。 如果你的客户同意，你可以记录下采访，以便稍后再听并写下你自己的笔记。 🗒</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重要的是要观察到广泛的用户，尤其是在组中有多种用户的情况下。 如果你只关注一个小组，那么你可能会满足这对夫妇的需求，而拒绝其他人。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我对问题有满意的答案时，我可以通过创建草图或基本模型来开始实际的“设计”工作。在这一点上，我并没有将重点放在外观或精度上，我只是尝试为我的想法建立一些视觉支持。有时，我什至没有构建整个功能或页面，而只是构建一个特定的部分，例如复杂的控制器，模式，表单等等。我还尝试至少提出2-3个概念。这将帮助我与团队交流思想：那是我参与开发人员的地方，因为下一步是了解技术限制。当然，如果我们无法为用户找出有史以来最好的UI元素，那也没关系。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在收集了我们需要的所有信息之后（包括用户的必备信息，开发人员的约束以及可能的其他因素，例如设计，完整性和一致性准则等），我们的工作重点变得更加狭窄。这是我开始在像素完美的UI上工作的地方。我创建了可点击的原型，因此可以为团队提供一个快照，以显示实际软件的外观和工作方式，更重要的是，它们将成为可用性测试的核心：是的，我们将回头再回头。</p></br><h1 id="可用性测试简介"><a href="#可用性测试简介" class="headerlink" title="可用性测试简介"></a><strong>可用性测试简介</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户测试类似于访谈，你一次要与1位用户交谈，但是你可以提出任务而不是提问。你应该准备要执行的3-4个任务，就像它们已经存在时在系统中通常会执行的操作一样。这是验证你的工作，查看用户是否真的能够通过你的特定概念解决他们的问题的好方法。你如何进行这些会议的方式可能会因项目，概念因人员而异，但是以下一些重点可以派上用场：</p><ul><li>你测试用户界面而不是用户。无论他们做错了什么，不是他们的错，这是你的界面的缺陷。他们应该知道，你也知道。</li><li>不要给出详细的说明，而要编写高级任务，类似于现实生活中的任务。即使他们受过使用你的软件的教育，也不会一直有人陪他们走走。为了模拟这一点，你也不能通过原型指导他们。</li><li>包括与任务不直接相关的选项。如果你使用一些原型制作工具，它可能会以某种方式突出显示可点击元素。如果唯一可点击的东西是测试的控制器，他们将很容易找到解决方法。但是，如果有几个不同的可操作项目，它们将能够环顾四周，打开和关闭物品，并且一旦达成交易便会迷失方向。即使你感觉“来吧，就在那里，为什么不找到它”，也应该抵制胆量并保持沉默。对你来说也许很清楚，但对他们来说却是一个谜。这些测试的目的是发现谜语，而不是证明你的想法合理。</li><li>提醒参与者在整个会议过程中大声思考，以便你了解他们为什么做自己的事情。与面试期间一样，你应该创建笔记并可能记录会话。会议结束后，你还可以与用户聊天。你可以回去问一下，如果他们在会议期间没有解释，为什么他们要做特定的事情。你甚至可以在这一点上询问他们的意见，但绝不能在会议期间提出。放弃有关UI的想法可能会使你偏离测试目标，因此请保持专注并保持参与者的专注。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些会议的结果将帮助你了解概念的弱点，或者只是帮助你选择最佳的概念。 你可以重新考虑一些事情，然后再进行测试，然后再继续。 测试和迭代的次数取决于你的时间和预算：根据 <code>Jacob Nielsen</code> 的说法，如果与5个用户一起测试，最好的方法是考虑未发现的问题的数量和会话的成本，因为一段时间后，用户会反复发现其他已经存在的问题 裸露。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适当招募参与者也很重要。 如果你要为会计师构建应用程序，则可能不会获得机械师的宝贵反馈。 同样，如果你要改善现有服务，则最好与已经使用该服务的人联系，而不是与新员工交谈（除非你尝试弄清楚新手将如何与新功能交互）。</p><br><h1 id="要避免的常见错误"><a href="#要避免的常见错误" class="headerlink" title="要避免的常见错误"></a><strong>要避免的常见错误</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一种称为设计批判的做法，在这种做法中，大量的团队成员（设计师，开发人员，质量保证人员，产品经理等）坐在一起讨论设计。 你提出自己的想法，其他人则可以基于对一致性，技术约束，所有问题或简单的可用性假设的关注而提出问题并提出更改建议。 这可能真的很有帮助：当你花很长时间尝试解决问题时，可能会遇到困难。 睁开眼睛和其他角度可以帮助你摆脱困境，无论如何都要进行一些头脑风暴总是好的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，团队经常将<code>DC</code>会话与适当的可用性验证混淆。 为什么不能仅用它们代替<code>UX</code>研究有以下几个原因：</p><ul><li><strong><em>详细说明</em></strong> &nbsp;&nbsp;&nbsp;&nbsp;在可用性测试期间，你将执行任务并查看其他人如何与你的原型进行交互，而设计评论则是关于你自己讲述整个故事。你按照流程进行操作，并告诉团队正在发生什么以及为什么。这样很容易理解，但是如果仅<code>UI</code>没有解释，则可能会失败。</li><li><strong><em>领域知识</em></strong> &nbsp;&nbsp;&nbsp;&nbsp;即使你只是在从事合同项目，与你一起工作的团队也具有丰富的领域知识。你知道系统的工作原理，知道后台发生了什么，如何传输数据，调用了什么<code>API</code>……用户不知道这种事情，你也不是你的用户。</li><li><strong><em>主观性</em></strong> &nbsp;&nbsp;&nbsp;&nbsp;虽然你可能喜欢某些东西，但其他人可能不喜欢。另外，尽管你认为某些事情很清楚，但其他人可能不理解。当你说“我认为这可行”时，这只是你的观点，其他人可能会基于他们的观点对此进行争论。意见分歧可以帮助你取得进展，但是，如果保持不变，这是一个标志，你应该查看用户的反应方式，而不是争夺你的意见。</li><li><strong><em>自我</em></strong>  &nbsp;&nbsp;&nbsp;&nbsp;我并不是说它总是存在，但是这些讨论很容易变成有争议的论据，每个人都试图说服他人。我对此不够强调：你没有为自己设计（或编写代码），而是为用户设计。如果团队中的某个人有一个更好的主意，或者只是发现了一个错误，请高兴地为你提供改善产品的机会。这不是单人表演，而是团队失败或胜利。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，要在没有任何实际数据的情况下通过一次演示来证明自己要困难得多。当你的设计基于推测时，可能很难捍卫一个想法，因为你无法用事实来支持它。其他人可能有不同的假设，从这一点出发，论点立足或落在参与者的说服力上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这并不意味着这些会议根本没有用，它们无法替代研究，因为它们以不同的方式帮助你。我也认为争论通常是好的，因为我们可以了解很多彼此的观点。我要说的是不确定性使事情变得困难，因为你只有在发表作品后才能看到结果。最好的办法是定期与团队进行研究并进行同步，以便在技术上仍可行的情况下，确保要构建的内容能够很好地为用户服务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你创建的所有内容都会带来用户体验。 UX不是你设计的，而是工作的必然结果。请记住这一点。 🙏</p></br><h1 id="设计师应该编码吗？-开发人员应该设计吗？"><a href="#设计师应该编码吗？-开发人员应该设计吗？" class="headerlink" title="设计师应该编码吗？ 开发人员应该设计吗？"></a><strong>设计师应该编码吗？ 开发人员应该设计吗？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为存在这个永恒的问题是因为图形<code>UI</code>设计本身通常并不困难。 <code>UI</code>设计工具（例如<code>Sketch</code>或<code>Figma</code>）非常简单，即使没有经验也很容易使用，而无需谈论网络上成千上万的优质教程和资源。图形用户界面设计是一项技能，而成为专家意味着你还拥有许多其他有价值的技能，这些技能最终将定义你。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于设计师和开发人员的思维方式之间存在核心差异，因此我更喜欢将研究与设计结合起来，而不是将设计与编码结合起来。如果你对自己的系统技术知识有偏见，可能很难找到问题的抽象解决方案。这就是为什么我在多个学科的协作以及不同观点的结合中看到真正价值的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，以视觉方式呈现你的作品仍然是有益的，因为它可以帮助你发现潜在的盲点和缺失的边缘情况，还可以帮助连接点并查看整体图片，最后但并非最不重要的一点：它要快得多在设计工具中进行修复而不是在实际代码中进行修复。因此，虽然我不说开发人员应该设计，但某些设计技能可以很好地补充你的工作流程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;介绍产品专业人员用来定义问题，创建概念和选择最佳解决方案的方法。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;与关于设计师职务的争论类似，对于设计师是否应该编码，这是一个永无止境的讨论。 首先，我们谈论的是根本不同的心态。 尽管开发人员对技术流程的思考更多，但设计人员专注于用户执行的一系列操作，因为他们的目的是提出解决客户问题的方法。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此，产品设计师（或UX设计师，但正如我之前提到的那样，我不喜欢该职位）通常不做任何编码，仅因为我们从事的活动是专职职责。 设计师的大部分工作实际上甚至没有建立图形用户界面，而是进行了大量的交流和研究。 🔍&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="用户体验" scheme="http://www.xuebaonline.com/categories/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="用户体验" scheme="http://www.xuebaonline.com/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>作为Swift开发人员，如何提供更好的用户体验？</title>
    <link href="http://www.xuebaonline.com/%E4%BD%9C%E4%B8%BASwift%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%9F/"/>
    <id>http://www.xuebaonline.com/%E4%BD%9C%E4%B8%BASwift%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%9F/</id>
    <published>2020-04-26T10:34:02.000Z</published>
    <updated>2020-04-26T10:49:25.872Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过一些可访问性提示来学习用户体验设计的基础知识，你可以立即使用这些提示为每个人构建更好的移动应用程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 很有趣，但是你曾经尝试过 <code>UX</code> 吗？ 当然有 你使用的所有内容都会带来用户体验。 遵循这样的逻辑：你创建并将要由他人使用的所有内容也将导致 <code>UX</code> 。 但是到底是什么，设计师和开发人员在哪里适合呢？ 让我们找出答案。</p><a id="more"></a></br><h1 id="用户体验设计"><a href="#用户体验设计" class="headerlink" title="用户体验设计"></a><strong>用户体验设计</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于所有不同类型的设计师，都有大量的文章，我也可以编写自己的文章，但现在暂时跳过。 我唯一要提及的是，我个人不喜欢 <code>“用户体验设计师”</code> 这个称呼，因为它可能会引起误解。 几乎没有设计专业人员经验的公司都希望你神奇地找出最好的 <code>UX</code> ：“因为那是你的工作，对吧？ 错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><em>用户体验是任何使用工具的人都在发生的现象。</em></strong> 任何工具。你是否在Twitter上发帖？它是 <code>UX</code> 。你是否在 <code>iPad</code> 上阅读邮件？它是 <code>UX</code> 。你是否喝用旧金属咖啡机制作的咖啡？用户体验。你是否刚刚从宜家购买了新椅子，并且必须将其放在一起？相同。你是否只是坐在崭新的椅子上享受一杯咖啡？仍然是 <code>UX</code> 。 ☕️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我可以设计这些东西吗？我可以说你会从头到尾按照此特定顺序进行所有这些操作，并且你会喜欢吗？不。我可以映射这种情况的可能方式吗？是的开始了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户体验“设计”是了解需求（你想每天早上在舒适的椅子上上班前喝咖啡），然后提供满足需求的工具。当然，我希望你尽可能轻松地实现自己的目标，因此，我将尝试了解你现在的处事方式以及如何更改这些处境以改善你的处境。然后，我将找出一种方法并定义“预期的用户体验”，并为你进行设置。到达那里后，你将获得真实的用户体验，这可能与我们期望的有很大不同。<strong><em>用户体验设计的目标是使期望的用户体验尽可能接近实际用户体验。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，舒适性不是 <code>UX</code> 的唯一方面。无论你创建什么内容，都希望使其易于理解，可学习，令人难忘，一致，可访问且安全。</p><p><strong>如果看起来也不错，那很好。</strong></p></br><h1 id="UX-舒适：辅助功能简介"><a href="#UX-舒适：辅助功能简介" class="headerlink" title="UX != 舒适：辅助功能简介"></a><strong>UX != 舒适：辅助功能简介</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如前所述，构建良好的用户界面具有挑战性。假设你正在开发应用程序，网站，服务或其他任何东西，并且希望使用框架的帮助。网路上有许多使用者介面框架和范本，因此你会很容易找到适合你的介面。可能要格外小心，为你的用户找到合适的产品。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可访问性（简称<code>a11y</code>）是 <code>UX</code> 最重要的方面之一。世界人口的10-20％患有一种或多种残疾。根据此摘要，英国，美国和加拿大的网络用户中有 <code>7％</code> 有灵活性问题；其中<code>8％</code>有某种色盲；并且其中<code>3-4％</code>的人看不清自己的阅读能力，而且随着时间的流逝越来越多。人们经常说a11y是有特殊需求的用户，但是我们不是都有我们自己的“特殊”自定义偏好吗？我们整理工作表以轻松实现所有功能，将应用程序按特定顺序分组在<code>iPhone</code>上，我们打开黑暗模式以获得更好的阅读体验和爱侣般的功耗… <code>A11y</code>并没有太大不同，并且移动设备很多辅助功能注意事项实际上非常简单：将信息最小化以适合小屏幕；使用明确的措辞，尤其是在可诉诸事项上；提供合理的触摸目标尺寸和间距；将控制器放置在易于访问的位置；使用正确的背景-前景对比（有类似的工具可以帮助你）；不仅依赖颜色：使用绿色，黄色和红色点进行状态反馈对你来说可能是一个简单明了的主意，但是对于某些人来说，它们只是灰色阴影（这是一个很酷的浏览器扩展程序，可以帮助你了解其他人看到）；手势应尽可能简单，如果你可以添加变通功能以通过屏幕菜单甚至键盘操作来模拟手势，则效果会更好，因为越来越多的移动设备也支持键盘。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，<code>iOS</code>具有强大的<code>a11y</code>支持，我也非常推荐这篇关于<code>SwiftUI</code>可访问性的文章。长话短说：通过采用<code>SwiftUI</code>，你将在正确的道路上为所有<code>iOS</code>用户提供可访问的<code>UI</code>（当然，与设计无关）。 <code>UIKit</code>也并非没有选项，但我将保留<code>Tib</code>的技术部分。 🙂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有更多的原则，但是下面列出的是一个好的开始。你可以将它们应用到<code>Web</code>应用程序中，因为无论如何都需要使其可移动。但是，即使你已做好一切准备，你仍然可能会出错。让我给你看一个例子。</p></br><h1 id="视觉设计的力量"><a href="#视觉设计的力量" class="headerlink" title="视觉设计的力量"></a><strong>视觉设计的力量</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设你在一个网页上，其中加载了“无限”元素列表以进行滚动（例如新闻源）。页面底部有一个固定的页脚，其中包含一些持久性和动态（隐藏）操作。你可以从页面中选择项目，然后在页脚中通过批量操作按钮“全部删除”。容易吧？ 👌</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在假设你不能使用触摸或鼠标，只能使用物理键盘。你可以按<code>Tab</code>键进行导航，从一个<code>UI</code>元素跳到另一个<code>UI</code>元素，但是列表仅加载越来越多的数据，因此你无法到达页脚，这意味着你无法进行操作。当然，修复起来很容易，只需将“加载滚动”选项替换为“加载更多”按钮，即可集中精力跳转到页脚，而无需加载更多项目。但是，如果你错过了它，则可能会阻止某些用户执行操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从另一个角度来看这个例子。选择要删除的项目，然后出现“全部删除”按钮，取消选择它们后它消失，因此可以连接各个点。但是，如果你没有看到此视觉反馈，该怎么办？如果只有屏幕阅读器告诉你“全部删除”按钮处于焦点，该怎么办？你是否知道仅适用于所选项目，还是希望它清除所有数据？如你所见，你使用的副本也很重要。当你看到“全部删除”已连接到所选项目时，“仅删除所选内容”对于那些只能依靠耳朵听的人也很清楚。虽然基本的UI对大多数用户都适用，但可访问的UI对所有人都更好。因此，别忘了照顾它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编码前设计UI可以帮助你解决这些情况，因此你不必浪费时间实施有缺陷的UI的多个版本。最受欢迎的框架都具有用于设计工具（例如<code>Sketch</code>或<code>Figma</code>）的组件库，因此你不会费劲将代码与设计进行匹配。大型公司非常注重维护和记录自己的自定义框架和<code>UI</code>库（共称为设计系统），以实现更快的工作流和更一致的<code>UI</code>，从而满足所有<code>UX</code>要求。但我会保留此内容以备将来之用。 😉</p></br><h1 id="用户界面之外的用户体验"><a href="#用户界面之外的用户体验" class="headerlink" title="用户界面之外的用户体验"></a><strong>用户界面之外的用户体验</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经讨论了工具的“触感”，现在让我们来看看幕后。他们说，最好的UX是看不见的，我敢说，至少在我们要执行任务时，我们都更喜欢简单而不是美观或娱乐。你的用户界面有多酷，服务是否不好，或者没有给用户他们想要的东西都没有关系。但是，如果你提供的工具运行良好，并且可以帮助用户有效地完成工作，则他们可能不太在乎界面的外观（请记住将 <code>iOS6</code> 换成 <code>iOS7</code> 😏）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，<code>UI</code>的简单性意味着后台的复杂性。只需考虑一下搜索引擎：这是一个非常简单的用户体验，你只需在搜索字段（甚至是浏览器的网址栏）中输入内容，然后魔术般地出现在屏幕上。在这里，你无需关心美观，有趣的动画或其他任何内容，而只关心速度和准确性：你想找到东西，现在就想要。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道看到加载动画超过3秒钟是多么令人沮丧。实际上，有研究表明，如果加载时间超过3秒，用户将放弃你的网站，这可能会令人震惊。毋庸置疑，视觉设计师对此无能为力。这是<code>UX</code>高度依赖开发人员的工作的众多情况之一，这是巨大的责任！我们所有人都希望轻松完成工作，但是有时候选择短路径意味着我们的用户将不得不走更长的路。我知道在项目束缚我们的过程中有很多因素（期限，遗留代码，依赖项等），但是如果你有机会提出问题的解决方案，请不要犹豫，因为这样做更容易。你的用户稍后会感谢你。 😊</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过一些可访问性提示来学习用户体验设计的基础知识，你可以立即使用这些提示为每个人构建更好的移动应用程序。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Swift&lt;/code&gt; 很有趣，但是你曾经尝试过 &lt;code&gt;UX&lt;/code&gt; 吗？ 当然有 你使用的所有内容都会带来用户体验。 遵循这样的逻辑：你创建并将要由他人使用的所有内容也将导致 &lt;code&gt;UX&lt;/code&gt; 。 但是到底是什么，设计师和开发人员在哪里适合呢？ 让我们找出答案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="用户体验" scheme="http://www.xuebaonline.com/categories/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="用户体验" scheme="http://www.xuebaonline.com/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>揭秘 WordPress Hook 系统</title>
    <link href="http://www.xuebaonline.com/%E6%8F%AD%E7%A7%98%20WordPress%20Hook%20%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.xuebaonline.com/%E6%8F%AD%E7%A7%98%20WordPress%20Hook%20%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-04-26T09:50:08.000Z</published>
    <updated>2020-04-26T10:13:55.975Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你一直在使用 <code>WordPress</code> 开发网站（包括插件和主题开发），那么你可能已经听说过以下术语：<code>挂钩</code>，<code>操作</code>和<code>过滤器</code>。 这些是 <code>WordPress</code> 使用的 <a href="https://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="noopener"><code>事件驱动架构模式(英文：Event-driven architecture)</code></a> 的一部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是 <code>WordPress</code> 开发的新手还是发现难以理解基本概念？ 我不能推荐足够高的 <a href="https://www.sitepoint.com/author/scodrington/" target="_blank" rel="noopener"><code>Simon Codrington</code></a> 的 <code>WordPress</code> 插件开发简介教程。 他在解释 <code>动作</code> 和 <code>过滤器</code> 方面做得很出色。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本教程中，我将揭开 <code>WordPress</code> 钩子系统的神秘面纱，不遗余力。 事不宜迟，让我们开始吧。</p><a id="more"></a></br><h1 id="挂钩，动作，过滤器。-这些是什么？"><a href="#挂钩，动作，过滤器。-这些是什么？" class="headerlink" title="挂钩，动作，过滤器。 这些是什么？"></a><strong>挂钩，动作，过滤器。 这些是什么？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>“挂钩”</code>基本上是由 <code>WordPress</code> 核心，主题和插件在 <code>PHP</code> 执行或解释的各个阶段触发的事件。 当这些事件被触发时，挂钩或附加到它们的所有函数和/或类方法均以其正确顺序执行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>挂钩</code>有两种形式，<code>动作</code>和<code>过滤器</code>。 前者用于在流程执行的各个阶段添加和删除功能部件，而后者则用于修改各种功能部件和实现的行为。 如果你仍然不了解，请不要担心。 当我们开始在下面看到一些代码示例时，你将看到。</p></br><h1 id="WordPress中Hook系统的重要性"><a href="#WordPress中Hook系统的重要性" class="headerlink" title="WordPress中Hook系统的重要性"></a><strong>WordPress中Hook系统的重要性</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>钩子系统</code> 在 <code>WordPress</code> 中的重要性仅仅是可扩展性。 它使添加和删除功能以及调整/修改 <code>WordPress</code> 核心，插件和主题中功能的实现成为可能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你编写可扩展的插件和主题时，其他开发人员无需编辑核心源代码就可以改进和扩展它们。</p></br><h1 id="深入研究WordPress挂钩系统"><a href="#深入研究WordPress挂钩系统" class="headerlink" title="深入研究WordPress挂钩系统"></a><strong>深入研究WordPress挂钩系统</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>WordPress</code> 执行的各个阶段，通常会使用 <code>do_actions（）</code>和<code>a pply_filters（）</code> <code>PHP</code> 函数来触发大量事件。 这些事件可以通过 <code>add_action（）</code>和 <code>add_filter（）</code>进行订阅或挂接。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意使用“普通”一词。 还有其他触发事件的方法。 我们将在本教程的第二部分中对此进行探讨。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是插件中操作的示例。 在我的 <code>ProfilePress</code> 用户注册插件中成功注册用户后，将触发此操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fires after a user registration is completed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param int $form_id ID of the registration form.</span></span><br><span class="line"><span class="comment"> * @param mixed $user_data array of registered user info.</span></span><br><span class="line"><span class="comment"> * @param int $user_id ID of the registered user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">do_action( 'pp_after_registration', $form_id, $user_data, $user_id );</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>WordPress</code> 执行期间，将处理与该操作关联的所有功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过滤器挂钩的一个示例是 <code>WordPress</code> 核心中的 <code>the_content</code> ，它过滤每个帖子内容。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Filter the post content.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 0.71</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> string $content Content of the current post.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   $content = apply_filters( <span class="string">'the_content'</span>, $content );</span><br></pre></td></tr></table></figure></br><h1 id="做个笔记"><a href="#做个笔记" class="headerlink" title="做个笔记"></a><strong>做个笔记</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>do_action（）</code>中，第一个参数是动作挂钩的名称，后续参数是可供挂钩到动作的函数使用的变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>apply_filters（）</code>中，第一个参数是过滤器挂钩的名称，第二个参数是修改或应用连接到过滤器的函数的数据或值。 后面的参数是挂钩到过滤器的函数可用的变量/值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不用担心，当我们检查代码示例时，所有这些将更有意义。</p><br><h1 id="动作挂钩示例"><a href="#动作挂钩示例" class="headerlink" title="动作挂钩示例"></a><strong>动作挂钩示例</strong></h1><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a><strong><em>实例1</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;试一下我的 <code>ProfilePress</code> 插件的 <code>pp_after_registration</code> 操作； 假设我们要实现一项功能，使用户在注册后会立即收到一条 <code>SMS</code>（通过称为 <code>Dolio</code> 的消息传递服务），欢迎他们访问你的网站。 我们的函数挂钩可以采用以下形式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'pp_after_registration'</span>, <span class="string">'send_users_welcome_sms'</span>, <span class="number">20</span>, <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send_users_welcome_sms</span><span class="params">( $form_id, $user_data, $user_id )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $service_locator;</span><br><span class="line"></span><br><span class="line">    $username    = $user_data[<span class="string">'username'</span>];</span><br><span class="line">    $firstName   = $user_data[<span class="string">'first_name'</span>];</span><br><span class="line">    $lastName    = $user_data[<span class="string">'last_name'</span>];</span><br><span class="line">    $phoneNumber = $user_data[<span class="string">'phone_number'</span>];</span><br><span class="line"></span><br><span class="line">    $text = <span class="string">&lt;&lt;&lt;SMS_CONTENT</span></span><br><span class="line"><span class="string">Hello <span class="subst">$firstName</span> <span class="subst">$lastName</span>, Welcome to SitePoint. "\r\n"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">User ID: <span class="subst">$user_id</span> "\r\n"</span></span><br><span class="line"><span class="string">Username: <span class="subst">$username</span> "\r\n"</span></span><br><span class="line"><span class="string">Password: The password you sign up with "\r\n"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SMS_CONTENT;</span></span><br><span class="line"></span><br><span class="line">    $dolio = $service_locator-&gt;get( <span class="string">'dolio_sdk'</span> );</span><br><span class="line">    $dolio-&gt;phone_number( $phoneNumber );</span><br><span class="line">    $dolio-&gt;sms_content( $text );</span><br><span class="line">    $dolio-&gt;send();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中 <code>add_action</code> 的第三个参数是挂钩优先级，该挂钩优先级指定了挂钩到 <code>pp_after_registration</code> 动作的函数的执行顺序。 将其保留为空将默认为10。而第四个参数指定函数挂钩将接受的参数数量。 如果为空，则默认为1。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我省略了第四个参数，因此默认为1，则<code>$ user_data</code>和<code>$ user_id</code>变量将为<code>null</code>，因为我们只告诉函数仅接受一个参数。</p><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a><strong><em>实例2</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WordPress</code> 包含以下动作挂钩- <code>wp_head</code> 和 <code>wp_footer</code> ，它们分别在<code>head</code>标签和前端的<code>body</code>标签之前触发。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些挂钩可用于在那些关键位置显示脚本和数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看看一些代码示例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下代码使用 <code>wp_head</code> 将 <code>Google</code> 的站点验证元标记添加到 <code>WordPress</code> 前端的标头中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'wp_head'</span>, <span class="string">'google_site_verification'</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">google_site_verification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;meta name="google-site-verification" content="ytl89rlFsAzH7dWLs_U2mdlivbrr_jgV4Gq7wClHDUJ8" /&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有挂钩函数都将是匿名的，而不是命名函数，以避免不必要的函数名称重复。 例如，上面的 <code>Google</code> 网站验证元标记的代码将变为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'wp_head'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;meta name="google-site-verification" content="ytl89rlFsAzH7dWLs_U2mdlivbrr_jgV4Gq7wClHDUJ8" /&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的代码使用 <code>wp_footer</code> 在 <code>WordPress</code> 前端的页脚区域中添加 <code>JavaScript</code> 。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'wp_footer'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;script type="text/javascript" src="http://example.com/wp-content/plugins/site-specific-plugin/hello-bar.js"&gt;&lt;/script&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><em>动作钩子代码示例足够多，让我们看看过滤器。</em></strong></p></br><h1 id="滤钩示例"><a href="#滤钩示例" class="headerlink" title="滤钩示例"></a><strong>滤钩示例</strong></h1><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a><strong><em>示例1</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们正在开发一个广告插入器插件，该插件将以编程方式在每个帖子内容前后插入广告，因此我们需要 <code>the_content</code> 过滤器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下代码在每个帖子内容前后都包含“我们喜欢 <code>SitePoint</code> ”文字。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_filter( <span class="string">'the_content'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">( $content )</span> </span>&#123;</span><br><span class="line">        $text = sprintf( <span class="string">'&lt;div class="notice alert"&gt;%s&lt;/div&gt;'</span>, __( <span class="string">'We love SitePoint'</span>, <span class="string">'sp'</span> ) );</span><br><span class="line">        $content = $text . $content . $text;</span><br><span class="line">        <span class="keyword">return</span> $content;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：<code>$text</code> 变量的内容与&lt;div class =“ notice alert”&gt;我们喜欢SitePoint &lt;/ div&gt;一样，尽管它已经国际化，所以可以本地化。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，函数参数 <code>$content</code> 是提供帖子内容的变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们在帖子内容前后添加自定义文本，将结果数据保存到 <code>$content</code> 中，然后返回。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：所有滤镜挂钩函数都必须在操作或修改后返回变量参数。</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a><strong><em>示例2</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将看到的另一个过滤器示例是 <code>the_title</code> 。 以下是 <code>wp-includes/post-template.php</code> 的158行中的定义方式。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Filter the post title.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 0.71</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> string $title The post title.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> int    $id    The post ID.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">return</span> apply_filters( <span class="string">'the_title'</span>, $title, $id );</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的代码通过在其后面附加 <code>-WeLoveSitePoint</code> 来仅修改 ID 为 5978的帖子的标题。 这要归功于 <code>$id</code> 参数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_filter( <span class="string">'the_title'</span>, <span class="function"><span class="keyword">function</span> <span class="params">( $title, $id )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( $id == <span class="string">'5978'</span> ) &#123;</span><br><span class="line">            $title .= <span class="string">' - WeLoveSitePoint'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $title;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">10</span>, <span class="number">2</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WordPress</code> 之所以继续成为领先的内容管理系统的原因是其可扩展性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>WordPress Hook</code> 系统使 <code>WordPress</code> 可以转换为功能强大的 <code>Web</code> 应用程序，无论是 <code>WooCommerce</code> 的电子商务商店，<code>bbPress</code> 的论坛还是 <code>BuddyPress</code> 的社交网站。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你一直在使用 &lt;code&gt;WordPress&lt;/code&gt; 开发网站（包括插件和主题开发），那么你可能已经听说过以下术语：&lt;code&gt;挂钩&lt;/code&gt;，&lt;code&gt;操作&lt;/code&gt;和&lt;code&gt;过滤器&lt;/code&gt;。 这些是 &lt;code&gt;WordPress&lt;/code&gt; 使用的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Event-driven_architecture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;事件驱动架构模式(英文：Event-driven architecture)&lt;/code&gt;&lt;/a&gt; 的一部分。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;你是 &lt;code&gt;WordPress&lt;/code&gt; 开发的新手还是发现难以理解基本概念？ 我不能推荐足够高的 &lt;a href=&quot;https://www.sitepoint.com/author/scodrington/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Simon Codrington&lt;/code&gt;&lt;/a&gt; 的 &lt;code&gt;WordPress&lt;/code&gt; 插件开发简介教程。 他在解释 &lt;code&gt;动作&lt;/code&gt; 和 &lt;code&gt;过滤器&lt;/code&gt; 方面做得很出色。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在本教程中，我将揭开 &lt;code&gt;WordPress&lt;/code&gt; 钩子系统的神秘面纱，不遗余力。 事不宜迟，让我们开始吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="Modules And Hooks" scheme="http://www.xuebaonline.com/tags/Modules-And-Hooks/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的模块和挂钩</title>
    <link href="http://www.xuebaonline.com/Swift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E6%8C%82%E9%92%A9/"/>
    <id>http://www.xuebaonline.com/Swift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E6%8C%82%E9%92%A9/</id>
    <published>2020-04-26T09:32:28.000Z</published>
    <updated>2020-04-26T11:00:01.650Z</updated>
    
    <content type="html"><![CDATA[<p>了解如何使用以 <code>Swift</code> 编写的松耦合模块插件系统通过新功能扩展应用程序。</p><h1 id="模块（插件）如何工作？"><a href="#模块（插件）如何工作？" class="headerlink" title="模块（插件）如何工作？"></a><strong>模块（插件）如何工作？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你可以创建可以在不知彼此的情况下一起工作的对象，那会很酷吗？ 想象一下，你正在构建一个动态表单。 根据一些内部条件，将使用来自启用模块的数据来构成字段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，你拥有模块 <code>A</code> ，<code>B</code> ，<code>C</code> ，其中 <code>A</code> 为您提供字段 <code>1、2、3</code>，<code>B</code> 模块负责字段4、5，而 <code>C</code> 是字段6的提供者。现在，如果您关闭 <code>B</code>， 您应该只能看到字段1、2、3和6。如果已打开所有内容，则应该看到从1到6的所有字段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以将完全相同的模式应用于许多事物。 试想一下最大的插件生态系统之一。 <code>WordPress</code> 使用 <a href="https://www.sitepoint.com/wordpress-hook-system/" target="_blank" rel="noopener"><code>钩子(英文：hooks)</code></a> 来扩展核心功能。 这些都是基于我上面刚刚提到的概念。 这是 <a href="https://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="noopener"><code>事件驱动的体系结构设计模式(英文：Event-driven architecture)</code></a> 的一部分。 现在的问题是，我们如何使用 <code>Swift</code> 实现类似的东西？ 🤔</p><a id="more"></a></br><h1 id="钩子系统的实现"><a href="#钩子系统的实现" class="headerlink" title="钩子系统的实现"></a><strong>钩子系统的实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们从带有调用点的协议开始。 模块管理器将调用此方法，以按名称调用正确的钩子函数。 我们将传递参数字典，因此我们的钩子可以有参数。 我们在这里使用 <code>Any</code> 类型作为值，因此你可以在给定键下将任何内容作为参数发送。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123; <span class="literal">nil</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们使用基于表单示例的简化版本来实现我们的模块。 🤓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 1"</span>, <span class="string">"Field 2"</span>, <span class="string">"Field 3"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 4"</span>, <span class="string">"Field 5"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 6"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们需要一个模块管理器，可以使用模块数组对其进行初始化。 该管理器将负责在每个模块上调用正确的调用方法，并将以类型安全的方式处理返回的响应。 我们将立即实现两个 <code>invoke</code> 方法版本。 一个用于合并结果，另一个用于返回挂钩的第一个结果。</p><p><strong>你可以尝试实现一个可以使用 <code>&amp;&amp;</code> 运算符合并 <code>Bool</code> 值的版本。</strong></p><p>这是我们使用两种通用方法的模块管理器实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ModuleManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span>  modules: [<span class="type">Module</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invokeAllHooks</span>&lt;T&gt;<span class="params">(<span class="number">_</span> name: String, type: T.<span class="keyword">Type</span>, params: [String: <span class="keyword">Any</span>] = [:])</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">self</span>.modules.<span class="built_in">map</span> &#123; module <span class="keyword">in</span></span><br><span class="line">            module.invoke(name: name, params: params)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? [<span class="type">T</span>] &#125;.flatMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invokeHook</span>&lt;T&gt;<span class="params">(<span class="number">_</span> name: String, type: T.<span class="keyword">Type</span>, params: [String: <span class="keyword">Any</span>] = [:])</span></span> -&gt; <span class="type">T?</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> module <span class="keyword">in</span> <span class="keyword">self</span>.modules &#123;</span><br><span class="line">            <span class="keyword">let</span> result = module.invoke(name: name, params: params)</span><br><span class="line">            <span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result <span class="keyword">as</span>? <span class="type">T</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <code>invokeAllHooks</code> 方法将通用类型的数组合并在一起。 这是我们可以使用基础钩子方法收集他所有表单字段的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manager1 = <span class="type">ModuleManager</span>(modules: [<span class="type">A</span>(), <span class="type">B</span>(), <span class="type">C</span>()])</span><br><span class="line"><span class="keyword">let</span> form1 = manager1.invokeAllHooks(<span class="string">"example_form"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(form1) <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager2 = <span class="type">ModuleManager</span>(modules: [<span class="type">A</span>(), <span class="type">C</span>()])</span><br><span class="line"><span class="keyword">let</span> form2 = manager2.invokeAllHooks(<span class="string">"example_form"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(form2) <span class="comment">// 1, 2, 3, 6</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>invokeHook</code> 方法，你可以实现类似的行为，例如责任链设计模式。 响应程序链的工作方式非常相似，<code>Apple</code> 几乎在每个平台上都使用响应程序来处理 <code>UI</code> 事件。 让我通过更新模块 <code>B</code> 向你展示它的工作方式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_responder"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleResponderHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 4"</span>, <span class="string">"Field 5"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleResponderHook</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">"Hello, this is module B."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们在两个管理器上使用 <code>invokeHook</code> 方法触发新的 <code>example_responder</code> 挂钩，我们将看到结果完全不同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = manager1.invokeHook(<span class="string">"example_responder"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value) <span class="comment">// Hello, this is module B.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = manager2.invokeHook(<span class="string">"example_responder"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value) <span class="comment">// this won't be called at all...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第一种情况下，由于我们在其中一个模块中为此钩子实现了一个实现，因此将显示返回值，因此可以进行打印。 在第二种情况下，没有模块可以处理该事件，因此不会执行条件内的块。 告诉你，就像一个响应链。 😜</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用模块或插件是将代码的某些部分解耦的有效方法。 我真的很喜欢钩子函数，因为它们可以为应用程序中的几乎所有内容提供扩展点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将其与动态模块加载器混合使用，你将在 <code>Vapor</code> 之上拥有一个完全可扩展的下一代后端解决方案。 你可以独立于模块使用已编译的核心系统，以后可以仅升级整个组件的某些部分而无需接触其他部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解如何使用以 &lt;code&gt;Swift&lt;/code&gt; 编写的松耦合模块插件系统通过新功能扩展应用程序。&lt;/p&gt;
&lt;h1 id=&quot;模块（插件）如何工作？&quot;&gt;&lt;a href=&quot;#模块（插件）如何工作？&quot; class=&quot;headerlink&quot; title=&quot;模块（插件）如何工作？&quot;&gt;&lt;/a&gt;&lt;strong&gt;模块（插件）如何工作？&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你可以创建可以在不知彼此的情况下一起工作的对象，那会很酷吗？ 想象一下，你正在构建一个动态表单。 根据一些内部条件，将使用来自启用模块的数据来构成字段。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;例如，你拥有模块 &lt;code&gt;A&lt;/code&gt; ，&lt;code&gt;B&lt;/code&gt; ，&lt;code&gt;C&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 为您提供字段 &lt;code&gt;1、2、3&lt;/code&gt;，&lt;code&gt;B&lt;/code&gt; 模块负责字段4、5，而 &lt;code&gt;C&lt;/code&gt; 是字段6的提供者。现在，如果您关闭 &lt;code&gt;B&lt;/code&gt;， 您应该只能看到字段1、2、3和6。如果已打开所有内容，则应该看到从1到6的所有字段。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们可以将完全相同的模式应用于许多事物。 试想一下最大的插件生态系统之一。 &lt;code&gt;WordPress&lt;/code&gt; 使用 &lt;a href=&quot;https://www.sitepoint.com/wordpress-hook-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;钩子(英文：hooks)&lt;/code&gt;&lt;/a&gt; 来扩展核心功能。 这些都是基于我上面刚刚提到的概念。 这是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Event-driven_architecture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;事件驱动的体系结构设计模式(英文：Event-driven architecture)&lt;/code&gt;&lt;/a&gt; 的一部分。 现在的问题是，我们如何使用 &lt;code&gt;Swift&lt;/code&gt; 实现类似的东西？ 🤔&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="Modules And Hooks" scheme="http://www.xuebaonline.com/tags/Modules-And-Hooks/"/>
    
  </entry>
  
  <entry>
    <title>Swift初始化模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-26T08:53:01.000Z</published>
    <updated>2020-04-26T09:32:03.950Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终指南，如何在指定的，方便的，可使用的初始化工具等帮助下初始化你的 <code>Swift</code> 数据类型。</p><h1 id="什么是初始化？"><a href="#什么是初始化？" class="headerlink" title="什么是初始化？"></a><strong>什么是初始化？</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" target="_blank" rel="noopener"><code>初始化(英文: Initialization)</code></a> 是准备使用的类，结构或枚举实例的过程。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个过程是通过初始化程序来处理的，初始化程序只是一种特殊的函数，通常为它们保留 <code>init</code> 关键字-因此您不必使用 <code>func</code> 关键字-通常您不会从初始化程序中返回任何值 。</p><a id="more"></a></br><h1 id="初始化属性"><a href="#初始化属性" class="headerlink" title="初始化属性"></a><strong>初始化属性</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类和结构必须在创建该类或结构的实例时将其所有存储的属性设置为适当的初始值。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先想象一个非常简单的结构，它只有两个属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，上面的规则说我们必须初始化所有属性，因此让我们通过创建第一个 <code>init</code> 方法来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像其他所有 <code>Swift</code> 函数一样。 现在我们可以创建我们的第一点了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，如果它们是变量而不是常量，则不必初始化隐式解包的可选属性和可选属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相同的逻辑适用于类，你可以通过将 <code>struct</code> 关键字更改为 <code>class</code> 来尝试。 但是结构是值类型，类是引用类型，这种差异将为我们提供两种类型的独特功能。</p></br><h1 id="成员初始化（仅适用于结构）"><a href="#成员初始化（仅适用于结构）" class="headerlink" title="成员初始化（仅适用于结构）"></a><strong>成员初始化（仅适用于结构）</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于 <code>struct</code> 的好处是，如果你不提供自己的 <code>init</code> 方法，则编译器将免费生成一个逐成员的 <code>init</code> 。 但是有很多问题。 生成的方法将包含除具有默认值的常量以外的所有属性（也为可选属性），并且它将具有内部访问类型，因此在其他模块中将不可见。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果任何结构的存储属性都是私有的，则该结构类型的默认成员初始化器被视为私有的。 同样，如果结构的任何存储属性是文件专用的，则初始化程序是文件专用的。 否则，初始化程序的访问级别为 <code>internal</code> 。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> key: <span class="type">Int!</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span> = <span class="string">"zero"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, key: <span class="number">0</span>) <span class="comment">// provided by the memberwise init</span></span><br></pre></td></tr></table></figure></br><h1 id="初始化失败"><a href="#初始化失败" class="headerlink" title="初始化失败"></a><strong>初始化失败</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时情况可能会出错，并且你不想创建坏的或无效的对象，例如，你想从有效点列表中过滤掉 <code>origo</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>?(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123; <span class="comment">// ? marks that this could fail</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>) <span class="comment">// nil</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>) <span class="comment">// valid point</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过 <code>rawValues</code> 初始化从 <code>RawRepresentable</code> 协议传递的枚举，这也是一个失败的初始化模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> red</span><br><span class="line">    <span class="keyword">case</span> blue</span><br><span class="line">    <span class="keyword">case</span> yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c1 = <span class="type">Color</span>(rawValue: <span class="string">"orange"</span>) <span class="comment">// nil, no such case</span></span><br><span class="line"><span class="keyword">let</span> c2 = <span class="type">Color</span>(rawValue: <span class="string">"red"</span>) <span class="comment">// .red</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以使用 <code>init！</code> 而不是<code>init ?</code> ，这将创建实例的隐式展开的可选类型。 请注意，类也可以具有失败的初始化器。</p></br><h1 id="初始化纯Swift类"><a href="#初始化纯Swift类" class="headerlink" title="初始化纯Swift类"></a><strong>初始化纯Swift类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你知道类是 <code>Swift</code> 编程语言中的本机类型。 你甚至不必导入 <code>Foundation</code> 框架即可创建全新的类。 这是由纯 <code>Swift</code> 类表示的完全相同的 <code>Point</code> 对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次我们不得不自己提供 <code>init</code> 方法，因为类没有成员初始化器。 它们是引用类型和继承逻辑，因此为它们生成成员初始化方法会更加复杂。</p></br><h1 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a><strong>默认初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 <code>Swift</code> 类，如果为所有存储的属性提供默认值，即使是可选属性，也将免费获得内部默认初始化程序。 实际上，它看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>()</span><br></pre></td></tr></table></figure><p>或者，如果我们遵循前面的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> key: <span class="type">Int!</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span> = <span class="string">"zero"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这感觉太不对了。 为什么一个点具有键和标签属性？ 拥有一个可能具有额外属性的子对象会很好。 现在该通过类继承来重构此代码了。</p></br><h1 id="指定的初始值设定项-Designated-initializer"><a href="#指定的初始值设定项-Designated-initializer" class="headerlink" title="指定的初始值设定项(Designated initializer)"></a><strong>指定的初始值设定项(Designated initializer)</strong></h1><blockquote><p><strong><em>提示：</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.codingexplorer.com/designated-initializers-convenience-initializers-swift/" target="_blank" rel="noopener"><code>指定的初始化器(Designated initializer)</code></a> 是类的主要初始化器。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换句话说，它没有用便捷关键字标记。 一个类也可以具有多个指定的初始化器。 因此，让我们继续我们的 <code>Point</code> 类，它将成为 <code>NamedPoint</code> 类的超类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123; <span class="comment">// this is the designated initializer</span></span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedPoint</span>: <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>, label: <span class="type">String?</span>) &#123; <span class="comment">// designated</span></span><br><span class="line">        <span class="keyword">self</span>.label = label</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(point: <span class="type">Point</span>, label: <span class="type">String?</span>) &#123; <span class="comment">// also designated</span></span><br><span class="line">        <span class="keyword">self</span>.label = label</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: point.x, y: point.y) <span class="comment">// delegating up</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">NamedPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>, label: <span class="string">"first"</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="type">NamedPoint</span>(point: <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>), label: <span class="string">"second"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定的初始值设定项必须始终从其直接超类调用指定的初始值设定项，因此你必须委托链。 但是首先，我们必须按照初始化的第一条规则来初始化所有属性。 因此，这意味着 <code>Swift</code> 语言具有两个阶段的初始化过程。</p><p><strong><em>两阶段初始化</em></strong></p><ul><li>每个存储的属性由引入它的类分配一个初始值。</li><li>每个类都有机会自定义其存储的属性。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，根据这些规则，首先我们必须初始化 <code>label</code> 属性，然后进行委托，然后才有机会做其他事情。</p></br><h1 id="便捷初始化"><a href="#便捷初始化" class="headerlink" title="便捷初始化"></a><strong>便捷初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它们是用于简化初始化的初始化程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，例如在前面的例子中，如果我们可以为 <code>x</code> 和 <code>y</code> 等于数字的点设置一个初始化器。 在某些情况下，这将非常方便。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(z: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(x: z, y: z) <span class="comment">// we're calling the designated init</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(z: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;便捷初始化程序必须调用同一类中另一个 <code>&quot;convenience&quot;</code> 初始化程序，但是您不必写出关键字，实际上，这些 <code>init</code> 方法略有不同，你可以从一个到另一个进行调出，这就是为什么它看起来一样的原因。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(z: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(x: z, y: z)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="type">Point</span>(z: <span class="number">1</span>)</span><br></pre></td></tr></table></figure></br><h1 id="必需的初始值设定项-Required-initializer"><a href="#必需的初始值设定项-Required-initializer" class="headerlink" title="必需的初始值设定项(Required initializer)"></a><strong>必需的初始值设定项(Required initializer)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你在类中标记了一个必需的初始化器，则所有直接类（必须在每个级别中都标记为必需）也必须实现该类的子类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedPoint</span>: <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.label = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">NamedPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure></br><h1 id="覆盖初始化器"><a href="#覆盖初始化器" class="headerlink" title="覆盖初始化器"></a><strong>覆盖初始化器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中，默认情况下不会为子类继承初始化器。 如果要为父类已经具有的子类提供相同的初始化程序，则必须使用 <code>override</code> 关键字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedPoint</span>: <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.label = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">NamedPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong><em>初始化继承有两个规则，这是第一个…</em></strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你的子类没有定义任何指定的初始值设定项，它将自动继承其所有超类指定的初始值设定项。</span><br><span class="line"></span><br><span class="line">***...还有第二个：***</span><br><span class="line">&#96;&#96;&#96;提示:&#96;&#96;&#96;\</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你的子类提供了其所有超类指定的初始值设定项的实现（通过按规则1继承它们，或通过提供自定义实现作为其定义的一部分），则它会自动继承所有超类便利的初始值设定项。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;br&gt;</span><br><span class="line"></span><br><span class="line"># **取消初始化**</span><br><span class="line"></span><br><span class="line">&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在取消分配类实例之前，将立即调用反初始化程序。</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此，如果你想在类终止时进行一些手动清理，这就是你要寻找的方法。 在大多数情况下，你不必担心内存管理，因为 &#96;&#96;&#96;ARC&#96;&#96;&#96; 会为你完成。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; Swift</span><br><span class="line">class Point &#123;</span><br><span class="line">   let x: Int</span><br><span class="line">   let y: Int</span><br><span class="line"></span><br><span class="line">   init(x: Int, y: Int) &#123;</span><br><span class="line">       self.x &#x3D; x</span><br><span class="line">       self.y &#x3D; y</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   deinit &#123;</span><br><span class="line">       print(&quot;Point is clenaed up.&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1: Point? &#x3D; Point(x: 1, y: 1)</span><br><span class="line">p1 &#x3D; nil &#x2F;&#x2F;deinit is being called </span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最终指南，如何在指定的，方便的，可使用的初始化工具等帮助下初始化你的 &lt;code&gt;Swift&lt;/code&gt; 数据类型。&lt;/p&gt;
&lt;h1 id=&quot;什么是初始化？&quot;&gt;&lt;a href=&quot;#什么是初始化？&quot; class=&quot;headerlink&quot; title=&quot;什么是初始化？&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是初始化？&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;初始化(英文: Initialization)&lt;/code&gt;&lt;/a&gt; 是准备使用的类，结构或枚举实例的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这个过程是通过初始化程序来处理的，初始化程序只是一种特殊的函数，通常为它们保留 &lt;code&gt;init&lt;/code&gt; 关键字-因此您不必使用 &lt;code&gt;func&lt;/code&gt; 关键字-通常您不会从初始化程序中返回任何值 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="初始化模式" scheme="http://www.xuebaonline.com/tags/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift带闭包的懒惰初始化</title>
    <link href="http://www.xuebaonline.com/Swift%E5%B8%A6%E9%97%AD%E5%8C%85%E7%9A%84%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://www.xuebaonline.com/Swift%E5%B8%A6%E9%97%AD%E5%8C%85%E7%9A%84%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2020-04-26T07:55:06.000Z</published>
    <updated>2020-04-26T08:46:52.783Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何创建具有模块化和可读性的对象。</p><h1 id="使用初衷"><a href="#使用初衷" class="headerlink" title="使用初衷"></a><strong>使用初衷</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>iOS</code> 之旅的开始，我遵循了 <code>YouTube</code> 上的教程。 我看到一些使用如下所示的方法来创建 <code>UI</code> 对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> makeBox: <span class="type">UIView</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> view = <span class="type">UIView</span>()</span><br><span class="line"> <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为学习者，我复制了练习并使用了它。 但是，有一天，有人问我：“为什么要添加 <code>{}</code> ，为什么 <code>（）</code> 末尾存在？ 它是计算属性吗？” 我无法回答。</p><a id="more"></a></br><h1 id="学习的目标"><a href="#学习的目标" class="headerlink" title="学习的目标"></a><strong>学习的目标</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有三个目标。 首先，了解如何使用上述非常规方式初始化对象。 其次，了解何时在 <code>Swift</code> 中使用惰性 <code>var</code> 。 最后，如何最终正确使用它。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a><strong><em>先决条件</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了充分理解文章中的内容，我强烈建议您熟悉以下主题。</p><ul><li><a href="https://blog.bobthedeveloper.io/no-fear-closure-in-swift-3-with-bob-72a10577c564?gi=bfa929c89fa9" target="_blank" rel="noopener"><code>Closures</code></a></li><li><a href="https://blog.bobthedeveloper.io/swift-retention-cycle-in-closures-and-delegate-836c469ef128" target="_blank" rel="noopener"><code>Capture List and retention cycle [weak self]</code></a></li><li>Descent Object Oriented Programming</li></ul></br><h1 id="创建UI组件"><a href="#创建UI组件" class="headerlink" title="创建UI组件"></a><strong>创建UI组件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我解释上述非常规方法之前，让我们先回顾一下你的过去。 为了在 <code>Swift</code> 中创建一个按钮，你可能已经做了类似的事情。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine Size</span></span><br><span class="line"><span class="keyword">let</span> buttonSize = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="comment">// Create Instance</span></span><br><span class="line"><span class="keyword">let</span> bobButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">bobButton.backgroundColor = .black</span><br><span class="line">bobButton.titleLabel?.text = <span class="string">"Bob"</span></span><br><span class="line">bobButton.titleLabel?.textColor = .white</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设你必须创建其他三个按钮，你可能必须复制上面的代码，然后将名称从 <code>bobButton</code> 更改为 <code>bobbyButton</code> 。这非常繁琐。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New Button</span></span><br><span class="line"><span class="keyword">let</span> bobbyButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">bobbyButton.backgroundColor = .black</span><br><span class="line">bobbyButton.titleLabel?.text = <span class="string">"Bob"</span></span><br><span class="line">bobbyButton.titleLabel?.textColor = .white</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使事情变得容易一些，你可以：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xcode-edit-all.gif" alt="带闭包的懒惰初始化" title="这也适用于键盘快捷键：ctrl-cmd-e"></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用快捷键：ctrl-cmd-e，完成上述操作。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不想重复这样创建，则可以创建一个函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createButton</span><span class="params">(enterTitle: String)</span></span> -&gt; <span class="type">UIButton</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = enterTitle</span><br><span class="line"> <span class="keyword">return</span> button</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createButton(enterTitle: <span class="string">"Yoyo"</span>) <span class="comment">//  👍</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，在 <code>iOS</code> 开发中，很少有自定义按钮看起来相似的情况。 因此，一个函数可能需要更多的参数，包括背景颜色，标题，边框半径，阴影等。 你的功能可能最终看起来像：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createButton</span><span class="params">(title: String, borderWidth: Double, backgrounColor, ...)</span></span> -&gt; <span class="type">Button</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使你向函数添加默认参数，上面的代码也不是理想的选择。 它降低了可读性。 因此，最好还是保留上面乏味的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有什么方法可以使它减少乏味和更有条理？ 当然。 我们已经调查了你的过去—现在该加紧步伐，展望你的未来。</p></br><h1 id="引入非常规方式"><a href="#引入非常规方式" class="headerlink" title="引入非常规方式"></a><strong>引入非常规方式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以非常规的方式创建UI组件之前，让我们首先回答最初问题: <code>{}</code> 是什么意思，它是计算属性吗？</p><p><strong><em>不，这只是一个封闭块。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，让我们演示如何使用闭包创建对象。 我们将设计一个名为 <code>Human</code> 的结构。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"> <span class="keyword">init</span>() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Born 1996"</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，这就是创建带闭包的对象的方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createBob = &#123; () -&gt; <span class="type">Human</span> <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">let</span> human = <span class="type">Human</span>()</span><br><span class="line"> <span class="keyword">return</span> human</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> babyBob = createBob() <span class="comment">// "Born 1996"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>仅说明一下，createBob</code> 是一个类型为 <code>（）-&gt; Human</code> 的闭包。 您已经通过调用 <code>createBob（）</code> 创建了一个名为 <code>babyBob</code> 的实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，你必须创建两个常量： <code>createBob</code> 和 <code>babyBob</code> 。 如果你想在一个语句中做所有事情怎么办？ </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bobby = &#123; () -&gt; <span class="type">Human</span> <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">let</span> human = <span class="type">Human</span>()</span><br><span class="line"> <span class="keyword">return</span> human</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，闭包块通过在末尾添加 <code>（）</code> 来执行自身，而 <code>bobby</code> 现在附加了一个 <code>Human</code> 对象。 很好的东西。</p><p><strong><em>你已经了解了如何使用闭包块初始化对象。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们来创建一个 <code>UI</code> 对象，该对象应该与上面的示例相似。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bobView = &#123; () -&gt; <span class="type">UIView</span> <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">let</span> view = <span class="type">UIView</span>()</span><br><span class="line"> view.backgroundColor = .black</span><br><span class="line"> <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;太好了，我们可以缩短它的时间。 实际上，我们不需要指定封闭块的类型。 相反，我们要做的就是指定实例的类型，例如 <code>bobView</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bobbyView: <span class="type">UIView</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> view = <span class="type">UIView</span>()</span><br><span class="line"> view.backgroundColor = .black</span><br><span class="line"> <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 能够基于关键字 <code>return</code> 推断出闭包块是 <code>（）-&gt; UIView</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，看看。 上面的示例应该看起来与我担心的“非常规方式”相同。</p></br><h1 id="闭包初始化的好处"><a href="#闭包初始化的好处" class="headerlink" title="闭包初始化的好处"></a><strong>闭包初始化的好处</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们讨论了创建对象的乏味以及使用函数引起的问题。 在你的脑海中，你肯定在想：“为什么我应该改用闭包？”</p><h2 id="容易复制"><a href="#容易复制" class="headerlink" title="容易复制"></a><strong><em>容易复制</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我不喜欢使用 <code>Storyboard</code> ，我喜欢复制和粘贴 <code>UI</code> 对象。 实际上，我的计算机中有一个“库”。 让我们假设库中有一个如下所示的按钮。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = <span class="number">1</span></span><br><span class="line"> button.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要做的就是复制整行，然后将 <code>myButton</code> 的名称更改为 <code>newButton</code> 以供使用。 如果不使用闭包方法，则可能不得不将 <code>button</code> 的名称更改为 <code>newButton</code> 7–8次。 我们可以使用上面的 <code>Xcode</code> 快捷方式，但为什么不使其更简单。</p><h2 id="代码更整洁"><a href="#代码更整洁" class="headerlink" title="代码更整洁"></a><strong><em>代码更整洁</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于将对象组合在一起，看代码更加直观。 比较一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init with Closure</span></span><br><span class="line"><span class="keyword">let</span> leftCornerButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = <span class="number">1</span></span><br><span class="line"> button.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">let</span> rightCornerButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = <span class="number">1</span></span><br><span class="line"> button.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p><em><code>比较</code></em></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init With Fingers</span></span><br><span class="line"><span class="keyword">let</span> leftCornerButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">leftCornerButton.backgroundColor = .black</span><br><span class="line">leftCornerButton.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line">leftCornerButton.titleLabel?.textColor = .white</span><br><span class="line">leftCornerButton.layer.cornerRadius = <span class="number">1</span></span><br><span class="line">leftCornerButton.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rightCornerButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">rightCornerButton.backgroundColor = .black</span><br><span class="line">rightCornerButton.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line">rightCornerButton.titleLabel?.textColor = .white</span><br><span class="line">rightCornerButton.layer.cornerRadius = <span class="number">1</span></span><br><span class="line">rightCornerButton.layer.masksToBounds = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管使用闭包创建对象要多加几行，但我感到有点不知所措，因为我只需要向按钮添加属性，而不必向 <code>rightCornerButton</code> 或 <code>leftCornerButton</code> 添加属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，如果按钮的名称更具描述性，那么创建带有闭包块的对象通常需要较少的行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你已经实现了第一个目标。 恭喜你</p><h2 id="延迟初始化应用"><a href="#延迟初始化应用" class="headerlink" title="延迟初始化应用"></a><strong><em>延迟初始化应用</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你已经走了很长一段路。 现在该实现本教程的第二个目标。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能在下面看到了类似的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntenseMathProblem</span> </span>&#123;</span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> complexNumber: <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="comment">// imagine it requires a lot of CPU</span></span><br><span class="line">  <span class="number">1</span> * <span class="number">1</span></span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性允许您执行的操作是，仅当你尝试访问 <code>complexNumber</code> 属性时，才会计算 <code>complexNumber</code> 属性。 例如:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> problem = <span class="type">IntenseMathProblem</span></span><br><span class="line">problem()  <span class="comment">// No value for complexNumber</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前， <code>complexNumber</code> 没有值。 但是，一旦你访问该媒体资源，</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">problem().complexNumber <span class="comment">// Now returns 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性变量经常用于对数据库进行排序并从任何后端服务中获取数据，因为你绝对不想在创建对象时对所有内容进行计算和排序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，你的手机会崩溃，因为该物体过大且RAM无法处理。</p></br><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面只是 <code>lazy var</code> 的一个应用。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong><em>排序</em></strong></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortManager</span> </span>&#123;</span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> sortNumberFromDatabase: [<span class="type">Int</span>] = &#123;</span><br><span class="line">  <span class="comment">// Sorting logic</span></span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a><strong><em>图像压缩</em></strong></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompressionManager</span> </span>&#123;</span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> compressedImage: <span class="type">UIImage</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> image = <span class="type">UIImage</span>()</span><br><span class="line">  <span class="comment">// Compress the image</span></span><br><span class="line">  <span class="comment">// Logic</span></span><br><span class="line">  <span class="keyword">return</span> image</span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="懒加载规则"><a href="#懒加载规则" class="headerlink" title="懒加载规则"></a><strong>懒加载规则</strong></h1><ul><li>你不能将lazy与let一起使用，因为它没有初始值，并且在以后访问它时才可以达到。</li><li>你不能将其与计算属性一起使用，因为当你修改与惰性属性有关系的任何变量时，总是会重新计算计算属性（需要CPU）。</li><li>惰性仅对结构或类的成员有效</li></ul></br><h1 id="懒加载能捕获"><a href="#懒加载能捕获" class="headerlink" title="懒加载能捕获"></a><strong>懒加载能捕获</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如果你已阅读上一篇有关<a href="https://blog.bobthedeveloper.io/swift-retention-cycle-in-closures-and-delegate-836c469ef128" target="_blank" rel="noopener"><code>“封闭和委托中的循环引用”</code></a>的文章，您可能会感到奇怪。 让我们测试一下。 创建一个名为 <code>BobGreet</code> 的类。 它具有两个属性：名称为 <code>String</code> 的名称和问候语也为 <code>String</code> 的问候语，但使用闭包块进行了初始化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BobGreet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Bob the Developer"</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> greeting: <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, \(self.name)"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I'm gone, bruh 🙆‍"</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;封闭块可能对 <code>BobGuest</code> 强引用，但让我们尝试取消分配。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bobGreet: <span class="type">BobGreet?</span> = <span class="type">BobGreet</span>()</span><br><span class="line">bobGreet?.greeting</span><br><span class="line">bobGreet = <span class="literal">nil</span> <span class="comment">// I'm gone, bruh 🙆‍</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无需担心 <code>[unown self]</code> 闭包块没有对该对象的引用。 取而代之的是，它只是在封闭块内复制自身。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何创建具有模块化和可读性的对象。&lt;/p&gt;
&lt;h1 id=&quot;使用初衷&quot;&gt;&lt;a href=&quot;#使用初衷&quot; class=&quot;headerlink&quot; title=&quot;使用初衷&quot;&gt;&lt;/a&gt;&lt;strong&gt;使用初衷&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 &lt;code&gt;iOS&lt;/code&gt; 之旅的开始，我遵循了 &lt;code&gt;YouTube&lt;/code&gt; 上的教程。 我看到一些使用如下所示的方法来创建 &lt;code&gt;UI&lt;/code&gt; 对象。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; makeBox: &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt; = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; view = &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; view&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;作为学习者，我复制了练习并使用了它。 但是，有一天，有人问我：“为什么要添加 &lt;code&gt;{}&lt;/code&gt; ，为什么 &lt;code&gt;（）&lt;/code&gt; 末尾存在？ 它是计算属性吗？” 我无法回答。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="懒加载模式" scheme="http://www.xuebaonline.com/tags/%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift Lazy属性初始化</title>
    <link href="http://www.xuebaonline.com/Swift%20Lazy%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://www.xuebaonline.com/Swift%20Lazy%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2020-04-26T07:37:12.000Z</published>
    <updated>2020-04-26T07:52:47.513Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Swift中什么是惰性存储属性？ 你应该如何以及何时使用它？ 快速入门指南，需要记住的一些关键点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先回顾一下在 <code>Swift</code> 中声明和初始化存储属性的最常用方法：</p><h1 id="直接分配"><a href="#直接分配" class="headerlink" title="直接分配"></a><strong>直接分配</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过直接分配初始值来对常量和变量存储的属性进行初始化的最简单形式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constant</span></span><br><span class="line"><span class="keyword">let</span> fontSize: <span class="type">CGFloat</span> = <span class="number">24.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// variable</span></span><br><span class="line"><span class="keyword">var</span> spacing: <span class="type">CGFloat</span> = <span class="number">16.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Optional</span></span><br><span class="line"><span class="keyword">var</span> title: <span class="type">String?</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，默认情况下，可选参数初始化为 <code>nil</code> 。 我喜欢将恒定的魔术数字（如 <code>fontSize</code> ）收集到一个结构中，使它们成为静态的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">ViewMetrics</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> fontSize: <span class="type">CGFloat</span> = <span class="number">24.0</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">titleLabel.font = <span class="type">ViewMetrics</span>.fontSize</span><br></pre></td></tr></table></figure></br><h1 id="使用初始化器"><a href="#使用初始化器" class="headerlink" title="使用初始化器"></a><strong>使用初始化器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你没有将初始值分配给存储属性作为其定义的一部分，则必须在初始化程序中进行设置。 引用《 Swift编程语言》指南：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类和结构必须在创建该类或结构的实例时将其所有存储的属性设置为适当的初始值。 存储的属性不能处于不确定状态。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(title: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.title = title</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当属性始终采用相同的初始值时，最好在声明属性时进行设置，而不要在初始化程序中进行设置。</p></br><h1 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a><strong>使用闭包</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当初始值需要更多设置时，闭包是一个不错的选择。 我发现闭包样式比许多初始化程序代码更可取，因为它使设置接近属性声明。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button: <span class="type">UIButton</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> button = <span class="type">UIButton</span>(type: .system)</span><br><span class="line">  button.titleLabel?.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="type">ViewMetrics</span>.fontSize)</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化包含属性的类型时，将调用一次闭包。 闭包的返回值分配给该属性。 不要忘记尾随（）来执行关闭。</p></br><h1 id="懒加载方式"><a href="#懒加载方式" class="headerlink" title="懒加载方式"></a><strong>懒加载方式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当初始值创建起来开销相对较大时时，通常会使用惰性初始化。 仅在确定需要时才创建值。 如果你是从 <code>Objective-C</code> 转到 <code>Swift</code> 的，那么您可能会熟悉使用 <code>getter</code> 仅在首次使用属性时才对其进行延迟初始化的技术：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">NSNumberFormatter</span> *)decimalFormatter &#123;</span><br><span class="line">  <span class="keyword">if</span> (_decimalFormatter == <span class="literal">nil</span>) &#123;</span><br><span class="line">    _decimalFormatter = [[<span class="type">NSNumberFormatter</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [_decimalFormatter setNumberStyle:<span class="type">NSNumberFormatterDecimalStyle</span>];        </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _decimalFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么 <code>Swift</code> 中的惰性属性呢？ <code>Swift</code> 属性没有后备实例变量（如 <code>_decimalFormatter</code> ）。 要在 <code>Swift</code> 中延迟初始化属性，请添加 <code>lazy</code> 关键字：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> decimalFormatter: <span class="type">NumberFormatter</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> formatter = <span class="type">NumberFormatter</span>()</span><br><span class="line">  formatter.numberStyle = .decimal</span><br><span class="line">  <span class="keyword">return</span> formatter</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，惰性属性始终为 <code>var</code> 。 当访问属性时，可以在初始化完成后调用该闭包。</p></br><h1 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a><strong>访问属性</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性属性初始化的另一个常见用法是，当初始值取决于初始化实例的属性或方法时。 例如，使用闭包设置对象，此堆栈视图可以作为 <code>let constant</code> 属性使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stackView: <span class="type">UIStackView</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> stackView = <span class="type">UIStackView</span>()</span><br><span class="line">  stackView.spacing = <span class="type">ViewMetrics</span>.spacing</span><br><span class="line">  <span class="keyword">return</span> stackView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请记住，在初始化期间调用了闭包，因此你尚不能使用 <code>self</code> 来访问实例的任何属性或方法。 如果你需要访问 <code>self</code> ，则必须将 <code>let</code> 替换为 <code>lazy var</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spacing: <span class="type">CGFloat</span> = <span class="number">16.0</span>  &#123;</span><br><span class="line">  <span class="keyword">didSet</span> &#123;</span><br><span class="line">    stackView.spacing = spacing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> stackView: <span class="type">UIStackView</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> stackView = <span class="type">UIStackView</span>()</span><br><span class="line">  stackView.spacing = spacing</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> stackView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，在对象初始化之后执行关闭操作，因此你可以通过 <code>self</code> 完全访问实例属性和方法。 这是声明诸如用户界面组件之类的便捷方式。 将任何常见配置移至单独的方法或类扩展：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buttonFontSize: <span class="type">CGFloat</span> = <span class="number">18.0</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> redButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">UILabel</span>.colorButton(title: <span class="string">"Red"</span>, color: .red, fontSize: buttonFontSize)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> blueButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">UILabel</span>.colorButton(title: <span class="string">"Blue"</span>, color: .blue, fontSize: buttonFontSize)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></br><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a><strong>要点</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要记住的一些关键点并不明显，并且经常引起混乱（至少对我而言）：</p><ul><li>引用闭包内的其他实例属性或方法时，无需编写self。</li><li>闭包不会逃逸，因此你无需使用 <code>weak self</code> 避免形成循环引用。</li><li>初始化之前，如果属性可以被多个线程访问，请小心。 无法保证只有在设置初始值之前有多个线程同时访问该属性时才将其初始化一次。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在Swift中什么是惰性存储属性？ 你应该如何以及何时使用它？ 快速入门指南，需要记住的一些关键点。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先回顾一下在 &lt;code&gt;Swift&lt;/code&gt; 中声明和初始化存储属性的最常用方法：&lt;/p&gt;
&lt;h1 id=&quot;直接分配&quot;&gt;&lt;a href=&quot;#直接分配&quot; class=&quot;headerlink&quot; title=&quot;直接分配&quot;&gt;&lt;/a&gt;&lt;strong&gt;直接分配&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过直接分配初始值来对常量和变量存储的属性进行初始化的最简单形式：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// constant&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; fontSize: &lt;span class=&quot;type&quot;&gt;CGFloat&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;24.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// variable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; spacing: &lt;span class=&quot;type&quot;&gt;CGFloat&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;16.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Optional&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; title: &lt;span class=&quot;type&quot;&gt;String?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="懒加载模式" scheme="http://www.xuebaonline.com/tags/%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的懒加载模式</title>
    <link href="http://www.xuebaonline.com/Swift%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-26T03:01:52.000Z</published>
    <updated>2020-04-26T08:48:54.614Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何在 <code>Swift</code> 中使用惰性属性来提高性能，避免使用可选参数或只是为了使初始化过程更加简洁。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在程式设计中, 惰性初始是一种拖延战术。在第一次需求出现以前，先延迟创建物件、计算值或其它昂贵程序。这通常是以一个旗号来实现，用旗号来标示是否完成其程式。每次请求对象时，会先测试此旗号。如果已完成，直接传回，否则当场执行。<br>对于此想法更一般的论述，可见惰性求值。对指令式语言，这个模式可能潜藏着危险，尤其是使用共享状态的程式习惯。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以设计模式的观点来说，惰性初始通常会和工厂方法模式合作，这结合了三种构想：</p><ul><li>使用一个工厂去得到一个类别的实例（工厂方法模式）。</li><li>将实例存在一个集合中，所以下次要求一个实例却有相同参数时，可以得到同一个实例（可和单例模式来做比较）。</li><li>在第一次时，使用惰性初始来实例化物件（惰性初始模式）。</li></ul><a id="more"></a></br><h1 id="懒惰的终极指南"><a href="#懒惰的终极指南" class="headerlink" title="懒惰的终极指南"></a><strong>懒惰的终极指南</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果仅在某个时间点需要某个属性，则可以在其前面加上 <code>lazy</code> 关键字，以便在初始化过程中将其 <code>“excluded”</code> ，并且将按需分配其默认值。 这对于创建成本高昂或需要更多时间创建的类型很有用。 这是一个懒惰公主的小故事。 👸💤</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepingBeauty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zzz...sleeping..."</span>)</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"sleeping beauty is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Castle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> princess = <span class="type">SleepingBeauty</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"castle is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a new castle..."</span>)</span><br><span class="line"><span class="keyword">let</span> castle = <span class="type">Castle</span>()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此代码段的输出如下所示，但是你可以看到公主睡了很长时间，她也“堵住了”城堡。 🏰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a new castle...</span><br><span class="line">zzz...sleeping...</span><br><span class="line">sleeping beauty is ready!</span><br><span class="line">castle is ready!</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以通过添加 <code>lazy</code> 关键字来加快处理速度，因此你的英雄将有时间杀死龙，我们的公主可以睡在她的床上直到需要她为止。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepingBeauty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zzz...sleeping..."</span>)</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"sleeping beauty is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Castle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> princess = <span class="type">SleepingBeauty</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"castle is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a new castle..."</span>)</span><br><span class="line"><span class="keyword">let</span> castle = <span class="type">Castle</span>()</span><br><span class="line">castle.princess</span><br></pre></td></tr></table></figure><p>好多了！ 现在城堡立即为战斗做好了准备，因此王子可以唤醒他所爱的人，并且……他们从此过着幸福的生活。 故事结局。👸 ❤️ 🤴</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a new castle...</span><br><span class="line">castle is ready!</span><br><span class="line">zzz...sleeping...</span><br><span class="line">sleeping beauty is ready!</span><br></pre></td></tr></table></figure><p>希望你喜欢童话故事，但让我们做一些真正的编码吧！ 🤓</p></br><h1 id="避免懒加载可选属性"><a href="#避免懒加载可选属性" class="headerlink" title="避免懒加载可选属性"></a><strong>避免懒加载可选属性</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你在前面的示例中所看到的，可以使用惰性属性来提高 <code>Swift</code> 代码的性能。 您也可以消除对象中的可选项。 如果你要处理 <code>UIView</code> 派生类，这将很有用。 例如，如果你的视图层次结构需要 <code>UILabel</code> ，则通常必须将该属性声明为可选属性或隐式展开的可选存储属性。 让我们通过使用惰性和消除邪恶的可选要求的方式来重新制作此示例。 😈</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.label)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.label.textColor = .black</span><br><span class="line">        <span class="keyword">self</span>.label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况还不错，但是我仍然更喜欢将我的视图声明为隐式展开的可选对象。 💀</p></br><h1 id="使用懒加载闭包"><a href="#使用懒加载闭包" class="headerlink" title="使用懒加载闭包"></a>使用懒加载闭包</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <a href="http://www.xuebaonline.com/Swift%E5%B8%A6%E9%97%AD%E5%8C%85%E7%9A%84%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96/"><code>懒加载闭包(lazy closure)</code></a> 将一些代码包装在其中。 与存储的属性相比，懒惰的主要优点是，只有对该变量执行读取操作时，才执行块。 您还可以使用常规存储属性填充 <a href="http://www.xuebaonline.com/Swift%20Lazy%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/"><code>惰性属性(lazy property)</code></a> 的值。 让我们在实践中看一下。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.textColor = .black</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想整理一下init方法，这是一个不错的做法。 你可以将所有对象自定义逻辑放在闭包内。 闭包在读取时自动执行（自我执行的闭包），因此当你调用self.label时，你的代码块将被执行并贴紧：视图将准备就绪。</p><blockquote><p><strong><em>提示：</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你不能在存储的属性中使用 <code>self</code> ，但是可以使用 <code>lazy closure</code> 来使用 <code>self</code> 。 注意：如果你不想造成引用循环和内存泄漏，则应始终使用 <code>[unown self]</code> 。 ♻️</p></blockquote></br><h1 id="使用工厂模式进行-Lazy-initialization"><a href="#使用工厂模式进行-Lazy-initialization" class="headerlink" title="使用工厂模式进行 Lazy initialization"></a><strong><em>使用工厂模式进行 Lazy initialization</em></strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我已经有几篇关于 <code>Swift</code> 中 <a href="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><code>工厂设计模式</code></a> 的文章，所以现在我只想向你展示如何使用工厂方法和结合了 <code>lazy property</code> 的静态工厂。</p></br><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong><em>工厂方法</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不喜欢自动执行的闭包，则可以将代码移出工厂方法，并将其与惰性变量一起使用。 像这样简单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = <span class="keyword">self</span>.createCustomLabel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">createCustomLabel</span><span class="params">()</span></span> -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"called"</span>)</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.textColor = .black</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，工厂方法的工作方式类似于你的惰性属性的私有初始化程序。 让我们更进一步，以便可以稍微提高可重用性…</p><h2 id="静态工厂方式"><a href="#静态工厂方式" class="headerlink" title="静态工厂方式"></a><strong><em>静态工厂方式</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想在应用程序的多个部分中重复使用这些初始化代码，则将它们初始化为 <a href="http://www.xuebaonline.com/tags/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"><code>静态工厂(static factory)</code></a> 可能是一个好习惯。 例如，这非常适合初始化自定义视图。 另外，创建自定义视图实际上并不是视图控制器任务，因此本示例中的职责更加分离。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = <span class="type">UILabel</span>.createCustomLabel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">createCustomLabel</span><span class="params">()</span></span> -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.textColor = .black</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;免费获得你可以享受静态工厂属性/方法的优点，例如缓存或返回特定的子类型。 挺整洁的！ 👍</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性变量是优化代码的一种非常方便的方法，但是它们只能在结构和类上使用。 n你不能将它们用作计算属性，这意味着它们在你每次尝试访问它们时都不会返回闭包块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个重要的事情是，惰性属性不是线程安全的，因此你必须谨慎使用它们。 另外，你并不总是希望消除隐式解包的可选值，有时候崩溃只是更好的选择！ 🐛</p><blockquote><p><strong><em>提示：</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;别偷懒！</p></blockquote><p>…但是请随时使用惰性属性！ 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解如何在 &lt;code&gt;Swift&lt;/code&gt; 中使用惰性属性来提高性能，避免使用可选参数或只是为了使初始化过程更加简洁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在程式设计中, 惰性初始是一种拖延战术。在第一次需求出现以前，先延迟创建物件、计算值或其它昂贵程序。这通常是以一个旗号来实现，用旗号来标示是否完成其程式。每次请求对象时，会先测试此旗号。如果已完成，直接传回，否则当场执行。&lt;br&gt;对于此想法更一般的论述，可见惰性求值。对指令式语言，这个模式可能潜藏着危险，尤其是使用共享状态的程式习惯。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;以设计模式的观点来说，惰性初始通常会和工厂方法模式合作，这结合了三种构想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用一个工厂去得到一个类别的实例（工厂方法模式）。&lt;/li&gt;
&lt;li&gt;将实例存在一个集合中，所以下次要求一个实例却有相同参数时，可以得到同一个实例（可和单例模式来做比较）。&lt;/li&gt;
&lt;li&gt;在第一次时，使用惰性初始来实例化物件（惰性初始模式）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="懒加载模式" scheme="http://www.xuebaonline.com/tags/%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift对象池设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-26T02:56:07.000Z</published>
    <updated>2020-04-26T03:01:11.220Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本快速教程中，我将解释并向你展示如何使用 <code>Swift</code> 编程语言实现对象池设计模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="对象池"><code>对象池（英语：object pool pattern）</code></a>是一种设计模式。一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的效能提升。从池子中取得对象的时间是可预测的，但新建一个实例所需的时间是不确定。</p><a id="more"></a></br><h1 id="Swift-中的通用对象池"><a href="#Swift-中的通用对象池" class="headerlink" title="Swift 中的通用对象池"></a><strong>Swift 中的通用对象池</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象池模式是一种创新的设计模式。其背后的主要思想是，首先创建一组对象（一个池），然后从该池中获取和释放对象，而不是不断创建和释放它们。 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么？性能改进。例如， <code>Dispatch</code> 框架使用对象池模式为开发人员提供预先创建的队列，因为创建队列（带有关联线程）是相对昂贵的操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象池模式的另一个用例是 <code>worker</code> 。例如，您必须从Web上下载数百个图像，但是您只想同时下载5个图像，则可以使用5个工作对象池来完成。分配少量的工作程序（实际上将完成下载任务）可能要比为每个图像下载请求创建一个新的工作程序便宜得多。 🖼</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么这种模式的缺点呢？有一些。例如，如果池中有工作程序，则它们可能包含状态或敏感的用户数据。你也必须非常小心。重设所有内容。同样，如果你在多线程环境中运行，则还必须使池成为线程安全的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个简单的通用线程安全对象池类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> lockQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"pool.lock.queue"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> semaphore: <span class="type">DispatchSemaphore</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> items = [<span class="type">T</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> items: [<span class="type">T</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.semaphore = <span class="type">DispatchSemaphore</span>(value: items.<span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">self</span>.items.reserveCapacity(items.<span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">self</span>.items.append(contentsOf: items)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">acquire</span><span class="params">()</span></span> -&gt; <span class="type">T?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.semaphore.wait(timeout: .distantFuture) == .success, !<span class="keyword">self</span>.items.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.lockQueue.sync &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>.items.remove(at: <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">release</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.lockQueue.sync &#123;</span><br><span class="line">            <span class="keyword">self</span>.items.append(item)</span><br><span class="line">            <span class="keyword">self</span>.semaphore.signal()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pool = <span class="type">Pool</span>&lt;<span class="type">String</span>&gt;([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(a ?? "</span>n/a<span class="string">") acquired"</span>)</span><br><span class="line"><span class="keyword">let</span> b = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(b ?? "</span>n/a<span class="string">") acquired"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(c ?? "</span>n/a<span class="string">") acquired"</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .<span class="keyword">default</span>).asyncAfter(deadline: .now() + .seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> item = b &#123;</span><br><span class="line">        pool.release(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"No more resource in the pool, blocking thread until..."</span>)</span><br><span class="line"><span class="keyword">let</span> x = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(x ?? "</span>n/a<span class="string">") acquired again"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在示例中，实现仅几行。 你具有通用池项的线程安全数组，一个调度信号量（如果池中没有可用对象将阻塞该信号量）以及两个方法以实际使用对象池。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在示例中，你可以看到，如果池中没有剩余的对象，则当前队列将被阻塞，直到资源被释放并可以使用为止。 所以要当心，不要意外阻塞主线程！ 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在本快速教程中，我将解释并向你展示如何使用 &lt;code&gt;Swift&lt;/code&gt; 编程语言实现对象池设计模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;对象池&quot;&gt;&lt;code&gt;对象池（英语：object pool pattern）&lt;/code&gt;&lt;/a&gt;是一种设计模式。一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的效能提升。从池子中取得对象的时间是可预测的，但新建一个实例所需的时间是不确定。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="对象池设计模式" scheme="http://www.xuebaonline.com/tags/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift外观设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-26T02:30:49.000Z</published>
    <updated>2020-04-26T02:51:38.845Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观设计模式是复杂子系统上的简化界面。 展示一个使用 <code>Swift</code> 的快速实例。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="外观模式"><code>外观模式（Facade pattern）</code></a> ，是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。</p><a id="more"></a><p><img src="http://q8wtfza4q.bkt.clouddn.com/fp-stp1.png" alt="外观设计模式"></p><ul><li><p>结构</p><ul><li><p>Facade</p><p>  这个外观类为子系统中Packages 1、2、3提供一个共同的对外接口</p></li><li><p>Clients</p><p>  客户对象通过一个外观接口读写子系统中各接口的数据资源。</p></li><li><p>Packages</p><p>  客户可以通过外观接口读取的内部库。</p></li></ul></li></ul></br><h1 id="什么是外观设计模式"><a href="#什么是外观设计模式" class="headerlink" title="什么是外观设计模式"></a><strong>什么是外观设计模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观设计模式名字的由来是源于建筑结构的术语。</p><blockquote><p>one exterior side of a building, usually the front</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件开发中，此定义可以转换为外部所有内容，隐藏所有内部部分。 因此，外观的主要目的是在一些更复杂的丑陋外观上提供漂亮的API。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，如果你有两个或多个单独的子系统需要一起工作以完成某种任务，则外观设计模式会很方便。 它可以隐藏底层的复杂性，再加上如果隐藏方法内部发生任何更改，则外观的界面仍然可以保持不变。 👍</p></br><h1 id="外观设计模式实例"><a href="#外观设计模式实例" class="headerlink" title="外观设计模式实例"></a><strong>外观设计模式实例</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我让我们想象一个带有切换按钮的应用程序，该按钮可以打开或关闭特定设置。 如果用户点击它，我们将更改默认存储中的基础设置值，此外，我们还希望播放声音作为给定输入的额外反馈。 这是三个不同的东西组合在一起。 🎶</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toggleSettings</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// change underlying settings value</span></span><br><span class="line">    <span class="keyword">let</span> settingsKey = <span class="string">"my-settings"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> originalValue = <span class="type">UserDefaults</span>.standard.bool(forKey: settingsKey)</span><br><span class="line">    <span class="keyword">let</span> newValue = !originalValue</span><br><span class="line"></span><br><span class="line">    <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(newValue, forKey: settingsKey)</span><br><span class="line">    <span class="type">UserDefaults</span>.standard.synchronize()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// positive feedback sound</span></span><br><span class="line">    <span class="type">AudioServicesPlaySystemSound</span>(<span class="number">1054</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update UI</span></span><br><span class="line">    <span class="keyword">self</span>.switchButton.setOn(newValue, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恭喜，我们已经创建了最简单的外观！ 如果你对这段代码熟悉，则意味着您过去已经使用了 <code>Facade</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，事情可能会更加复杂，例如，如果你有一个 <code>Web</code> 服务，并且需要上传一些数据和附件文件，那么你还可以编写一个 <code>Facade</code> 来隐藏子系统的底层复杂性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观设计模式确实很容易创建，有时你甚至不会注意到正在使用外观模式，但是它们对于隐藏，解耦或简化事物非常有用。 😉</p></br><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><br><ul><li><p><a href="https://www.appcoda.com/design-pattern-structural/" target="_blank" rel="noopener"><code>Design Patterns in Swift #3: Facade and Adapter</code></a></p></li><li><p><a href="https://rubygarage.org/blog/swift-design-patterns" target="_blank" rel="noopener"><code>Top 5 Design Patterns in Swift for iOS App Development</code></a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;外观设计模式是复杂子系统上的简化界面。 展示一个使用 &lt;code&gt;Swift&lt;/code&gt; 的快速实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;外观模式&quot;&gt;&lt;code&gt;外观模式（Facade pattern）&lt;/code&gt;&lt;/a&gt; ，是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="外观设计模式" scheme="http://www.xuebaonline.com/tags/%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>在Swift中处理非可选选项</title>
    <link href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%A4%84%E7%90%86%E9%9D%9E%E5%8F%AF%E9%80%89%E9%80%89%E9%A1%B9/"/>
    <id>http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%A4%84%E7%90%86%E9%9D%9E%E5%8F%AF%E9%80%89%E9%80%89%E9%A1%B9/</id>
    <published>2020-04-26T01:49:49.000Z</published>
    <updated>2020-04-26T02:19:11.394Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可选参数可以说是 <code>Swift</code> 最重要的功能之一，也是将其与 <code>Objective-C</code> 之类的语言区分开来的关键。 通过被迫处理可能为 <code>nil</code> 的情况，我们倾向于编写更具可预测性和较少错误的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有时可选参数可能会使你处于一个很难处理的局面，在程序员看来，你知道（或至少在假设之下）某个变量在使用时始终为 <code>non-nil</code> ，即使它是 可选类型。 就像在视图控制器中处理视图时一样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tableView: <span class="type">UITableView?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        tableView = <span class="type">UITableView</span>(frame: view.bounds)</span><br><span class="line">        view.addSubview(tableView!)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewModelDidUpdate</span><span class="params">(<span class="number">_</span> viewModel: ViewModel)</span></span> &#123;</span><br><span class="line">        tableView?.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下， <code>Swift</code> 程序员会在与制表符和空格几乎相同的程度上存在分歧。 有人说：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“由于它是可选的，因此你应该始终正确地解开它，使用 <code>let</code> 或 <code>guard let</code> 。”</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而其他人会朝完全不同的方向说：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“由于你知道变量将不会为 <code>nil</code> ，请强制将其解包（使用！）。 崩溃比处于不确定状态要好。”</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本上，我们在这里谈论的是是否进行 <a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener" title="防御性编程"><code>防御性编程(英文：defensive programming)</code></a>。 我们是否试图从不确定的状态中恢复，还是仅仅放弃并崩溃？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我必须对这个问题给出一个二元的答案，那么我肯定会选择后者。 未定义状态会导致很难发现错误，可能会导致不必要的代码执行，而采用防御性编程只会导致难以推理的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，我宁愿不必给出二进制答案，而是研究一些可用于以更细微的方式解决此问题的技术。 </p></br><h1 id="真的可选吗？"><a href="#真的可选吗？" class="headerlink" title="真的可选吗？"></a><strong>真的可选吗？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变量和属性是可选的，但实际上是程序逻辑所必需的，实际上是体系结构缺陷的征兆。 如果需要某些东西，到没有它会使你处于不确定状态-它不是可选的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管在某些情况下（例如与某些系统 <code>API</code> 进行交互时），确实很难避免使用可选项–在许多情况下，我们可以使用某些技术来摆脱可选项。</p></br><h1 id="懒加载-lazy-比非可选的-non-optionally-optional-要好"><a href="#懒加载-lazy-比非可选的-non-optionally-optional-要好" class="headerlink" title="懒加载(lazy)比非可选的(non-optionally optional)要好"></a><strong>懒加载(lazy)比非可选的(non-optionally optional)要好</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种避免使用属性的可选选项的方法，即通过使用惰性属性来避免在创建父对象之后需要创建值的属性（例如，视图控制器中的视图-应该在 <code>loadView()</code> 或 <code>viewDidLoad()</code> 中创建）。 惰性属性可以是非可选的，但仍不需要在其父级的初始值设定项中创建。 它将在首次访问时创建。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从之前更新 <code>TableViewController</code> ，以对其表视图使用对属性进行懒加载：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> tableView = <span class="type">UITableView</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        tableView.frame = view.bounds</span><br><span class="line">        view.addSubview(tableView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewModelDidUpdate</span><span class="params">(<span class="number">_</span> viewModel: ViewModel)</span></span> &#123;</span><br><span class="line">        tableView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有可选项，没有不确定的状态！ 🎉</p></br><h1 id="适当的依赖项管理要比非可选的可选项好"><a href="#适当的依赖项管理要比非可选的可选项好" class="headerlink" title="适当的依赖项管理要比非可选的可选项好"></a><strong>适当的依赖项管理要比非可选的可选项好</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可选项的另一个常见用法是打破 <a href="https://en.wikipedia.org/wiki/Circular_dependency" target="_blank" rel="noopener" title="循环依赖关系"><code>循环依赖关系(circular dependencies)</code></a> 。 有时您可能会遇到 <code>A</code> 依赖于 <code>B</code> ，但 <code>B</code> 也依赖于 <code>A</code> 的情况。类似于此设置：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> commentManager: <span class="type">CommentManager?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userDidPostComment</span><span class="params">(<span class="number">_</span> comment: Comment)</span></span> &#123;</span><br><span class="line">        user.totalNumberOfComments += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">logOutCurrentUser</span><span class="params">()</span></span> &#123;</span><br><span class="line">        user.logOut()</span><br><span class="line">        commentManager?.clearCache()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> userManager: <span class="type">UserManager?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">composer</span><span class="params">(<span class="number">_</span> composer: CommentComposer</span></span></span><br><span class="line"><span class="function"><span class="params">                  didPostComment comment: Comment)</span></span> &#123;</span><br><span class="line">        userManager?.userDidPostComment(comment)</span><br><span class="line">        handle(comment)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clearCache</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cache.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们在上面看到的，我们在 <code>UserManager</code> 和 <code>CommentManager</code> 之间具有循环依赖关系，其中它们都不假定彼此拥有所有权，但是它们在逻辑上仍然相互依赖。 那只是等待发生的错误！ 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决上述问题，我们改为让 <code>CommentComposer</code> 充当中间人，并负责通知 <code>UserManager</code> 和 <code>CommentManager</code> 已做出评论：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentComposer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> commentManager: <span class="type">CommentManager</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> userManager: <span class="type">UserManager</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> textView = <span class="type">UITextView</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(commentManager: <span class="type">CommentManager</span>,</span><br><span class="line">         userManager: <span class="type">UserManager</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.commentManager = commentManager</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">postComment</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> comment = <span class="type">Comment</span>(text: textView.text)</span><br><span class="line">        commentManager.handle(comment)</span><br><span class="line">        userManager.userDidPostComment(comment)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，<code>UserManager</code> 可以拥有对 <code>CommentManager</code> 的强引用，而没有循环引用（或依赖)：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> commentManager: <span class="type">CommentManager</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(commentManager: <span class="type">CommentManager</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.commentManager = commentManager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userDidPostComment</span><span class="params">(<span class="number">_</span> comment: Comment)</span></span> &#123;</span><br><span class="line">        user.totalNumberOfComments += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再次删除了所有可选内容，并提供了可预测的代码！ 🎉</p></br><h1 id="崩溃"><a href="#崩溃" class="headerlink" title="崩溃"></a><strong>崩溃</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的示例中，我们看到了一些示例，在这些示例中我们可以调整代码以通过删除可选选项来消除不确定性。 但是，有时候这是不可能的。 假设你正在加载包含应用程序配置的本地 <code>JSON</code> 文件。 这本质上是一项可能会失败的操作，因此我们将需要添加一些错误处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果配置无法加载，则继续执行程序会使应用程序处于未定义状态，因此在这种情况下可能会引发崩溃。 这样，我们可以获得崩溃报告，并希望我们的 <code>tests &amp; QA</code> 检查流程能够早于解决此问题并将其传递给用户。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，我们如何崩溃？ 最简单的解决方案是简单地使用 <code>! operator</code> ，强制解开可选选项，如果它包含 <code>nil</code> 则导致崩溃：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = loadConfiguration()!</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管这种方法很简单，但缺点是很大。 如果此代码开始崩溃，我们将得到的错误消息是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: unexpectedly found <span class="literal">nil</span> <span class="keyword">while</span> unwrapping an <span class="type">Optional</span> value</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;错误消息不会告诉我们错误的原因和发生位置，也没有提供解决方法的线索。 相反，让我们结合使用 <code>guard</code> 语句和 <code>preconditionFailure()</code> 函数，以自定义消息退出。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> configuration = loadConfiguration() <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">preconditionFailure</span>(<span class="string">"Configuration couldn't be loaded. "</span> +</span><br><span class="line">                        <span class="string">"Verify that Config.JSON is valid."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用以上方法崩溃时，我们将获得更多有用的错误消息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: <span class="type">Configuration</span> couldn’t be loaded. <span class="type">Verify</span> that <span class="type">Config1</span>.<span class="type">JSON</span> <span class="keyword">is</span> valid.: file ~/<span class="type">DemoApp</span>/<span class="type">Sources</span>/<span class="type">AppDelegate</span>.swift, line <span class="number">17</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以采取明确的措施来解决该问题，并且我们确切知道它在代码库中的位置！ 🚀</p></br><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a><strong>更多</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进行上面的 <code>guard-let-preconditionFailure</code> 操作可能会有些乏味，并且确实会使代码难于遵循。 我们真的不想在代码中留出如此大的空间，这样的特殊情况-我们要专注于我们的逻辑。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的解决方案是 <code>Require</code> 。 它在 <code>Optional</code> 上添加了一个简单的 <code>require()</code> 方法，可以完成上述操作，但是使调用站点更加整洁。 使用 <code>Require</code> 时，上述配置加载代码如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = loadConfiguration().require(hint: <span class="string">"Verify that Config.JSON is valid"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果失败，它将给我们以下错误消息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: <span class="type">Required</span> value was <span class="literal">nil</span>. <span class="type">Debugging</span> hint: <span class="type">Verify</span> that <span class="type">Config1</span>.<span class="type">JSON</span> <span class="keyword">is</span> valid: file ~/<span class="type">DemoApp</span>/<span class="type">Sources</span>/<span class="type">AppDelegate</span>.swift, line <span class="number">17</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Require</code> 的另一个优点是，它还将引发 <code>NSException</code> 以及调用 <code>preconditionFailure</code> ，这将使崩溃报告工具（如 <code>Crashlytics</code> ）能够提取崩溃的所有元数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想在代码中使用  <a href="https://github.com/JohnSundell/Require" target="_blank" rel="noopener" title="Require"><code>Require</code></a> ，它是 <a href="https://github.com/JohnSundell/Require" target="_blank" rel="noopener" title="Require"><code>GitHub</code></a> 上的开源代码。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，这些是我在 <code>Swift</code> 中处理非可选可选内容的技巧：</p><ul><li>懒加载(lazy)比非可选的(non-optionally optional)要好</li><li>适当的依赖项管理要比非可选的可选项好</li><li>当您需要使用非可选的可选选项时，正常崩溃</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选参数可以说是 &lt;code&gt;Swift&lt;/code&gt; 最重要的功能之一，也是将其与 &lt;code&gt;Objective-C&lt;/code&gt; 之类的语言区分开来的关键。 通过被迫处理可能为 &lt;code&gt;nil&lt;/code&gt; 的情况，我们倾向于编写更具可预测性和较少错误的代码。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;但是，有时可选参数可能会使你处于一个很难处理的局面，在程序员看来，你知道（或至少在假设之下）某个变量在使用时始终为 &lt;code&gt;non-nil&lt;/code&gt; ，即使它是 可选类型。 就像在视图控制器中处理视图时一样：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TableViewController&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; tableView: &lt;span class=&quot;type&quot;&gt;UITableView?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tableView = &lt;span class=&quot;type&quot;&gt;UITableView&lt;/span&gt;(frame: view.bounds)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        view.addSubview(tableView!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;viewModelDidUpdate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; viewModel: ViewModel)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tableView?.reloadData()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="迭代器设计模式" scheme="http://www.xuebaonline.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="optionals" scheme="http://www.xuebaonline.com/tags/optionals/"/>
    
      <category term="non-optional" scheme="http://www.xuebaonline.com/tags/non-optional/"/>
    
  </entry>
  
  <entry>
    <title>在Swift中创建自定义集合</title>
    <link href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/"/>
    <id>http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/</id>
    <published>2020-04-26T01:29:52.000Z</published>
    <updated>2020-04-26T02:20:25.950Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建对象或值的集合时，我们通常使用标准库提供的数据结构-例如 <code>Array</code> ，<code>Dictionary</code> 和 <code>Set</code> 。 尽管这三个案例涵盖了大多数用例，但有时创建自定义包装器集合可以使你使代码更可预测，并且更不易出错。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此次，让我们看看作为应用程序开发人员的我们如何在 <code>Swift</code> 中定义此类自定义集合，以及结合枚举的强大功能，如何让我们为自己创建一些非常漂亮的 <code>API</code> 。</p><a id="more"></a></br><h1 id="删除可选"><a href="#删除可选" class="headerlink" title="删除可选"></a><strong>删除可选</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像我们在 <a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%A4%84%E7%90%86%E9%9D%9E%E5%8F%AF%E9%80%89%E9%80%89%E9%A1%B9/" title="在Swift中处理非可选的可选内容"><code>“在Swift中处理非可选的可选内容”</code></a> 中介绍的那样，减少了在实际需要的值真正需要时使用可选的需求，这确实可以帮助我们避免错误并简化我们的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，集合的问题在于，你通常无法保证它们是否包含一定的值，因此，你往往会遇到很多可选内容和逻辑，这些可选内容和逻辑要求以一种或另一种方式将它们拆开。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们正在为一家杂货店构建应用程序，并且我们希望拥有一个用户界面，该界面可让用户按类别显示所有产品。 要为此类UI创建模型，我们可以使用 <code>Dictionary</code> ，其使用 <code>Category</code> 作为其键类型，并使用 <code>[Product]</code> 作为其值类型，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> products: [<span class="type">Category</span> : [<span class="type">Product</span>]] = [</span><br><span class="line">    .dairy: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Milk"</span>, category: .dairy),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Butter"</span>, category: .dairy)</span><br><span class="line">    ],</span><br><span class="line">    .vegetables: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Cucumber"</span>, category: .vegetables),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Lettuce"</span>, category: .vegetables)</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管上述方法有效，但要求我们编写这样的代码，以便例如仅显示所有 <code>Product</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> dairyProducts = products[.dairy] &#123;</span><br><span class="line">    <span class="keyword">guard</span> !dairyProducts.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        renderEmptyView()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render(dairyProducts)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    renderEmptyView()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很好，但是可能会更好。 但是，插入新产品变得更加麻烦：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> products = [<span class="type">Category</span> : [<span class="type">Product</span>]]()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> product: Product)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> productsInCategory = products[product.category] &#123;</span><br><span class="line">            productsInCategory.append(product)</span><br><span class="line">            products[product.category] = productsInCategory</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            products[product.category] = [product]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好消息是，通过创建我们自己的自定义集合，我们可以使上述两个示例变得更好更清晰。 而且，更好的消息是-借助 <code>Swift</code> 的面向协议的设计-创建这样的集合实际上非常容易！</p></br><h1 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a><strong>创建集合</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 标准库中的所有集合都遵循 <code>Collection</code> 协议，而 <code>Collection</code> 协议又继承自 <code>Sequence</code> 协议。 通过使自定义集合符合这两个协议，它可以完全免费地利用所有标准集合操作（例如，迭代和过滤）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从定义自定义 <code>ProductCollection</code> 的基础开始，这将使我们能够以更好的方式处理产品和类别。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProductCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">DictionaryType</span> = [<span class="type">Category</span> : [<span class="type">Product</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Underlying, private storage, that is the same type of dictionary</span></span><br><span class="line">    <span class="comment">// that we previously was using at the call site</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> products = <span class="type">DictionaryType</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable our collection to be initialized with a dictionary</span></span><br><span class="line">    <span class="keyword">init</span>(products: <span class="type">DictionaryType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.products = products</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们将通过实现协议要求使其符合 <code>Collection</code> 。 我们要做的大多数事情就是简单地将调用转发到基础 <code>products</code> 字典，然后让它进行“繁重的工作”：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span>: <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Required nested types, that tell Swift what our collection contains</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">DictionaryType</span>.<span class="type">Index</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">DictionaryType</span>.<span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The upper and lower bounds of the collection, used in iterations</span></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123; <span class="keyword">return</span> products.startIndex &#125;</span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123; <span class="keyword">return</span> products.endIndex &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Required subscript, based on a dictionary index</span></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Index</span>) -&gt; <span class="type">Iterator</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> products[index] &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method that returns the next index when iterating</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Index)</span></span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> products.index(after: i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码使用的是 <code>Swift 4</code> ，这归功于对通用约束的改进（使我们可以更仔细地研究这些改进以及如何在以后的文章中使用类型约束），从而使自定义集合的定义变得更加简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们有了一个自定义集合，可以将其用作内置集合之一。 例如，我们可以遍历它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (category, productsInCategory) <span class="keyword">in</span> products &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者在其上使用诸如 <code>map</code> 的操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> categories = productCollection.<span class="built_in">map</span> &#123; $<span class="number">0</span>.key &#125;</span><br></pre></td></tr></table></figure></br><h1 id="自定义集合-API"><a href="#自定义集合-API" class="headerlink" title="自定义集合 API"></a><strong>自定义集合 API</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们已经为我们的系列奠定了基础，让我们开始向其中添加一些 <code>API</code> ，使我们能够使我们的产品处理代码更好。 我们将从一个自定义的下标重载开始，该重载使我们无需处理可选项就可以获取或设置一系列产品：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(category: <span class="type">Category</span>) -&gt; [<span class="type">Product</span>] &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> products[category] ?? [] &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; products[category] = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还添加一个便捷的 <code>API</code> ，以轻松地将新 <code>product</code> 插入我们的收藏夹：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> product: Product)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> productsInCategory = <span class="keyword">self</span>[product.category]</span><br><span class="line">        productsInCategory.append(product)</span><br><span class="line">        <span class="keyword">self</span>[product.category] = productsInCategory</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以返回原始的 <code>product</code> 处理代码，并将其更新为更好的代码。 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dairyProducts = products[.dairy]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dairyProducts.isEmpty &#123;</span><br><span class="line">    renderEmptyView()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    render(dairyProducts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> products = <span class="type">ProductCollection</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(product: Product)</span></span> &#123;</span><br><span class="line">        products.insert(product)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="通过-Key-值获取"><a href="#通过-Key-值获取" class="headerlink" title="通过 Key 值获取"></a><strong>通过 Key 值获取</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，到了关键时候！ 由于我们的自定义集合基本上只是字典的包装，因此我们可以轻松地添加对使用字典文字进行初始化的支持。 这样做将使我们能够编写如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> products: <span class="type">ProductCollection</span> = [</span><br><span class="line">    .dairy: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Milk"</span>, category: .dairy),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Butter"</span>, category: .dairy)</span><br><span class="line">    ],</span><br><span class="line">    .vegetables: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Cucumber"</span>, category: .vegetables),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Lettuce"</span>, category: .vegetables)</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;太酷了！ 这不仅对减少生产代码中的冗长有用，而且还将使在我们的测试中设置产品集合模拟更加简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要做的就是遵守    <code>ExpressibleByDictionaryLiteral</code> ，它要求我们实现一个带有文字的初始化程序，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span>: <span class="title">ExpressibleByDictionaryLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Key</span> = <span class="type">Category</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Value</span> = [<span class="type">Product</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(dictionaryLiteral elements: (<span class="type">Category</span>, [<span class="type">Product</span>])...) &#123;</span><br><span class="line">        <span class="keyword">for</span> (category, productsInCategory) <span class="keyword">in</span> elements &#123;</span><br><span class="line">            products[category] = productsInCategory</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用自定义集合可能是一种非常强大的工具，可以以一种更加可预测且易于使用的方式来处理一组值。 当您处理多个值时，它不一定总是您的首选解决方案，但在正确的情况下，它确实可以帮助你编写更简洁的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在调试时，了解诸如集合之类的事物的工作方式也非常有帮助，或者使你了解如何优化与集合相关的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 &lt;code&gt;Swift&lt;/code&gt; 中创建对象或值的集合时，我们通常使用标准库提供的数据结构-例如 &lt;code&gt;Array&lt;/code&gt; ，&lt;code&gt;Dictionary&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; 。 尽管这三个案例涵盖了大多数用例，但有时创建自定义包装器集合可以使你使代码更可预测，并且更不易出错。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此次，让我们看看作为应用程序开发人员的我们如何在 &lt;code&gt;Swift&lt;/code&gt; 中定义此类自定义集合，以及结合枚举的强大功能，如何让我们为自己创建一些非常漂亮的 &lt;code&gt;API&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="迭代器设计模式" scheme="http://www.xuebaonline.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Collection" scheme="http://www.xuebaonline.com/tags/Collection/"/>
    
      <category term="Collections" scheme="http://www.xuebaonline.com/tags/Collections/"/>
    
  </entry>
  
  <entry>
    <title>Swift迭代器设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-26T01:13:26.000Z</published>
    <updated>2020-04-26T02:22:15.675Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用一些 <a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/" title="自定义序列"><code>自定义序列</code></a>（符合 <code>Swift</code> 标准库中的 <code>IteratorProtocol</code> ），学习迭代器设计模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在面向对象编程里，<a href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="迭代器模式">迭代器模式</a> 是一种设计模式，是一种最简单也最常见的设计模式。它可以让用户透过特定的接口访问容器中的每一个元素而不用了解底层的实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，我将重点介绍迭代器设计模式。 该模式在 <a href="https://developer.apple.com/documentation/swift/swift_standard_library" target="_blank" rel="noopener" title="Swift标准库"><code>Swift标准库</code></a> 中大量使用，如果你需要创建迭代器，有一些协议可以为你提供支持，但是老实说：我从来没有直接实现过这种模式。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实是，在99％的用例中，你将永远不必处理这种模式，因为对 <code>Swift</code> 中直接内置的迭代器提供了惊人的支持。 始终使用序列，数组，字典而不是直接实现此模式，但是很高兴知道事情是如何进行的。 🙃</p><a id="more"></a></br><h1 id="什么是迭代器设计模式？"><a href="#什么是迭代器设计模式？" class="headerlink" title="什么是迭代器设计模式？"></a><strong>什么是迭代器设计模式？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顾名思义，该模式使你可以迭代一组元素。 这是其中一种定义：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供一种在不暴露其基础表示的情况下顺序访问聚合对象的元素的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长话短说，迭代器为你提供了一个界面，无论你在后台如何实现这些集合，都可以使你对集合进行迭代。 这是上面使用字符串迭代器的理论的快速示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">StringIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStringIterator</span>: <span class="title">StringIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> values: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> index: <span class="type">Int?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> values: [<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.values = values</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">for</span> index: Int?)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = index, index &lt; <span class="keyword">self</span>.values.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="literal">nil</span>, !<span class="keyword">self</span>.values.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = <span class="keyword">self</span>.nextIndex(<span class="keyword">for</span>: <span class="keyword">self</span>.index) &#123;</span><br><span class="line">            <span class="keyword">self</span>.index = index</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.values[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Iterable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">StringIterator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataArray</span>: <span class="title">Iterable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> dataSource: [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataSource = [<span class="string">"🐶"</span>, <span class="string">"🐔"</span>, <span class="string">"🐵"</span>, <span class="string">"🦁"</span>, <span class="string">"🐯"</span>, <span class="string">"🐭"</span>, <span class="string">"🐱"</span>, <span class="string">"🐮"</span>, <span class="string">"🐷"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">StringIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ArrayStringIterator</span>(<span class="keyword">self</span>.dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="type">DataArray</span>()</span><br><span class="line"><span class="keyword">let</span> iterator = data.makeIterator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> next = iterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，它们有两个主要协议和一个非常简单的实现。 现在，我们的 <code>DataArray</code> 类的行为就像一个真实的数组，可以通过使用循环来迭代基础元素。 让我们抛开理论，通过使用实际的 <code>Swift标准库组件</code> 从上面重新实现示例。 😉</p></br><h1 id="Swift-中的自定义序列"><a href="#Swift-中的自定义序列" class="headerlink" title="Swift 中的自定义序列"></a><strong>Swift 中的自定义序列</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 具有内置的序列协议，可帮助你创建迭代器。 在 <code>Swift</code> 中实现自己的序列就是通过创建自定义迭代器对象来隐藏基础数据结构。 你只需存储当前索引，并在每次调用下一个函数时根据该索引返回下一个元素。 😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Emojis</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> animals: [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">EmojiIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">EmojiIterator</span>(<span class="keyword">self</span>.animals)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EmojiIterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> values: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> index: <span class="type">Int?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> values: [<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.values = values</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">for</span> index: Int?)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = index, index &lt; <span class="keyword">self</span>.values.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="literal">nil</span>, !<span class="keyword">self</span>.values.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = <span class="keyword">self</span>.nextIndex(<span class="keyword">for</span>: <span class="keyword">self</span>.index) &#123;</span><br><span class="line">            <span class="keyword">self</span>.index = index</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.values[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emojis = <span class="type">Emojis</span>(animals: [<span class="string">"🐶"</span>, <span class="string">"🐔"</span>, <span class="string">"🐵"</span>, <span class="string">"🦁"</span>, <span class="string">"🐯"</span>, <span class="string">"🐭"</span>, <span class="string">"🐱"</span>, <span class="string">"🐮"</span>, <span class="string">"🐷"</span>])</span><br><span class="line"><span class="keyword">for</span> emoji <span class="keyword">in</span> emojis &#123;</span><br><span class="line">    <span class="built_in">print</span>(emoji)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，<a href="https://developer.apple.com/documentation/swift/sequence" target="_blank" rel="noopener" title="Sequence protocol"><code>Sequence protocol</code></a> 与第一个示例中使用的自定义可迭代协议的通用对应项。   <a href="https://developer.apple.com/documentation/swift/iteratorprotocol" target="_blank" rel="noopener" title="IteratorProtocol"><code>IteratorProtocol</code></a> 有点像之前使用的字符串迭代器协议，但是更加迅捷，当然也更通用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，这很棒。 最后，你知道如何创建自定义序列。 如果你想隐藏数据结构并提供通用的可迭代接口，那么这很好。 想象一下，如果你将要开始使用字典而不是使用数组来存储命名的表情符号而没有用于包装它们的迭代器，将会发生什么。 🤔</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我想谈谈 <code>Swift标准库</code> 中还有另外一个超级有用的东西。 没错，一个抽象级别的应用，我们看这里：</p></br><h1 id="Swift-中的自定义集合"><a href="#Swift-中的自定义集合" class="headerlink" title="Swift 中的自定义集合"></a><strong>Swift 中的自定义集合</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://developer.apple.com/documentation/swift/collection" target="_blank" rel="noopener" title="Collections"><code>Collections</code></a> 是序列之外的第一步。 它们内部的元素可以通过下标访问，它们还定义了 <code>startIndex</code> 和 <code>endIndex</code> ，而且集合中的各个元素可以多次访问。 听起来不错？ 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时创建 <a href=""自定义集合类型""><code>自定义集合类型</code></a> 可能很有用。 例如，如果你想消除可选值。 想象一下分类的收藏夹机制，对于每个类别，您都有一系列的收藏夹，因此你必须处理空的和不存在的案例。 使用自定义集合，你可以将多余的代码隐藏在自定义数据结构中，并为应用程序的其余部分提供一个简洁的界面。 😍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">FavoriteType</span> = [<span class="type">String</span>: [<span class="type">String</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> list: <span class="type">FavoriteType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Favorites</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.list = <span class="type">FavoriteType</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Favorites</span>: <span class="title">Collection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">FavoriteType</span>.<span class="type">Index</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">FavoriteType</span>.<span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.startIndex</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.endIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Index</span>) -&gt; <span class="type">Iterator</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list[index]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Index)</span></span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.index(after: i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">String</span>) -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list[index] ?? []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> value: String, category: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> values = <span class="keyword">self</span>.list[category] &#123;</span><br><span class="line">            <span class="keyword">guard</span> !values.<span class="built_in">contains</span>(value) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            values.append(value)</span><br><span class="line">            <span class="keyword">self</span>.list[category] = values</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.list[category] = [value]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> value: String, category: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> values = <span class="keyword">self</span>.list[category] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        values = values.<span class="built_in">filter</span> &#123; $<span class="number">0</span> == value &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> values.isEmpty &#123;</span><br><span class="line">            <span class="keyword">self</span>.list.removeValue(forKey: category)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.list[category] = values</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Favorites</span>.shared.add(<span class="string">"apple"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.add(<span class="string">"pear"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.add(<span class="string">"apple"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Favorites</span>.shared[<span class="string">"fruits"</span>]</span><br><span class="line"></span><br><span class="line"><span class="type">Favorites</span>.shared.remove(<span class="string">"apple"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.remove(<span class="string">"pear"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.list</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我知道，这是一个非常简单的示例，但它说明了为什么集合比纯序列更高级。 此外，在下面的链接中，有很好的演示，演示了精心编写的收藏集。 随时了解有关隐藏在Swift标准库中（不是那么深）的这些超级协议和自定义数据类型的更多信息。 🤐</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过使用一些 &lt;a href=&quot;http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/&quot; title=&quot;自定义序列&quot;&gt;&lt;code&gt;自定义序列&lt;/code&gt;&lt;/a&gt;（符合 &lt;code&gt;Swift&lt;/code&gt; 标准库中的 &lt;code&gt;IteratorProtocol&lt;/code&gt; ），学习迭代器设计模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在面向对象编程里，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;迭代器模式&quot;&gt;迭代器模式&lt;/a&gt; 是一种设计模式，是一种最简单也最常见的设计模式。它可以让用户透过特定的接口访问容器中的每一个元素而不用了解底层的实现。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这次，我将重点介绍迭代器设计模式。 该模式在 &lt;a href=&quot;https://developer.apple.com/documentation/swift/swift_standard_library&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;Swift标准库&quot;&gt;&lt;code&gt;Swift标准库&lt;/code&gt;&lt;/a&gt; 中大量使用，如果你需要创建迭代器，有一些协议可以为你提供支持，但是老实说：我从来没有直接实现过这种模式。 😅&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;事实是，在99％的用例中，你将永远不必处理这种模式，因为对 &lt;code&gt;Swift&lt;/code&gt; 中直接内置的迭代器提供了惊人的支持。 始终使用序列，数组，字典而不是直接实现此模式，但是很高兴知道事情是如何进行的。 🙃&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="迭代器设计模式" scheme="http://www.xuebaonline.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift适配器设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T10:45:18.000Z</published>
    <updated>2020-04-26T01:15:53.944Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用真实示例和 <code>Swift</code> 中的适配器设计模式，将不兼容的对象转换为目标接口或类。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设计模式中，<a href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="适配器模式">适配器模式</a>（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。</p><a id="more"></a><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h1><p>有两种类型的适配器模式：</p><ul><li><p><strong>对象适配器模式</strong></p><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。</p><p>  <img src="http://q8wtfza4q.bkt.clouddn.com/adp-stp1.png" alt="对象适配器模式" title="对象适配器模式"></p></li></ul><br><ul><li><strong>类适配器模式</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种适配器模式下，适配器继承自已实现的类（一般多重继承）。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/adp-stp2.png" alt="类适配器模式" title="类适配器模式"></p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适配器是一种结构设计模式，允许具有不兼容接口的对象一起工作。 换句话说，它转换对象的接口以使其适应不同的对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，适配器可以将一件事转换为另一件事，有时也称为包装器，因为它可以包装对象并在其周围提供一个新接口。 就像特定接口或旧类的软件加密狗一样。 </p><br><h1 id="适配器设计模式的实现"><a href="#适配器设计模式的实现" class="headerlink" title="适配器设计模式的实现"></a><strong>适配器设计模式的实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建适配器实际上是一件非常容易的事情。 你只需要创建一个新对象，将旧对象“装箱”到其中，并在新类或结构上实现所需的接口即可。 换句话说，包装器对象将是我们的适配器，通过包装另一个适配器对象来实现目标接口。</p><h2 id="Adaptee"><a href="#Adaptee" class="headerlink" title="Adaptee"></a><strong>Adaptee</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们正在适应特定目标的对象（例如，老式的USB-A端口）。</p><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a><strong>Adapter</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个包装原始对象并产生由某些目标接口指定的新要求的对象（这完成了实际工作，也就是上面的小软件狗）。</p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们要与（我们的 <code>USB-C</code> 插座）适配器一起使用的对象。</p><br><h1 id="如何在Swift中使用适配器模式？"><a href="#如何在Swift中使用适配器模式？" class="headerlink" title="如何在Swift中使用适配器模式？"></a><strong>如何在Swift中使用适配器模式？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要在代码中集成第三方库，则可以使用适配器，但是其接口与你的要求不匹配。 例如，你可以围绕整个 <code>SDK</code>或后端 <code>API</code> 端点创建包装器，以创建一个公分母。 👽</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我的示例中，我将使用适配器类包装 <code>EKEvent</code> 对象，以实现全新的协议。 📆</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> EventKit</span><br><span class="line"></span><br><span class="line"><span class="comment">// our target protocol</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> startDate: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> endDate: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adapter (wrapper class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> dateFormatter: <span class="type">DateFormatter</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        dateFormatter.dateFormat = <span class="string">"yyyy. MM. dd. HH:mm"</span></span><br><span class="line">        <span class="keyword">return</span> dateFormatter</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> event: <span class="type">EKEvent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(event: <span class="type">EKEvent</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.event = event</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// actual adapter implementation</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">EventAdapter</span>: <span class="title">Event</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.event.title</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> startDate: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dateFormatter.string(from: event.startDate)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> endDate: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dateFormatter.string(from: event.endDate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let's create an EKEvent adaptee instance</span></span><br><span class="line"><span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()</span><br><span class="line">dateFormatter.dateFormat = <span class="string">"MM/dd/yyyy HH:mm"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> calendarEvent = <span class="type">EKEvent</span>(eventStore: <span class="type">EKEventStore</span>())</span><br><span class="line">calendarEvent.title = <span class="string">"Adapter tutorial deadline"</span></span><br><span class="line">calendarEvent.startDate = dateFormatter.date(from: <span class="string">"07/30/2018 10:00"</span>)</span><br><span class="line">calendarEvent.endDate = dateFormatter.date(from: <span class="string">"07/30/2018 11:00"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// now we can use the adapter class as an Event protocol, instead of an EKEvent</span></span><br><span class="line"><span class="keyword">let</span> adapter = <span class="type">EventAdapter</span>(event: calendarEvent)</span><br><span class="line"><span class="comment">// adapter.title</span></span><br><span class="line"><span class="comment">// adapter.startDate</span></span><br><span class="line"><span class="comment">// adapter.endDate</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个用例是当你必须使用几个现有的最终类或结构，但它们缺少某些功能，并且你想在它们之上构建一个新的目标接口时。 有时，实现包装程序来处理这种混乱情况是一个不错的选择。 🤷‍♂️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是适配器设计模式的全部内容。 通常，用 <code>Swift</code> 或任何其他编程语言实现它确实很容易，但是它非常有用，有时是不可避免的。 孩子们，请记住：不要在加密狗上太用力！😉</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过使用真实示例和 &lt;code&gt;Swift&lt;/code&gt; 中的适配器设计模式，将不兼容的对象转换为目标接口或类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在设计模式中，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;适配器模式&quot;&gt;适配器模式&lt;/a&gt;（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="适配器设计模式" scheme="http://www.xuebaonline.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift关于Dependency Injection (DI)</title>
    <link href="http://www.xuebaonline.com/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/"/>
    <id>http://www.xuebaonline.com/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/</id>
    <published>2020-04-25T09:13:51.000Z</published>
    <updated>2020-04-25T10:39:44.036Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 为我们许多人打开了函数式编程的世界。 但这仍然是面向对象的语言，而不是功能的语言。 我们的主要工具 <code>Cocoa frameworks</code> 是面向对象的。 因此，我们自己可能仍然会继续编写面向对象的代码。 这样做的问题是实际上很难编写设计良好的面向对象的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有很多不同的设计原则，例如 <code>SOLID</code> ，<code>KISS</code> ，<code>DRY</code> 等（ <code>YAGNI</code> ， <code>RAP</code> ，<code>CQS</code> ），甚至更多的设计模式。 至少对于我来说，有这么多不同的原理和模式这一事实意味着，即使有可能，良好的面向对象设计也很难。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖注入本身不是我刚才提到的 <code>SOLID</code> 原则的一部分。 但这与他们所有人息息相关。 不幸的是，依赖注入的概念被许多误解所包围。</p><a id="more"></a><blockquote><p>维基百科为我们提供了非常复杂的定义：<br>“在软件工程中，依赖性注入是一种软件设计模式，可实现控制反转以解决依赖性。”  - <code>Wikipedia</code></p></blockquote><blockquote><p>还有几句话……相反，一些开发人员说依赖注入只是传递一个实例变量。<br>“依赖注入实际上只是传递一个实例变量。”  - <code>James Shore</code></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他人则认为这是某种奇巧淫技，需要使用复杂而缓慢的框架，或者它仅与测试有关，只会使代码更难以理解。 我会说所有这些都是对依赖注入的误解。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将尽我所能使其更加清晰，并展示我对依赖注入的了解。 我将尝试展示如何进行依赖注入。 不仅如此，我们不应该这样做。</p></br><h1 id="为什么要依赖注射？"><a href="#为什么要依赖注射？" class="headerlink" title="为什么要依赖注射？"></a><strong>为什么要依赖注射？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，让我们看看依赖注入首先要解决的问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编程中，我们总是必须处理不同种类和级别的抽象。他们无处不在。接口，方法，闭包，甚至是具体的类型和变量名称-它们都是抽象的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了实现良好的代码设计，使用适当的抽象非常重要，因为它们会使我们的代码松散耦合。这意味着我们代码的不同组件可以替换为其他实现，而不会影响其他组件。当我们的代码松散耦合时，它变得更容易测试，更容易扩展，更容易重用，更容易并行开发。所有这些使维护变得更容易。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;松耦合代码是依赖注入的主要目标。它使我们能够编写松耦合的代码。因此，它使测试，扩展和重用代码变得更加容易。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多时候，仅在单元测试中讨论依赖注入。实际上，它极大地提高了可测试性，尤其是在 <code>Swift</code> 中。但是实际情况要广泛得多。如果我们的最终目标不仅是对某些类进行单元测试，还需要松散的耦合并使代码可维护，那么我们将需要付出更多的努力，而不仅仅是传递实例变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管从本质上讲，依赖注入实际上是关于传递实例变量，或者说将依赖传递给它们的使用者更好。这是第一步，也是每个第一步中最重要的一步。但这只是一个故事的一部分。还有第二步，甚至第三步。这些步骤使仅传递变量和依赖注入之间有所不同。</p></br><h1 id="依赖注射模式"><a href="#依赖注射模式" class="headerlink" title="依赖注射模式"></a><strong>依赖注射模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们从第一步开始。 有几种模式可以将依赖关系传递给消费者：</p><ul><li>构造函数注入</li><li>属性注入</li><li>方法注入</li><li>环境语境</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看看来自 <code>Cocoa frameworks</code> 的示例的使用。</p></br><h1 id="CONSTRUCTOR注入"><a href="#CONSTRUCTOR注入" class="headerlink" title="CONSTRUCTOR注入"></a><strong>CONSTRUCTOR注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是从 <strong><code>CoreData</code></strong> 注入构造函数的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NSPersistentStore</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(</span><br><span class="line">        persistentStoreCoordinator root: <span class="type">NSPersistentStoreCoordinator?</span>, </span><br><span class="line">        configurationName name: <span class="type">String?</span>, </span><br><span class="line">        <span class="type">URL</span> url: <span class="type">NSURL</span>, </span><br><span class="line">        options: [<span class="type">NSObject</span>: <span class="type">AnyObject</span>]?</span><br><span class="line">    )</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> persistentStoreCoordinator: <span class="type">NSPersistentStoreCoordinator?</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，持久性存储协调器的实例与其他一些参数一起传递给 <code>NSPersistentStore</code> 的构造函数。 然后，对协调器的引用将被存储，并且在运行时无法更改。</p><blockquote><p>通过构造函数注入，我们将依赖项作为构造函数参数传递并将其存储在只读属性中。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管在 <code>Cocoa frameworks</code> 中没有太多构造函数注入的示例，但这是注入依赖关系的首选方法。 因为它是最容易实现的，所以可以确保始终存在依赖项，并且在运行时不会更改依赖项，这使它更加安全。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在某些情况下，构造函数注入是不可能的或不合适的。 在这些情况下，我们应该使用属性注入。</p></br><h1 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a><strong>属性注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何 <code>iOS</code> 应用程序中到处都有这种模式。 例如，委托模式通常使用属性注入来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">public</span> <span class="keyword">var</span> transitioningDelegate: <span class="type">UIViewControllerTransitioningDelegate?</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，这里的视图控制器公开了用于转换委托的可写属性，如果要覆盖 <code>dafault</code> 行为，我们可以随时更改它。</p><blockquote><p>使用属性注入，消费者通过可写属性获得其依赖关系，该属性也具有一些默认值。</p></blockquote></br><h1 id="本地和外部默认设置"><a href="#本地和外部默认设置" class="headerlink" title="本地和外部默认设置"></a><strong>本地和外部默认设置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果存在良好的本地默认依赖关系，则应使用属性注入。 “本地”表示在同一模块中定义。 nil也是理想的本地默认值，它只是使依赖项成为可选项。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当实现来自单独的模块时，它是外来的。然后，我们不应将其用作默认值。而且我们不应该将属性注入用于这种依赖性。相反，我们应该使用构造函数注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象一下，传递委托的默认实现不是在 <code>UIKit</code> 中定义的，而是在其他框架中定义的。然后，即使我们从不使用此 <code>API</code> ，也始终需要链接到该框架。 <code>UIKit</code> 与该框架紧密结合。它拖延了这种无用的依赖性。我们自己的代码也会发生同样的情况，这将使重用变得更加困难。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与构造函数注入属性注入进行比较可能更容易理解，并且使我们的 <code>API</code> 看起来更灵活。但是与此同时，它可能更难以实现，并使我们的代码更脆弱。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要适当的默认实现或以适当的方式处理可选值，这可能会导致带有可选包装的可选代码混乱。其次，我们不能将属性定义为不可变的。因此，如果我们不想在设置后就对其进行更改，则需要确保在运行时而不是在编译时进行更改。另外，我们可能需要同步对其进行访问，以防止出现线程问题。由于这些原因，如果我们可以使用构造函数注入，那么我们应该首选属性注入。</p></br><h1 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a><strong>方法注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一个模式，方法注入，就像将参数传递给方法一样简单。 例如，这里是 <code>NSCoding</code> 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">NSCoding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encodeWithCoder</span><span class="params">(aCoder: NSCoder)</span></span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次将该方法称为不同的实例，甚至可以将 <code>NSCoder</code> 的实现作为参数传递。</p><blockquote><p>使用方法注入依赖关系作为参数传递给方法。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当依赖关系随每个方法调用而变化时，或者当依赖关系是暂时的并且不需要在方法范围之外保持对它的引用时，通常使用方法注入。</p><h1 id="AMBIENT-CONTEXT"><a href="#AMBIENT-CONTEXT" class="headerlink" title="AMBIENT CONTEXT"></a><strong>AMBIENT CONTEXT</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一种模式-环境上下文-在 <code>Cocoa</code> 中很难找到。 <code>NSURLCache</code> 可能是最接近的示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NSURLCache</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">setSharedURLCache</span>(<span class="title">cache</span>: <span class="title">NSURLCache</span>)</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">class</span> <span class="title">func</span> <span class="title">sharedURLCache</span>() -&gt; <span class="title">NSURLCache</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在这里我们可以将 <code>NSURLCach</code> 的任何子类设置为共享实例，然后使用静态 <code>getter</code> 访问它。 这是它与不可写的单例的主要区别。</p><blockquote><p>使用静态方法或具有某些默认值的静态可写属性来实现AMBIENT CONTEXT。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此模式仅应用于表示一些跨领域关注点的真正通用依赖项，例如日志记录，无性，访问时间和日期等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>AMBIENT CONTEXT</code> 有其自身的优势。 它使依赖关系始终可访问，并且不会污染 <code>API</code>。 非常适合跨领域的关注。 但是在其他情况下，它并不能证明其缺点。 它使依赖关系隐式化，并表示可能不是您想要的全局可变状态。</p><p>因此，如果依赖性不是真正通用的，那么我们应该考虑使用其他DI模式。</p><h1 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a><strong><em>关注点分离</em></strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会注意到，所有这些模式都非常简单，它们共享一个共同的原则-关注点分离。我们从依赖的使用者中消除了几项责任：使用什么具体实现，如何配置它以及如何管理其生命周期。这使我们可以轻松地在不同的上下文或测试中替换依赖关系，更改其生存期策略，例如使用共享或单独的实例，或更改依赖关系的构造方式。所有这些都无需改变其消费者。这使消费者不再依赖于它们，从而使它们更易于重用，扩展，开发和测试。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些模式的明显副作用是，现在我们代码的每个用户都需要提供其定义。但是他们如何得到它们？如果他们直接创建它们，那么它们将与那些依赖关系紧密地联系在一起。因此，我们只是将问题移到另一个地方。这个问题将我们带到了所谓的“合成根”（Compound Root）问题上。</p></br><h1 id="COMPOSITION-ROOT"><a href="#COMPOSITION-ROOT" class="headerlink" title="COMPOSITION ROOT"></a><strong>COMPOSITION ROOT</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>COMPOSITION ROOT</code> 是将应用程序不同层的组件连接在一起的地方。 拥有复合根的主要目的是将配置逻辑与我们其余的代码分开，并以通用的方式在定义明确的位置进行配置。 拥有一段代码，单个职责就是配置其他组件。 创建依赖关系并将其注入到构造函数或属性中只能在“合成根目录”中完成。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/di-stp1.png" alt="COMPOSITION ROOT"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 理想情况下，应用程序中应该有一个<code>COMPOSITION ROOT</code>，并且它应该靠近应用程序入口点。 就像这张图一样。 但是不必使用单个方法或类来实现。 它可以包含所需的多个类和方法，直到它们在同一组件层中在一起为止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是VIPER示例应用程序中 <code>COMPOSITION ROOT</code> 的示例实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDependencies</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        configureDependencies()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">configureDependencies</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Root Level Classes</span></span><br><span class="line">        <span class="keyword">let</span> coreDataStore = <span class="type">CoreDataStore</span>()</span><br><span class="line">        <span class="keyword">let</span> clock = <span class="type">DeviceClock</span>()</span><br><span class="line">        <span class="keyword">let</span> rootWireframe = <span class="type">RootWireframe</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// List Module Classes</span></span><br><span class="line">        <span class="keyword">let</span> listPresenter = <span class="type">ListPresenter</span>()</span><br><span class="line">        <span class="keyword">let</span> listDataManager = <span class="type">ListDataManager</span>()</span><br><span class="line">        <span class="keyword">let</span> listInteractor = <span class="type">ListInteractor</span>(dataManager: listDataManager, clock: clock)</span><br><span class="line">        ...    </span><br><span class="line">        listInteractor.output = listPresenter</span><br><span class="line">        listPresenter.listInteractor = listInteractor</span><br><span class="line">        listPresenter.listWireframe = listWireframe</span><br><span class="line">        listWireframe.addWireframe = addWireframe</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们有一些根类，仅管理窗口根视图控制器的根线框以及一些待办事项列表的单独组件，例如演示者，交互器，线框。 然后，我们将它们全部连接在一起。 它全部在一类中实现。 我们使用此类的唯一地方是应用程序委托：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> appDependencies = <span class="type">AppDependencies</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        application: UIApplication, </span></span></span><br><span class="line"><span class="function"><span class="params">        didFinishLaunchingWithOptions launchOptions: [NSObject : AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        appDependencies.installRootViewControllerIntoWindow(window!)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们首先创建依赖项类，它将配置所有组件并将它们连接在一起。 然后，我们只调用一个在窗口中设置根视图控制器的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，将通过一个调用在此处创建整个对象图，并且稍后将在运行时创建的唯一对象是视图控制器和视图。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，关于DI的文章或讨论中通常不会讨论不幸的成分根。 但这可能是依赖注入的最重要部分之一。 如果我们能够做到这一点，我们已经走了很长一段路。</p><blockquote><p>正确实现DI的最大挑战是将所有具有依赖项的类移至Composition Root。 - Mark Seeman</p></blockquote><h1 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a><strong>反模式</strong></h1><p>但是，由于在尝试正确实现某些模式时经常会发生这种情况，因此我们很容易以反模式结束。 因此，现在让我们进入黑暗的一面，看看什么是常见的DI反模式。</p><h1 id="控制怪胎"><a href="#控制怪胎" class="headerlink" title="控制怪胎"></a><strong>控制怪胎</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个是控制狂。 那就是当我们根本不使用DI的时候。 依赖项的使用者何时控制创建依赖项的方式和时间。 每当使用者在 <code>Composition Root</code> 之外的任何地方使用构造函数直接或间接获得依赖项时，都会发生这种情况。 例如，在其自己的构造函数中或仅在需要时使用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repository: <span class="type">RecipesRepository</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.repository = <span class="type">CoreDataRecipesRepository</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这是否意味着根本不允许我们使用构造函数？ 当然不是。 这取决于我们构建的依赖类型。</p><h1 id="稳定和波动的依赖"><a href="#稳定和波动的依赖" class="headerlink" title="稳定和波动的依赖"></a><strong>稳定和波动的依赖</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它们有两种-稳定的和易变的。当涉及到稳定的依赖关系时，我们不必担心直接在其使用者内部构造它们。但是我们应该避免对不稳定的依赖项这样做。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是易失性依赖项？需要某种特定环境设置（例如数据库或网络访问）的任何依赖项。实现不确定性行为的依赖项是易变的，例如，如果它们使用随机数，依赖于时间或实现加密，则它们是易变的。当我们期望依赖项将被替换或者由于它是并行开发而尚未准备就绪时，它也是易变的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易失性依赖项的症状是它们禁用了一些宽松的耦合好处。如果依赖关系不允许我们并行测试，扩展，重用或开发我们的代码，则应将其视为易变的。否则，它是一个稳定的依赖项。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，首先，我们需要了解依赖项是易失性还是​​稳定的，并在其易失性时使用“依赖项注入”模式注入它。</p><h1 id="Bastard-注入"><a href="#Bastard-注入" class="headerlink" title="Bastard 注入"></a><strong>Bastard 注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一个反模式称为 <code>Bastard</code> 注入。 当我们有让我们为测试提供依赖关系的构造函数以及在生产中使用默认实现的另一个构造函数时，就会发生这种情况。 在 <code>Swift</code> 中，我们可以使用以下示例中的默认参数轻松地做到这一点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repository: <span class="type">RecipesRepository</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(repository: <span class="type">RecipesRepository</span> = <span class="type">CoreDataRecipesRepository</span>()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.repository = repository</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从某一方面来看，这种模式提高了可测试性。 这种反模式的问题是使用默认的外部默认值-在其他模块中定义。 这使我们的代码可测试，但与另一个模块紧密耦合。 如果默认实现是本地的，则此反模式的影响会小得多。 也许最好将其重构为属性注入。 但是，当默认实现是外部实现时，我们应该使用构造函数注入，并且不要为此参数提供默认值。 相反，我们应该在 <code>“Composition Root”</code> 中提供它。 这样我们就不会失去任何灵活性，而是避免与另一个模块紧密耦合。</p><h1 id="服务定位器"><a href="#服务定位器" class="headerlink" title="服务定位器"></a><strong>服务定位器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要讨论的最后一个反模式是服务定位器。 服务定位器是某些服务的通用名称，我们可以查询以前在其中注册的不同对象。 这是最棘手的反模式，因为它可以使我们感到一切都很好。 许多开发人员甚至根本不认为它是反模式。 但是 <code>Service Locator</code> 实际上与依赖注入相反。</p><p>让我们看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locator = <span class="type">ServiceLocator</span>.sharedInstance</span><br><span class="line"></span><br><span class="line">locator.register( &#123; <span class="type">CoreDataRecipesRepository</span>() &#125;, </span><br><span class="line">                    forType: <span class="type">RecipesRepository</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repository: <span class="type">RecipesRepository</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> locator = <span class="type">ServiceLocator</span>.sharedInstance</span><br><span class="line">        <span class="keyword">self</span>.repository = locator.resolve(<span class="type">RecipesRepository</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此示例中，我们提供了一些可以使用静态属性访问的服务。然后，对于我们的依赖关系类型，我们注册一个产生一些具体实例的工厂。然后，我们在需要时向此服务询问我们的依赖关系，而不是使用构造函数或属性注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;似乎 <code>Service Locator</code> 提供了依赖注入的所有好处。它提高了可扩展性和可测试性，因为我们可以注册依赖的另​​一种实现而无需更改其使用者。它将配置与使用分开，还支持并行开发。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是它没有几个主要缺点。它使依赖项隐式而不是显式，从而隐藏了真实类的复杂性。为了能够使用此类，我们现在需要了解其内部详细信息。我们没有看到它的依赖关系，只会在运行时或通过检查其实现或文档来找到它们的依赖关系。借助服务定位器，我们的代码也与之紧密结合。这完全破坏了可重用性，并使代码的可维护性降低。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于这些原因，我倾向于认为 <code>Service Locator</code> 是一种反模式。而不是使用它，我们应该显式定义依赖项，使用 <code>DI</code> 模式注入它们，并使用 <code>Composition Root</code> 将它们连接在一起。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们总结一下到那时为止我们已经讨论过的内容。我们讨论了依赖注入用于实现松散耦合，这使我们的代码更易于维护。我们讨论了不同的 <code>DI</code> 模式，其中应该优先选择构造函数注入。我们讨论了什么是本地和外部依赖关系以及什么是稳定和易失性依赖关系。我们还讨论了应避免的常见 <code>DI</code> 反模式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这一点上，我们使用 <code>DI</code> 模式将依赖关系明确化，并将所有配置移到了 <code>Composition Root</code> 中，这已经是我们实现目标的一大步-松散耦合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们的代码还没有完全耦合。下一步是使用抽象对依赖关系进行建模。让我们记住 <code>SOLID</code> 原则之一。</p></br><h1 id="依赖反转原理（DIP）"><a href="#依赖反转原理（DIP）" class="headerlink" title="依赖反转原理（DIP）"></a><strong>依赖反转原理（DIP）</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖反转原则说，高级代码不应依赖于低级代码，它们都应依赖于抽象，而抽象不应依赖于细节。关键是该类及其依赖项应处于相同的抽象级别。如果我们有一些服务，它不应该依赖于具体的API存储库或数据库存储库，因为它们属于较低层。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，我们不应依赖通过 <code>Alamofire</code> 实现的 <code>API</code> 存储库或通过 <code>CoreData</code> 或 <code>Realm</code> 实现的数据库存储库。因为这将使我们的代码与特定的实现紧密结合。相反，我们应该依靠更高级别的抽象。服务和存储库都应依赖于该抽象。因此，较高和较低级别之间的依赖性方向是相反的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们应该遵循这一原则来松散耦合代码。依赖注入不仅是我们之前讨论的模式。它要求同时应用模式和依赖倒置原则。没有这些，我们将无法获得松耦合的所有好处。</p><blockquote><p><strong><em>DI = DI patterns + DIP</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常说，松散耦合是通过针对接口而不是针对实现进行编程来实现的。</p><blockquote><p><strong><em>编程到接口而不是实现（设计模式：可重用的面向对象软件的元素</em></strong>）</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是依赖倒置原则说它不是关于接口，而是关于抽象。 松耦合并不意味着到处都有接口或协议。 因为并非总是接口是好的和可重用的抽象。</p><blockquote><p><strong><em>编程为 <del>接口</del> 抽象</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口（或协议）只是一种我们可以用来对抽象进行建模的语言构造。 这是我们的代码与之通信的一种方式。 但这并不能保证良好和可重用的抽象，这是松散耦合的关键。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基类有时可以和协议一样好的抽象。 当然，大多数时候我们可能会使用协议对抽象进行建模。 但是在各处引入协议时要小心。 它可能是不需要的独立级别。 在Swift协议中，有时会比较麻烦。</p><blockquote><p><strong><em>Interfaces are not abstractions - Mark Seeman</em></strong> </p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/di-stp2.png" alt="Interfaces&amp;&amp;abstractions"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你在构造函数中传递依赖项或使用属性或方法注入时-您应将其作为抽象传递（同样，不必使用协议）。 如果使用 <code>ambinet</code>上下文，则相同。 它不仅是一些共享的静态实例，还应该是抽象的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，依赖注入和松散耦合不仅可以通过依赖注入模式来实现，而且可以通过依赖反转原理以及使用抽象对依赖关系进行建模来实现。</p></br><h1 id="控制和DI容器的反转"><a href="#控制和DI容器的反转" class="headerlink" title="控制和DI容器的反转"></a><strong>控制和DI容器的反转</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，使用另一种设计原则，我们还可以采取进一步的措施。该原理称为控制反转。通常将其视为框架的定义特征。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用库时，流程是“正常的”，我们从代码中调用库。但是在框架的情况下，它是倒置的-框架使用不同的回调方法调用我们的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并且我们可以将这一原理应用于使用特殊框架来管理依赖项。通常，这些框架称为依赖注入容器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有许多不同的容器可用。实际上，大多数人可能甚至不知道使用了一个DI容器。它是 <code>Interface Builder</code> 。在 <code>Interface Builder</code> 中，我们可以通过接口或基类使用 <code>@IBOutlet</code> 拖放任何 <code>NSObject</code> 并对其进行引用。与视图控制器相同。我们可以将情节提要和 <code>Xibs</code> 视为视图控制器的工厂。 <code>Interface Builder</code>是 <code>XML</code> 配置样式的示例。当然，它不是功能齐全的 <code>DI</code> 容器，也不是其主要目标，但仍然可以用于该目的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你访问 <code>CocoaPods</code> 并搜索“依赖注入”，则会发现很多不同的开源 <code>DI</code> 容器。也许甚至太多了。但是你会注意到，其中只有少数成功和流行。让我们简短地看一下其中的两个-一个来自 <code>Objective-C</code> ，另一个来自 <code>Swift</code> 。</p></br><h1 id="TYPHOON"><a href="#TYPHOON" class="headerlink" title="TYPHOON"></a><strong>TYPHOON</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个是 <strong><em><a href="http://typhoonframework.org" target="_blank" rel="noopener"><code>Typhoon</code></a></em></strong> ，它可能是 <code>Cocoa</code> 开发者中最受欢迎的DI容器。 它具有相对简单且文档齐全的 <code>API</code> ，具有许多强大的功能。 它得到了良好的维护和支持，并且仍将继续改进。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就 <code>API</code> <code>Typhoon</code> 而言，构件是称为程序集的对象。 这是此类装配接口的示例。 它看起来像一个简单的工厂。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIClientAssembly</span>: <span class="title">TyphoonAssembly</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">apiClient</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在实现中，不是返回某种类型的具体实例（如从工厂方法中返回），而是返回 <code>TyphoonDefinition</code> ，它描述了在请求实例时应如何创建该实例。 应该使用什么初始化以及使用什么参数，应该注入什么属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">apiClient</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">TyphoonDefinition</span>.withClass(<span class="type">APIClientImp</span>.<span class="keyword">self</span>) &#123; definition <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        definition.useInitializer(#selector(<span class="type">APIClientImp</span>.<span class="keyword">init</span>(session:))) &#123;</span><br><span class="line">            initializer <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            initializer.injectParameterWith(<span class="keyword">self</span>.session())</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        definition.injectProperty(<span class="string">"logger"</span>, with: <span class="keyword">self</span>.logger())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们定义 <code>API Client</code> 将使用 <code>init（session :)</code> 构造函数创建，并且其 <code>session</code> 参数将由同一程序集提供。 我们还定义了将由同样的程序集提供的 <code>logger</code> 实例注入 <code>logger</code> 属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以为组件定义不同的范围或生命周期策略。 例如，对于 <code>Singleton</code> 范围， <code>Typhoon</code> 将仅创建一个 <code>logger</code> 实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">TyphoonDefinition</span>.withClass(<span class="type">NSURLSession</span>.<span class="keyword">self</span>) &#123; definition <span class="keyword">in</span></span><br><span class="line">        definition.useInitializer(#selector(<span class="type">NSURLSession</span>.sharedSession))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">TyphoonDefinition</span>.withClass(<span class="type">ConsoleLogger</span>.<span class="keyword">self</span>) &#123; definition <span class="keyword">in</span></span><br><span class="line">        definition.scope = .<span class="type">Singleton</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要从程序集中获取某种类型的实例，我们首先将其激活，然后仅调用其接口方法。 激活后，组装方法将不返回 <code>TyphoonDefinitions</code> ，而是返回根据我们提供的规则创建的实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> assembly = <span class="type">APIClientAssembly</span>().activate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apiClient = assembly.apiClient() <span class="keyword">as</span>! <span class="type">APIClient</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使这项工作有效， <code>Typhoon</code> 大量使用了 <code>Objective-C</code> 运行时。 <code>在使用Objective-C</code> 运行时的 <code>Swift</code> 应用程序中看起来并不正确。 我们仍然可以在 <code>Swift</code> 以及 <code>Objective-C</code> 中使用 <code>Typhoon</code> 。 但是，我们将面临一些问题：</p><ul><li>需要子类 <code>NSObject</code> 并使用 <code>@objc</code> 定义协议</li><li>注射过程中调用的方法应该是动态的</li><li>需要类型转换</li><li>并非所有功能都可以在 <code>Swift</code> 中使用</li><li><code>Swift</code> 的 <code>API</code> 太冗长</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Typhoon</code> 团队最近宣布，他们开始着手于纯粹的 <code>Swift</code> 实施，而我迫不及待地想看看他们会提出什么建议。 但是现在我不会在纯 <code>Swift</code> 代码库中以当前状态使用 <code>Typhoon</code> 。 尤其是当本机解决方案已经很少时。</p><h1 id="DIP"><a href="#DIP" class="headerlink" title="DIP"></a><strong>DIP</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em><a href="https://github.com/AliSoftware/Dip" target="_blank" rel="noopener"><code>Dip</code></a></em></strong> 是其中之一。 它仅在 <code>Swift</code> 中工作，根本不需要 <code>Objective-C</code> 运行时。 实际上，它甚至没有对 <code>Foundation</code> 的引用，因此我们可以在可以使用 <code>Swift</code> 的任何平台上使用它。 它也是类型安全的，与 <code>Typhoon</code> 相比实现起来并不复杂。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 就 <code>API</code> 而言，它采用的方法对于其他平台上的 <code>DI</code> 容器而言更为传统，并遵循“注册解析”模式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们用于 <code>Typhoon</code> 的相同示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="type">DependencyContainer</span>()</span><br><span class="line"></span><br><span class="line">container.register &#123; </span><br><span class="line">    <span class="keyword">try</span> <span class="type">APIClientImp</span>(session: container.resolve()) <span class="keyword">as</span> <span class="type">APIClient</span> </span><br><span class="line">&#125;</span><br><span class="line">.resolveDependencies &#123; container, client <span class="keyword">in</span></span><br><span class="line">    client.logger = <span class="keyword">try</span> container.resolve()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.register &#123; <span class="type">NSURLSession</span>.sharedSession() <span class="keyword">as</span> <span class="type">NetworkSession</span> &#125;</span><br><span class="line">container.register(.<span class="type">Singleton</span>) &#123; <span class="type">ConsoleLogger</span>() <span class="keyword">as</span> <span class="type">Logger</span> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们将 <code>APIClientImp</code> 注册为 <code>APIClient</code> 协议的实现。 容器还将解析构造器参数，并且在创建实例时将设置 <code>logger</code> 属性。 对于会话参数容器，它将使用共享的 <code>URL</code> 会话，对于记录器，它将创建一个单例实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，当我们需要获取 <code>APIClient</code> 的实例时，我们只需调用容器的 <code>resolve</code> 方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apiClient = <span class="keyword">try</span>! container.resolve() <span class="keyword">as</span> <span class="type">APIClient</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会注意到，该 <code>API</code> 与我们在 <code>Service Locator</code> 中看到的几乎相同。 但这与 <code>API</code> 或实现无关，而与我们如何使用它有关。 如果您不想将容器用作服务定位器，请记住，只能在 <code>“Composition Root”</code> 中调用它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Dip</code> 还提供了一些很酷的功能，例如自动接线。 例如，我们可以定义要自动注入的 <code>logger</code> 属性。 容器将首先创建 <code>APIClient</code> 实例，然后使用其镜像查找 <code>logger</code> 属性并将真实实例注入其中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIClientImp</span>: <span class="title">APIClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _logger = <span class="type">Injected</span>&lt;<span class="type">Logger</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> logger: <span class="type">Logger?</span> &#123; <span class="keyword">return</span> _logger.value &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，当我们使用其构造函数注册 <code>APIClient</code> 而不是调用 <code>resolve</code> 获取 <code>NetworkSession</code> 参数时，我们只是说我们要使用传递给工厂闭包的第一个参数。 然后容器将推断出它的类型并为我们解决。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIClientImp</span>: <span class="title">APIClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">NetworkSession</span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.register &#123; <span class="type">APIClientImp</span>(session: $<span class="number">0</span>) <span class="keyword">as</span> <span class="type">APIClient</span> &#125;</span><br></pre></td></tr></table></figure><p>这样可以大大简化配置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们比较 <code>“Typhoon”</code> 和 <code>“Dip”</code> 的基本特征，我们会注意到它们共享大多数特征。 尽管它没有像 <code>Objective-C</code> 一样强大的运行时功能，但是在 <code>Swift</code> 中几乎可以实现相同的功能似乎令人惊讶。 但是，泛型和类型推断实际上是其中的重点。</p><table><thead><tr><th align="left"></th><th align="center">Typhoon</th><th align="right">Dip</th></tr></thead><tbody><tr><td align="left"><strong>Constructor, property, method injection</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Lifecycle management</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Circular dependencies</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Runtime arguments</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Named definitions</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Storyboards integration</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Auto-wiring</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Thread safety</strong></td><td align="center">✘</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Interception</strong></td><td align="center">✔︎</td><td align="right">✘</td></tr><tr><td align="left"><strong>Infrastructure</strong></td><td align="center">✔︎</td><td align="right">✘</td></tr></tbody></table></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会问，当我自己可以做时，为什么需要使用 <code>Typhoon</code> 或 <code>Dip</code> 或任何其他 <code>DI</code> 容器。 我可以建议的理由很少。 它们提供了与情节提要板的轻松集成，可以为您管理有时可能很棘手的组件生命周期，可以简化某些配置， <code>Typhoon</code> 还使用 <code>NSProxy</code> 和其他一些附加功能提供了轻松的拦截功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是请记住， <code>DI</code> 容器是可选的，并且依赖注入与使用 <code>DI</code> 容器不同。</p><blockquote><p><strong><em>DI ≠ DI Container</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在新项目中，我们可以根据需要从它开始，但是在旧代码库中，我们应该首先使用依赖注入模式，组合根和依赖反转原理对其进行重构，然后查看是否需要DI容器（在大多数情况下，回答将为“否”）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您具有复杂的配置，并且发现自己实现了一些类似 <code>DI</code> 容器的方法来简化它们，或者需要它提供的一些其他功能，那么可能会受益于使用现有的实现。但是，如果您对自己的工厂还可以的话-它的工厂很棒，请继续使用它们。不要仅仅为了使用 <code>DI</code> 容器而使用它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DI</code> 本身也是如此。对于在何处应用它以及需要解耦系统的哪些部分，要保持理性。不要尝试解决你尚未遇到的问题。也许你永远不会拥有它们，或者当你真正面对它们时，现在解决它们的方式将不合适。最后， <code>DI</code> 只是达到目的的一种手段，就像我们使用的任何其他模式或技术一样。它本身不是目标。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我想提到一些有用的资源，你可以在其中找到有关DI和一些相关主题的更多信息。</p></br><ul><li><a href="https://www.manning.com/books/dependency-injection-in-dot-net" target="_blank" rel="noopener"><code>“Dependency Injection in .Net” by Mark Seeman</code></a></li><li><a href="https://ilya.puchka.me/dependency-injection-in-swift/" target="_blank" rel="noopener"><code>Mark Seeman’s blog</code></a></li><li><a href="https://www.objc.io/issues/15-testing/dependency-injection/" target="_blank" rel="noopener"><code>objc.io Issue 15: Testing. Dependency Injection, by Jon Reid</code></a></li><li><a href="https://martinfowler.com/articles/dipInTheWild.html" target="_blank" rel="noopener"><code>“DIP in the wild”</code></a></li><li><a href="http://www.loosecouplings.com/2011/02/non-di-code-spaghetti-code.html" target="_blank" rel="noopener"><code>Non-DI code == spaghetti code?</code></a></li></ul><hr><hr><ul><li><p><a href="https://www.manning.com/books/dependency-injection-in-dot-net" target="_blank" rel="noopener"><code>&quot;Dependency Injection in .Net&quot; Mark Seeman</code></a> ↩︎</p></li><li><p><a href="https://github.com/mutualmobile/VIPER-SWIFT/blob/master/VIPER-SWIFT/Classes/AppDependencies.swift" target="_blank" rel="noopener"><code>https://github.com/mutualmobile/VIPER-SWIFT/blob/master/VIPER-SWIFT/Classes/AppDependencies.swift</code></a> ↩︎</p></li><li><p><a href="http://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/" target="_blank" rel="noopener"><code>http://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/</code></a> ↩︎</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Swift&lt;/code&gt; 为我们许多人打开了函数式编程的世界。 但这仍然是面向对象的语言，而不是功能的语言。 我们的主要工具 &lt;code&gt;Cocoa frameworks&lt;/code&gt; 是面向对象的。 因此，我们自己可能仍然会继续编写面向对象的代码。 这样做的问题是实际上很难编写设计良好的面向对象的代码。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有很多不同的设计原则，例如 &lt;code&gt;SOLID&lt;/code&gt; ，&lt;code&gt;KISS&lt;/code&gt; ，&lt;code&gt;DRY&lt;/code&gt; 等（ &lt;code&gt;YAGNI&lt;/code&gt; ， &lt;code&gt;RAP&lt;/code&gt; ，&lt;code&gt;CQS&lt;/code&gt; ），甚至更多的设计模式。 至少对于我来说，有这么多不同的原理和模式这一事实意味着，即使有可能，良好的面向对象设计也很难。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;依赖注入本身不是我刚才提到的 &lt;code&gt;SOLID&lt;/code&gt; 原则的一部分。 但这与他们所有人息息相关。 不幸的是，依赖注入的概念被许多误解所包围。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="依赖注入设计模式" scheme="http://www.xuebaonline.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Dependency Injection" scheme="http://www.xuebaonline.com/tags/Dependency-Injection/"/>
    
  </entry>
  
  <entry>
    <title>Swift依赖注入设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T08:52:06.000Z</published>
    <updated>2020-04-25T10:41:58.390Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用Swift学习依赖注入模式,使用DI编写松耦合代码。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我真的很喜欢James Shore的这句话：依赖注入意味着给对象一个实例变量，如此而已。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我看来，学习依赖注入要稍微复杂一点，但是如果你将问题弄清楚，你将意识到实现 <a href="http://www.xuebaonline.com/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/" title="DI模式">DI模式</a> 就像给对象实例变量一样简单。 别开玩笑，这确实是理所当然的，但是许多开发人员使它过于复杂，并在错误的位置使用了注入。 💉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习DI并不是关于实现细节，而是关于你将如何使用该模式。 依赖项注入有四个小变化，让我们通过使用真实的示例进行遍历，这些示例将帮助你了解何时使用依赖项注入。 现在抓住键盘！ 💻</p><a id="more"></a></br><h1 id="了解依赖注入-dependency-injection"><a href="#了解依赖注入-dependency-injection" class="headerlink" title="了解依赖注入(dependency injection)"></a><strong>了解依赖注入(dependency injection)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我之前提到的，DI是一个简单概念，你实际上并不需要外部库或框架来开始使用它。假设你有两个单独的对象。对象A要使用对象B。向你的第一个依赖发送一个消息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果将对象B硬编码为对象A，那将是不好的，因为从那时起，如果没有B，就无法使用A。现在将其扩展到约100个对象级别。如果你对此问题不采取任何措施，那么你会毫无头绪。 🍝</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，主要目标是创建尽可能多的独立对象，或者创建一些松散耦合的代码，以提高可重用性和可测试性。关注分离和去耦也是在这里使用，因为在大多数情况下，你应该从字面上将逻辑功能分离为独立的对象。 🤐</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，从理论上讲，两个对象都应该只做一件特定的事情，并且它们之间的依赖关系通常是通过通用描述符（协议）实现的，而无需对具体实例进行硬编码。为此，使用依赖注入可以提高代码质量，因为可以在不更改其他对象实现的情况下替换依赖。这对于模拟，测试，重用等很有用。</p></br><h1 id="如何在Swift中进行DI？"><a href="#如何在Swift中进行DI？" class="headerlink" title="如何在Swift中进行DI？"></a><strong>如何在Swift中进行DI？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 是一种了不起的编程语言，对协议和面向对象的原理都提供了出色的支持。 它也具有强大的功能，但是现在让我们忽略它。 依赖关系注入可以通过多种方式完成，但是在本教程中，我将只关注一些基本的，没有任何外部依赖关系注入的基础知识。 😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，让我们从一个协议开始，但这只是因为 <code>Swift</code> 不会向公众公开 <code>Encoder</code> ，但是我们在演示中需要类似的东西。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Encoder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span>&lt;T&gt;<span class="params">(<span class="number">_</span> value: T)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Encodable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">JSONEncoder</span>: <span class="title">Encoder</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PropertyListEncoder</span>: <span class="title">Encoder</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性列表和JSON编码器已经实现了此方法，我们只需要扩展对象以符合我们的全新协议即可。</p><h1 id="Custructor-注入"><a href="#Custructor-注入" class="headerlink" title="Custructor 注入"></a><strong>Custructor 注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖项注入的最常见形式是构造函数注入或基于初始化的注入。 主要的思路是通过初始化程序传递依赖关系，并将该对象存储在（私有只读/不可变）属性变量中。 这里的主要好处是，在对象创建之前，你的对象将具有所有依赖关系，以使其正常工作。 🔨</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> encoder: <span class="type">Encoder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> title</span><br><span class="line">        <span class="keyword">case</span> content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>, encoder: <span class="type">Encoder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">        <span class="keyword">self</span>.encoder = encoder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encoded</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Constructor injection"</span>, encoder: <span class="type">JSONEncoder</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encoded(), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以在构造函数中为编码器指定一个 <code>defult</code> 值，但是你应该担心恶意注入反模式！ 这意味着如果默认值来自另一个模块，则你的代码将与该模块紧密耦合。 所以请三思！ 🤔</p></br><h1 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a><strong>属性注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时很难进行初始化初始化注入，因为你的类必须从系统类继承。 如果你必须使用视图或控制器，这将使过程变得非常困难。 对于这种情况，一个好的解决方案是使用基于属性的注入设计模式。 也许你不能完全控制初始化，但是你始终可以控制属性。 唯一的缺点是，你必须先检查该属性是否已显示（已设置），然后再进行任何操作。 🤫</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> encoder: <span class="type">Encoder?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> title</span><br><span class="line">        <span class="keyword">case</span> content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encoded</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> encoder = <span class="keyword">self</span>.encoder <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Encoding is only supported with a valid encoder object."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Property injection"</span>)</span><br><span class="line">post.encoder = <span class="type">JSONEncoder</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encoded(), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>iOS</code> 框架中有很多属性注入模式，委托模式通常是这样实现的。 另外一个很大的好处是这些属性可以是可变的，因此你可以即时替换它们。 ✈️</p><h1 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a><strong>方法注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果只需要一次依赖关系，则实际上不需要将其存储为对象变量。 除了可以使用初始化参数或公开的可变属性，你还可以将依赖项作为方法参数传递，这种方法称为方法注入或基于参数的注入。 👍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(using encoder: Encoder)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Method injection"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encode(using: <span class="type">JSONEncoder</span>()), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次调用此方法时，你的依赖关系可能会有所不同，不需要从该依赖关系中保留引用，因此将仅在本地方法范围内使用它。</p></br><h1 id="上下文语境"><a href="#上下文语境" class="headerlink" title="上下文语境"></a><strong>上下文语境</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的最后一个模式非常危险。 它仅应用于与多个对象实例一起共享的通用依赖项。 日志，分析或缓存机制就是一个很好的例子。 🚧</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encoded</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">Post</span>.encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> _encoder: <span class="type">Encoder</span> = <span class="type">PropertyListEncoder</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setEncoder</span><span class="params">(<span class="number">_</span> encoder: Encoder)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._encoder = encoder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> encoder: <span class="type">Encoder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Post</span>._encoder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Ambient context"</span>)</span><br><span class="line"><span class="type">Post</span>.setEncoder(<span class="type">JSONEncoder</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encoded(), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上下文语境有一些缺点。 它可能很适合横切关注点，但会创建隐式依赖关系并表示全局可变状态。 强烈不建议这样做，你应该首先考虑其他依赖注入方式，但是有时它可能非常适合你。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用Swift学习依赖注入模式,使用DI编写松耦合代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先，我真的很喜欢James Shore的这句话：依赖注入意味着给对象一个实例变量，如此而已。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在我看来，学习依赖注入要稍微复杂一点，但是如果你将问题弄清楚，你将意识到实现 &lt;a href=&quot;http://www.xuebaonline.com/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/&quot; title=&quot;DI模式&quot;&gt;DI模式&lt;/a&gt; 就像给对象实例变量一样简单。 别开玩笑，这确实是理所当然的，但是许多开发人员使它过于复杂，并在错误的位置使用了注入。 💉&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;学习DI并不是关于实现细节，而是关于你将如何使用该模式。 依赖项注入有四个小变化，让我们通过使用真实的示例进行遍历，这些示例将帮助你了解何时使用依赖项注入。 现在抓住键盘！ 💻&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="依赖注入设计模式" scheme="http://www.xuebaonline.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift委托设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%A7%94%E6%89%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%A7%94%E6%89%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T08:39:15.000Z</published>
    <updated>2020-04-25T08:51:07.282Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;委托设计模式是通过 <code>Swift</code> 中的通用接口（协议）在两个对象之间进行通信的相对简单的方法。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="委托模式">委托模式</a>（delegation pattern）是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承。</p><a id="more"></a></br><h1 id="在Swift中实现委派"><a href="#在Swift中实现委派" class="headerlink" title="在Swift中实现委派"></a><strong>在Swift中实现委派</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你将需要一个委托协议，一个实际委托任务的委托人以及一个实现委托协议并完成 <strong>“老板”</strong> 所要求的实际工作的委托对象。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：客户端报告一个错误。 项目经理会创建一个问题，并告诉一位开发人员尽快解决问题。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的场景就是委托👆。 在某个时刻发生了事件，因此委托人（经理）使用外部资源（开发人员）使用一个公共接口（描述双方的问题）来完成某件事（修复🐛）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了演示委托在现实生活中的工作方式，我举了一个非常简单的例子。 我将使用类似的方法（因为Xcode游乐场仍然每1-5分钟冻结一次），就像我对命令模式所做的那样，但是此方法的目的几乎是完全不同的，因为我们正在谈论委托模式。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env swift</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InputDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldContinueListening: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didStartListening</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(input: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> delegate: <span class="type">InputDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate?.didStartListening()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> input = <span class="built_in">readLine</span>() <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.delegate?.didReceive(input: input)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.delegate?.shouldContinueListening ?? <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputReceiver</span>: <span class="title">InputDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldContinueListening: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didStartListening</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"👻 Please be nice and say \"hi\", if you want to leave just tell me \"bye\":"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(input: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> input &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"hi"</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"🌎 Hello world!"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"bye"</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"👋 Bye!"</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"🔍 Command not found! Please try again:"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inputHandler = <span class="type">InputHandler</span>()</span><br><span class="line"><span class="keyword">let</span> inputReceiver = <span class="type">InputReceiver</span>()</span><br><span class="line">inputHandler.delegate = inputReceiver</span><br><span class="line">inputHandler.listen()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是你可以在 <code>Swift</code> 中创建自己的委托模式的方式。 你可以想象，<code>Apple</code> 正在使用 <code>UICollectionViewDataSource</code> ，<code>UICollectionViewDelegate</code> 等在后台做同样的事情。你只需实现委托，它们将提供协议和委托人。 🤔</p></br><h1 id="弱属性，委托和类"><a href="#弱属性，委托和类" class="headerlink" title="弱属性，委托和类"></a><strong>弱属性，委托和类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存管理是非常重要的事情，因此值得一提的是，所有的类委托都应该是 <strong>弱引用</strong>，否则你将 <strong>很难管理器生命周期，易引起内存泄露</strong>，这一点必须注意。 😱</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InputDelegate</span>: <span class="title">class</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">InputDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputReceiver</span>: <span class="title">InputDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是修改后的 <code>Swift</code> 代码段，但是现在使用一个类作为委托。 你只需要稍微更改协议和委托者内部的属性即可。 如果要将类分配为委托，请始终使用弱引用该变量。 ⚠️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如代码中展示的，委托模式很容易，但是很危险。 它通过提供可以由实现委托（有时是数据源）协议的任何人使用的公共接口来帮助解耦。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;委托设计模式是通过 &lt;code&gt;Swift&lt;/code&gt; 中的通用接口（协议）在两个对象之间进行通信的相对简单的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;委托模式&quot;&gt;委托模式&lt;/a&gt;（delegation pattern）是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="委托设计模式" scheme="http://www.xuebaonline.com/tags/%E5%A7%94%E6%89%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift命令设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T08:12:58.000Z</published>
    <updated>2020-04-25T08:33:09.103Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令设计模式是众多设计模式中的一种，也比较常用。 这是用Swift编写的命令设计模板的一个小例子。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="命令模式">命令模式</a>（英语：Command pattern）是一种设计模式，它尝试以对象来代表实际行动。命令对象可以把行动(action) 及其参数封装起来，于是这些行动可以被：</p><ul><li>重复多次</li><li>取消（如果该对象有实现的话）</li><li>取消后又再重做</li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些都是现代大型应用程序所必须的功能，即“撤销”及“重复”。除此之外，可以用命令模式来实现的功能例子还有：</p><ul><li>交易行为</li><li>进度列</li><li>向导</li><li>用户界面按钮及功能表项目</li><li>线程 pool</li><li>宏收录</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想为稍后将要执行的不同操作提供一个通用界面，那么该命令模式将非常方便。 通常，它是一个对象，其中包含正确运行基础操作所需的所有信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令通常用于处理用户界面操作，创建撤消管理器或管理事务。 让我们通过使用表情符号创建命令行参数处理程序来查看 <code>Swift</code> 中的命令模式实现。 💾</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env swift</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelpCommand</span>: <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Help</span>().info()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Help</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">info</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">             🤖 Commander 🤖</span></span><br><span class="line"><span class="string">                  v1.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Available commands:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            👉 help      This command</span></span><br><span class="line"><span class="string">            👉 ls        List documents</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Bye! 👋</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListCommand</span>: <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">List</span>().homeDirectoryContents()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">homeDirectoryContents</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> documentsURL = fileManager.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask).first <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Could not open documents directory"</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> fileURLs = <span class="keyword">try</span> fileManager.contentsOfDirectory(at: documentsURL, includingPropertiesForKeys: <span class="literal">nil</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\n\t📁 Listing documents directory:\n"</span>)</span><br><span class="line">            <span class="built_in">print</span>(fileURLs.<span class="built_in">map</span> &#123; <span class="string">"\t\t💾 "</span> + $<span class="number">0</span>.lastPathComponent &#125;.joined(separator: <span class="string">"\n\n"</span>) + <span class="string">"\n"</span> )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> commands: [<span class="type">String</span>:<span class="type">Command</span>] = [:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.commands[<span class="string">"help"</span>] = <span class="type">HelpCommand</span>()</span><br><span class="line">        <span class="keyword">self</span>.commands[<span class="string">"ls"</span>] = <span class="type">ListCommand</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arguments = <span class="type">CommandLine</span>.arguments[<span class="number">1</span>...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> key = arguments.first, <span class="keyword">self</span>.commands[key] != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Usage: ./command.swift [\(self.commands.keys.joined(separator: "</span>|<span class="string">"))]"</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.commands[key]!.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">App</span>().run()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果保存此文件，只需在终端窗口中键入 <code>./file-name.swift</code> 即可运行它。 <code>Swift</code> 编译器将负责其余的工作。 ⚒</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令设计模式的实际用例：</p><ul><li>各种按钮动作</li><li>集合/表视图选择操作</li><li>在控制器之间导航</li><li>历史记录管理/撤消管理器</li><li>交易行为</li><li>进度管理</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如你所了解那样，该模式可以应用于多个区域。 苹果为此专门制作了一个名为 <code>NSInvocation</code> 的特定类，但不幸的是，由于它的动态行为，它在 <code>Swift</code> 中不可用。 没什么大不了的，你始终可以制定自己的协议和实现，在大多数情况下，你只需要一个包装基础命令逻辑的额外类即可。 😛</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;命令设计模式是众多设计模式中的一种，也比较常用。 这是用Swift编写的命令设计模板的一个小例子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;命令模式&quot;&gt;命令模式&lt;/a&gt;（英语：Command pattern）是一种设计模式，它尝试以对象来代表实际行动。命令对象可以把行动(action) 及其参数封装起来，于是这些行动可以被：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复多次&lt;/li&gt;
&lt;li&gt;取消（如果该对象有实现的话）&lt;/li&gt;
&lt;li&gt;取消后又再重做&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="命令设计模式" scheme="http://www.xuebaonline.com/tags/%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift原型设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T07:49:06.000Z</published>
    <updated>2020-04-25T08:03:11.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型设计模式用于创建基础对象的克隆，因此让我们看一些用Swift编写的实际示例。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式是 <a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="创建型模式">创建型模式</a> 的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这也是一种创新的设计模式，当你对一个对象进行非常基本的配置并且想要将这些预定义值提供（复制）给另一个对象时，这很有用。 基本上，你是从原型对象制作复制。 😊😊😊</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法有一些好处，例如，你不必继承子类，但可以单独配置复制。 这也意味着，如果你要使用原型，则可以删除一堆样板代码（配置）。 🤔</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paragraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> font: <span class="type">UIFont</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(font: <span class="type">UIFont</span> = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>),</span><br><span class="line">         color: <span class="type">UIColor</span> = .darkText,</span><br><span class="line">         text: <span class="type">String</span> = <span class="string">""</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = font</span><br><span class="line">        <span class="keyword">self</span>.color = color</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clone</span><span class="params">()</span></span> -&gt; <span class="type">Paragraph</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Paragraph</span>(font: <span class="keyword">self</span>.font, color: <span class="keyword">self</span>.color, text: <span class="keyword">self</span>.text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> base = <span class="type">Paragraph</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = base.clone()</span><br><span class="line">title.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">title.text = <span class="string">"This is the title"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = base.clone()</span><br><span class="line">first.text = <span class="string">"This is the first paragraph"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> second = base.clone()</span><br><span class="line">second.text = <span class="string">"This is the second paragraph"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上面的代码所示，实现只是几行代码。 你只需要一个默认的初始化程序和一个复制方法。 一切都将在 <code>init</code> 方法中针对原型对象进行预配置，并且你可以使用 <code>clone</code> 方法进行复制，但这时很明显……</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们再看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paragraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> font: <span class="type">UIFont</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(font: <span class="type">UIFont</span> = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>),</span><br><span class="line">         color: <span class="type">UIColor</span> = .darkText,</span><br><span class="line">         text: <span class="type">String</span> = <span class="string">""</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = font</span><br><span class="line">        <span class="keyword">self</span>.color = color</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clone</span><span class="params">()</span></span> -&gt; <span class="type">Paragraph</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Paragraph</span>(font: <span class="keyword">self</span>.font, color: <span class="keyword">self</span>.color, text: <span class="keyword">self</span>.text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> base = <span class="type">Paragraph</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = base.clone()</span><br><span class="line">title.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">title.text = <span class="string">"This is the title"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = base.clone()</span><br><span class="line">first.text = <span class="string">"This is the first paragraph"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> second = base.clone()</span><br><span class="line">second.text = <span class="string">"This is the second paragraph"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你打算获取已知对象状态的快照，则原型设计模式也很有用。 例如，在绘图应用程序中，你可以将形状类作为原型，可以开始向其添加路径，有时甚至可以从中创建快照。 你可以继续处理新对象，但这将使你能够在将来的任何时间返回到保存状态。 🎉</p><p>当你的应用程序不依赖于创建，合成和表示对象的方法时，应考虑选择它，以及至少下列各项之一：</p><ul><li>在运行时创建对象</li><li>你想避免工厂的复杂层次结构</li><li>对象只能有很少的状态</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，就是 <code>Swift</code> 中的原型设计模式。 🐿</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型设计模式用于创建基础对象的克隆，因此让我们看一些用Swift编写的实际示例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型模式是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;创建型模式&quot;&gt;创建型模式&lt;/a&gt; 的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="原型设计模式" scheme="http://www.xuebaonline.com/tags/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>比较工厂设计模式</title>
    <link href="http://www.xuebaonline.com/%E6%AF%94%E8%BE%83%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/%E6%AF%94%E8%BE%83%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T07:38:40.000Z</published>
    <updated>2020-04-25T07:49:56.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用Swift语言了解静态工厂，简单工厂，工厂方法和抽象工厂之间的区别。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为对所有工厂模式进行汇总比较会很高兴，所以这里是你应该了解的所有内容。 构造它们相对简单，在本示例中，我将使用一些用 <code>Swift</code> 编程语言编写的 <code>UIColor</code> 来向你展示基础知识。 🧙‍♂️</p><a id="more"></a><h1 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a><strong>静态工厂</strong></h1><ul><li>没有单独的工厂类别</li><li>命名静态方法来初始化对象</li><li>可以具有缓存并可以返回子类型</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> primary: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> .black &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> secondary: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> .white &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> primary = <span class="type">UIColor</span>.primary</span><br><span class="line"><span class="keyword">let</span> secondary = <span class="type">UIColor</span>.secondary</span><br></pre></td></tr></table></figure><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a><strong>简单工厂</strong></h1><ul><li>一个工厂类</li><li>枚举( <code>switch-case</code> )出其中的实例对象</li><li>封装各种代码</li><li>如果列表太大，请使用工厂方法</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> primary</span><br><span class="line">        <span class="keyword">case</span> secondary</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> style: Style)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style</span><br><span class="line">        <span class="keyword">case</span> .primary:</span><br><span class="line">            <span class="keyword">return</span> .black</span><br><span class="line">        <span class="keyword">case</span> .secondary:</span><br><span class="line">            <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primary = factory.create(.primary)</span><br><span class="line"><span class="keyword">let</span> secondary = factory.create(.secondary)</span><br></pre></td></tr></table></figure><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong>工厂方法</strong></h1><ul><li>多个（解耦的）工厂类</li><li>每个实例的工厂方法</li><li>为工厂创建一个简单的协议</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .black</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> primaryColorFactory = <span class="type">PrimaryColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> secondaryColorFactory = <span class="type">SecondaryColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primary = primaryColorFactory.create()</span><br><span class="line"><span class="keyword">let</span> secondary = secondaryColorFactory.create()</span><br></pre></td></tr></table></figure><h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a><strong>抽象工厂</strong></h1><ul><li>结合简单的工厂和工厂方法</li><li>对整个应用程序具有全局作用</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exact same factory method pattern from above</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .black</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple factory pattern from above using the factory methods</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> dark</span><br><span class="line">        <span class="keyword">case</span> light</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> theme: Theme)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> theme &#123;</span><br><span class="line">        <span class="keyword">case</span> .dark:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">PrimaryColorFactory</span>().create()</span><br><span class="line">        <span class="keyword">case</span> .light:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">SecondaryColorFactory</span>().create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">AppColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primaryColor = factory.create(.dark)</span><br><span class="line"><span class="keyword">let</span> secondaryColor = factory.create(.light)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，所有这些都是使用 <code>Swift</code> 编写的实际示例的工厂模式。 👍</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用Swift语言了解静态工厂，简单工厂，工厂方法和抽象工厂之间的区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我认为对所有工厂模式进行汇总比较会很高兴，所以这里是你应该了解的所有内容。 构造它们相对简单，在本示例中，我将使用一些用 &lt;code&gt;Swift&lt;/code&gt; 编程语言编写的 &lt;code&gt;UIColor&lt;/code&gt; 来向你展示基础知识。 🧙‍♂️&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂设计模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift抽象工厂设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T07:26:13.000Z</published>
    <updated>2020-04-25T07:39:20.965Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们将工厂方法与简单的工厂外观结合起来：这是用Swift语言编写的抽象工厂设计模式！</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82" target="_blank" rel="noopener" title="抽象工厂模式">抽象工厂模式</a>（英语：Abstract factory pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举个例子来说，比如一个抽象工厂类叫做DocumentCreator（文档创建器），此类提供创建若干种产品的接口，包括createLetter()（创建信件）和createResume()（创建简历）。其中，createLetter()返回一个Letter（信件），createResume()返回一个Resume（简历）。系统中还有一些DocumentCreator的具体实现类，包括FancyDocumentCreator和ModernDocumentCreator。这两个类对DocumentCreator的两个方法分别有不同的实现，用来创建不同的“信件”和“简历”（用FancyDocumentCreator的实例可以创建FancyLetter和FancyResume，用ModernDocumentCreator的实例可以创建ModernLetter和ModernResume）。这些具体的“信件”和“简历”类均继承自抽象类，即Letter和Resume类。客户端需要创建“信件”或“简历”时，先要得到一个合适的DocumentCreator实例，然后调用它的方法。一个工厂中创建的每个对象都是同一个主题的（“fancy”或者“modern”）。客户端程序只需要知道得到的对象是“信件”或者“简历”，而不需要知道具体的主题，因此客户端程序从抽象工厂DocumentCreator中得到了Letter或Resume类的引用，而不是具体类的对象引用。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“工厂”是创建产品（对象）的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够抵消这样的“额外工作”。</p></blockquote><h1 id="Swift抽象工厂"><a href="#Swift抽象工厂" class="headerlink" title="Swift抽象工厂"></a><strong>Swift抽象工厂</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂模式提供了一种封装一组具有共同主题的单个工厂而无需指定其具体类的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，抽象工厂可以为你创建相关对象的族。 该实现通常结合简单的工厂和工厂方法原理。 单个对象是通过工厂方法创建的，而整个对象都包装在一个“抽象”的简单工厂中。 现在检查代码！ 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service protocols</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StagingService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://dev.localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StagingServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">StagingService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// production</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://live.localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProductionService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// abstract factory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Environment</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> production</span><br><span class="line">        <span class="keyword">case</span> staging</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> env: <span class="type">Environment</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(env: <span class="type">Environment</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.env = env</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>.env &#123;</span><br><span class="line">        <span class="keyword">case</span> .production:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ProductionServiceFactory</span>().create()</span><br><span class="line">        <span class="keyword">case</span> .staging:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">StagingServiceFactory</span>().create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">AppServiceFactory</span>(env: .production)</span><br><span class="line"><span class="keyword">let</span> service = factory.create()</span><br><span class="line"><span class="built_in">print</span>(service.url)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上代码看到的，使用抽象工厂将影响整个应用程序逻辑，而工厂方法仅对本地部分产生影响。 实现可能会有所不同，例如你也可以为抽象工厂创建一个独立的协议，但是在此示例中，我想使事情尽可能简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂通常用于实现对象独立性。 例如，如果你使用通用接口用 <code>Swift</code> 编写了多个不同的 <code>SQL</code> 数据库连接器（ <code>PostgreSQL</code> ，<code>MySQL</code> 等），则可以随时使用此模式在它们之间轻松切换。 可以将类似的逻辑应用于具有类似情况的业务。 🤔</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;让我们将工厂方法与简单的工厂外观结合起来：这是用Swift语言编写的抽象工厂设计模式！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;抽象工厂模式&quot;&gt;抽象工厂模式&lt;/a&gt;（英语：Abstract factory pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="抽象工厂设计模式" scheme="http://www.xuebaonline.com/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift工厂方法设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T07:16:57.000Z</published>
    <updated>2020-04-25T07:23:43.529Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法设计模式是一种专用的非静态方法，用于隐藏对象的创建逻辑。 让我们用Swift做吧！</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p><a id="more"></a><h1 id="工厂方法只是一种非静态方法"><a href="#工厂方法只是一种非静态方法" class="headerlink" title="工厂方法只是一种非静态方法"></a><strong>工厂方法只是一种非静态方法</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面对现实，这种模式只是通常由简单协议和类支持的一种方法。 从一个非常简单的示例开始：想象一个可以为您的服务端点创建基本URL的类。 我们称之为服务工厂。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createProductionUrl</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ServiceFactory</span>()</span><br><span class="line">factory.createProductionUrl()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会想，这甚至不接近工厂方法模式，但请稍候…让我们通过为服务类创建协议以及返回 <code>URL</code> 的协议，使事情变得有些复杂。 现在，我们可以将基本生产环境url协议实现为一个单独的类，并从生产服务工厂类返回该特定实例。 只需检查一下代码即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProductionService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ProductionServiceFactory</span>()</span><br><span class="line"><span class="keyword">let</span> request = factory.create()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么我们将所有逻辑分为两类和协议？ 请相信我去耦是一件好事。 从现在开始，你可以轻松编写带有虚拟 <code>url</code> 的模拟服务。 显然，这需要一个匹配的工厂类。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些模拟实例还将实现服务协议，因此你可以以相对轻松的方式添加新类型，而无需更改原始代码库。 工厂方法解决了简单工厂模式的一个特定问题。 如果列表（ <code>switch-case</code> 的列表）太长，那么只有一个工厂就很难维护新对象。 工厂方法通过引入多个工厂对象来解决此问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工厂方法设计模式是一种专用的非静态方法，用于隐藏对象的创建逻辑。 让我们用Swift做吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂方法设计模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift中快速简单的工厂设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T05:15:16.000Z</published>
    <updated>2020-04-25T07:15:19.575Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，我们来讨论简单的工厂设计模式，该模式使用Swift以一种非常简单的方式封装对象创建。</p></blockquote><h1 id="使用-switch-case-实现简单的工厂模式"><a href="#使用-switch-case-实现简单的工厂模式" class="headerlink" title="使用 switch-case 实现简单的工厂模式"></a><strong>使用 switch-case 实现简单的工厂模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式的目标是封装一些经常变化的东西。 想象一下应用程序的调色板。 你可能必须每天根据设计师的最新习惯来更改颜色。 如果你不得不手动搜索和替换每个单独的颜色代码实例，那将给你带来极大的不便。 因此，让我们在Swift中创建一个简单的工厂，该工厂可以根据给定的样式返回颜色。 🎩</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> text</span><br><span class="line">        <span class="keyword">case</span> background</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> style: Style)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style &#123;</span><br><span class="line">        <span class="keyword">case</span> .text:</span><br><span class="line">            <span class="keyword">return</span> .black</span><br><span class="line">        <span class="keyword">case</span> .background:</span><br><span class="line">            <span class="keyword">return</span> .white</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> textColor = factory.create(.text)</span><br><span class="line"><span class="keyword">let</span> backgroundColor = factory.create(.background)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这真的很有用，尤其是涉及复杂的对象初始化过程时。 您还可以定义一个协议，并使用 <code>switch-case</code> 块返回实现所需接口的各种实例类型。 🚦</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevEnvironment</span>: <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"dev"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiveEnvironment</span>: <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"live"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnvironmentFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> dev</span><br><span class="line">        <span class="keyword">case</span> live</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> type: EnvType)</span></span> -&gt; <span class="type">Environment</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> type &#123;</span><br><span class="line">        <span class="keyword">case</span> .dev:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">DevEnvironment</span>()</span><br><span class="line">        <span class="keyword">case</span> .live:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">LiveEnvironment</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">EnvironmentFactory</span>()</span><br><span class="line"><span class="keyword">let</span> dev = factory.create(.dev)</span><br><span class="line"><span class="built_in">print</span>(dev.identifier)</span><br></pre></td></tr></table></figure><p>因此，有关简单工厂设计模式的几件事要记住：</p><ul><li>通过分离初始化和使用逻辑，有助于松耦合</li><li>它只是包装可以经常更改的东西的包装器</li><li>可以使用枚举和开关盒在Swift中实现简单的工厂</li><li>如果您计划返回不同的对象（POP🎉），请使用协议</li><li>保持简单🏭</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式将创建与实际用法分开，并将职责移至特定角色，因此，如果发生某些变化，你只需要修改工厂即可。 你可以保留所有测试，而其他所有功能则完全不受影响。 强大而简单！ 💪</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这次，我们来讨论简单的工厂设计模式，该模式使用Swift以一种非常简单的方式封装对象创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;使用-switch-case-实现简单的工厂模式&quot;&gt;&lt;a href=&quot;#使用-switch-case-实现简单的工厂模式&quot; class=&quot;headerlink&quot; title=&quot;使用 switch-case 实现简单的工厂模式&quot;&gt;&lt;/a&gt;&lt;strong&gt;使用 switch-case 实现简单的工厂模式&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这种模式的目标是封装一些经常变化的东西。 想象一下应用程序的调色板。 你可能必须每天根据设计师的最新习惯来更改颜色。 如果你不得不手动搜索和替换每个单独的颜色代码实例，那将给你带来极大的不便。 因此，让我们在Swift中创建一个简单的工厂，该工厂可以根据给定的样式返回颜色。 🎩&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="构造函数" scheme="http://www.xuebaonline.com/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="静态工厂方法" scheme="http://www.xuebaonline.com/tags/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift中构造函数与静态工厂方法的比较</title>
    <link href="http://www.xuebaonline.com/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>http://www.xuebaonline.com/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-04-25T04:19:43.000Z</published>
    <updated>2020-04-25T05:12:12.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当实例化对象时，哪个更好：构造函数还是静态工厂方法？ 我们来看一看。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我相信Joshua Bloch 在他的非常不错的书 《Effective Java》 中首先说了它：与构造函数相比，静态工厂方法是实例化对象的首选方法。 我不同意。 不仅因为我相信静态方法是纯粹的邪恶，而且主要是因为在这种特殊情况下，它们形成好的方法，使我们认为我们必须偏向使用它们。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从面向对象的角度分析推理并弄清楚其原因。这是一个具有一个主要构造函数和两个次要构造函数的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">Color</span>(<span class="type">String</span> rgb) &#123;</span><br><span class="line">        this(<span class="type">Integer</span>.parseInt(rgb, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Color</span>(int red, int green, int blue) &#123;</span><br><span class="line">        this(red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是带有三个静态工厂方法的类似类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromRGB(<span class="type">String</span> rgb) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(<span class="type">Integer</span>.parseInt(rgb, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromPalette(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromHex(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你更喜欢哪一个？</p><p>根据Joshua Bloch的说法，使用静态工厂方法而不是构造函数具有三个基本优点（实际上有四个优点，但是第四个不再适用于Java）：</p><ul><li>他们有名字。</li><li>他们可以缓存。</li><li>它们可以是子类型。</li></ul><p>我认为，如果设计错误，那么这三者都是很合理的。 它们是解决问题的好办法。 让我们一一介绍。</p><h1 id="命名存在"><a href="#命名存在" class="headerlink" title="命名存在"></a><strong>命名存在</strong></h1><p>这是使用构造函数制作 <code>red tomato</code> 颜色对象的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>这是使用静态工厂方法的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>makeFromPalette（）</code> 在语义上比新的 <code>Color（）</code> 更丰富。 如果我们将它们传递给构造函数，谁知道这三个数字意味着什么。 但是“palette”可以帮助我们立即解决所有问题。</p><p>但是，正确的解决方案是使用多态和封装，以将问题分解为几个语义丰富的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="type">Color</span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HexColor</span> <span class="title">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">HexColor</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RGBColor</span> <span class="title">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Color</span> origin;</span><br><span class="line">    <span class="type">RGBColor</span>(int red, int green, int blue) &#123;</span><br><span class="line">        this.origin = new <span class="type">HexColor</span>(</span><br><span class="line">            red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们使用类的构造函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">RGBColor</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure></br><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h1><p>假设我在应用程序中的多个位置需要一个 <code>red tomato</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// ... sometime later</span></span><br><span class="line"><span class="type">Color</span> red = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此创建两个对象，这显然是低效的，因为它们是相同的。 最好将第一个实例保留在内存中的某个位置，并在第二个调用到达时将其返回。 静态工厂方法可以解决这个问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// ... sometime later</span></span><br><span class="line"><span class="type">Color</span> red = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在 <code>Color</code> 内的某个地方，保存一个私有静态 <code>Map</code> ，其中已实例化了所有对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Map</span> &lt; <span class="type">Integer</span>, <span class="type">Color</span> &gt; <span class="type">CACHE</span> =</span><br><span class="line">        new <span class="type">HashMap</span> &lt; &gt; ();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromPalette(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">final</span> int hex = red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Color</span>.<span class="type">CACHE</span>.computeIfAbsent(</span><br><span class="line">            hex, h - &gt; new <span class="type">Color</span>(h)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是非常高效的。 对于像我们的 <code>Color</code> 这样的对象，问题可能不会那么明显，但是当对象较大时，其实例化和垃圾回收可能会浪费大量时间。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有一种面向对象的方法可以解决此问题。 我们只是介绍了一个新的类 <code>Palette</code> ，它将变成一个颜色存储区：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Palette</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Map</span> &lt; <span class="type">Integer</span>, <span class="type">Color</span> &gt; colors =</span><br><span class="line">        new <span class="type">HashMap</span> &lt; &gt; ();</span><br><span class="line">    <span class="type">Color</span> take(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">final</span> int hex = red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue;</span><br><span class="line">        <span class="keyword">return</span> this.computerIfAbsent(</span><br><span class="line">            hex, h - &gt; new <span class="type">Color</span>(h)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们一次创建一个 <code>Palette</code> 实例，并要求它在每次需要时向我们返回一种颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = palette.take(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// Later we will get the same instance:</span></span><br><span class="line"><span class="type">Color</span> red = palette.take(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p><strong>没有静态方法，没有静态属性。</strong></p></br><h1 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a><strong>子类型</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们的 <code>Color</code> 类具有 <code>lighter()</code> 方法，该方法应该将颜色转移到下一个可用的 <code>lighter</code> 上：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    protected <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(hex + <span class="number">0x111</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有时更希望通过一组可用的 <code>Pantone</code> 颜色选择下一种较浅的颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PantoneColor</span> <span class="title">extends</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">PantoneName</span> pantone;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">String</span> name) &#123;</span><br><span class="line">        this(new <span class="type">PantoneName</span>(name));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">PantoneName</span> name) &#123;</span><br><span class="line">        this.pantone = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">PantoneColor</span>(this.pantone.up());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建一个静态工厂方法，该方法将决定哪种 <code>Color</code> 实现最适合我们：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> code;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> make(int h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> new <span class="type">PantoneColor</span>(<span class="string">"19-1664 TPX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">RGBColor</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果要求使用真正的红色，我们将返回 <code>PantoneColor</code> 的一个实例。 在所有其他情况下，它只是标准的 <code>RGBColor</code> 。 该决定是通过静态工厂方法做出的。 这就是我们所说的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> color = <span class="type">Color</span>.make(<span class="number">0xBF1932</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于构造函数只能返回在其中声明的类，因此不可能对构造函数执行相同的 <code>“forking”</code> 。静态方法具有返回 <code>Color</code> 的任何子类型所需的所有自由。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是，在面向对象的世界中，我们可以而且必须以不同的方式去做。 首先，我们将 <code>Color</code> 设置为接口：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="type">Color</span> &#123;</span><br><span class="line">    <span class="type">Color</span> lighter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们将需要的构造方法移至其自己的类 <code>Colors</code> ，就像在上一个示例中所做的那样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colors</span> </span>&#123;</span><br><span class="line">    <span class="type">Color</span> make(int h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> new <span class="type">PantoneColor</span>(<span class="string">"19-1664-TPX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">RGBColor</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而且我们将使用 <code>Colors</code> 类的实例，而不是 <code>Color</code> 内部的静态方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colors.make(<span class="number">0xBF1932</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，这仍然不是真正的面向对象的思维方式，因为我们正在将决策权从它所属的对象上移开。 通过静态工厂方法 <code>make（</code>）或新类 <code>Colors</code> （实际上并不重要），我们将对象分成两部分。 第一部分是对象本身，第二部分是决策算法，它位于其他地方。<br>面向对象的设计是将逻辑放入 <code>PantoneColor</code> 类的对象中，该对象将装饰原始的RGBColor：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PantoneColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Color</span> origin;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">Color</span> color) &#123;</span><br><span class="line">        this.origin = color;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Color</span> next;</span><br><span class="line">        <span class="keyword">if</span> (this.origin.hex() == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            next = new <span class="type">RGBColor</span>(<span class="number">0xD12631</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next = this.origin.lighter();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">PantoneColor</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建一个 <code>RGBColor</code> 实例，并使用 <code>PantoneColor</code> 装饰它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> red = new <span class="type">PantoneColor</span>(</span><br><span class="line">    new <span class="type">RGBColor</span>(<span class="number">0xBF1932</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要求红色返回较浅的颜色，它返回 <code>Pantone</code> 调色板中的一种，而不是仅在 <code>RGB</code> 坐标中较浅的颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> lighter = red.lighter(); <span class="comment">// 0xD12631</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，这个示例是原始的，如果我们真的希望它适用于所有 <code>Pantone</code> 颜色，则需要进一步改进。 逻辑必须保留在类内部，而不是外部，静态工厂方法甚至其他补充类中。 当然，我在说的是属于这个特定类的逻辑。 如果与类实例的管理有关，则可以有容器和存储，就像上面的上一个示例一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总而言之，我强烈建议您不要使用静态方法，尤其是当它们要替换对象构造函数时。 通过其构造函数生成对象是任何面向对象软件中最“神圣”的时刻，请不要错过它的美丽。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当实例化对象时，哪个更好：构造函数还是静态工厂方法？ 我们来看一看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 我相信Joshua Bloch 在他的非常不错的书 《Effective Java》 中首先说了它：与构造函数相比，静态工厂方法是实例化对象的首选方法。 我不同意。 不仅因为我相信静态方法是纯粹的邪恶，而且主要是因为在这种特殊情况下，它们形成好的方法，使我们认为我们必须偏向使用它们。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="构造函数" scheme="http://www.xuebaonline.com/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="静态工厂方法" scheme="http://www.xuebaonline.com/tags/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift静态工厂设计模式</title>
    <link href="http://www.xuebaonline.com/Swift%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T03:48:39.000Z</published>
    <updated>2020-04-25T04:21:36.398Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，我们一起看一下有关 <a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95" target="_blank" rel="noopener" title="静态工厂设计模式">静态工厂设计模式</a> 的知识，并展示一些使用Swift编程语言的用例。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。” </p></blockquote><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个对象常常需要复杂的过程，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。</p></blockquote></br><h1 id="静态工厂模式示例"><a href="#静态工厂模式示例" class="headerlink" title="静态工厂模式示例"></a><strong>静态工厂模式示例</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象创建中的有些过程包括决定创建哪个对象、管理对象的生命周期，以及管理特定对象的创建和销毁的概念。</p></blockquote><h2 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a><strong>命名构造函数</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于静态装饰模式的第一个好处是，每个静态装饰方法都可以有一个名称。 <code>Apple</code> 在其 <code>UIColor</code> 类实现中使用此模式来创建诸如 <code>.red</code> ，<code>.yellow</code> 等的命名颜色。请注意，<code>Swift</code> 中的实现实际上不是方法，而是静态属性，它返回实际实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">TimeInterval</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> second: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> minute: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">60</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> hour: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">3_600</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> day: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">86_400</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> week: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">604_800</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果很难记住一天或一周是几秒钟，为什么不为它创建一个命名初始化器。 看到 <code>TimeInterval.week</code> 比 <code>604_800</code> 好得多。 😅</p></br><h2 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a><strong>缓存对象</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态工厂模式的下一个优点是，为了更好地使用内存，它可以支持缓存。 这样，如果你通过静态构造函数（也称为<a href="http://www.xuebaonline.com/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/" title="Swift中构造函数与静态工厂方法的比较">静态工厂方法</a>）对其进行初始化，则可以限制所创建对象的数量。 🏭</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - cache</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> cache: [<span class="type">String</span>:<span class="type">Service</span>] = [:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cached</span><span class="params">(name: String)</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">Service</span>.cache[name] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="type">Service</span>.cache[name] = <span class="type">Service</span>(named: name)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cache[name]!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - static factory</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> local: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cached(name: <span class="string">"local"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> remote: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cached(name: <span class="string">"remote"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(named name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h2 id="本地初始化范围"><a href="#本地初始化范围" class="headerlink" title="本地初始化范围"></a><strong>本地初始化范围</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于静态工厂方法的另一个好处是，你可以将类的初始化限制为私有作用域。 换句话说，只能通过静态工厂方法进行对象创建。 你只需要将 <code>init</code> 方法设为私有。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> local: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>(name: <span class="string">"local"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> remote: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>(name: <span class="string">"remote"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>请注意，您可以使用 <code>final＆static</code> 关键字限制子类化。 如果要允许子类化，则应删除 <code>final</code> 并为属性使用 <code>class</code> 关键字而不是 <code>static</code> ，这样子类可以覆盖工厂方法。</strong> 🤔</p></br><h2 id="静态返回任何数据"><a href="#静态返回任何数据" class="headerlink" title="静态返回任何数据"></a><strong>静态返回任何数据</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 静态工厂也可以返回给定对象的子类型，但是为什么我们不更进一步呢？ 你还可以从静态方法返回任何类型的数据，我知道这似乎是一种作弊，因为我不是在这里创建 <code>UIColor</code> 的实例，但是我相信在这里值得一提这个方法，静态工厂。 有时，这个技术可能非常有用。 😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span><span class="params">(with color: UIColor)</span></span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">1</span>, height: <span class="number">1</span>)</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(rect.size)</span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()!</span><br><span class="line">        context.setFillColor(color.cgColor)</span><br><span class="line">        context.fill(rect)</span><br><span class="line">        <span class="keyword">let</span> img = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> img!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> redImage: <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>.image(with: .red)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在本文中，我们一起看一下有关 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;静态工厂设计模式&quot;&gt;静态工厂设计模式&lt;/a&gt; 的知识，并展示一些使用Swift编程语言的用例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。” &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="工厂模式" scheme="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift生成器模式</title>
    <link href="http://www.xuebaonline.com/Swift%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T03:24:29.000Z</published>
    <updated>2020-04-25T03:49:52.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>了解如何在Swift中实现生成器模式，以隐藏创建具有许多单独属性的对象的复杂性。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>iOS</code> 开发中，会使用到很多设计模式，<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="生成器模式">生成器模式</a> 也叫构建器模式，我们也会经常用到。在以下的行文过程中均使用生成器模式来表述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成器模式（英：Builder Pattern）是一种设计模式，又名：建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p><a id="more"></a></br><h1 id="生成器模式如何工作？"><a href="#生成器模式如何工作？" class="headerlink" title="生成器模式如何工作？"></a><strong>生成器模式如何工作？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成器模式可以通过多种方式实现，但是如果你了解该模式的主要目标，那实际上就没有关系：</p><blockquote><p><strong>Builder设计模式的目的是将复杂对象的构造与其表示分开。</strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如果你有一个具有很多属性的对象，想隐藏初始化过程的复杂性，可以编写一个生成器并通过该生成器构造该对象。 它可以像控制整个构建过程的构建方法或外部类一样简单。 这完全取决于给定的环境。 🏗</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，我们对该设计模式有一个详细的认知，让我们来看一下使用实例和强大的 <code>Swift</code> 编程语言的生成器模式！ 💪</p></br><h1 id="简单的-Emitter-生成器"><a href="#简单的-Emitter-生成器" class="headerlink" title="简单的 Emitter 生成器"></a><strong>简单的 Emitter 生成器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SKEmitterNode</code> 是一个很好的例子。 如果要创建自定义 <code>Emitter</code> 并以编程方式设置属性（通常用于 <code>SpriteKit</code> 游戏），则像这样的 <code>Emitter</code> 生成器类可能是一个合理的解决方案。 👾</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmitterBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKEmitterNode</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> emitter = <span class="type">SKEmitterNode</span>()</span><br><span class="line">        emitter.particleTexture = <span class="type">SKTexture</span>(imageNamed: <span class="string">"MyTexture"</span>)</span><br><span class="line">        emitter.particleBirthRate = <span class="number">100</span></span><br><span class="line">        emitter.particleLifetime = <span class="number">60</span></span><br><span class="line">        emitter.particlePositionRange = <span class="type">CGVector</span>(dx: <span class="number">100</span>, dy: <span class="number">100</span>)</span><br><span class="line">        emitter.particleSpeed = <span class="number">10</span></span><br><span class="line">        emitter.particleColor = .red</span><br><span class="line">        emitter.particleColorBlendFactor = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> emitter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">EmitterBuilder</span>().build()</span><br></pre></td></tr></table></figure></br><h1 id="简单的-theme-生成器"><a href="#简单的-theme-生成器" class="headerlink" title="简单的 theme 生成器"></a><strong>简单的 theme 生成器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们远离游戏，想象一下你正在为UIKit应用程序创建一个主题引擎，该引擎具有许多自定义字体，颜色等。生成器对于构造独立主题可能很有用。 🔨</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> textColor: <span class="type">UIColor?</span></span><br><span class="line">    <span class="keyword">let</span> backgroundColor: <span class="type">UIColor?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> light</span><br><span class="line">        <span class="keyword">case</span> dark</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(<span class="number">_</span> style: Style)</span></span> -&gt; <span class="type">Theme</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style &#123;</span><br><span class="line">        <span class="keyword">case</span> .light:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Theme</span>(textColor: .black, backgroundColor: .white)</span><br><span class="line">        <span class="keyword">case</span> .dark:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Theme</span>(textColor: .white, backgroundColor: .black)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="type">ThemeBuilder</span>()</span><br><span class="line"><span class="keyword">let</span> light = builder.build(.light)</span><br><span class="line"><span class="keyword">let</span> dark = builder.build(.dark)</span><br></pre></td></tr></table></figure></br><h1 id="“Chained”-URL构建器"><a href="#“Chained”-URL构建器" class="headerlink" title="“Chained” URL构建器"></a><strong>“Chained” URL构建器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用这种方法，你可以通过多种方法配置对象，并且每个方法都将返回相同的生成器对象。 这样，您可以链接配置，并在最后一步构建最终对象实例。 ⛓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> components: <span class="type">URLComponents</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.components = <span class="type">URLComponents</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(scheme: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.scheme = scheme</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(host: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.host = host</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(port: Int)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.port = port</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(path: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> path = path</span><br><span class="line">        <span class="keyword">if</span> !path.hasPrefix(<span class="string">"/"</span>) &#123;</span><br><span class="line">            path = <span class="string">"/"</span> + path</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.components.path = path</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addQueryItem</span><span class="params">(name: String, value: String)</span></span> -&gt; <span class="type">URLBuilder</span>  &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.components.queryItems == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.components.queryItems = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.components.queryItems?.append(<span class="type">URLQueryItem</span>(name: name, value: value))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">URL?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.components.url</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URLBuilder</span>()</span><br><span class="line">    .<span class="keyword">set</span>(scheme: <span class="string">"https"</span>)</span><br><span class="line">    .<span class="keyword">set</span>(host: <span class="string">"localhost"</span>)</span><br><span class="line">    .<span class="keyword">set</span>(path: <span class="string">"api/v1"</span>)</span><br><span class="line">    .addQueryItem(name: <span class="string">"sort"</span>, value: <span class="string">"name"</span>)</span><br><span class="line">    .addQueryItem(name: <span class="string">"order"</span>, value: <span class="string">"asc"</span>)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure></br><h1 id="director-类的生成器模式"><a href="#director-类的生成器模式" class="headerlink" title="director 类的生成器模式"></a><strong>director 类的生成器模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们认识一下 <code>director</code> 实例。 使构建器与确切的配置部分解耦。 因此，举例来说，你可以制作带有圆圈的游戏，但是后来如果你改变主意并想使用正方形，那相对容易。 你只需要创建一个新的生成器，其他所有内容都可以相同。 🎬</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NodeBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">SKColor</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NodeDirector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> builder: <span class="type">NodeBuilder</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleNodeBuilder</span>: <span class="title">NodeBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">SKColor</span> = .clear</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="type">SKShapeNode</span>(circleOfRadius: <span class="keyword">self</span>.size)</span><br><span class="line">        node.name = <span class="keyword">self</span>.name</span><br><span class="line">        node.fillColor = <span class="keyword">self</span>.color</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerNodeDirector</span>: <span class="title">NodeDirector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> builder: <span class="type">NodeBuilder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(builder: <span class="type">NodeBuilder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.builder = builder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.builder.name = <span class="string">"Hello"</span></span><br><span class="line">        <span class="keyword">self</span>.builder.size = <span class="number">32</span></span><br><span class="line">        <span class="keyword">self</span>.builder.color = .red</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.builder.build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="type">CircleNodeBuilder</span>()</span><br><span class="line"><span class="keyword">let</span> director = <span class="type">PlayerNodeDirector</span>(builder: builder)</span><br><span class="line"><span class="keyword">let</span> player = director.build()</span><br></pre></td></tr></table></figure><h1 id="基于Block的构建器"><a href="#基于Block的构建器" class="headerlink" title="基于Block的构建器"></a><strong>基于Block的构建器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一种更快捷的方法是使用 <code>Block</code> 而不是生成器类来配置对象。 当然，我们可以争论这是否仍然是生成器模式…😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(block: <span class="params">(<span class="params">(UILabel)</span></span></span></span> -&gt; <span class="type">Void</span>)) -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        block(label)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> label = <span class="type">UILabel</span>.build &#123; label <span class="keyword">in</span></span><br><span class="line">    label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    label.text = <span class="string">"Hello wold!"</span></span><br><span class="line">    label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 请注意，生成器的实现可能会因具体实例而异。 有时，生成器模式与工厂模式结合在一起。 对此，几乎每个人都以不同的方式解释它，但是我认为这不是问题。 设计模式是精心设计的准则，但有时你必须这么做。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;了解如何在Swift中实现生成器模式，以隐藏创建具有许多单独属性的对象的复杂性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 &lt;code&gt;iOS&lt;/code&gt; 开发中，会使用到很多设计模式，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;生成器模式&quot;&gt;生成器模式&lt;/a&gt; 也叫构建器模式，我们也会经常用到。在以下的行文过程中均使用生成器模式来表述。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成器模式（英：Builder Pattern）是一种设计模式，又名：建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="生成器模式" scheme="http://www.xuebaonline.com/tags/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>在Swift中重构单例模式用法</title>
    <link href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/"/>
    <id>http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/</id>
    <published>2020-04-25T02:38:47.000Z</published>
    <updated>2020-04-25T03:52:42.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>清洁，模块化和可测试代码库的小技巧。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件开发中，不鼓励使用单例，并且对此表示反对，但这是有充分理由的。 它们很难测试或无法测试，并且在其他类中隐式使用它们时会纠缠你的代码库，从而使代码重用变得困难。 在大多数情况下，单例模式无非是对全局易变状态的保存。 每个人至少知道这是一个糟糕的主意。 但是，<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="单例模式">单例模式</a> 有时是不可避免和必要的错误。 我们如何以一种干净，模块化和可测试的方式将它们合并到我们的代码中？</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 </p></blockquote><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p></blockquote><h1 id="单例模式无处不在"><a href="#单例模式无处不在" class="headerlink" title="单例模式无处不在"></a><strong>单例模式无处不在</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 <code>Apple</code> 平台上，<code>Cocoa</code> 和 <code>Cocoa Touch</code> 框架中到处都有单例。 有 <code>UIApplication.shared</code>，<code>FileManager.default</code>，<code>NotificationCenter.default</code>，<code>UserDefaults.standard</code>，<code>URLSession.shared</code> 等。 设计模式甚至在 <code>Cocoa</code> 核心能力指南中都有自己的部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当你隐式引用这些（以及你自己的）单例时，将增加更改代码所需的工作量。 这也使测试代码变得困难或不可能，因为无法从使用它们的类之外更改或模拟这些单例。 这是你在iOS应用中都会看到的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentUser = <span class="type">CurrentUserManager</span>.shared.user</span><br><span class="line">        <span class="keyword">if</span> currentUser != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// do something with current user</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mySetting = <span class="type">UserDefaults</span>.standard.bool(forKey: <span class="string">"mySetting"</span>)</span><br><span class="line">        <span class="keyword">if</span> mySetting &#123;</span><br><span class="line">            <span class="comment">// do something with setting</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">URLSession</span>.shared.dataTask(with: <span class="type">URL</span>(string: <span class="string">"http://someResource"</span>)!) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// handle response</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这就是我所说 隐式引用 的意思-你只需在类中直接使用单例。 我们可以做得更好。 在Swift中，有一种轻量级，简便且影响小的方式来改善这一点。 Swift也使其使用起来更加优雅。</p><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简而言之，答案是 <a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener" title="依赖注入"><strong>依赖注入</strong></a> 。 该原则表明你应该设计类和函数，以使所有输入都是显式的。 如果你重构上面的代码片段以使用依赖项注入，它将看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> userManager: <span class="type">CurrentUserManager</span></span><br><span class="line">    <span class="keyword">let</span> defaults: <span class="type">UserDefaults</span></span><br><span class="line">    <span class="keyword">let</span> urlSession: <span class="type">URLSession</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userManager: <span class="type">CurrentUserManager</span>, defaults: <span class="type">UserDefaults</span>, urlSession: <span class="type">URLSession</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">        <span class="keyword">self</span>.defaults = defaults</span><br><span class="line">        <span class="keyword">self</span>.urlSession = urlSession</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentUser = userManager.user</span><br><span class="line">        <span class="keyword">if</span> currentUser != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// do something with current user</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mySetting = defaults.bool(forKey: <span class="string">"mySetting"</span>)</span><br><span class="line">        <span class="keyword">if</span> mySetting &#123;</span><br><span class="line">            <span class="comment">// do something with setting</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        urlSession.dataTask(with: <span class="type">URL</span>(string: <span class="string">"http://someResource"</span>)!) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// handle response</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此类不再隐式（或显式）依赖于任何单例。 它显式依赖于 <code>CurrentUserManager</code>， <code>UserDefaults</code> 和 <code>URLSession</code> ，但是有关这些依赖项的任何内容均表示它们是单例。 这个细节不再重要，但是功能保持不变。 视图控制器仅知道这些对象的实例存在。 在需要使用该对象时，你可以传递单例。 同样，从类的角度来看，此细节无关紧要。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>(userManager: .shared, defaults: .standard, urlSession: .shared)</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p><strong>特别提示：<code>Swift</code> 类型推断在这里起作用。 除了编写 <code>URLSession.shared</code>，您还可以编写 <code>.shared</code> 。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你需要提供其他默认值（例如，如果你需要与<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW6" target="_blank" rel="noopener" title="应用组内共享数据">应用组共享数据</a>），则更改起来很容易。 实际上，你不必更改此类中的任何代码。 而不传递 <code>UserDefaults.standard</code>，而是传递 <code>UserDefaults（suiteName：“ com.myApp”）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，在单元测试中，你现在可以传递这些类的其他实例。 在Swift中无法进行真正的模拟，但是有一些解决方法。 这取决于您要如何构造代码。 你可以为 <code>CurrentUserManager</code> 使用协议，然后可以在测试中“模拟”该协议。 你可以为 <code>UserDefaults</code> 提供构造的方法类进行测试。 你可以将 <code>URLSession</code> 设置为可选，并在测试中传递 <code>nil</code>。</p><h1 id="重构陷阱"><a href="#重构陷阱" class="headerlink" title="重构陷阱"></a><strong>重构陷阱</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能对这个想法很感兴趣，现在你想解开并解放陷入困境的代码库。尽管依赖注入是理想的选择，并且可以为你提供更纯净的对象模型，但是实现它通常很困难。更重要的是，在首次编写代码时，很少会设计出适应这种情况的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们上面重构的内容现在更具模块化和可测试性-但确实存在问题。 <code>MyViewController</code> 的初始值设定项曾经是空的 <code>（init（））</code> ，但现在需要三个参数。每个调用位置都必须更改。构造此方法的干净而正确的方法是将实例从上到下或从以前的视图控制器传递到此实例。这将需要将数据从对象图的根传递到所有子类。特别是在iOS中，当你将数据从视图控制器传递到视图控制器时，这可能会引起很多麻烦。尤其是传统代码库将难以立即实现如此大的更改。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大多数类（尤其是视图控制器）的初始化程序都需要更改。当你意识到必须重构整个应用程序时，这种更改变得异常困难。要么一切都将被破坏，要么仅某些类将被更新以进行依赖注入，而其他一些类将继续隐式引用单例。这种不一致可能在将来引起问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在复杂、大型的旧版代码库中，这样的重构可能根本不可行-至少不能同时进行，而且也不能没有回归。因此，你可能会争辩说，你根本不应该重构并忍受这种情况。然后需要几个月或几年的时间你您必须支持多个用户-现在在实现切换帐户时 <code>CurrentUserManager</code> 无法正常工作。你如何应对？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一种更为先进的方式，也有一种从一开始就设计你要使用的类以适应下一次此类变化的方法。</p><h1 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a><strong>默认参数值</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最喜欢的Swift功能之一是默认参数值。 它们非常有用，可以为你的代码带来很大的灵活性。 使用默认参数，你可以解决上述问题，而不必担心依赖注入问题，也不会在代码库中引入过多的复杂性。 也许你的应用程序实际上只有一个用户，所以实现所有这种依赖注入是不必要的开销。</p><p>你可以给单例设置默认参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userManager: <span class="type">CurrentUserManager</span> = .shared, defaults: <span class="type">UserDefaults</span> = .standard, urlSession: <span class="type">URLSession</span> = .shared) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">        <span class="keyword">self</span>.defaults = defaults</span><br><span class="line">        <span class="keyword">self</span>.urlSession = urlSession</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，从方法调用的角度来看，初始化程序没有改变。 但是类本身存在很大的差异，它现在使用依赖项注入，不再引用单例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>()</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你从此更改中学到了什么？你可以使用此模式重构每个类，而无需更新任何调用的地方。语义上或功能上都没有改变。但是，你的类也在使用依赖注入。他们只是在内部使用实例。你可以如上所述测试它们并维护一个灵活的模块化API，同时公共接口保持不变。本质上，你可以继续在代码库中工作，就好像什么都没有改变一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有时间传入自定义非空参数，你可以执行此操作而无需更改任何类。你只需要更新调用的位置即可。此外，如果你决定使用成熟的依赖关系注入并从上至下传递每个单个依赖关系，则只需删除默认参数并从上方传递依赖关系。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要，你甚至可以选择加入或选择退出任何默认值。在以下示例中，我们提供了自定义 <code>UserDefaults</code>，但保留了 <code>CurrentUserManager</code> 和 <code>URLSession</code> 的默认参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appGroupDefaults = <span class="type">UserDefaults</span>(suiteName: <span class="string">"com.myApp"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>(defaults: appGroupDefaults)</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></bar><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 使这种“部分”依赖注入变得很方便实用。通过为类添加新属性和带有默认值的初始化参数，你可以使你的代码具有更大的模块化和可测试性，而不必重构，也不必完全使用成熟的依赖项注入。如果从一开始就设计这样的类，那么你会发现自己写出 <code>bug</code> 的概率降低了很多-当你遇到 <code>bug</code> 是，将更容易定位和解决。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 除了此处的简单示例（类，结构，枚举，函数）之外，你还可以将这些概念和设计应用于代码的所有区域。 <code>Swift</code> 中的每个函数都可以采用默认参数值。通过花一些时间来思考未来可能发生的变化，我们可以创建可以轻松适应变化的类型和功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 构建和设计好的软件意味着编写<strong>易于更改</strong>但<strong>难以破解的代码</strong>。这就是依赖项注入的动机，而 <code>Swift</code> 的默认参数可以帮助你快速，轻松且优雅地实现这一目标。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;清洁，模块化和可测试代码库的小技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在软件开发中，不鼓励使用单例，并且对此表示反对，但这是有充分理由的。 它们很难测试或无法测试，并且在其他类中隐式使用它们时会纠缠你的代码库，从而使代码重用变得困难。 在大多数情况下，单例模式无非是对全局易变状态的保存。 每个人至少知道这是一个糟糕的主意。 但是，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;单例模式&quot;&gt;单例模式&lt;/a&gt; 有时是不可避免和必要的错误。 我们如何以一种干净，模块化和可测试的方式将它们合并到我们的代码中？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="单例模式" scheme="http://www.xuebaonline.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Swift单例模式</title>
    <link href="http://www.xuebaonline.com/Swift%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/Swift%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T02:13:37.000Z</published>
    <updated>2020-04-25T03:13:50.738Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Singleto</code>n 是有史以来最受争议的设计模式。了解在 <code>iOS</code> 项目中使用 <code>Swift</code> 单例类的正确方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每个人都在批评的单例模式，大多数人都将其称为反模式。但是单例模式到底是什么，为什么这么差呢？</p><a id="more"></a><h1 id="Singleton-是什么"><a href="#Singleton-是什么" class="headerlink" title="Singleton 是什么?"></a><strong>Singleton 是什么?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于简单，这是一种非常流行且普遍采用的模式。在整个应用程序生命周期中，单例类只能有一个实例。单个实例只能通过静态属性访问，并且初始化后的对象通常在全局范围内共享。这就像一个全局变量。 🌏</p><h1 id="全局变量和状态"><a href="#全局变量和状态" class="headerlink" title="全局变量和状态"></a><strong>全局变量和状态</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式的声誉很差，因为他们共享全局可变的状态。即使在经验丰富的开发人员圈子中，始终会担心使用 <code>global</code> 关键字。全局状态和变量是副作用的温床。可以从程序的任何位置访问全局变量，因此使用它们的类将变为有状态，不安全，紧密耦合且难以调试。出于明显的原因，通过这种方式与对象共享状态不是一个好习惯。 🤮</p><h1 id="Singleton-的副作用"><a href="#Singleton-的副作用" class="headerlink" title="Singleton 的副作用"></a><strong>Singleton 的副作用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你应该尽可能确定范围和隔离变量，并最大程度地减少代码的状态性。这将消除副作用，使您的代码更安全地使用。考虑以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// method is written by someone else</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    global = x</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">global = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> result = square(<span class="number">5</span>)</span><br><span class="line">result += global <span class="comment">//we assume that global is 1</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">//wtf 30 it should be 26</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>square</code> 方法由其他人编写，由于某种原因，他们希望将输入存储在相同的全局变量中。现在，当您调用该函数时，除非您查看他的代码，否则您将一无所获。想象一下，在一个由多个代码作者编写的具有大量oop类的项目中的此类问题……GOOD LUCK! 🐛🐛🐛</p><h1 id="单例对象的生命周期"><a href="#单例对象的生命周期" class="headerlink" title="单例对象的生命周期"></a><strong>单例对象的生命周期</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 单例创建一次并永久存在，它们的工作几乎就像全局变量一样，这就是为什么你必须格外小心。你应该仅使用在应用程序整个生命周期内都能维持的单例状态来管理这些状态。例如，特定于用户的会话通常是不好的做法，你应该重新考虑设计。另外，默认情况下，Swift也不是线程安全的，因此，如果你使用单例，则还必须为多线程问题做好准备。但是，如果它们因此造成问题，我们难道不应该完全避免它们吗？答案是不。 🚫</p><h1 id="我们应该在什么时候使用单例类"><a href="#我们应该在什么时候使用单例类" class="headerlink" title="我们应该在什么时候使用单例类"></a><strong>我们应该在什么时候使用单例类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>UIApplication</code> 很可能是单例的，因为应该只有一个应用程序实例，并且该实例应该一直存在，直到你将其关闭为止。这就是单例的完美例子。另一个用例可以是 <code>Logger</code> 类。使用单例是安全的，因为无论记录器是否打开，你的应用程序的行为都不会有所不同。没有其他人会拥有或管理记录器，并且你只会将信息传递到记录器中，因此状态不会混乱。<strong>结论：对于单例模式的使用，控制台或记录器类是完全可以接受的方案。</strong> 👏</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Console</span>.<span class="keyword">default</span>.notice(<span class="string">"Hello I'm a singleton!"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apple 框架中有很多“单一”（并非一切都是真正的单例对象）用例，这是一个简短列表，因此您可以从中获得一些启发：</p><ul><li>HTTPCookieStorage.shared</li><li>URLCredentialStorage.shared</li><li>URLSessionConfiguration.default</li><li>URLSession.shared</li><li>FileManager.default</li><li>Bundle.main</li><li>UserDefaults.standard</li><li>NotificationCenter.default</li><li>UIScreen.main</li><li>UIDevice.current</li><li>UIApplication.shared</li><li>MPMusicPlayerController.systemMusicPlayer</li><li>GKLocalPlayer.localPlayer（）</li><li>SKPaymentQueue.default（）</li><li>WCSession.default</li><li>CKContainer.default（）</li><li>etc</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经看到许多管理器类以单例形式实现，例如网络，位置或核心数据管理器，但是这些对象通常不应该是单例，仅仅是因为它可以是多个单例。 💩</p><p><strong>单例模式可能非常有用，但应谨慎使用。</strong></p><p>如果要将某个类变成单例，请问自己以下问题：</p><ul><li>还有其他任何东西拥有，管理或负责吗？</li><li>是否将只有一个实例？</li><li>它会是一个全局状态变量吗？</li><li>我真的应该使用全局共享对象吗？</li><li>是否应该贯穿整个应用程序生命周期？</li><li>有其他选择吗？</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果以上所有内容的答案都是肯定的，那么您可以“安全地”使用单例或全局变量来存储数据。 🎉🎉🎉</p><h1 id="如何使用Swift创建一个单例"><a href="#如何使用Swift创建一个单例" class="headerlink" title="如何使用Swift创建一个单例?"></a><strong>如何使用Swift创建一个单例?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建单例对象确实很容易，但是在应用此设计模式之前，请务必三思而后行，并考虑其他选择。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Singleton</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// don't forget to make this private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> singleton = <span class="type">Singleton</span>.shared</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，我总是创建一个特定的单例对象，称为App。通过这种方式，我可以将与应用程序相关的全局状态属性连接到那个单例中。命名约定也有助于关联和理解其中的内容。 💡</p><h1 id="如何消除单例"><a href="#如何消除单例" class="headerlink" title="如何消除单例?"></a><strong>如何消除单例?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果还有其他方法，则应在大约90％的情况下使用该方法。单例模式最常见的替代解决方案是依赖注入。首先，你应该将单例方法抽象为协议，然后，如果仍然需要，可以将其用作默认实现。现在，您可以将单例或<a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/" title="重构对象">重构的对象</a>注入正确的位置。这样，你的代码就可以使用协议的模拟对象进行测试，甚至可以忽略单例本身。 😎</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">DataCompletionBlock</span> = (<span class="type">Data?</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. abstract away the required functions</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. make your "singleton" conform to the protocol</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSession</span>: <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> task = <span class="keyword">self</span>.dataTask(with: request) &#123; data, <span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            completionHandler(data)</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> session: <span class="type">Session</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. using dependency injection with the "singleton" object</span></span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">Session</span> = <span class="type">URLSession</span>.shared) &#123;</span><br><span class="line">        <span class="keyword">self</span>.session = session</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(<span class="number">_</span> request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.session.make(request: request, completionHandler: completionHandler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. create mock object</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockedSession</span>: <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        completionHandler(<span class="string">"Mocked data response"</span>.data(using: .utf8))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. write your tests</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> api = <span class="type">ApiService</span>(session: <span class="type">MockedSession</span>())</span><br><span class="line">    <span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)!)</span><br><span class="line">    api.load(request) &#123; data <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(data: data!, encoding: .utf8)!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像你看到的，单例模式非常容易实现，但是很难决定其应用程序形式。我并不是说这是一种反模式，因为显然不是这样，但是如果你打算使用单例模式，请当心。 😉</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Singleto&lt;/code&gt;n 是有史以来最受争议的设计模式。了解在 &lt;code&gt;iOS&lt;/code&gt; 项目中使用 &lt;code&gt;Swift&lt;/code&gt; 单例类的正确方法。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 每个人都在批评的单例模式，大多数人都将其称为反模式。但是单例模式到底是什么，为什么这么差呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="单例模式" scheme="http://www.xuebaonline.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>NSCODER和SWIFT初始化</title>
    <link href="http://www.xuebaonline.com/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://www.xuebaonline.com/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2020-04-25T01:36:42.000Z</published>
    <updated>2020-04-25T01:53:24.699Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您正在使用 <code>Swift</code> 并想对实现 <code>NSCoding</code> 的东西进行子类化（例如 <code>UIView</code>，<code>UIViewController</code> 等），则可能会遇到麻烦的情况。即，<code>NSCoding</code> 协议需要 <code>init(coder：aDecoder)</code> 初始化程序，这意味着如果你为超类重写了指定的初始化程序，则需要实现该初始化程序。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那就好了，但是 <code>Swift</code> 在确保对类的所有属性进行超级严格的调用之前，都要确保在 <code>init()</code> 中分配了一个值。这意味着，如果您想提供自己的初始化程序，则无法执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    name = <span class="string">"Bar"</span></span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle:<span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>init（coder :)</code> 初始值设定项未设置 <code>name</code> 属性，因此不会进行编译。你可以在两个初始值设定项中都重复初始化和设置名称，但是当你在init中进行了很多工作时，这很糟糕（如果希望尽可能避免使用可选属性，则应该这样做）。</p><p>在 Objective-C 中，如果要在多个 <code>init</code> 方法之间共享初始化逻辑，则只需定义一个通用的 <strong>“setup”</strong> 方法即可执行所有共享的东西，并从两个初始化器中调用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype) <span class="keyword">init</span> &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span> <span class="keyword">self</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype) initWithCoder:(<span class="type">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span> <span class="keyword">self</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) setup &#123;</span><br><span class="line">  <span class="keyword">self</span>.name = @<span class="string">"Foo"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  这种方式不会立即就创建出你想要的对象。问题在于，在这两个初始化程序中，我们都在调用    <code>[super init]</code> 之前，先给 <code>self.name</code> 分配了一个值，但这在 <code>Swift</code> 语法中是不可行的。我们也不能将对 <code>self.setup</code> 的调用移到对 <code>super.init（）</code> 的调用之上，因为在类通过调用 <code>super.init（）</code> 完全初始化之后，才允许您引用 <code>self</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  那么，如何将这只鸡从鸡蛋中取出并放到盘子上呢？好吧，我们要等到初始化后才能对 <code>self</code> 调用方法，但是只要我们从 <strong>“convienience”</strong> 初始化程序中调用它，就可以调用另一个 <code>init</code> 。仅通过示例进行解释可能更容易：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> coder: <span class="type">NSCoder?</span> = <span class="literal">nil</span>) &#123;</span><br><span class="line">    name = <span class="string">"Bar"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> coder = coder &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle:<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(coder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在指定的初始化程序中添加了一个可选的 <code>NSCoder</code> 参数，并将其默认设置为 <code>nil</code> ，因此我们仍然可以像以前一样在没有任何参数的情况下调用它。但是，现在已将<code>NSCoding</code> 协议中要求的 <code>init（coder :)</code> 初始值设定项标记为<strong>convienience</strong>，这意味着它可以调用指定的初始值设定项并传入编码器。</p><p>在指定的 <code>init</code> 中，我们检查 <code>coder</code> 是否为非 <code>nil</code> （如果让coder = conditional为条件），如果是，则调用 <code>super.init（coder :)</code> 。如果为 <code>nil</code>，我们将执行本来应该做的事情，并调用 <code>super.init（nibName：nil，bundle：nil）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，编译器很高兴在调用 <code>super.init（）</code> 之前为属性分配值，并且可以将初始化逻辑放在一个地方。如果要在情节提要中使用 <code>ViewController</code> ，则框架将调用init（coder :)，如果要以编程方式创建一个，则可以说 <code>let fooVC = FooViewController（）</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果您正在使用 &lt;code&gt;Swift&lt;/code&gt; 并想对实现 &lt;code&gt;NSCoding&lt;/code&gt; 的东西进行子类化（例如 &lt;code&gt;UIView&lt;/code&gt;，&lt;code&gt;UIViewController&lt;/code&gt; 等），则可能会遇到麻烦的情况。即，&lt;code&gt;NSCoding&lt;/code&gt; 协议需要 &lt;code&gt;init(coder：aDecoder)&lt;/code&gt; 初始化程序，这意味着如果你为超类重写了指定的初始化程序，则需要实现该初始化程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>UIKit初始化模式</title>
    <link href="http://www.xuebaonline.com/UIKit%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuebaonline.com/UIKit%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T00:05:14.000Z</published>
    <updated>2020-04-25T02:12:15.476Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>了解UIKit中两个常用类的初始化过程。了解UIViewcontroller和UIView初始化模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIKit</code> 是在iOS开发过程中必须也是使用频次最高的一个类库，里面包含了许多与用户直接交互的控件比如：<code>UIView</code>, <code>UITableView</code>, <code>UIScrollView</code> 等。在收到用户交互的设计图之后，我们要合理的使用这些控件，就能编写出交互良好的应用。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了类库中包含的基础控件之外，我们也能够对控件根据业务需要进行整合，也就是设计出一套适用于本公司的组件，提高开发速度。</p><h1 id="UIViewController-初始化"><a href="#UIViewController-初始化" class="headerlink" title="UIViewController 初始化"></a><strong>UIViewController 初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，<code>UIViewController</code> 的初始化非常简单。如果要完全控制，则只需要重写一些方法。这取决于你使用何种方式调用 <code>init</code> ，如果你使用一个 <code>storyboard</code> 初始化控制器，那么 <a href="http://www.xuebaonline.com/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/" title="NSCODER和SWIFT初始化">init(coder)</a> 是你所需要的。如果你尝试从外部 <code>nib</code> 文件启动控制器，则将调用 <code>init（nib，bundle）</code> 。你还有第三个选择，你可以通过代码以编程方式初始化控制器。简而言之，为了进行合理的初始化过程，这是你必须要做的。</p></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍两种 <code>UIViewControllers</code> 的初始化模式，第一种只是一个常见的init函数，在每种情况下都可以调用该函数来初始化控制器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(nibName nibNameOrNil: <span class="type">String?</span>, bundle nibBundleOrNil: <span class="type">Bundle?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do your stuff here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以在之后的子类中隐藏 <code>init（nib，bundle）</code> 和 <code>init（coder）</code> 方法。在子类中不必重写 <code>init（nib，bundle）</code>，并且可以将 <code>init（coder）</code> 标记为默认初始化程序。这个似乎是有点棘手的解决方案，使用起来不是很方便，但确实可以完成 <code>ViewController</code> 的初始化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do your stuff here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFutureViewController</span>: <span class="title">ViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> vc = <span class="type">MyFutureViewController</span>()</span><br></pre></td></tr></table></figure><hr></br><h1 id="UIView-初始化"><a href="#UIView-初始化" class="headerlink" title="UIView 初始化"></a><strong>UIView 初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通常为 <code>UIView</code> 创建一个通用的初始化程序，以使初始化过程更加轻松，使用起来更加方便。还会在该初始值设定项方法中将 <code>translate autoresizing mask</code> 属性设置为 <code>false</code> ，因为它是2017年，没有人再使用 <code>spring＆struts</code> 了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用自动布局助手也很不错，如果你想从nib文件中初始化视图，那么有一些便利的方法也很好。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(autolayout: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(autolayout: Bool = <span class="literal">true</span>)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _self = <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">let</span> view  = _self <span class="keyword">as</span> <span class="type">UIView</span></span><br><span class="line">        view.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">        <span class="keyword">return</span> _self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">createFromNib</span><span class="params">(owner: <span class="keyword">Any</span>? = <span class="literal">nil</span>, options: [AnyHashable: <span class="keyword">Any</span>]? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Bundle</span>.main.loadNibNamed(<span class="type">String</span>(describing: <span class="keyword">self</span>), owner: owner, options: options)?.last <span class="keyword">as</span>! <span class="type">UIView</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> view = <span class="type">UIView</span>(autolayout: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>使用这些代码片段，为所有 <code>UIKit</code> 类维护一个合理的初始化过程确实很容易，因为其中大多数都是从这两个 “主要” 类派生的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;了解UIKit中两个常用类的初始化过程。了解UIViewcontroller和UIView初始化模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;UIKit&lt;/code&gt; 是在iOS开发过程中必须也是使用频次最高的一个类库，里面包含了许多与用户直接交互的控件比如：&lt;code&gt;UIView&lt;/code&gt;, &lt;code&gt;UITableView&lt;/code&gt;, &lt;code&gt;UIScrollView&lt;/code&gt; 等。在收到用户交互的设计图之后，我们要合理的使用这些控件，就能编写出交互良好的应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/categories/Swift/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/categories/UIKit/"/>
    
    
      <category term="iOS" scheme="http://www.xuebaonline.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.xuebaonline.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UIKit" scheme="http://www.xuebaonline.com/tags/UIKit/"/>
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>后端实践三:Ubuntu18.04安装Vapor4.0</title>
    <link href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89:Ubuntu18.04%E5%AE%89%E8%A3%85Vapor4.0/"/>
    <id>http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89:Ubuntu18.04%E5%AE%89%E8%A3%85Vapor4.0/</id>
    <published>2020-04-17T08:52:46.000Z</published>
    <updated>2020-04-25T01:11:06.910Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文章《<a href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/" title="后端实践二:Ubuntu18.04安装最新版Swift5.2">后端实践二:Ubuntu18.04安装最新版Swift5.2</a>》可以在 Ubuntu18.04 的服务器上顺利安装最新版本的 <code>Swift</code> 。我们参照 <a href="https://docs.vapor.codes/3.0/install/ubuntu/" target="_blank" rel="noopener">官网文档</a> 安装 <code>Vapor4.0</code> 的开发环境。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官网上的文档跟开发维护的速度有一定的版本误差，所以现在在官网上看到的安装方法是针对 <code>Vapor(&gt;3.0 &amp;&amp; &lt; 4.0)</code> 的版本。由于版本间差异比较大，在实践过程中，只会关注到 <code>Vapor(&gt;=4.0)</code> 以上版本的新特性。在创建工程和引入依赖库的过程中也会出现微小的差别，我们在后续的实践中会总结到。</p></blockquote><h1 id="验证-Swift-安装"><a href="#验证-Swift-安装" class="headerlink" title="验证 Swift 安装"></a><strong>验证 Swift 安装</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过访问 <code>Swift.org</code>，可以得到一份如何在 <code>Linux</code> 上安装 <code>Swift</code> 的文档。我们完成对 <code>Swift</code> 的安装之后，在终端中输入如下命令：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><a id="more"></a><p>如果在终端中输出如下信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Apple</span> <span class="type">Swift</span> version <span class="number">4.1</span>.<span class="number">0</span> (swiftlang-<span class="number">900.0</span>.<span class="number">69.2</span> clang-<span class="number">900.0</span>.<span class="number">38</span>)</span><br><span class="line"><span class="type">Target</span>: x86_64-apple-macosx10.<span class="number">9</span></span><br></pre></td></tr></table></figure><p>那么标识我们在 <code>Linux</code> 上成功安装 <code>Swift</code>。</p><h1 id="安装-Vapor-Toolbox"><a href="#安装-Vapor-Toolbox" class="headerlink" title="安装 Vapor Toolbox"></a><strong>安装 Vapor Toolbox</strong></h1><p>在 <code>Vapor 4.0</code> 发布之前，在 <code>Linux</code> 上安装，只需要在终端中敲入如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL apt.vapor.sh -o apt.vapor.sh</span><br></pre></td></tr></table></figure><p>这个执行安装的命令已经被废弃。</p><h2 id="Toolbox-源代码"><a href="#Toolbox-源代码" class="headerlink" title="Toolbox 源代码"></a><code>Toolbox</code> 源代码</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于之后的版本中，不在将该文件托管至软件源，所以我们在安装时需要做出如下操作获取到 <code>Toolbox</code> 源代码到本地文件夹中：</p><p>下载 <code>Toolbox</code> 源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vapor/toolbox.git</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-1stp.png" alt="Toolbox"></p><h2 id="编译-Vapor-可执行文件"><a href="#编译-Vapor-可执行文件" class="headerlink" title="编译 Vapor 可执行文件"></a>编译 <code>Vapor</code> 可执行文件</h2><p>进入到 <code>Toolbox</code> 工程的根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> toolbox/</span><br></pre></td></tr></table></figure><p>编译 <code>Toolbox</code>  发布版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build -<span class="built_in">c</span> release</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于获取的源代码中缺少部分文件，期间或存在报错发现 <code>Toolbox</code> 中没有 <code>LinuxMain.swift</code> 文件在 <code>Tests</code> 文件夹中，这时我们进入到 <code>XCTest</code> 文件夹中。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-2stp.png" alt="Vapor"></p><p>创建 <code>LinuxMain.swift</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch LinuxMain.swift</span><br></pre></td></tr></table></figure><p>编辑 <code>LinuxMain.swift</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim LinuxMain.swift</span><br></pre></td></tr></table></figure><p>向 <code>LinuxMain.swift</code> 文件中添加测试代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> AppTests</span><br><span class="line"></span><br><span class="line"><span class="type">XCTMain</span>([testCase(<span class="type">AppTests</span>.allTests)])</span><br></pre></td></tr></table></figure><p>保存修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq!</span><br></pre></td></tr></table></figure><p>重新执行如下命令，完成编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build -c release</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-3stp.png" alt="Vapor"></p><p>找到编译成功的 <code>Vapor</code> 文件</p><blockquote><p>执行完 <code>build</code> 命令之后，会在输出的文件中生成一个可执行的二进制文件。</p></blockquote><p>查找 <code>Vapor</code> 所在的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name vapor</span><br></pre></td></tr></table></figure><blockquote><p>这时会看到输出一个类似如下的文件夹 <code>.build/x86_64-unknown-linux/release/vapor</code> ,这个文件夹里就是我们要使用到的文件 <code>Vapor</code> 。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-4stp.png" alt="Vapor"></p><p>配置 <code>Vapor</code> 的环境变量</p><p>将包含可执行文件 <code>Vapor</code> 的文件目录添加在 <code>PATH</code> 中。</p><p>配置 <code>Vapor</code> 环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp vapor /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>验证是否配置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vapor --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-5stp.png" alt="Vaporhelp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此 <code>Vapor 4.0</code> 的环境配置已经完成。由于 <code>3.0</code> 和 <code>4.0</code> 版本差异比较大，在配置方面也有差异。在创建项目时更需要加上 <code>branch=4</code> 等。后续会加入：创建第一个 <code>Hello World</code> 工程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过文章《&lt;a href=&quot;http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/&quot; title=&quot;后端实践二:Ubuntu18.04安装最新版Swift5.2&quot;&gt;后端实践二:Ubuntu18.04安装最新版Swift5.2&lt;/a&gt;》可以在 Ubuntu18.04 的服务器上顺利安装最新版本的 &lt;code&gt;Swift&lt;/code&gt; 。我们参照 &lt;a href=&quot;https://docs.vapor.codes/3.0/install/ubuntu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网文档&lt;/a&gt; 安装 &lt;code&gt;Vapor4.0&lt;/code&gt; 的开发环境。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;官网上的文档跟开发维护的速度有一定的版本误差，所以现在在官网上看到的安装方法是针对 &lt;code&gt;Vapor(&amp;gt;3.0 &amp;amp;&amp;amp; &amp;lt; 4.0)&lt;/code&gt; 的版本。由于版本间差异比较大，在实践过程中，只会关注到 &lt;code&gt;Vapor(&amp;gt;=4.0)&lt;/code&gt; 以上版本的新特性。在创建工程和引入依赖库的过程中也会出现微小的差别，我们在后续的实践中会总结到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;验证-Swift-安装&quot;&gt;&lt;a href=&quot;#验证-Swift-安装&quot; class=&quot;headerlink&quot; title=&quot;验证 Swift 安装&quot;&gt;&lt;/a&gt;&lt;strong&gt;验证 Swift 安装&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们通过访问 &lt;code&gt;Swift.org&lt;/code&gt;，可以得到一份如何在 &lt;code&gt;Linux&lt;/code&gt; 上安装 &lt;code&gt;Swift&lt;/code&gt; 的文档。我们完成对 &lt;code&gt;Swift&lt;/code&gt; 的安装之后，在终端中输入如下命令：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/categories/Server/"/>
    
      <category term="Vapor4.0" scheme="http://www.xuebaonline.com/categories/Vapor4-0/"/>
    
      <category term="Ubuntu18.04" scheme="http://www.xuebaonline.com/categories/Ubuntu18-04/"/>
    
      <category term="Swift5.2" scheme="http://www.xuebaonline.com/categories/Swift5-2/"/>
    
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="Server" scheme="http://www.xuebaonline.com/tags/Server/"/>
    
      <category term="Ubuntu" scheme="http://www.xuebaonline.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>后端实践二:Ubuntu18.04安装最新版Swift5.2</title>
    <link href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/"/>
    <id>http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/</id>
    <published>2020-04-17T06:51:16.000Z</published>
    <updated>2020-04-25T01:06:57.345Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文章《<a href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/" title="后端实践一:开发环境搭建VMware下安装Ubuntu18.04">后端实践一:开发环境搭建VMware下安装Ubuntu18.04</a>》可以完成在  <code>mac</code> 上搭建起可用的 <code>Ubuntu 18.04</code> 的服务器。接下来我们要在此基础上完善 <code>Vapor 4.0</code> 的开发环境。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ubuntu 18.04 安装 Swift 5.2.2 ，可在 Vapor 官网的引导完成。这篇文章就是讲解如何完成在 Ubuntu 上安装最新版本 Swift，构建出一个强大的云端服务器。</p></blockquote><h1 id="Ubuntu-系统环境搭建"><a href="#Ubuntu-系统环境搭建" class="headerlink" title="Ubuntu 系统环境搭建"></a><strong><code>Ubuntu</code> 系统环境搭建</strong></h1><h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里使用的SecureCRT作为终端连接服务器，也可以使用 <code>iTerm2</code> 连接服务器。</p></blockquote><a id="more"></a><p>使用 <code>SecureCRT</code> 提供的远程登录功能连接 <code>Ubuntu</code> 服务器的配置信息：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-1stop.png" alt="SecureCRT"></p><p>使用 <code>SecureCRT</code> 终端使用系统自带的远程登录功能连接 <code>Ubuntu</code> 服务器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-2stp.png" alt="使用SecureCRT"></p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-3stp.png" alt="使用SecureCRT"></p><p>使用 <code>iTerm2</code> 终端使用系统自带的远程登录功能连接Ubuntu 服务器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-4stp.png" alt="iTerm2"></p><p>查看当前服务器系统版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><blockquote><p>Swift 依赖一些三方类库。</p></blockquote><p>必须安装的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install clang libicu-dev -y</span><br><span class="line">sudo apt-get install libcurl3 libpython2.7 libpython2.7-dev</span><br></pre></td></tr></table></figure><h2 id="安装-Swift"><a href="#安装-Swift" class="headerlink" title="安装 Swift"></a>安装 <code>Swift</code></h2><p>在 <a href="https://swift.org/download/#releases" target="_blank" rel="noopener">Swift.org</a> 查找我们要安装的Swift对应版本的Toolchain，复制下载链接。</p><blockquote><p>在写这篇文章时最新版的Swift是v5.2.2。</p></blockquote><p>找到对应系统以及对应版本<a href="https://swift.org/builds/swift-5.2.2-release/ubuntu1804/swift-5.2.2-RELEASE/swift-5.2.2-RELEASE-ubuntu18.04.tar.gz" target="_blank" rel="noopener">下载链接</a>：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-5stp.png" alt="下载链接"></p><p>可以采用两种下载方式：</p><ul><li>在本机上使用上方链接，下载 <code>Toolchain</code> ，上传到 <code>Ubuntu</code> 服务器上，完成后续安装；</li><li>在 <code>Ubuntu</code> 上使用 <code>wget url</code> 的方式直接在服务器上安装。</li></ul><p>接下来 使用  <code>wget url</code> 下载 <code>swift</code> 安装包，并解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://swift.org/builds/swift-5.2.2-release/ubuntu1804/swift-5.2.2-RELEASE/swift-5.2.2-RELEASE-ubuntu18.04.tar.gz</span><br></pre></td></tr></table></figure><p>解压 <code>swift</code> 到文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf swift-5.2.2-RELEASE-ubuntu18.04.tar.gz</span><br></pre></td></tr></table></figure><p>将解压的文件保存在 <code>share</code> 目录下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv swift-5.2.2-RELEASE-ubuntu18.04 /usr/share/swift</span><br></pre></td></tr></table></figure><h2 id="配置-Swift-环境变量"><a href="#配置-Swift-环境变量" class="headerlink" title="配置 Swift 环境变量"></a>配置 <code>Swift</code> 环境变量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成以上操作即完成了 <code>swift</code> 的的安装，为了更方便的使用 <code>Swift</code> ，需要配置其在全局任意目录下可使用。</p><p>配置 <code>Swift</code> 环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=/usr/share/swift/usr/bin:<span class="variable">$PATH</span>"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h2><p>检查当前系统的 <code>Swift</code> 版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift -version</span><br></pre></td></tr></table></figure><ul><li>如果出现 <code>Command &#39;swift&#39; not found ...</code> 该提示，关闭连接终端，重新连接服务器，再次执行上述命令。</li></ul><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-6stp.png" alt="installSuccess"></p><h1 id="运行-Swift-程序"><a href="#运行-Swift-程序" class="headerlink" title="运行 Swift 程序"></a><strong>运行 <code>Swift</code> 程序</strong></h1><h2 id="在终端运行程序，简单测试环境是否达建成功。"><a href="#在终端运行程序，简单测试环境是否达建成功。" class="headerlink" title="在终端运行程序，简单测试环境是否达建成功。"></a>在终端运行程序，简单测试环境是否达建成功。</h2><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift</span><br></pre></td></tr></table></figure><p>此时进入到终端界面。</p><p>编辑一段 <code>Swift</code> 程序代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>, b = <span class="number">13</span>, <span class="built_in">c</span> = a + b</span><br></pre></td></tr></table></figure><p>在终端输入以下命令退出编辑模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:exit</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-7stp.png" alt="Swift"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成 <code>Swift</code> 在 <code>Ubuntu</code> 环境下的配置，接下来可以配置 <code>Vapor 4.0</code> 的开发环境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过文章《&lt;a href=&quot;http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/&quot; title=&quot;后端实践一:开发环境搭建VMware下安装Ubuntu18.04&quot;&gt;后端实践一:开发环境搭建VMware下安装Ubuntu18.04&lt;/a&gt;》可以完成在  &lt;code&gt;mac&lt;/code&gt; 上搭建起可用的 &lt;code&gt;Ubuntu 18.04&lt;/code&gt; 的服务器。接下来我们要在此基础上完善 &lt;code&gt;Vapor 4.0&lt;/code&gt; 的开发环境。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Ubuntu 18.04 安装 Swift 5.2.2 ，可在 Vapor 官网的引导完成。这篇文章就是讲解如何完成在 Ubuntu 上安装最新版本 Swift，构建出一个强大的云端服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Ubuntu-系统环境搭建&quot;&gt;&lt;a href=&quot;#Ubuntu-系统环境搭建&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 系统环境搭建&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;code&gt;Ubuntu&lt;/code&gt; 系统环境搭建&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;连接服务器&quot;&gt;&lt;a href=&quot;#连接服务器&quot; class=&quot;headerlink&quot; title=&quot;连接服务器&quot;&gt;&lt;/a&gt;连接服务器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这里使用的SecureCRT作为终端连接服务器，也可以使用 &lt;code&gt;iTerm2&lt;/code&gt; 连接服务器。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/categories/Server/"/>
    
      <category term="Vapor4.0" scheme="http://www.xuebaonline.com/categories/Vapor4-0/"/>
    
      <category term="Ubuntu18.04" scheme="http://www.xuebaonline.com/categories/Ubuntu18-04/"/>
    
      <category term="Swift5.2" scheme="http://www.xuebaonline.com/categories/Swift5-2/"/>
    
    
      <category term="Swift" scheme="http://www.xuebaonline.com/tags/Swift/"/>
    
      <category term="Server" scheme="http://www.xuebaonline.com/tags/Server/"/>
    
      <category term="Ubuntu" scheme="http://www.xuebaonline.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04替换国内源</title>
    <link href="http://www.xuebaonline.com/Ubuntu18.04%E6%9B%BF%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"/>
    <id>http://www.xuebaonline.com/Ubuntu18.04%E6%9B%BF%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</id>
    <published>2020-04-17T04:58:13.000Z</published>
    <updated>2020-04-25T01:10:03.748Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再国内使用国外的软件源普遍会比较慢，但是国内也有很多的软件源可供选择。在修改软件源之前，查看系统软件源版本：</p><p><strong><em>查看版本：</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -c</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong><em>备份系统源配置文件：</em></strong></p><p>在修改之前要对系统的配置文件做好备份，这是个好习惯。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h1 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a><strong>阿里源</strong></h1><h2 id="更新源的配置文件"><a href="#更新源的配置文件" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multivers</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a><strong>中科大源</strong></h1><h2 id="更新源的配置文件-1"><a href="#更新源的配置文件-1" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="163源"><a href="#163源" class="headerlink" title="163源"></a><strong>163源</strong></h1><h2 id="更新源的配置文件-2"><a href="#更新源的配置文件-2" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-2"><a href="#更新-2" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a><strong>清华源</strong></h1><h2 id="更新源的配置文件-3"><a href="#更新源的配置文件-3" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-3"><a href="#更新-3" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Ubuntu18.04的配置中，更新了系统的软件源，国内源推荐使用清华源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;再国内使用国外的软件源普遍会比较慢，但是国内也有很多的软件源可供选择。在修改软件源之前，查看系统软件源版本：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;查看版本：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lsb_release -c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/categories/Server/"/>
    
      <category term="Vapor4.0" scheme="http://www.xuebaonline.com/categories/Vapor4-0/"/>
    
      <category term="Ubuntu18.04" scheme="http://www.xuebaonline.com/categories/Ubuntu18-04/"/>
    
      <category term="Ubuntu软件源" scheme="http://www.xuebaonline.com/categories/Ubuntu%E8%BD%AF%E4%BB%B6%E6%BA%90/"/>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/tags/Server/"/>
    
      <category term="Ubuntu" scheme="http://www.xuebaonline.com/tags/Ubuntu/"/>
    
      <category term="VMware" scheme="http://www.xuebaonline.com/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>后端实践一:开发环境搭建VMware下安装Ubuntu18.04</title>
    <link href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/"/>
    <id>http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/</id>
    <published>2020-04-17T01:17:13.000Z</published>
    <updated>2020-04-25T01:08:41.946Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Mac</code> 环境下使用 <code>VMware</code> 安装 <code>Ubuntu 18.04</code> 的主要目的是用于对后端开发框架：<code>Vapor 4.0</code> 的实践。由于 <code>Vapor 4.0</code> 框架支持 <code>MacOS</code> 和 <code>Ubuntu</code> ，所以实践时间，以使用 <code>Ubuntu</code> 为主。</p><a id="more"></a><blockquote><p>VMware  的下载和安装这里就不在赘述，自行下载安装即可。</p></blockquote><h1 id="下载-Ubuntu-的-ISO-文件"><a href="#下载-Ubuntu-的-ISO-文件" class="headerlink" title="下载 Ubuntu 的 ISO 文件"></a><strong>下载 <code>Ubuntu</code> 的 <code>ISO</code> 文件</strong></h1><h2 id="国内有很多镜像源，这里选用网易的镜像源。"><a href="#国内有很多镜像源，这里选用网易的镜像源。" class="headerlink" title="国内有很多镜像源，这里选用网易的镜像源。"></a>国内有很多镜像源，这里选用<a href="http://mirrors.163.com/ubuntu-releases/" target="_blank" rel="noopener" title="网易的镜像源">网易的镜像源</a>。</h2><p>这里建议使用 <code>Ubuntu 18.04</code> 版本，按照图示下载即可。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/163-source.png" alt="网易镜像源"></p><p>本次安装中使用的镜像为：<a href="http://mirrors.163.com/ubuntu-releases/18.04/ubuntu-18.04.4-live-server-amd64.iso" target="_blank" rel="noopener" title="Ubuntu18.04"><code>ubuntu-18.04.4-live-server-amd64.iso</code></a>。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/Ubuntu-1804-server.png" alt="Ubuntu1804"></p><h1 id="VMware-虚拟机配置"><a href="#VMware-虚拟机配置" class="headerlink" title="VMware 虚拟机配置"></a><strong><code>VMware</code> 虚拟机配置</strong></h1><p>在使用 <code>VMware</code> 安装 <code>Ubuntu</code>虚拟机时，按照引导安装即可。</p><h2 id="打开-VMware-软件"><a href="#打开-VMware-软件" class="headerlink" title="打开 VMware 软件"></a>打开 <code>VMware</code> 软件</h2><blockquote><p>根据提示我们在准备安装时，选择<strong>自定义安装</strong>。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-1stp.png" alt="自定义安装"></p><h2 id="选择虚拟的操作系统"><a href="#选择虚拟的操作系统" class="headerlink" title="选择虚拟的操作系统"></a>选择虚拟的操作系统</h2><p>这里选择 <code>Linux</code> -&gt; <code>Ubuntu</code> 64位。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们下载的系统就是 <code>Ubuntu 18.04</code> 64位。还有很重要的一点，因为安装这个操作系统的目的是作为 <code>Vapor 4.0</code> 的服务器，所以在选用操作系统时，我们不需要图形界面。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-2stp.png" alt="选择操作系统类型"></p><h2 id="选择固件类型"><a href="#选择固件类型" class="headerlink" title="选择固件类型"></a>选择固件类型</h2><p>选择固件类型其实就是选择磁盘引导方式。</p><blockquote><p>相对这两种方式进一步了解，可自行查资料。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-3stp.png" alt="选择引导方式"></p><h2 id="选择虚拟磁盘"><a href="#选择虚拟磁盘" class="headerlink" title="选择虚拟磁盘"></a>选择虚拟磁盘</h2><p>选择虚拟磁盘为虚拟操作系统在本机上开辟操作磁盘的空间。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为不会再虚拟机上做比较大的文件操作， <code>20G</code> 的磁盘空间已经够用。在开辟磁盘空间时，开辟的是空间使用上限，在虚拟操作系统文件所占用的空间以实际使用为准，并不是开辟了多少，就是用多少。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-4stp.png" alt="选择虚拟磁盘"></p><h2 id="完成配置"><a href="#完成配置" class="headerlink" title="完成配置"></a>完成配置</h2><p>点击继续即可完成虚拟机配置。</p><blockquote><p>虚拟机配置采用 <code>VMWare</code> 提供的默认配置即可，不用过多的操作。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-5stp.png" alt="完成配置"></p><h2 id="保存虚拟机文件"><a href="#保存虚拟机文件" class="headerlink" title="保存虚拟机文件"></a>保存虚拟机文件</h2><p>点击保存将虚拟机文件保存在默认文件夹中。</p><blockquote><p>文件的保存位置可以是默认位置，也可以是自定义的位置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-6stp.png" alt="完成配置"></p><h1 id="安装-Ubuntu-18-04"><a href="#安装-Ubuntu-18-04" class="headerlink" title="安装 Ubuntu 18.04"></a><strong>安装 <code>Ubuntu 18.04</code></strong></h1><p>在使用 <code>VMware</code> 完成对 <code>Ubuntu</code>虚拟机配置时，即会进入系统的安装界面。</p><h2 id="开启-CD-DVD-，并选取镜像"><a href="#开启-CD-DVD-，并选取镜像" class="headerlink" title="开启 CD/DVD ，并选取镜像"></a>开启 <code>CD/DVD</code> ，并选取镜像</h2><p>在完成对虚拟机配置之后，进入到引导界面，开启 <code>CD/DVD</code> ，并加载镜像。</p><blockquote><p>因为启动时未加载系统镜像，所在期初会出现引导出错的问题。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-7stp.png" alt="引导失败"></p><blockquote><p>开启CD/DVD，并加载镜像。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-8stp.png" alt="加载镜像"></p><h2 id="选择系统引导语言"><a href="#选择系统引导语言" class="headerlink" title="选择系统引导语言"></a>选择系统引导语言</h2><p>镜像加载完成，选择系统引导语言的默认语言。</p><blockquote><p>安装系统的提示比较简单，也见名知意，所以在安装的全过程，我们均会使用英文完成安装。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-9stp.png" alt="选择系统引导语言"></p><h2 id="选择系统语言"><a href="#选择系统语言" class="headerlink" title="选择系统语言"></a>选择系统语言</h2><p>镜像加载完成，选择操作系统的默认语言。</p><blockquote><p>因为是作为服务器使用，为了避免以后因为字符编码上造成不必要的麻烦，这里选择英文。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-10stp.png" alt="选择系统语言"></p><h2 id="选择键盘布局"><a href="#选择键盘布局" class="headerlink" title="选择键盘布局"></a>选择键盘布局</h2><p>选择键盘布局默认选择英文键盘。</p><blockquote><p>键盘布局选择英文，大部分的笔记本、台式电脑键盘采用英文布局。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-11stp.png" alt="选择键盘布局"></p><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>网络设置主要是设置操作系统的网络链接方式，这里采用默认跟随本机网络变化。</p><blockquote><p>因为是在虚拟软件中使用操作系统，网络配置采用默认配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-12stp.png" alt="网络设置"></p><h2 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h2><p>系统需要一个代理接口联网，默认网络链接走本机。</p><blockquote><p>代理网络可以设置链接特定的网络中，比如公司内网。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-13stp.png" alt="代理设置"></p><h2 id="设置系统镜像"><a href="#设置系统镜像" class="headerlink" title="设置系统镜像"></a>设置系统镜像</h2><p>这里的镜像是软件包的镜像源。</p><blockquote><p>在安装的过程中使用默认的软件包镜像源，后续推荐替换的国内镜像。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-14stp.png" alt="设置系统镜像"></p><h2 id="设置文件系统"><a href="#设置文件系统" class="headerlink" title="设置文件系统"></a>设置文件系统</h2><p>文件系统设置采用默认设置。</p><blockquote><p>选取使用整个磁盘空间。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-15stp.png" alt="设置文件系统"></p><blockquote><p>文件系统采用系统推荐的默认方式配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-16stp.png" alt="设置文件系统"></p><blockquote><p>文件系统分区采用默认的分区方式。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-17stp.png" alt="设置文件系统"></p><h2 id="个人信息设置"><a href="#个人信息设置" class="headerlink" title="个人信息设置"></a>个人信息设置</h2><p>个人信息设置主要是设置 <code>root</code> 账户密码，服务器名称，登录账户及密码。</p><blockquote><p>完成设置信息之后，建议对该信息进行备份保存。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-18stp.png" alt="个人信息设置"></p><h2 id="OpenSSH-设置"><a href="#OpenSSH-设置" class="headerlink" title="OpenSSH 设置"></a><code>OpenSSH</code> 设置</h2><p>OpenSSH可是系统支持远程登录，远程操作。</p><blockquote><p>建议安装，在以后的操作中会比较方便，远程操作软件推荐 <code>SecureCRT</code> 。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-19stp.png" alt="OpenSSH设置"></p><h2 id="服务软件"><a href="#服务软件" class="headerlink" title="服务软件"></a>服务软件</h2><p>这里可以选择性的安装。</p><blockquote><p>针对自己想用的软件进行安装，建议用到什么安装什么。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-20stp.png" alt="服务软件一览"></p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>完成所有的配置之后，系统机会进入安装界面，安装过程比较久。</p><blockquote><p>系统安装时间会长一些，具体看各自电脑配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-21stp.png" alt="安装系统"></p><h1 id="登录-Ubuntu18-04"><a href="#登录-Ubuntu18-04" class="headerlink" title="登录 Ubuntu18.04"></a><strong>登录 <code>Ubuntu18.04</code></strong></h1><p>完成安装之后，系统就会进入终端，输入用户名和密码进入系统。</p><h2 id="输入用户信息"><a href="#输入用户信息" class="headerlink" title="输入用户信息"></a>输入用户信息</h2><p>输入用户名和密码，按照提示输入。</p><blockquote><p>在 <code>2.9</code> 中的用户信息，就是需要的登录信息。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-22stp.png" alt="输入用户信息"></p><blockquote><p>成功进入 <code>Ubuntu</code> 系统中。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-23stp.png" alt="输入用户信息"></p><h1 id="Ubuntu-18-04-个性化配置"><a href="#Ubuntu-18-04-个性化配置" class="headerlink" title="Ubuntu 18.04 个性化配置"></a><strong><code>Ubuntu 18.04</code> 个性化配置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后续会加入一些实用的小技巧：国内的软件源，远程登录、配置数据库、安装 <code>Vapor 4.0</code> 开发环境等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Mac&lt;/code&gt; 环境下使用 &lt;code&gt;VMware&lt;/code&gt; 安装 &lt;code&gt;Ubuntu 18.04&lt;/code&gt; 的主要目的是用于对后端开发框架：&lt;code&gt;Vapor 4.0&lt;/code&gt; 的实践。由于 &lt;code&gt;Vapor 4.0&lt;/code&gt; 框架支持 &lt;code&gt;MacOS&lt;/code&gt; 和 &lt;code&gt;Ubuntu&lt;/code&gt; ，所以实践时间，以使用 &lt;code&gt;Ubuntu&lt;/code&gt; 为主。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/categories/Server/"/>
    
      <category term="Vapor4.0" scheme="http://www.xuebaonline.com/categories/Vapor4-0/"/>
    
    
      <category term="Server" scheme="http://www.xuebaonline.com/tags/Server/"/>
    
      <category term="Ubuntu" scheme="http://www.xuebaonline.com/tags/Ubuntu/"/>
    
      <category term="VMware" scheme="http://www.xuebaonline.com/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.xuebaonline.com/hello-world/"/>
    <id>http://www.xuebaonline.com/hello-world/</id>
    <published>2020-04-14T03:41:23.589Z</published>
    <updated>2020-04-18T13:42:59.685Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://www.xuebaonline.com/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
