<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="G0fHOrfJn5sHWzmi6ZCcg2aX83myBc-9U1BJZJJDSTU">
  <meta name="baidu-site-verification" content="7gJOLignE2">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.xuebaonline.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Swift 源码系列(一)：Array的实现原理探究">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 源码系列(一)：Array的实现原理探究">
<meta property="og:url" content="https://www.xuebaonline.com/Swift%20%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97(%E4%B8%80)%EF%BC%9AArray%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/index.html">
<meta property="og:site_name" content="Char&#39;s Blog">
<meta property="og:description" content="Swift 源码系列(一)：Array的实现原理探究">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.xuebaonline.com/array_im_01.png">
<meta property="article:published_time" content="2020-12-12T01:20:00.000Z">
<meta property="article:modified_time" content="2020-12-14T02:21:22.480Z">
<meta property="article:author" content="Char">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Swift 源码">
<meta property="article:tag" content="Swift进阶">
<meta property="article:tag" content="Protocols">
<meta property="article:tag" content="协议编程">
<meta property="article:tag" content="泛型">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="多态">
<meta property="article:tag" content="Collection">
<meta property="article:tag" content="Types">
<meta property="article:tag" content="Arrays">
<meta property="article:tag" content="Dictionaries">
<meta property="article:tag" content="Sets">
<meta property="article:tag" content="使用闭包集合迭代">
<meta property="article:tag" content="Strings">
<meta property="article:tag" content="构建自己的类型">
<meta property="article:tag" content="Structures">
<meta property="article:tag" content="结构体">
<meta property="article:tag" content="Methods">
<meta property="article:tag" content="Classes">
<meta property="article:tag" content="Advanced Classes">
<meta property="article:tag" content="面试题">
<meta property="article:tag" content="Swift 源码系列(一)：Array的实现原理探究">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.xuebaonline.com/array_im_01.png">

<link rel="canonical" href="https://www.xuebaonline.com/Swift%20%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97(%E4%B8%80)%EF%BC%9AArray%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Swift 源码系列(一)：Array的实现原理探究 | Char's Blog</title>
  
    <script>
      function sendPageView() {
        if (CONFIG.hostname !== location.hostname) return;
        var uid = localStorage.getItem('uid') || (Math.random() + '.' + Math.random());
        localStorage.setItem('uid', uid);
        navigator.sendBeacon('https://www.google-analytics.com/collect', new URLSearchParams({
          v  : 1,
          tid: 'UA-165583776-1',
          cid: uid,
          t  : 'pageview',
          dp : encodeURIComponent(location.pathname)
        }));
      }
      document.addEventListener('pjax:complete', sendPageView);
      sendPageView();
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f44aa1d26d8ba6a20c1a09a9cdcd7e3d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Char's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Char's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">如切如磋，如琢如磨。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">122</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">49</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">147</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.xuebaonline.com/Swift%20%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97(%E4%B8%80)%EF%BC%9AArray%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.xuebaonline.com/blog_avatar.JPG">
      <meta itemprop="name" content="Char">
      <meta itemprop="description" content="曾经沧海难为水，除却巫山不是云。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Char's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Swift 源码系列(一)：Array的实现原理探究
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-12 09:20:00" itemprop="dateCreated datePublished" datetime="2020-12-12T09:20:00+08:00">2020-12-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Array/" itemprop="url" rel="index"><span itemprop="name">Array</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">Swift 源码阅读</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/Swift%20%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97(%E4%B8%80)%EF%BC%9AArray%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Swift%20%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97(%E4%B8%80)%EF%BC%9AArray%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>
            <div class="post-description">Swift 源码系列(一)：Array的实现原理探究</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>​        使用一项新的技术之后，使用时间愈长就对内部实现原理愈感到好奇。基于难以压抑的好奇心，决定花点时间对这门语言一些实现一探究竟。</p>
<p>​        阅读源码之前需要准备一些资料：</p>
<ul>
<li><code>Swift</code> 源代码：<strong><a href="https://github.com/apple/swift" target="_blank" rel="noopener">https://github.com/apple/swift</a></strong></li>
<li><code>Swift</code> 版本：<strong>5.3</strong></li>
<li>阅读文件：<code>swift-master/stdlib/public/core/Array.swift</code> </li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        阅读这个文件的原因是最近接手一个比较棘手的项目，之所以棘手原因是前任开发者开发起来过于随意，其中的一些小细节疏漏了，导致本来已经比较艰难的项目更是雪上加霜。尤其是在数组的使用上沿用 <code>Objective-C</code> 的用法，由于 <code>Swift</code> 被称为是 <strong>高效、安全</strong>，在实现上有差别，在使用上也需要注意一些细节，所以就对 <code>Swift</code> 中 <code>Array</code> 的具体实现一探究竟。</p>
<p>​        在这个文件中，一开头我们看到这样一句话：“Three generic, mutable array-like types with value semantics.”。大概意思就是具有值语义的三种通用的可变数组类型。而且是一个有序可随机访问的集合。</p>
<p>我们可以总结出 <code>Swift</code> 中  <code>Array</code> 特点：</p>
<ul>
<li><p>值类型</p>
</li>
<li><p>通用(支持多种数据类型存储)</p>
</li>
<li><p>可变</p>
</li>
<li><p>有序</p>
</li>
<li><p>可随机访问</p>
</li>
</ul>
<blockquote>
<p><code>Array&lt;Element&gt;</code> is like <code>ContiguousArray&lt;Element&gt;</code> when <code>Element</code> is not a reference type or an Objective-C existential. Otherwise, it may use an <code>NSArray</code> bridged from Cocoa for storage.</p>
</blockquote>
<p>源文件中的注释描述的比较清晰，如果 <code>Array</code> 中的元素为非引用类型或者非 <code>Objective-C</code> 扩展的类型，其存储和使用和使用方式与 <code>ContiguousArray</code> 一直。否则会将其桥接转换成 <code>NSArray</code> 存储。</p>
<a id="more"></a>



<blockquote>
<p>Arrays are one of the most commonly used data types in an app. You use arrays to organize your app’s data. Specifically, you use the <code>Array</code> type  to hold elements of a single type, the array’s <code>Element</code> type. An array can store any kind of elements—from integers to strings to classes.</p>
</blockquote>
<p><code>Array</code> 使用来存储想要保存的任意数据，但是使用时需要注意其特点：</p>
<ul>
<li>内部元素类型一致</li>
<li>数据类型单一</li>
<li>任意类型的元素</li>
</ul>
<blockquote>
<p>Swift makes it easy to create arrays in your code using an array literal: simply surround a comma-separated list of values with square brackets. Without any other information, Swift creates an array that includes the specified values, automatically inferring the array’s <code>Element</code> type. </p>
</blockquote>
<h1 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h1><p>1、创建 <code>Array</code> 方式很简单，可以直接使用 <code>[]</code> 将元素使用 <code>,</code> 分开的元素放入其中即可完成一个数组的创建。在没有执行数组元素类型的情况下，<code>Swift</code> 中推断出元素数组中元素类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An array of 'Int' elements</span></span><br><span class="line"><span class="keyword">let</span> oddNumbers = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// An array of 'String' elements</span></span><br><span class="line"><span class="keyword">let</span> streets = [<span class="string">"Albemarle"</span>, <span class="string">"Brandywine"</span>, <span class="string">"Chesapeake"</span>]</span><br></pre></td></tr></table></figure>

<p>2、也可以在声明中执行元素类型来创建一个空数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shortened forms are preferred</span></span><br><span class="line"><span class="keyword">var</span> emptyDoubles: [<span class="type">Double</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// The full type name is also allowed</span></span><br><span class="line"><span class="keyword">var</span> emptyFloats: <span class="type">Array</span>&lt;<span class="type">Float</span>&gt; = <span class="type">Array</span>()</span><br></pre></td></tr></table></figure>

<p>3、也可以使用固定数目的默认值进行预初始化的数组：<code>Array(repeating:count:)</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> digitCounts = <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(digitCounts)</span><br><span class="line"><span class="comment">// Prints "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"</span></span><br></pre></td></tr></table></figure>

<h1 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h1><p>1、当需要对数组的所有元素执行某种操作时，请使用 <code>for</code>-<code>in</code> 循环遍历数组的内容。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> street <span class="keyword">in</span> streets &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I don't live on \(street)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints "I don't live on Albemarle."</span></span><br><span class="line"><span class="comment">// Prints "I don't live on Brandywine."</span></span><br><span class="line"><span class="comment">// Prints "I don't live on Chesapeake."</span></span><br></pre></td></tr></table></figure>

<p>2、是否是空数组（ <code>isEmpty</code> ）</p>
<p>使用 <code>isEmpty</code> 属性来快速检查一个数组是否有任何数组元素，或使用count属性查找数组中的元素数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> oddNumbers.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I don't know any odd numbers."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I know \(oddNumbers.count) odd numbers."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints "I know 8 odd numbers."</span></span><br></pre></td></tr></table></figure>

<p>3、访问第一个或者是最后一个元素</p>
<p>使用 <code>first</code> 和 <code>last</code> 属性可以安全地访问数组的 第一个和最后一个元素的值。如果数组为空，则这些属性为  <code>“nil”</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstElement = oddNumbers.first, <span class="keyword">let</span> lastElement = oddNumbers.last &#123;</span><br><span class="line">    <span class="built_in">print</span>(firstElement, lastElement, separator: <span class="string">", "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints "1, 15"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(emptyDoubles.first, emptyDoubles.last, separator: <span class="string">", "</span>)</span><br><span class="line"><span class="comment">// Prints "nil, nil"</span></span><br></pre></td></tr></table></figure>

<p>4、使用下标访问元素</p>
<p>​        通过下标访问单个数组元素。非空数组的第一个元素始终位于索引 0 。使用从0到但不包括数组计数的任何整数为数组添加下标。使用负数或等于或大于 <code>count</code> 的索引会触发运行时错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(oddNumbers[<span class="number">0</span>], oddNumbers[<span class="number">3</span>], separator: <span class="string">", "</span>)</span><br><span class="line"><span class="comment">// Prints "1, 7"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(emptyDoubles[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// Triggers runtime error: Index out of range</span></span><br></pre></td></tr></table></figure>

<h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><p>1、在数组尾部添加(单个、多个)元素</p>
<p>使用<code>append（_ :)</code>方法将单个元素添加到数组的末尾。通过将另一个数组或任何类型的序列传递给 <code>append（contentsOf:)</code> 方法来同时添加多个元素。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students = [<span class="string">"Ben"</span>, <span class="string">"Ivy"</span>, <span class="string">"Jordell"</span>]</span><br><span class="line"></span><br><span class="line">students.append(<span class="string">"Maxime"</span>)</span><br><span class="line">students.append(contentsOf: [<span class="string">"Shakia"</span>, <span class="string">"William"</span>])</span><br><span class="line"><span class="comment">// ["Ben", "Ivy", "Jordell", "Maxime", "Shakia", "William"]</span></span><br></pre></td></tr></table></figure>

<p>2、在数组指定位置添加(单个、多个)元素</p>
<p>使用 <code>insert（_：at :)</code> 方法添加单个元素，并通过使用 <code>insert（contentsOf：at :)</code> 来从另一个集合或数组文字中插入多个元素，从而在数组中间添加新元素。该索引处的元素和以后的索引将移后以腾出空间。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">students.insert(<span class="string">"Liam"</span>, at: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// ["Ben", "Ivy", "Jordell", "Liam", "Maxime", "Shakia", "William"]</span></span><br></pre></td></tr></table></figure>

<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><p>1、使用下标移除元素</p>
<p>使用 <code>remove(at:)</code> 、<code>removeSubrange(_:)</code> 、 <code>removeLast()</code> 方法移除数组中的元素。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ben's family is moving to another state</span></span><br><span class="line">students.remove(at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// ["Ivy", "Jordell", "Liam", "Maxime", "Shakia", "William"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// William is signing up for a different class</span></span><br><span class="line">students.removeLast()</span><br><span class="line"><span class="comment">// ["Ivy", "Jordell", "Liam", "Maxime", "Shakia"]</span></span><br></pre></td></tr></table></figure>

<p>2、替换元素</p>
<p>可以将一个新值赋值给数组某个下标所存储的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> i = students.firstIndex(of: <span class="string">"Maxime"</span>) &#123;</span><br><span class="line">    students[i] = <span class="string">"Max"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["Ivy", "Jordell", "Liam", "Max", "Shakia"]</span></span><br></pre></td></tr></table></figure>

<h1 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h1><p>​        每个数组都保留特定数量的内存来保存其内容。当向数组中添加元素并且该数组开始超出其保留容量时，该数组会<strong><em>分配更大的内存区域，并将其元素复制到新的存储中</em></strong>。新存储是旧存储的倍数储存空间的大小。这种<strong><em>指数增长策略意味着追加元素的时间恒定，平均许多追加操作的性能。触发重新分配的追加操作会降低性能，但是随着数组变大，它们的发生频率会越来越低。</em></strong></p>
<p>​        如果你知道大约需要存储多少个元素，请在添加到数组之前使用 <code>reserveCapacity（_ :)</code> 方法，以避免中间重新分配。使用 <code>capacity</code> 和 <code>count</code> 属性来确定在不分配更大存储空间的情况下，数组可以存储多少元素。</p>
<blockquote>
<p><code>C、C++</code> 中数组的扩容方式可以去了解一下。在上文中已经提到。数组的频繁扩容是比较损耗性能，所在开发中尽可能避免这样的操作。</p>
</blockquote>
<p>​        对于大多数 <code>“元素”</code> 类型的数组，此存储是连续的内存块。对于元素类型为类或 <code>@objc</code> 协议类型的数组，此存储可以是连续的内存块或 <code>NSArray</code> 的实例。因为 <code>NSArray</code> 的任意子类都可以变成 <code>Array</code> ，所以在这种情况下不能保证表示和效率。</p>
<h1 id="修改拷贝的数组"><a href="#修改拷贝的数组" class="headerlink" title="修改拷贝的数组"></a>修改拷贝的数组</h1><p>​        每个数组都有一个独立的值，其中包括其所有元素的值。对于整数和其他结构等简单类型，这意味着当你更改一个数组中的值时，该元素的值在数组的任何副本中均不会更改。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> numbersCopy = numbers</span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="comment">// Prints "[100, 2, 3, 4, 5]"</span></span><br><span class="line"><span class="built_in">print</span>(numbersCopy)</span><br><span class="line"><span class="comment">// Prints "[1, 2, 3, 4, 5]"</span></span><br></pre></td></tr></table></figure>

<p>​        如果数组中的元素是类的实例，则语义是相同的，尽管它们最初可能看起来有所不同。在这种情况下，存储在数组中的值是对位于数组外部的对象的引用。如果在一个数组中更改对对象的引用，则只有<strong><em>该数组对新对象具有引用</em></strong>。但是，如果两个数组包含对同一对象的引用，则可以从两个数组观察对该对象的属性的更改。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An integer type with reference semantics</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> firstIntegers = [<span class="type">IntegerReference</span>(), <span class="type">IntegerReference</span>()]</span><br><span class="line"><span class="keyword">var</span> secondIntegers = firstIntegers</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modifications to an instance are visible from either array</span></span><br><span class="line">firstIntegers[<span class="number">0</span>].value = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(secondIntegers[<span class="number">0</span>].value)</span><br><span class="line"><span class="comment">// Prints "100"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Replacements, additions, and removals are still visible</span></span><br><span class="line"><span class="comment">// only in the modified array</span></span><br><span class="line">firstIntegers[<span class="number">0</span>] = <span class="type">IntegerReference</span>()</span><br><span class="line"><span class="built_in">print</span>(firstIntegers[<span class="number">0</span>].value)</span><br><span class="line"><span class="comment">// Prints "10"</span></span><br><span class="line"><span class="built_in">print</span>(secondIntegers[<span class="number">0</span>].value)</span><br><span class="line"><span class="comment">// Prints "100"</span></span><br></pre></td></tr></table></figure>

<p>​        数组与标准库中的所有可变大小集合一样，都使用<strong><em>写时复制</em></strong>优化。数组的多个副本共享同一存储，直到你修改其中一个副本为止。发生这种情况时，要修改的数组将用其唯一拥有的副本替换其存储，然后对其进行适当修改。有时会进行优化以减少复制量。</p>
<p>​        这意味着，如果一个数组正在与其他副本共享存储，则对该数组进行的第一个变异操作会产生复制该数组的成本。作为其存储唯一所有者的数组可以在适当位置执行变异操作。</p>
<p>​        在下面的示例中，将创建一个 <code>“numbers”</code> 数组以及共享同一存储的两个副本。当原始的 <code>numbers</code> 数组被修改时，它会在进行修改之前为其存储创建唯一的副本。在对 <code>“numbers”</code> 进行进一步修改的同时，两个副本继续共享原始存储。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> firstCopy = numbers</span><br><span class="line"><span class="keyword">var</span> secondCopy = numbers</span><br><span class="line"></span><br><span class="line"><span class="comment">// The storage for 'numbers' is copied here</span></span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">200</span></span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">300</span></span><br><span class="line"><span class="comment">// 'numbers' is [100, 200, 300, 4, 5]</span></span><br><span class="line"><span class="comment">// 'firstCopy' and 'secondCopy' are [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h1 id="Array-和-NSArray-桥接"><a href="#Array-和-NSArray-桥接" class="headerlink" title="Array 和 NSArray 桥接"></a><code>Array</code> 和 <code>NSArray</code> 桥接</h1><p>​        当你需要访问需要使用 <code>NSArray</code> 实例而不是 <code>Array</code> 中的数据的 <code>API</code> 时，请使用类型转换运算符 <code>(as)</code> 桥接你的实例。为了使桥接成为可能，数组的 <code>“元素”</code> 类型必须是类，<code>“@objc”</code> 协议（从 <code>Objective-C</code> 导入或带有 <code>“@objc”</code> 属性标记的协议）或桥接到的类型，基础类型。</p>
<p>​        以下示例显示了如何将 <code>Array</code> 实例桥接到 <code>NSArray</code> ，以使用 <code>write(to：atomically :)</code> 方法。在这个例子中，可以将 <code>colors</code> 数组桥接到 <code>NSArray</code> ，因为 <code>colors</code> 数组的 <code>String</code> 元素桥接到 <code>NSString</code> 。另一方面，编译器阻止桥接 <code>moreColors</code> 数组，因为它的 <code>Element</code>类型是 <code>Optional &lt;String&gt;</code> ，它不会桥接到 <code>Foundation</code> 类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"periwinkle"</span>, <span class="string">"rose"</span>, <span class="string">"moss"</span>]</span><br><span class="line"><span class="keyword">let</span> moreColors: [<span class="type">String?</span>] = [<span class="string">"ochre"</span>, <span class="string">"pine"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(fileURLWithPath: <span class="string">"names.plist"</span>)</span><br><span class="line">(colors <span class="keyword">as</span> <span class="type">NSArray</span>).write(to: url, atomically: <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">(moreColors <span class="keyword">as</span> <span class="type">NSArray</span>).write(to: url, atomically: <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// error: cannot convert value of type '[String?]' to type 'NSArray'</span></span><br></pre></td></tr></table></figure>

<p>​        如果数组的元素已经是一个类或 <code>@objc</code> 协议的实例，则从 <code>Array</code> 桥接到 <code>NSArray</code> 会占用 <code>O(1)</code> 时间和 <code>O(1)</code> 空间。否则，将花费 <code>O(n)</code> 的时间和空间复杂度。</p>
<p>​        当目标数组的元素类型是类或 <code>@objc</code> 协议时，从 <code>NSArray</code> 桥接到 <code>Array</code> 首先在对象上调用 <code>copy(with :)</code>（在 <code>Objective-C</code> 中为 <code>copyWithZone:</code> ）方法。数组以获取不可变的副本，然后执行耗时 O(1) 的其他 <code>Swift</code> 备注事项。对于已经是不可变的 <code>NSArray</code> 实例，通常在 O(1) 时间返回 <code>copy(with :)</code> 相同的数组；否则，复制性能未指定。如果 <code>copy(with :)</code> 返回相同的数组，则 <code>NSArray</code> 和<code>Array</code> 的实例将使用相同的写时复制优化共享存储，该优化是在 <code>Array</code> 的两个实例共享存储时使用的。</p>
<p>​        当目标数组的元素类型是桥接到 <code>Foundation</code> 类型的非类类型时，从 <code>NSArray</code> 到 <code>Array</code> 的桥接将在 O(n) 时间内将元素的桥接副本复制到连续存储中。例如，从 <code>NSArray</code> 到 <code>Array &lt;Int&gt;</code> 的桥接执行了这样的复制。访问 <code>Array</code> 实例的元素时，不需要进一步的桥接。</p>
<blockquote>
<p>注意：<code>ContiguousArray</code>和 <code>ArraySlice</code> 类型不是桥接的；这些类型的实例始终具有连续的内存块作为存储空间。</p>
</blockquote>
<h1 id="序列化数组"><a href="#序列化数组" class="headerlink" title="序列化数组"></a>序列化数组</h1><p>1、创建一个包含有序元素的数组。</p>
<p>你可以使用此初始化程序从符合 <code>Sequence</code> 协议的任何其他类型创建数组。例如，你可能想创建一个从1到7的整数的数组。请在某个范围内使用此初始化程序，而不要在数组文字中键入所有这些数字。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = <span class="type">Array</span>(<span class="number">1</span>...<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="comment">// Prints "[1, 2, 3, 4, 5, 6, 7]"</span></span><br></pre></td></tr></table></figure>

<p>你还可以使用此初始化程序将复杂的序列或集合类型转换回数组。例如，<strong><em>字典的 <code>“keys”</code> 属性不是具有自己存储空间的数组，它是一个集合，仅当它们被访问时才从字典中映射其元素，从而节省了分配数组所需的时间和空间。</em></strong>但是，如果您需要将这些键传递给采用数组的方法，请使用此初始值设定项将该列表从其 <code>LazyMapCollection&lt;Dictionary &lt;String，Int&gt; , Int&gt;</code> 类型转换为简单的 <code>[String]</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheImagesWithNames</span><span class="params">(names: [String])</span></span> &#123;</span><br><span class="line">    <span class="comment">// custom image loading and caching</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> namedHues: [<span class="type">String</span>: <span class="type">Int</span>] = [<span class="string">"Vermillion"</span>: <span class="number">18</span>, <span class="string">"Magenta"</span>: <span class="number">302</span>,</span><br><span class="line">        <span class="string">"Gold"</span>: <span class="number">50</span>, <span class="string">"Cerise"</span>: <span class="number">320</span>]</span><br><span class="line"><span class="keyword">let</span> colorNames = <span class="type">Array</span>(namedHues.keys)</span><br><span class="line">cacheImagesWithNames(colorNames)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(colorNames)</span><br><span class="line"><span class="comment">// Prints "["Gold", "Cerise", "Magenta", "Vermillion"]"</span></span><br></pre></td></tr></table></figure>

<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Parameter s: The sequence of elements to turn into an array.</span></span><br><span class="line">@inlinable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">S</span>: <span class="type">Sequence</span>&gt;(<span class="number">_</span> s: <span class="type">S</span>) <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">  <span class="keyword">self</span> = <span class="type">Array</span>(</span><br><span class="line">    _buffer: _Buffer(</span><br><span class="line">      _buffer: s._copyToContiguousArray()._buffer,</span><br><span class="line">      shiftedToStartIndex: <span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建一个包含指定数量的单个重复值的新数组。</p>
<p>这是创建一个数组的示例，该数组用五个包含字母 <em>Z</em> 的字符串初始化。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fiveZs = <span class="type">Array</span>(repeating: <span class="string">"Z"</span>, <span class="built_in">count</span>: <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(fiveZs)</span><br><span class="line"><span class="comment">// Prints "["Z", "Z", "Z", "Z", "Z"]"</span></span><br></pre></td></tr></table></figure>

<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">/// - repeatedValue: The element to repeat.</span></span><br><span class="line"><span class="comment">/// - count: The number of times to repeat the value passed in the</span></span><br><span class="line"><span class="comment">/// `repeating` parameter. `count` must be zero or greater.</span></span><br><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.init"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(repeating repeatedValue: <span class="type">Element</span>, <span class="built_in">count</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> p: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line">  (<span class="keyword">self</span>, p) = <span class="type">Array</span>._allocateUninitialized(<span class="built_in">count</span>)</span><br><span class="line">  <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">    p.initialize(to: repeatedValue)</span><br><span class="line">    p += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  _endMutation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@inline(never)</span><br><span class="line">@usableFromInline</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">_allocateBufferUninitialized</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  minimumCapacity: Int</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; _Buffer &#123;</span><br><span class="line">  <span class="keyword">let</span> newBuffer = _ContiguousArrayBuffer&lt;<span class="type">Element</span>&gt;(</span><br><span class="line">    _uninitializedCount: <span class="number">0</span>, minimumCapacity: minimumCapacity)</span><br><span class="line">  <span class="keyword">return</span> _Buffer(_buffer: newBuffer, shiftedToStartIndex: <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建一个指定容量但是未进行初始化的数组</p>
<p>构造一个 <code>count</code> 未初始化元素的数组。</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@inlinable</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">init</span>(_uninitializedCount <span class="built_in">count</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">  _precondition(<span class="built_in">count</span> &gt;= <span class="number">0</span>, <span class="string">"Can't construct Array with count &lt; 0"</span>)</span><br><span class="line">  <span class="comment">// Note: Sinking this constructor into an else branch below causes an extra</span></span><br><span class="line">  <span class="comment">// Retain/Release.</span></span><br><span class="line">  _buffer = _Buffer()</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Creating a buffer instead of calling reserveCapacity saves doing an</span></span><br><span class="line">    <span class="comment">// unnecessary uniqueness check. We disable inlining here to curb code</span></span><br><span class="line">    <span class="comment">// growth.</span></span><br><span class="line">    _buffer = <span class="type">Array</span>._allocateBufferUninitialized(minimumCapacity: <span class="built_in">count</span>)</span><br><span class="line">    _buffer.mutableCount = <span class="built_in">count</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Can't store count here because the buffer might be pointing to the</span></span><br><span class="line">  <span class="comment">// shared empty array.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、构造字面量 <code>Array</code> 的入口；构建并返回一个 <code>“count”</code> 未初始化元素的数组。</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.uninitialized"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">_allocateUninitialized</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> <span class="built_in">count</span>: Int</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; (<span class="type">Array</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="type">Array</span>(_uninitializedCount: <span class="built_in">count</span>)</span><br><span class="line">  <span class="keyword">return</span> (result, result._buffer.firstElementAddress)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、使用给定的 <code>“Storage”</code> 返回一个 <code>“count”</code> 个未初始化元素的数组，以及一个指向第一个元素的未初始化内存的指针。</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Precondition: `storage is _ContiguousArrayStorage`.</span></span><br><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.uninitialized"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">_adoptStorage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> storage: __owned _ContiguousArrayStorage&lt;Element&gt;, <span class="built_in">count</span>: Int</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; (<span class="type">Array</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Element</span>&gt;) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> innerBuffer = _ContiguousArrayBuffer&lt;<span class="type">Element</span>&gt;(</span><br><span class="line">    <span class="built_in">count</span>: <span class="built_in">count</span>,</span><br><span class="line">    storage: storage)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="type">Array</span>(</span><br><span class="line">      _buffer: _Buffer(_buffer: innerBuffer, shiftedToStartIndex: <span class="number">0</span>)),</span><br><span class="line">      innerBuffer.firstElementAddress)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、终止构造字面量数组入口：释放仅包含未初始化元素的Array。</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@inlinable</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">_deallocateUninitialized</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Set the count to zero and just release as normal.</span></span><br><span class="line">  <span class="comment">// Somewhat of a hack.</span></span><br><span class="line">  _buffer.mutableCount = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="基础变动-basic-mutations"><a href="#基础变动-basic-mutations" class="headerlink" title="基础变动(basic mutations)"></a>基础变动(<strong><em>basic mutations</em></strong>)</h1><p>1、保留足够的空间来存储指定数量的元素。</p>
<p>如果要向数组中添加已知数量的元素，请使用此方法避免多次重新分配。 此<strong><em>方法确保数组具有唯一的，可变的，连续的存储，并至少为请求的元素数量分配了空间。</em></strong></p>
<p>在具有桥接存储的数组上调用 <code>reserveCapacity(_ :)</code>方法会触发向连续存储的复制，即使现有存储中有空间可以存储 <code>minimumCapacity</code> 元素。</p>
<p>出于性能原因，新分配的存储的大小可能大于请求的容量。 使用数组的 <code>“capacity”</code> 属性来确定新存储的大小。</p>
<p>2、保留阵列的几何增长策略</p>
<p>如果你实现了一个动态增长的数组支持的自定义数据结构，那么在调用 <code>reserveCapacity（_ :)</code>方法可能会导致性能不及预期。 数组需要遵循几何分配模式来添加元素，以实现摊销后的恒定时间性能。 <code>Array</code> 类型的 <code>append(_ :)</code> 和 <code>append(contentsOf :)</code>方法会为你处理此细节，但是 <code>reserveCapacity(_ :)</code> 只会分配你告诉它的空间（填充到 舍入值），仅此而已。 这避免了过度分配，但可能导致插入不具有摊销的恒定时间性能。</p>
<p>以下代码声明了“值”，一个整数数组和 <code>“addTenQuadratic()”</code> 函数，该函数在每次调用时将另外十个值添加到“值”数组中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values: [<span class="type">Int</span>] = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't use 'reserveCapacity(_:)' like this</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTenQuadratic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newCount = values.<span class="built_in">count</span> + <span class="number">10</span></span><br><span class="line">    values.reserveCapacity(newCount)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> values.<span class="built_in">count</span>..&lt;newCount &#123;</span><br><span class="line">        values.append(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 <code>“reserveCapacity(_ :)”</code> 的调用通过 <code>“addTenQuadratic()”</code>（线性增长），每次传递时，<code>“ values”</code> 数组的容量都会增加恰好10个元素。 该函数可能会衰减到在 <code>values.count</code> 中呈线性的性能，而不是对多个调用求平均值时具有恒定的时间。 几乎可以肯定这不是你想要的。</p>
<p>在这种情况下，最简单的解决方法通常是简单地删除对 <code>reserveCapacity(_ :)</code> 的调用，并让 <code>append(_ :)</code> 方法为你增加数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTen</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newCount = values.<span class="built_in">count</span> + <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> values.<span class="built_in">count</span>..&lt;newCount &#123;</span><br><span class="line">        values.append(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、如果你需要更多地控制数组的容量，你实现自定义的几何增长策略，将计算的大小传递给 <code>“reserveCapacity(_ :)”</code> 。</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Parameter minimumCapacity: The requested number of elements to store.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Complexity: O(*n*), where *n* is the number of elements in the array.</span></span><br><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.mutate_unknown"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">reserveCapacity</span><span class="params">(<span class="number">_</span> minimumCapacity: Int)</span></span> &#123;</span><br><span class="line">  _reserveCapacityImpl(minimumCapacity: minimumCapacity,</span><br><span class="line">                       growForAppend: <span class="literal">false</span>)</span><br><span class="line">  _endMutation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、保留足够的空间来存储 <code>“minimumCapacity”</code> 元素。 如果需要分配一个新的缓冲区，并且 <code>growForAppend</code> 为 <code>true</code> ，则使用 <code>&#39;_growArrayCapacity&#39;</code> 计算新的容量，但至少保持为 <code>&#39;minimumCapacity&#39;</code> 。</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@_alwaysEmitIntoClient</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">_reserveCapacityImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  minimumCapacity: Int, growForAppend: Bool</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> isUnique = _buffer.beginCOWMutation()</span><br><span class="line">  <span class="keyword">if</span> _slowPath(!isUnique || _buffer.mutableCapacity &lt; minimumCapacity) &#123;</span><br><span class="line">    _createNewBuffer(bufferIsUnique: isUnique,</span><br><span class="line">                     minimumCapacity: <span class="type">Swift</span>.<span class="built_in">max</span>(minimumCapacity, _buffer.<span class="built_in">count</span>),</span><br><span class="line">                     growForAppend: growForAppend)</span><br><span class="line">  &#125;</span><br><span class="line">  _internalInvariant(_buffer.mutableCapacity &gt;= minimumCapacity)</span><br><span class="line">  _internalInvariant(_buffer.mutableCapacity == <span class="number">0</span> ||</span><br><span class="line">                     _buffer.<span class="built_in">isUniquelyReferenced</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、创建一个新缓冲区，替换当前缓冲区。</p>
<p>如果 <code>bufferIsUnique</code> 为true，则假定该数组唯一引用该缓冲区，并且将元素（而不是复制）移动到新缓冲区。</p>
<p><code>“minimumCapacity”</code> 是新容量的下限。</p>
<p>如果 <code>growForAppend</code> 为true，则使用 <code>_growArrayCapacity</code> 计算新容量，但至少保持为 `minimumCapacity 。</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@_alwaysEmitIntoClient</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">_createNewBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  bufferIsUnique: Bool, minimumCapacity: Int, growForAppend: Bool</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  _internalInvariant(!bufferIsUnique || _buffer.<span class="built_in">isUniquelyReferenced</span>())</span><br><span class="line">  _buffer = _buffer._consumeAndCreateNew(bufferIsUnique: bufferIsUnique,</span><br><span class="line">                                         minimumCapacity: minimumCapacity,</span><br><span class="line">                                         growForAppend: growForAppend)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、将当前缓冲区的内容复制到新的唯一可变缓冲区。<br>新缓冲区的计数设置为 <code>“oldCount”</code> ，新缓冲区的容量足以容纳 <code>“ oldCount” +1</code> 个元素。</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@inline(never)</span><br><span class="line">@inlinable <span class="comment">// @specializable</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">_copyToNewBuffer</span><span class="params">(oldCount: Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> newCount = oldCount + <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> newBuffer = _buffer._forceCreateUniqueMutableBuffer(</span><br><span class="line">    countForNewBuffer: oldCount, minNewCapacity: newCount)</span><br><span class="line">  _buffer._arrayOutOfPlaceUpdate(&amp;newBuffer, oldCount, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.make_mutable"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">_makeUniqueAndReserveCapacityIfNotUnique</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> _slowPath(!_buffer.beginCOWMutation()) &#123;</span><br><span class="line">    _createNewBuffer(bufferIsUnique: <span class="literal">false</span>,</span><br><span class="line">                     minimumCapacity: <span class="built_in">count</span> + <span class="number">1</span>,</span><br><span class="line">                     growForAppend: <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.mutate_unknown"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">_reserveCapacityAssumingUniqueBuffer</span><span class="params">(oldCount: Int)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Due to make_mutable hoisting the situation can arise where we hoist</span></span><br><span class="line">  <span class="comment">// _makeMutableAndUnique out of loop and use it to replace</span></span><br><span class="line">  <span class="comment">// _makeUniqueAndReserveCapacityIfNotUnique that preceeds this call. If the</span></span><br><span class="line">  <span class="comment">// array was empty _makeMutableAndUnique does not replace the empty array</span></span><br><span class="line">  <span class="comment">// buffer by a unique buffer (it just replaces it by the empty array</span></span><br><span class="line">  <span class="comment">// singleton).</span></span><br><span class="line">  <span class="comment">// This specific case is okay because we will make the buffer unique in this</span></span><br><span class="line">  <span class="comment">// function because we request a capacity &gt; 0 and therefore _copyToNewBuffer</span></span><br><span class="line">  <span class="comment">// will be called creating a new buffer.</span></span><br><span class="line">  <span class="keyword">let</span> capacity = _buffer.mutableCapacity</span><br><span class="line">  _internalInvariant(capacity == <span class="number">0</span> || _buffer.isMutableAndUniquelyReferenced())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> _slowPath(oldCount + <span class="number">1</span> &gt; capacity) &#123;</span><br><span class="line">    _createNewBuffer(bufferIsUnique: capacity &gt; <span class="number">0</span>,</span><br><span class="line">                     minimumCapacity: oldCount + <span class="number">1</span>,</span><br><span class="line">                     growForAppend: <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.mutate_unknown"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">_appendElementAssumeUniqueAndCapacity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> oldCount: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">  newElement: __owned Element</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  _internalInvariant(_buffer.isMutableAndUniquelyReferenced())</span><br><span class="line">  _internalInvariant(_buffer.mutableCapacity &gt;= _buffer.mutableCount + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  _buffer.mutableCount = oldCount + <span class="number">1</span></span><br><span class="line">  (_buffer.mutableFirstElementAddress + oldCount).initialize(to: newElement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、向数组末尾添加元素</p>
<p>可以使用 <code>append(_:)</code> 在可变数组的末尾添加一个新的元素。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.append(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="comment">// Prints "[1, 2, 3, 4, 5, 100]"</span></span><br></pre></td></tr></table></figure>

<p>因为数组使用指数策略增加了分配的容量，所以在对 <code>append(_ :)</code> 方法的多次调用中求平均值时，将单个元素追加到数组是O(1)操作。 当数组具有附加容量并且不与其他实例共享其存储时，追加元素为O(1)。 当<strong><em>数组需要在追加之前重新分配存储或与另一个副本共享其存储时，追加为O(*n</em>)，其中<em>n</em>是数组的长度。*</strong></p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Parameter newElement: The element to append to the array.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Complexity: O(1) on average, over many calls to `append(_:)` on the</span></span><br><span class="line"><span class="comment">///   same array.</span></span><br><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.append_element"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> newElement: __owned Element)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Separating uniqueness check and capacity check allows hoisting the</span></span><br><span class="line">  <span class="comment">// uniqueness check out of a loop.</span></span><br><span class="line">  _makeUniqueAndReserveCapacityIfNotUnique()</span><br><span class="line">  <span class="keyword">let</span> oldCount = _buffer.mutableCount</span><br><span class="line">  _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)</span><br><span class="line">  _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)</span><br><span class="line">  _endMutation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、将序列的元素添加到数组的末尾</p>
<p>使用此方法可将序列的元素附加到此数组的末尾。 此示例将 <code>Range &lt;Int&gt;</code> 实例的元素附加到整数数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.append(contentsOf: <span class="number">10</span>...<span class="number">15</span>)</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="comment">// Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"</span></span><br></pre></td></tr></table></figure>

<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.append_contentsOf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span>&lt;S: Sequence&gt;<span class="params">(contentsOf newElements: __owned S)</span></span></span><br><span class="line">  <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> &#123;</span><br><span class="line">    _endMutation()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newElementsCount = newElements.underestimatedCount</span><br><span class="line">  _reserveCapacityImpl(minimumCapacity: <span class="keyword">self</span>.<span class="built_in">count</span> + newElementsCount,</span><br><span class="line">                       growForAppend: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oldCount = _buffer.mutableCount</span><br><span class="line">  <span class="keyword">let</span> startNewElements = _buffer.mutableFirstElementAddress + oldCount</span><br><span class="line">  <span class="keyword">let</span> buf = <span class="type">UnsafeMutableBufferPointer</span>(</span><br><span class="line">              start: startNewElements, </span><br><span class="line">              <span class="built_in">count</span>: _buffer.mutableCapacity - oldCount)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> (remainder,writtenUpTo) = buf.initialize(from: newElements)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// trap on underflow from the sequence's underestimate:</span></span><br><span class="line">  <span class="keyword">let</span> writtenCount = buf.<span class="built_in">distance</span>(from: buf.startIndex, to: writtenUpTo)</span><br><span class="line">  _precondition(newElementsCount &lt;= writtenCount, </span><br><span class="line">    <span class="string">"newElements.underestimatedCount was an overestimate"</span>)</span><br><span class="line">  <span class="comment">// can't check for overflow as sequences can underestimate</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This check prevents a data race writing to _swiftEmptyArrayStorage</span></span><br><span class="line">  <span class="keyword">if</span> writtenCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">    _buffer.mutableCount = _buffer.mutableCount + writtenCount</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> _slowPath(writtenUpTo == buf.endIndex) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A shortcut for appending an Array: If newElements is an Array then it's</span></span><br><span class="line">    <span class="comment">// guaranteed that buf.initialize(from: newElements) already appended all</span></span><br><span class="line">    <span class="comment">// elements. It reduces code size, because the following code</span></span><br><span class="line">    <span class="comment">// can be removed by the optimizer by constant folding this check in a</span></span><br><span class="line">    <span class="comment">// generic specialization.</span></span><br><span class="line">    <span class="keyword">if</span> newElements <span class="keyword">is</span> [<span class="type">Element</span>] &#123;</span><br><span class="line">      _internalInvariant(remainder.next() == <span class="literal">nil</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// there may be elements that didn't fit in the existing buffer,</span></span><br><span class="line">    <span class="comment">// append them in slow sequence-only mode</span></span><br><span class="line">    <span class="keyword">var</span> newCount = _buffer.mutableCount</span><br><span class="line">    <span class="keyword">var</span> nextItem = remainder.next()</span><br><span class="line">    <span class="keyword">while</span> nextItem != <span class="literal">nil</span> &#123;</span><br><span class="line">      _reserveCapacityAssumingUniqueBuffer(oldCount: newCount)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> currentCapacity = _buffer.mutableCapacity</span><br><span class="line">      <span class="keyword">let</span> base = _buffer.mutableFirstElementAddress</span><br><span class="line"></span><br><span class="line">      <span class="comment">// fill while there is another item and spare capacity</span></span><br><span class="line">      <span class="keyword">while</span> <span class="keyword">let</span> next = nextItem, newCount &lt; currentCapacity &#123;</span><br><span class="line">        (base + newCount).initialize(to: next)</span><br><span class="line">        newCount += <span class="number">1</span></span><br><span class="line">        nextItem = remainder.next()</span><br><span class="line">      &#125;</span><br><span class="line">      _buffer.mutableCount = newCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.reserve_capacity_for_append"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">reserveCapacityForAppend</span><span class="params">(newElementsCount: Int)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Ensure uniqueness, mutability, and sufficient storage.  Note that</span></span><br><span class="line">  <span class="comment">// for consistency, we need unique self even if newElements is empty.</span></span><br><span class="line">  _reserveCapacityImpl(minimumCapacity: <span class="keyword">self</span>.<span class="built_in">count</span> + newElementsCount,</span><br><span class="line">                       growForAppend: <span class="literal">true</span>)</span><br><span class="line">  _endMutation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.mutate_unknown"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">_customRemoveLast</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">  _makeMutableAndUnique()</span><br><span class="line">  <span class="keyword">let</span> newCount = _buffer.mutableCount - <span class="number">1</span></span><br><span class="line">  _precondition(newCount &gt;= <span class="number">0</span>, <span class="string">"Can't removeLast from an empty Array"</span>)</span><br><span class="line">  <span class="keyword">let</span> pointer = (_buffer.mutableFirstElementAddress + newCount)</span><br><span class="line">  <span class="keyword">let</span> element = pointer.move()</span><br><span class="line">  _buffer.mutableCount = newCount</span><br><span class="line">  _endMutation()</span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、删除并返回指定位置的元素</p>
<p>跟随指定位置的所有元素将向上移动以缩小间隙。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> measurements: [<span class="type">Double</span>] = [<span class="number">1.1</span>, <span class="number">1.5</span>, <span class="number">2.9</span>, <span class="number">1.2</span>, <span class="number">1.5</span>, <span class="number">1.3</span>, <span class="number">1.2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> removed = measurements.remove(at: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(measurements)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints "[1.1, 1.5, 1.2, 1.5, 1.3, 1.2]"</span></span><br></pre></td></tr></table></figure>

<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Parameter index: The position of the element to remove. `index` must</span></span><br><span class="line"><span class="comment">///   be a valid index of the array.</span></span><br><span class="line"><span class="comment">/// - Returns: The element at the specified index.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Complexity: O(*n*), where *n* is the length of the array.</span></span><br><span class="line">@inlinable</span><br><span class="line"><span class="meta">@discardableResult</span></span><br><span class="line">@_semantics(<span class="string">"array.mutate_unknown"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">  _makeMutableAndUnique()</span><br><span class="line">  <span class="keyword">let</span> currentCount = _buffer.mutableCount</span><br><span class="line">  _precondition(index &lt; currentCount, <span class="string">"Index out of range"</span>)</span><br><span class="line">  _precondition(index &gt;= <span class="number">0</span>, <span class="string">"Index out of range"</span>)</span><br><span class="line">  <span class="keyword">let</span> newCount = currentCount - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> pointer = (_buffer.mutableFirstElementAddress + index)</span><br><span class="line">  <span class="keyword">let</span> result = pointer.move()</span><br><span class="line">  pointer.moveInitialize(from: pointer + <span class="number">1</span>, <span class="built_in">count</span>: newCount - index)</span><br><span class="line">  _buffer.mutableCount = newCount</span><br><span class="line">  _endMutation()</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9、在指定的位置插入一个新元素</p>
<p>新元素将插入当前位于指定索引处的元素之前。 如果将数组的 <code>endIndex</code> 属性作为 <code>index</code> 参数传递，则新元素将附加到数组中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.insert(<span class="number">100</span>, at: <span class="number">3</span>)</span><br><span class="line">numbers.insert(<span class="number">200</span>, at: numbers.endIndex)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="comment">// Prints "[1, 2, 3, 100, 4, 5, 200]"</span></span><br></pre></td></tr></table></figure>

<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Parameter newElement: The new element to insert into the array.</span></span><br><span class="line"><span class="comment">/// - Parameter i: The position at which to insert the new element.</span></span><br><span class="line"><span class="comment">///   `index` must be a valid index of the array or equal to its `endIndex`</span></span><br><span class="line"><span class="comment">///   property.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Complexity: O(*n*), where *n* is the length of the array. If</span></span><br><span class="line"><span class="comment">///   `i == endIndex`, this method is equivalent to `append(_:)`.</span></span><br><span class="line">@inlinable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> newElement: __owned Element, at i: Int)</span></span> &#123;</span><br><span class="line">  _checkIndex(i)</span><br><span class="line">  <span class="keyword">self</span>.replaceSubrange(i..&lt;i, with: <span class="type">CollectionOfOne</span>(newElement))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、从数组中删除所有的元素</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Parameter keepCapacity: Pass `true` to keep the existing capacity of</span></span><br><span class="line"><span class="comment">///   the array after removing its elements. The default value is</span></span><br><span class="line"><span class="comment">///   `false`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Complexity: O(*n*), where *n* is the length of the array.</span></span><br><span class="line">@inlinable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">removeAll</span><span class="params">(keepingCapacity keepCapacity: Bool = <span class="literal">false</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> !keepCapacity &#123;</span><br><span class="line">    _buffer = _Buffer()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.replaceSubrange(<span class="built_in">indices</span>, with: <span class="type">EmptyCollection</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组实现相关算法"><a href="#数组实现相关算法" class="headerlink" title="数组实现相关算法"></a>数组实现相关算法</h1><p>1、相同类型数组的+和+=实现。 此操作与这些操作符的操作符声明（指定该类型作为首选此操作符的位置）相结合，可帮助表达式类型检查器加快在同一表达式中大量使用该操作符的情况。</p>
<p>算法实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  @inlinable</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> + <span class="params">(lhs: Array, rhs: Array)</span></span> -&gt; <span class="type">Array</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lhs = lhs</span><br><span class="line">    lhs.append(contentsOf: rhs)</span><br><span class="line">    <span class="keyword">return</span> lhs</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @inlinable</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> += <span class="params">(lhs: <span class="keyword">inout</span> Array, rhs: Array)</span></span> &#123;</span><br><span class="line">    lhs.append(contentsOf: rhs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、 <code>Array(unsafeUninitializedCapacity:initializingWith:)</code> 和 <code>ContiguousArray(unsafeUninitializedCapacity:initializingWith:)</code> 的函数实现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@inlinable</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">init</span>(</span><br><span class="line">  _unsafeUninitializedCapacity: <span class="type">Int</span>,</span><br><span class="line">  initializingWith initializer: (</span><br><span class="line">    <span class="number">_</span> buffer: <span class="keyword">inout</span> <span class="type">UnsafeMutableBufferPointer</span>&lt;<span class="type">Element</span>&gt;,</span><br><span class="line">    <span class="number">_</span> initializedCount: <span class="keyword">inout</span> <span class="type">Int</span>) <span class="keyword">throws</span> -&gt; <span class="type">Void</span></span><br><span class="line">) <span class="keyword">rethrows</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> firstElementAddress: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line">  (<span class="keyword">self</span>, firstElementAddress) =</span><br><span class="line">    <span class="type">Array</span>._allocateUninitialized(_unsafeUninitializedCapacity)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> initializedCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> buffer = <span class="type">UnsafeMutableBufferPointer</span>&lt;<span class="type">Element</span>&gt;(</span><br><span class="line">    start: firstElementAddress, <span class="built_in">count</span>: _unsafeUninitializedCapacity)</span><br><span class="line">  <span class="keyword">defer</span> &#123;</span><br><span class="line">    <span class="comment">// Update self.count even if initializer throws an error.</span></span><br><span class="line">    _precondition(</span><br><span class="line">      initializedCount &lt;= _unsafeUninitializedCapacity,</span><br><span class="line">      <span class="string">"Initialized count set to greater than specified capacity."</span></span><br><span class="line">    )</span><br><span class="line">    _precondition(</span><br><span class="line">      buffer.baseAddress == firstElementAddress,</span><br><span class="line">      <span class="string">"Can't reassign buffer in Array(unsafeUninitializedCapacity:initializingWith:)"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">self</span>._buffer.mutableCount = initializedCount</span><br><span class="line">    _endMutation()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> initializer(&amp;buffer, &amp;initializedCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建具有指定容量的数组，然后使用覆盖该数组未初始化内存的缓冲区调用给定的闭包</p>
<p>在闭包内部，将 <code>“ initializedCount”</code> 参数设置为由闭包初始化的元素数。 在闭包执行结束时，必须初始化 <code>“ buffer [0 .. &lt;initializedCount]”</code> 范围内的内存，并且必须对 <code>“ buffer [initializedCount ...]”</code> 范围内的内存进行未初始化。 即使<code>initializer</code>闭包引发错误，此后置条件也必须成立。</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Note: While the resulting array may have a capacity larger than the</span></span><br><span class="line"><span class="comment">///   requested amount, the buffer passed to the closure will cover exactly</span></span><br><span class="line"><span class="comment">///   the requested number of elements.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - unsafeUninitializedCapacity: The number of elements to allocate</span></span><br><span class="line"><span class="comment">///     space for in the new array.</span></span><br><span class="line"><span class="comment">///   - initializer: A closure that initializes elements and sets the count</span></span><br><span class="line"><span class="comment">///     of the new array.</span></span><br><span class="line"><span class="comment">///     - Parameters:</span></span><br><span class="line"><span class="comment">///       - buffer: A buffer covering uninitialized memory with room for the</span></span><br><span class="line"><span class="comment">///         specified number of elements.</span></span><br><span class="line"><span class="comment">///       - initializedCount: The count of initialized elements in the array,</span></span><br><span class="line"><span class="comment">///         which begins as zero. Set `initializedCount` to the number of</span></span><br><span class="line"><span class="comment">///         elements you initialize.</span></span><br><span class="line">@_alwaysEmitIntoClient @inlinable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(</span><br><span class="line">  unsafeUninitializedCapacity: <span class="type">Int</span>,</span><br><span class="line">  initializingWith initializer: (</span><br><span class="line">    <span class="number">_</span> buffer: <span class="keyword">inout</span> <span class="type">UnsafeMutableBufferPointer</span>&lt;<span class="type">Element</span>&gt;,</span><br><span class="line">    <span class="number">_</span> initializedCount: <span class="keyword">inout</span> <span class="type">Int</span>) <span class="keyword">throws</span> -&gt; <span class="type">Void</span></span><br><span class="line">) <span class="keyword">rethrows</span> &#123;</span><br><span class="line">  <span class="keyword">self</span> = <span class="keyword">try</span> <span class="type">Array</span>(</span><br><span class="line">    _unsafeUninitializedCapacity: unsafeUninitializedCapacity,</span><br><span class="line">    initializingWith: initializer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、调用带有指向数组连续存储的指针闭包</p>
<p>通常，优化器可以消除数组算法中的边界检查，但是当失败时，在传递给闭包的缓冲区指针上调用相同的算法可以让你以安全为代价。</p>
<p>下面的示例演示如何遍历缓冲区指针的内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> sum = numbers.withUnsafeBufferPointer &#123; buffer -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: buffer.startIndex, to: buffer.endIndex, by: <span class="number">2</span>) &#123;</span><br><span class="line">        result += buffer[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'sum' == 9</span></span><br></pre></td></tr></table></figure>

<p>作为参数传递给 <code>“ body ”</code> 的指针仅在执行 <code>“ withUnsafeBufferPointer(_ :)”</code> 期间有效。 不要存储或返回指针供以后使用。</p>
<p>函数实现:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Parameter body: A closure with an `UnsafeBufferPointer` parameter that</span></span><br><span class="line"><span class="comment">///   points to the contiguous storage for the array.  If no such storage exists, it is created. If</span></span><br><span class="line"><span class="comment">///   `body` has a return value, that value is also used as the return value</span></span><br><span class="line"><span class="comment">///   for the `withUnsafeBufferPointer(_:)` method. The pointer argument is</span></span><br><span class="line"><span class="comment">///   valid only for the duration of the method's execution.</span></span><br><span class="line"><span class="comment">/// - Returns: The return value, if any, of the `body` closure parameter.</span></span><br><span class="line">@inlinable</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">withUnsafeBufferPointer</span>&lt;R&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> body: <span class="params">(UnsafeBufferPointer&lt;Element&gt;)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">R</span></span><br><span class="line">) <span class="keyword">rethrows</span> -&gt; <span class="type">R</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">try</span> _buffer.withUnsafeBufferPointer(body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用指向数组的可变连续存储的指针来调用给定的闭包</p>
<p>通常，优化器可以消除数组算法中的边界检查，但是当失败时，在传递给闭包的缓冲区指针上调用相同的算法可以让你以安全为代价。</p>
<p>以下示例显示了如何将 <code>UnsafeMutableBufferPointer</code> 参数的内容修改为 <code>body</code> 来更改数组的内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.withUnsafeMutableBufferPointer &#123; buffer <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: buffer.startIndex, to: buffer.endIndex - <span class="number">1</span>, by: <span class="number">2</span>) &#123;</span><br><span class="line">        buffer.swapAt(i, i + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="comment">// Prints "[2, 1, 4, 3, 5]"</span></span><br></pre></td></tr></table></figure>

<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The pointer passed as an argument to `body` is valid only during the</span></span><br><span class="line"><span class="comment">/// execution of `withUnsafeMutableBufferPointer(_:)`. Do not store or</span></span><br><span class="line"><span class="comment">/// return the pointer for later use.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Warning: Do not rely on anything about the array that is the target of</span></span><br><span class="line"><span class="comment">///   this method during execution of the `body` closure; it might not</span></span><br><span class="line"><span class="comment">///   appear to have its correct value. Instead, use only the</span></span><br><span class="line"><span class="comment">///   `UnsafeMutableBufferPointer` argument to `body`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter body: A closure with an `UnsafeMutableBufferPointer`</span></span><br><span class="line"><span class="comment">///   parameter that points to the contiguous storage for the array.</span></span><br><span class="line"><span class="comment">///    If no such storage exists, it is created. If `body` has a return value, that value is also</span></span><br><span class="line"><span class="comment">///   used as the return value for the `withUnsafeMutableBufferPointer(_:)`</span></span><br><span class="line"><span class="comment">///   method. The pointer argument is valid only for the duration of the</span></span><br><span class="line"><span class="comment">///   method's execution.</span></span><br><span class="line"><span class="comment">/// - Returns: The return value, if any, of the `body` closure parameter.</span></span><br><span class="line">@_semantics(<span class="string">"array.withUnsafeMutableBufferPointer"</span>)</span><br><span class="line">@inlinable <span class="comment">// FIXME(inline-always)</span></span><br><span class="line">@inline(__always) <span class="comment">// Performance: This method should get inlined into the</span></span><br><span class="line"><span class="comment">// caller such that we can combine the partial apply with the apply in this</span></span><br><span class="line"><span class="comment">// function saving on allocating a closure context. This becomes unnecessary</span></span><br><span class="line"><span class="comment">// once we allocate noescape closures on the stack.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">withUnsafeMutableBufferPointer</span>&lt;R&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> body: <span class="params">(<span class="keyword">inout</span> UnsafeMutableBufferPointer&lt;Element&gt;)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">R</span></span><br><span class="line">) <span class="keyword">rethrows</span> -&gt; <span class="type">R</span> &#123;</span><br><span class="line">  _makeMutableAndUnique()</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">count</span> = _buffer.mutableCount</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that body can't invalidate the storage or its bounds by</span></span><br><span class="line">  <span class="comment">// moving self into a temporary working array.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> The stack promotion optimization that keys of the</span></span><br><span class="line">  <span class="comment">// "array.withUnsafeMutableBufferPointer" semantics annotation relies on the</span></span><br><span class="line">  <span class="comment">// array buffer not being able to escape in the closure. It can do this</span></span><br><span class="line">  <span class="comment">// because we swap the array buffer in self with an empty buffer here. Any</span></span><br><span class="line">  <span class="comment">// escape via the address of self in the closure will therefore escape the</span></span><br><span class="line">  <span class="comment">// empty array.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> work = <span class="type">Array</span>()</span><br><span class="line">  (work, <span class="keyword">self</span>) = (<span class="keyword">self</span>, work)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an UnsafeBufferPointer over work that we can pass to body</span></span><br><span class="line">  <span class="keyword">let</span> pointer = work._buffer.mutableFirstElementAddress</span><br><span class="line">  <span class="keyword">var</span> inoutBufferPointer = <span class="type">UnsafeMutableBufferPointer</span>(</span><br><span class="line">    start: pointer, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Put the working array back before returning.</span></span><br><span class="line">  <span class="keyword">defer</span> &#123;</span><br><span class="line">    _precondition(</span><br><span class="line">      inoutBufferPointer.baseAddress == pointer &amp;&amp;</span><br><span class="line">      inoutBufferPointer.<span class="built_in">count</span> == <span class="built_in">count</span>,</span><br><span class="line">      <span class="string">"Array withUnsafeMutableBufferPointer: replacing the buffer is not allowed"</span>)</span><br><span class="line"></span><br><span class="line">    (work, <span class="keyword">self</span>) = (<span class="keyword">self</span>, work)</span><br><span class="line">    _endMutation()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invoke the body.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">try</span> body(&amp;inoutBufferPointer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@inlinable</span><br><span class="line"><span class="keyword">public</span> __consuming <span class="function"><span class="keyword">func</span> <span class="title">_copyContents</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  initializing buffer: UnsafeMutableBufferPointer&lt;Element&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; (<span class="type">Iterator</span>,<span class="type">UnsafeMutableBufferPointer</span>&lt;<span class="type">Element</span>&gt;.<span class="type">Index</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">guard</span> !<span class="keyword">self</span>.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> (makeIterator(),buffer.startIndex) &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// It is not OK for there to be no pointer/not enough space, as this is</span></span><br><span class="line">  <span class="comment">// a precondition and Array never lies about its count.</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">var</span> p = buffer.baseAddress</span><br><span class="line">    <span class="keyword">else</span> &#123; _preconditionFailure(<span class="string">"Attempt to copy contents into nil buffer pointer"</span>) &#125;</span><br><span class="line">  _precondition(<span class="keyword">self</span>.<span class="built_in">count</span> &lt;= buffer.<span class="built_in">count</span>, </span><br><span class="line">    <span class="string">"Insufficient space allocated to copy array contents"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> s = _baseAddressIfContiguous &#123;</span><br><span class="line">    p.initialize(from: s, <span class="built_in">count</span>: <span class="keyword">self</span>.<span class="built_in">count</span>)</span><br><span class="line">    <span class="comment">// Need a _fixLifetime bracketing the _baseAddressIfContiguous getter</span></span><br><span class="line">    <span class="comment">// and all uses of the pointer it returns:</span></span><br><span class="line">    _fixLifetime(<span class="keyword">self</span>._owner)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      p.initialize(to: x)</span><br><span class="line">      p += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> it = <span class="type">IndexingIterator</span>(_elements: <span class="keyword">self</span>)</span><br><span class="line">  it._position = endIndex</span><br><span class="line">  <span class="keyword">return</span> (it,buffer.index(buffer.startIndex, offsetBy: <span class="keyword">self</span>.<span class="built_in">count</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、用指定集合中的元素替换一系列元素</p>
<p>此方法具有从数组中删除指定范围的元素并将新元素插入相同位置的作用。 新元素的数量不必与要删除的元素的数量匹配。</p>
<p>在这个例子中，整数数组中间的三个元素被 <code>Repeated &lt;Int&gt;</code> 实例的五个元素代替。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line">nums.replaceSubrange(<span class="number">1</span>...<span class="number">3</span>, with: repeatElement(<span class="number">1</span>, <span class="built_in">count</span>: <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br><span class="line"><span class="comment">// Prints "[10, 1, 1, 1, 1, 1, 50]"</span></span><br></pre></td></tr></table></figure>

<p>如果你将零长度范围作为 <code>“ subrange”</code> 参数传递，则此方法会将 <code>“ newElements”</code> 的元素插入 <code>“ subrange.startIndex”</code> 。 最好是调用<code>insert（contentsOf：at：）</code>方法。<br>同样，如果你将零长度的集合作为·“ newElements”·参数传递，则此方法将删除给定子范围内的元素，而无需替换。 最好调用<code>removeSubrange（_ :)</code>方法。</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - subrange: The subrange of the array to replace. The start and end of</span></span><br><span class="line"><span class="comment">///     a subrange must be valid indices of the array.</span></span><br><span class="line"><span class="comment">///   - newElements: The new elements to add to the array.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Complexity: O(*n* + *m*), where *n* is length of the array and</span></span><br><span class="line"><span class="comment">///   *m* is the length of `newElements`. If the call to this method simply</span></span><br><span class="line"><span class="comment">///   appends the contents of `newElements` to the array, this method is</span></span><br><span class="line"><span class="comment">///   equivalent to `append(contentsOf:)`.</span></span><br><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.mutate_unknown"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">replaceSubrange</span>&lt;C&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> subrange: Range&lt;Int&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  with newElements: __owned C</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> <span class="keyword">where</span> <span class="type">C</span>: <span class="type">Collection</span>, <span class="type">C</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">  _precondition(subrange.lowerBound &gt;= <span class="keyword">self</span>._buffer.startIndex,</span><br><span class="line">    <span class="string">"Array replace: subrange start is negative"</span>)</span><br><span class="line"></span><br><span class="line">  _precondition(subrange.upperBound &lt;= _buffer.endIndex,</span><br><span class="line">    <span class="string">"Array replace: subrange extends past the end"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> eraseCount = subrange.<span class="built_in">count</span></span><br><span class="line">  <span class="keyword">let</span> insertCount = newElements.<span class="built_in">count</span></span><br><span class="line">  <span class="keyword">let</span> growth = insertCount - eraseCount</span><br><span class="line"></span><br><span class="line">  _reserveCapacityImpl(minimumCapacity: <span class="keyword">self</span>.<span class="built_in">count</span> + growth,</span><br><span class="line">                       growForAppend: <span class="literal">true</span>)</span><br><span class="line">  _buffer.replaceSubrange(subrange, with: insertCount, elementsOf: newElements)</span><br><span class="line">  _endMutation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、返回一个布尔值，该值指示两个数组是否包含相同顺序的相同元素</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// You can use the equal-to operator (`==`) to compare any two arrays</span></span><br><span class="line"><span class="comment">/// that store the same, `Equatable`-conforming element type.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - lhs: An array to compare.</span></span><br><span class="line"><span class="comment">///   - rhs: Another array to compare.</span></span><br><span class="line">@inlinable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Array&lt;Element&gt;, rhs: Array&lt;Element&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> lhsCount = lhs.<span class="built_in">count</span></span><br><span class="line">  <span class="keyword">if</span> lhsCount != rhs.<span class="built_in">count</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test referential equality.</span></span><br><span class="line">  <span class="keyword">if</span> lhsCount == <span class="number">0</span> || lhs._buffer.identity == rhs._buffer.identity &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  _internalInvariant(lhs.startIndex == <span class="number">0</span> &amp;&amp; rhs.startIndex == <span class="number">0</span>)</span><br><span class="line">  _internalInvariant(lhs.endIndex == lhsCount &amp;&amp; rhs.endIndex == lhsCount)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We know that lhs.count == rhs.count, compare element wise.</span></span><br><span class="line">  <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;lhsCount &#123;</span><br><span class="line">    <span class="keyword">if</span> lhs[idx] != rhs[idx] &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、通过将这些值的必需成分输入给定的哈希值来对其进行哈希处理</p>
<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Parameter hasher: The hasher to use when combining the components</span></span><br><span class="line"><span class="comment">///   of this instance.</span></span><br><span class="line">@inlinable</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">hash</span><span class="params">(into hasher: <span class="keyword">inout</span> Hasher)</span></span> &#123;</span><br><span class="line">  hasher.combine(<span class="built_in">count</span>) <span class="comment">// discriminator</span></span><br><span class="line">  <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    hasher.combine(element)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用给定的闭包，并使用指针指向数组的可变连续存储的基础字节。<br>数组的 <code>“Element”</code> 类型必须是 <code>“trivial type”</code> ，可以仅进行逐位复制而无需任何间接或引用计数操作。 通常，不包含强引用或弱引用的本机Swift类型以及导入的C结构和枚举都是微不足道的。<br>下面的示例将byteValues数组中的字节复制到numbers中，即Int数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers: [<span class="type">Int32</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> byteValues: [<span class="type">UInt8</span>] = [<span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]</span><br><span class="line"></span><br><span class="line">numbers.withUnsafeMutableBytes &#123; destBytes <span class="keyword">in</span></span><br><span class="line">    byteValues.withUnsafeBytes &#123; srcBytes <span class="keyword">in</span></span><br><span class="line">        destBytes.copyBytes(from: srcBytes)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// numbers == [1, 2]</span></span><br></pre></td></tr></table></figure>

<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The pointer passed as an argument to `body` is valid only for the</span></span><br><span class="line"><span class="comment">/// lifetime of the closure. Do not escape it from the closure for later</span></span><br><span class="line"><span class="comment">/// use.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Warning: Do not rely on anything about the array that is the target of</span></span><br><span class="line"><span class="comment">///   this method during execution of the `body` closure; it might not</span></span><br><span class="line"><span class="comment">///   appear to have its correct value. Instead, use only the</span></span><br><span class="line"><span class="comment">///   `UnsafeMutableRawBufferPointer` argument to `body`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter body: A closure with an `UnsafeMutableRawBufferPointer`</span></span><br><span class="line"><span class="comment">///   parameter that points to the contiguous storage for the array.</span></span><br><span class="line"><span class="comment">///    If no such storage exists, it is created. If `body` has a return value, that value is also</span></span><br><span class="line"><span class="comment">///   used as the return value for the `withUnsafeMutableBytes(_:)` method.</span></span><br><span class="line"><span class="comment">///   The argument is valid only for the duration of the closure's</span></span><br><span class="line"><span class="comment">///   execution.</span></span><br><span class="line"><span class="comment">/// - Returns: The return value, if any, of the `body` closure parameter.</span></span><br><span class="line">@inlinable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">withUnsafeMutableBytes</span>&lt;R&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> body: <span class="params">(UnsafeMutableRawBufferPointer)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">R</span></span><br><span class="line">) <span class="keyword">rethrows</span> -&gt; <span class="type">R</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.withUnsafeMutableBufferPointer &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> body(<span class="type">UnsafeMutableRawBufferPointer</span>($<span class="number">0</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、使用指向数组连续存储的基础字节的指针来调用给定的闭包</p>
<p>数组的 <code>“Element”</code> 类型必须是 <code>“trivial type”</code> ，可以仅进行逐位复制而无需任何间接或引用计数操作。 通常，不包含强引用或弱引用的本机Swift类型以及导入的C结构和枚举都是微不足道的。</p>
<p>以下示例将numbers数组的字节复制到UInt8的缓冲区中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> byteBuffer: [<span class="type">UInt8</span>] = []</span><br><span class="line">numbers.withUnsafeBytes &#123;</span><br><span class="line">    byteBuffer.append(contentsOf: $<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// byteBuffer == [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, ...]</span></span><br></pre></td></tr></table></figure>

<p>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// - Parameter body: A closure with an `UnsafeRawBufferPointer` parameter</span></span><br><span class="line"><span class="comment">///   that points to the contiguous storage for the array.</span></span><br><span class="line"><span class="comment">///    If no such storage exists, it is created. If `body` has a return value, that value is also</span></span><br><span class="line"><span class="comment">///   used as the return value for the `withUnsafeBytes(_:)` method. The</span></span><br><span class="line"><span class="comment">///   argument is valid only for the duration of the closure's execution.</span></span><br><span class="line"><span class="comment">/// - Returns: The return value, if any, of the `body` closure parameter.</span></span><br><span class="line">@inlinable</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">withUnsafeBytes</span>&lt;R&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> body: <span class="params">(UnsafeRawBufferPointer)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">R</span></span><br><span class="line">) <span class="keyword">rethrows</span> -&gt; <span class="type">R</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.withUnsafeBufferPointer &#123;</span><br><span class="line">    <span class="keyword">try</span> body(<span class="type">UnsafeRawBufferPointer</span>($<span class="number">0</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Cocoa-Array-gt-Swift-Array-的桥接实现"><a href="#Cocoa-Array-gt-Swift-Array-的桥接实现" class="headerlink" title="Cocoa Array -&gt;Swift Array 的桥接实现"></a><code>Cocoa Array</code> -&gt;<code>Swift Array</code> 的桥接实现</h1><p>我们在这里隔离<code>Cocoa Array</code> -&gt;<code>Swift Array</code> 的桥接，以便将来我们可以桥接 <code>Cocoa Array</code> 。 我们需要此功能以ABI安全的方式进行桥接。 即使这看起来没用，也不要删除！</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@usableFromInline <span class="keyword">internal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_bridgeCocoaArray</span>&lt;T&gt;<span class="params">(<span class="number">_</span> _immutableCocoaArray: AnyObject)</span></span> -&gt; <span class="type">Array</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Array</span>(_buffer: _ArrayBuffer(nsArray: _immutableCocoaArray))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试将源NSArray转换为我们的本机缓冲区类型。 如果成功，则在其周围创建一个新的“ Array”并返回该数组。 否则返回“ nil”。<br>注意：此函数存在于此处，因此Foundation不必知道Array的实现详细信息</p>
<h1 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h1><p>在 <code>Array</code> 内部实现中，有这样一段代码，代码中强调使用 <code>_buffer</code> 进行数组的初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@inlinable</span><br><span class="line">@_semantics(<span class="string">"array.init.empty"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">  _buffer = _Buffer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 <code>_Buffer</code> 数据结构分析，其定义是：</p>
<p><img src="https://cdn.xuebaonline.com/array_im_01.png" alt=""></p>
<p>待续……</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Char 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Char 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5eacc50f0dcd8169" async="async"></script>
  </div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Char
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.xuebaonline.com/Swift%20%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97(%E4%B8%80)%EF%BC%9AArray%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" title="Swift 源码系列(一)：Array的实现原理探究">https://www.xuebaonline.com/Swift 源码系列(一)：Array的实现原理探究/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/Bogon">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/connectme.JPG">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"><i class="fa fa-tag"></i> iOS</a>
              <a href="/tags/Swift/" rel="tag"><i class="fa fa-tag"></i> Swift</a>
              <a href="/tags/Array/" rel="tag"><i class="fa fa-tag"></i> Array</a>
              <a href="/tags/Swift-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="tag"><i class="fa fa-tag"></i> Swift 源码阅读</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%ADSwift%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E7%BA%A6%E6%9D%9F%E4%BF%9D%E6%8C%81%E5%9B%A2%E9%98%9F%E5%86%85%E9%83%A8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E8%B7%B5/" rel="prev" title="在iOS工程中Swift代码进行约束保持团队内部代码风格一致性的实践">
      <i class="fa fa-chevron-left"></i> 在iOS工程中Swift代码进行约束保持团队内部代码风格一致性的实践
    </a></div>
      <div class="post-nav-item">
    <a href="/macOS%20Big%20Sur%2011.1%20Arm%E6%9E%B6%E6%9E%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8Homebrew/" rel="next" title="macOS Big Sur 11.1 Arm架构安装使用Homebrew">
      macOS Big Sur 11.1 Arm架构安装使用Homebrew <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#创建数组"><span class="nav-number">2.</span> <span class="nav-text">创建数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#访问数组元素"><span class="nav-number">3.</span> <span class="nav-text">访问数组元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#添加元素"><span class="nav-number">4.</span> <span class="nav-text">添加元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#删除元素"><span class="nav-number">5.</span> <span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组扩容"><span class="nav-number">6.</span> <span class="nav-text">数组扩容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#修改拷贝的数组"><span class="nav-number">7.</span> <span class="nav-text">修改拷贝的数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Array-和-NSArray-桥接"><span class="nav-number">8.</span> <span class="nav-text">Array 和 NSArray 桥接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列化数组"><span class="nav-number">9.</span> <span class="nav-text">序列化数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基础变动-basic-mutations"><span class="nav-number">10.</span> <span class="nav-text">基础变动(basic mutations)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组实现相关算法"><span class="nav-number">11.</span> <span class="nav-text">数组实现相关算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cocoa-Array-gt-Swift-Array-的桥接实现"><span class="nav-number">12.</span> <span class="nav-text">Cocoa Array -&gt;Swift Array 的桥接实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组初始化"><span class="nav-number">13.</span> <span class="nav-text">数组初始化</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Char"
      src="https://cdn.xuebaonline.com/blog_avatar.JPG">
  <p class="site-author-name" itemprop="name">Char</p>
  <div class="site-description" itemprop="description">曾经沧海难为水，除却巫山不是云。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">147</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">122</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element">
    <a onclick="Chatra('openChat', true);"><i class="fa fa-comment"></i>
    联系我
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Bogon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Bogon" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhangqixcu@gmail.com" title="E-Mail → mailto:zhangqixcu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5640441479" title="新浪微博 → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5640441479" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/bogonbug" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;bogonbug" rel="noopener" target="_blank"><i class="fab fa-skype fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Bogon" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Bogon" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/4368897/qizhang" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;4368897&#x2F;qizhang" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      推荐阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://developer.apple.com/swift/" title="https:&#x2F;&#x2F;developer.apple.com&#x2F;swift&#x2F;" rel="noopener" target="_blank">Swift 5.3</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://developer.apple.com/documentation/objectivec" title="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;objectivec" rel="noopener" target="_blank">Objective-C</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备20011156号-1 </a>
      <img src="/images/beian.png" style="display: inline-block;"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41172402000135" rel="noopener" target="_blank">豫公网安备41172402000135号 </a>
  </div>

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Char</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">博客全站共1.3m字</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">19:59</span>
</div>

<!--
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5eacc50f0dcd8169" async="async"></script>
  </div>
-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>




  <script>
    (function(d, w, c) {
      w.ChatraID = 'PxGFNHLgjQ3C3Hmpo';
      var s = d.createElement('script');
      w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
      };
      s.async = true;
      s.src = 'https://call.chatra.io/chatra.js';
      if (d.head) d.head.appendChild(s);
    })(document, window, 'Chatra');
  </script>









  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'rfRdmQpsk2Crnz747tDDOu26-gzGzoHsz',
      appKey     : 'eyu1k9BeINgR5FuXzbc969UA',
      placeholder: "写出你的想法……",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>