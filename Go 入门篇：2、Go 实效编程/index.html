<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
<script data-ad-client="ca-pub-5714801576974230" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="G0fHOrfJn5sHWzmi6ZCcg2aX83myBc-9U1BJZJJDSTU">
  <meta name="baidu-site-verification" content="7gJOLignE2">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.xuebaonline.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>


  <meta name="description" content="Go 入门篇：2、Go 实效编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 入门篇：2、Go 实效编程">
<meta property="og:url" content="https://www.xuebaonline.com/Go%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%9A2%E3%80%81Go%20%E5%AE%9E%E6%95%88%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Char&#39;s Blog">
<meta property="og:description" content="Go 入门篇：2、Go 实效编程">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-12-14T11:31:20.000Z">
<meta property="article:modified_time" content="2021-12-24T03:30:57.092Z">
<meta property="article:author" content="Char">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="mysql">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="ubuntu">
<meta property="article:tag" content="go">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.xuebaonline.com/Go%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%9A2%E3%80%81Go%20%E5%AE%9E%E6%95%88%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<script data-ad-client="ca-pub-5714801576974230" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <title>Go 入门篇：2、Go 实效编程 | Char's Blog</title>
  
    <script>
      function sendPageView() {
        if (CONFIG.hostname !== location.hostname) return;
        var uid = localStorage.getItem('uid') || (Math.random() + '.' + Math.random());
        localStorage.setItem('uid', uid);
        navigator.sendBeacon('https://www.google-analytics.com/collect', new URLSearchParams({
          v  : 1,
          tid: 'UA-165583776-1',
          cid: uid,
          t  : 'pageview',
          dp : encodeURIComponent(location.pathname)
        }));
      }
      document.addEventListener('pjax:complete', sendPageView);
      sendPageView();
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f44aa1d26d8ba6a20c1a09a9cdcd7e3d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Char's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Char's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">如切如磋，如琢如磨。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">143</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">67</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">176</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.xuebaonline.com/Go%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%9A2%E3%80%81Go%20%E5%AE%9E%E6%95%88%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cdn.xuebaonline.com/blog_avatar.JPG">
      <meta itemprop="name" content="Char">
      <meta itemprop="description" content="曾经沧海难为水，除却巫山不是云。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Char's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go 入门篇：2、Go 实效编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-14 19:31:20" itemprop="dateCreated datePublished" datetime="2021-12-14T19:31:20+08:00">2021-12-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E5%85%A5%E9%97%A8%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">Go 入门篇</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/Go%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%9A2%E3%80%81Go%20%E5%AE%9E%E6%95%88%E7%BC%96%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Go%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%9A2%E3%80%81Go%20%E5%AE%9E%E6%95%88%E7%BC%96%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>45k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>40 分钟</span>
            </span>
            <div class="post-description">Go 入门篇：2、Go 实效编程</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>Go</code> 是一门全新的语言。尽管它从既有的语言中借鉴了许多理念，但其与众不同的特性， 使得使用 <code>Go</code> 编程在本质上就不同于其它语言。将现有的 <code>C++</code> 或 <code>Java</code> 程序直译为 <code>Go</code> 程序并不能令人满意——毕竟<code>Java程序</code>是用<code>Java</code>编写的，而不是<code>Go</code>。 另一方面，若从<code>Go</code>的角度去分析问题，你就能编写出同样可行但大不相同的程序。 换句话说，要想将<code>Go</code>程序写得好，就必须理解其特性和风格。了解<em>命名</em>、<em>格式化</em>、 <em>程序结构</em>等既定规则也同样重要，这样你编写的程序才能更容易被其他程序员所理解。</p>
<p>本文档就如何编写清晰、地道的Go代码提供了一些技巧。它是对<a href="https://go-zh.org/ref/spec" target="_blank" rel="noopener">语言规范</a>、 Go语言之旅以及 如何<a href="https://go-zh.org/doc/code.html" target="_blank" rel="noopener">使用Go编程</a>的补充说明，因此我们建议您先阅读这些文档。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><a href="https://go-zh.org/src/" target="_blank" rel="noopener">Go包的源码</a>不仅是核心库，同时也是学习如何使用 <code>Go</code> 语言的示例源码。 此外，其中的一些包还包含了可工作的，独立的可执行示例，你可以直接在 <code>golang.org</code> 网站上运行它们，比如 这个例子 （单击文字“示例”来展开它）。如果你有任何关于某些问题如何解决，或某些东西如何实现的疑问， 也可以从中获取相关的答案、思路以及后台实现。</p>
<h1 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h1><p>格式化问题总是充满了争议，但却始终没有形成统一的定论。虽说人们可以适应不同的编码风格， 但抛弃这种适应过程岂不更好？若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少。 问题就在于如何实现这种设想，而无需冗长的语言风格规范。</p>
<p>在 <code>Go</code> 中我们另辟蹊径，让机器来处理大部分的格式化问题。<code>go fmt</code> 程序（也可用 <code>go fmt</code>，它以包为处理对象而非源文件）将Go程序按照标准风格缩进、 对齐，保留注释并在需要时重新格式化。若你想知道如何处理一些新的代码布局，请尝试运行 <code>go fmt</code> ；若结果仍不尽人意，请重新组织你的程序（或提交有关 <code>gofmt</code> 的 <code>Bug</code>），而不必为此纠结。</p>
<a id="more"></a>

<p>举例来说，你无需花时间将结构体中的字段注释对齐，<code>go fmt</code> 将为你代劳。 假如有以下声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span> <span class="comment">// 对象名</span></span><br><span class="line">	value <span class="keyword">int</span> <span class="comment">// 对象值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gofmt 会将它按列对齐为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	name    <span class="keyword">string</span> <span class="comment">// 对象名</span></span><br><span class="line">	value   <span class="keyword">int</span>    <span class="comment">// 对象值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准包中所有的Go代码都已经用 gofmt 格式化过了。</p>
<p>还有一些关于格式化的细节，它们非常简短：</p>
<ul>
<li>缩进<br>我们使用制表符<code>（tab）</code>缩进，<code>gofmt</code> 默认也使用它。在你认为确实有必要时再使用空格。</li>
<li>行的长度<br><code>Go</code>对行的长度没有限制，别担心打孔纸不够长。如果一行实在太长，也可进行折行并插入适当的<code>tab</code>缩进。</li>
<li>括号<br>比起 <code>C</code> 和 <code>Java</code>，<code>Go</code>所需的括号更少：控制结构<code>（if、for 和 switch）</code>在语法上并不需要圆括号。此外，操作符优先级处理变得更加简洁，因此<blockquote>
<p><code>x&lt;&lt;8 + y&lt;&lt;16</code><br>正表述了空格符所传达的含义。</p>
</blockquote>
</li>
</ul>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p><code>Go</code> 语言支持 <code>C</code> 风格的块注释 <code>/* */</code> 和 <code>C++</code> 风格的行注释 <code>//</code> 。 行注释更为常用，而块注释则主要用作包的注释，当然也可在禁用一大段代码时使用。<br><code>godoc </code>既是一个程序，又是一个 <code>Web服务器</code>，它对 <code>Go</code> 的源码进行处理，并提取包中的文档内容。 出现在顶级声明之前，且与该声明之间没有空行的注释，将与该声明一起被提取出来，作为该条目的说明文档。 这些注释的类型和风格决定了 <code>godoc</code> 生成的文档质量。<br>每个包都应包含一段包注释，即放置在包子句前的一个块注释。对于包含多个文件的包， 包注释只需出现在其中的任一文件中即可。包注释应在整体上对该包进行介绍，并提供包的相关信息。 它将出现在 <code>godoc</code> 页面中的最上面，并为紧随其后的内容建立详细的文档。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	regexp 包为正则表达式实现了一个简单的库。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	该库接受的正则表达式语法为：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	正则表达式:</span></span><br><span class="line"><span class="comment">		串联 &#123; '|' 串联 &#125;</span></span><br><span class="line"><span class="comment">	串联:</span></span><br><span class="line"><span class="comment">		&#123; 闭包 &#125;</span></span><br><span class="line"><span class="comment">	闭包:</span></span><br><span class="line"><span class="comment">		条目 [ '*' | '+' | '?' ]</span></span><br><span class="line"><span class="comment">	条目:</span></span><br><span class="line"><span class="comment">		'^'</span></span><br><span class="line"><span class="comment">		'$'</span></span><br><span class="line"><span class="comment">		'.'</span></span><br><span class="line"><span class="comment">		字符</span></span><br><span class="line"><span class="comment">		'[' [ '^' ] 字符遍历 ']'</span></span><br><span class="line"><span class="comment">		'(' 正则表达式 ')'</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> regexp</span><br></pre></td></tr></table></figure>
<p>若某个包比较简单，包注释同样可以简洁些。</p>
<blockquote>
<p>// path 包实现了一些常用的工具，以便于操作用反斜杠分隔的路径.<br>注释无需进行额外的格式化，如用星号来突出等。生成的输出甚至可能无法以等宽字体显示， 因此不要依赖于空格对齐，<code>godoc</code> 会像 <code>gofmt</code> 那样处理好这一切。 注释是不会被解析的纯文本，因此像<code>HTML</code> 或其它类似于 <code>_这样_</code> 的东西将按照 原样 输出，因此不应使用它们。<code>godoc</code> 所做的调整， 就是将已缩进的文本以等宽字体显示，来适应对应的程序片段。 <code>fmt</code> 包的注释就用了这种不错的效果。<br><code>godoc</code> 是否会重新格式化注释取决于上下文，因此必须确保它们看起来清晰易辨： 使用正确的拼写、标点和语句结构以及折叠长行等。<br>在包中，任何顶级声明前面的注释都将作为该声明的文档注释。 在程序中，每个可导出（首字母大写）的名称都应该有文档注释。<br>文档注释最好是完整的句子，这样它才能适应各种自动化的展示。 第一句应当以被声明的东西开头，并且是单句的摘要。</p>
</blockquote>
<blockquote>
<p>// Compile 用于解析正则表达式并返回，如果成功，则 Regexp 对象就可用于匹配所针对的文本。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(regexp *Regexp, err error)</span></span> &#123;</span><br></pre></td></tr></table></figure>

<p>若注释总是以名称开头，<code>godoc</code> 的输出就能通过 <code>grep</code> 变得更加有用。假如你记不住 <code>“Compile”</code> 这个名称，而又在找正则表达式的解析函数， 那就可以运行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ godoc regexp | grep parse</span><br></pre></td></tr></table></figure>
<p>若包中的所有文档注释都以“此函数…”开头，<code>grep</code> 就无法帮你记住此名称。 但由于每个包的文档注释都以其名称开头，你就能看到这样的内容，它能显示你正在寻找的词语。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ godoc regexp | grep parse</span><br><span class="line">	Compile parses a regular expression and returns, <span class="keyword">if</span> successful, a Regexp</span><br><span class="line">	parsed. It simplifies safe initialization of global variables holding</span><br><span class="line">	cannot be parsed. It simplifies safe initialization of global variables</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p><code>Go</code> 的声明语法允许成组声明。单个文档注释应介绍一组相关的常量或变量。 由于是整体声明，这种注释往往较为笼统。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表达式解析失败后返回错误代码。</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ErrInternal      = errors.New(<span class="string">"regexp: internal error"</span>)</span><br><span class="line">	ErrUnmatchedLpar = errors.New(<span class="string">"regexp: unmatched '('"</span>)</span><br><span class="line">	ErrUnmatchedRpar = errors.New(<span class="string">"regexp: unmatched ')'"</span>)</span><br><span class="line">	...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>即便是对于私有名称，也可通过成组声明来表明各项间的关系，例如某一组由互斥体保护的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	countLock   sync.Mutex</span><br><span class="line">	inputCount  <span class="keyword">uint32</span></span><br><span class="line">	outputCount <span class="keyword">uint32</span></span><br><span class="line">	errorCount  <span class="keyword">uint32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><p>正如命名在其它语言中的地位，它在 <code>Go</code> 中同样重要。有时它们甚至会影响语义： 例如，某个名称在包外是否可见，就取决于其首个字符是否为大写字母。 因此有必要花点时间来讨论 <code>Go</code> 程序中的命名约定。</p>
<h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p>当一个包被导入后，包名就会成了内容的访问器。在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"bytes"</span></span><br></pre></td></tr></table></figure>
<p>之后，被导入的包就能通过 <code>bytes.Buffer</code> 来引用了。 若所有人都以相同的名称来引用其内容将大有裨益， 这也就意味着包应当有个恰当的名称：<em><strong>其名称应该简洁明了而易于理解</strong></em>。按照惯例， <em><strong>包应当以小写的单个单词来命名，且不应使用下划线或驼峰记法</strong></em>。<code>err</code> 的命名就是出于简短考虑的，因为任何使用该包的人都会键入该名称。 不必担心引用次序的冲突。包名就是导入时所需的唯一默认名称， 它并不需要在所有源码中保持唯一，即便在少数发生冲突的情况下， 也可为导入的包选择一个别名来局部使用。 无论如何，通过文件名来判定使用的包，都是不会产生混淆的。</p>
<p><em><strong>另一个约定就是包名应为其源码目录的基本名称</strong></em>。在 <code>src/pkg/encoding/base64</code> 中的包应作为 <code>&quot;encoding/base64&quot;</code> 导入，其包名应为 <code>base64</code>， 而非 <code>encoding_base64</code> 或 <code>encodingBase64</code>。</p>
<p>包的导入者可通过包名来引用其内容，因此包中的可导出名称可以以此来避免冲突。 （请勿使用 <code>import</code> . 记法，它可以简化必须在被测试包外运行的测试， 除此之外应尽量避免使用。）例如，<code>bufio</code> 包中的缓存读取器类型叫做 <code>Reader</code> 而非 <code>BufReader</code>，因为用户将它看做 <code>bufio.Reader</code>，这是个清楚而简洁的名称。 此外，由于被导入的项总是通过它们的包名来确定，因此 <code>bufio.Reader</code> 不会与 <code>io.Reader</code> 发生冲突。同样，用于创建 <code>ring.Ring</code> 的新实例的函数（这就是 <code>Go</code> 中的构造函数）一般会称之为 <code>NewRing</code>，但由于 <code>Ring</code> 是该包所导出的唯一类型，且该包也叫 <code>ring</code>，因此它可以只叫做 <code>New</code>，它跟在包的后面，就像 <code>ring.New</code>。使用包结构可以帮助你选择好的名称。<br>另一个简短的例子是 <code>once.Do</code>，<code>once.Do(setup)</code> 表述足够清晰， 使用 <code>once.DoOrWaitUntilDone(setup)</code> 完全就是画蛇添足。 长命名并不会使其更具可读性。一份有用的说明文档通常比额外的长名更有价值。</p>
<h2 id="获取器"><a href="#获取器" class="headerlink" title="获取器"></a>获取器</h2><p><code>Go</code> 并不对获取器（<code>getter</code>）和设置器（<code>setter</code>）提供自动支持。 你应当自己提供获取器和设置器，通常很值得这样做，但若要将 <code>Get</code> 放到获取器的名字中，既不符合习惯，也没有必要。若你有个名为 <code>owner</code> （小写，未导出）的字段，其获取器应当名为 <code>Owner</code>（大写，可导出）而非 <code>GetOwner</code>。大写字母即为可导出的这种规定为区分方法和字段提供了便利。 若要提供设置器方法，<code>SetOwner</code> 是个不错的选择。两个命名看起来都很合理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">owner := obj.Owner()</span><br><span class="line"><span class="keyword">if</span> owner != user &#123;</span><br><span class="line">	obj.SetOwner(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口名"><a href="#接口名" class="headerlink" title="接口名"></a>接口名</h2><p>按照约定，只包含一个方法的接口应当以该方法的名称加上<code>-er</code>后缀来命名，如 <code>Reader</code>、<code>Writer</code>、 <code>Formatter</code>、<code>CloseNotifier</code> 等。<br>诸如此类的命名有很多，遵循它们及其代表的函数名会让事情变得简单。 <code>Read</code>、<code>Write</code>、<code>Close</code>、<code>Flush</code>、 <code>String</code> 等都具有典型的签名和意义。为避免冲突，请不要用这些名称为你的方法命名， 除非你明确知道它们的签名和意义相同。反之，若你的类型实现了的方法， 与一个众所周知的类型的方法拥有相同的含义，那就使用相同的命名。 请将字符串转换方法命名为 <code>String</code> 而非 <code>ToString</code>。</p>
<h2 id="驼峰记法"><a href="#驼峰记法" class="headerlink" title="驼峰记法"></a>驼峰记法</h2><p>最后，<code>Go</code>中约定使用驼峰记法 <code>MixedCaps</code> 或 <code>mixedCaps</code>。</p>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>和<code>C</code>一样，<code>Go</code>的正式语法使用分号来结束语句；和<code>C</code>不同的是，这些分号并不在源码中出现。 取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此因此源码中基本就不用分号了。</p>
<p>规则是这样的：若在新行前的最后一个标记为标识符（包括 <code>int</code> 和 <code>float64</code> 这类的单词）、数值或字符串常量之类的基本字面或以下标记之一</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> <span class="keyword">continue</span> <span class="keyword">fallthrough</span> <span class="keyword">return</span> ++ -- ) &#125;</span><br></pre></td></tr></table></figure>
<p>则词法分析将始终在该标记后面插入分号。这点可以概括为： “如果新行前的标记为语句的末尾，则插入分号”。</p>
<p>分号也可在闭括号之前直接省略，因此像</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; dst &lt;- &lt;-src &#125; &#125;()</span><br></pre></td></tr></table></figure>
<p>这样的语句无需分号。通常<code>Go</code>程序只在诸如 <code>for</code> 循环子句这样的地方使用分号， 以此来将初始化器、条件及增量元素分开。如果你在一行中写多个语句，也需要用分号隔开。</p>
<p>警告：无论如何，你都不应将一个控制结构（<code>if</code>、<code>for</code>、<code>switch</code> 或 <code>select</code>）的左大括号放在下一行。如果这样做，就会在大括号前面插入一个分号，这可能引起不需要的效果。 你应该这样写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &lt; f() &#123;</span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而不是这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &lt; f()  <span class="comment">// 错！</span></span><br><span class="line">&#123;           <span class="comment">// 错！</span></span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p><code>Go</code>中的结构控制与<code>C</code>有许多相似之处，但其不同之处才是独到之处。 <code>Go</code>不再使用 <code>do</code> 或 <code>while</code> 循环，只有一个更通用的 <code>for</code>；<code>switch</code> 要更灵活一点；<code>if</code> 和 <code>switch</code> 像 <code>for</code> 一样可接受可选的初始化语句； 此外，还有一个包含类型选择和多路通信复用器的新控制结构：<code>select</code>。 其语法也有些许不同：没有圆括号，而其主体必须始终使用大括号括住。</p>
<h2 id="If"><a href="#If" class="headerlink" title="If"></a>If</h2><p>在 <code>Go</code> 中，一个简单的 <code>if</code> 语句看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>强制的大括号促使你将简单的 <code>if</code> 语句分成多行。特别是在主体中包含 <code>return</code> 或 <code>break</code> 等控制语句时，这种编码风格的好处一比便知。</p>
<p>由于 <code>if</code> 和 <code>switch</code> 可接受初始化语句， 因此用它们来设置局部变量十分常见。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0664</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Print(err)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Go</code>的库中，你会发现若 <code>if</code> 语句不会执行到下一条语句时，亦即其执行体 以 <code>break</code>、<code>continue</code>、<code>goto</code> 或 <code>return</code> 结束时，不必要的 <code>else</code> 会被省略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">codeUsing(f)</span><br></pre></td></tr></table></figure>
<p>下例是一种常见的情况，代码必须防范一系列的错误条件。若控制流成功继续， 则说明程序已排除错误。由于出错时将以 <code>return</code> 结束， 之后的代码也就无需 <code>else</code> 了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">d, err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	f.Close()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">codeUsing(f, d)</span><br></pre></td></tr></table></figure>

<h2 id="重新声明与再次赋值"><a href="#重新声明与再次赋值" class="headerlink" title="重新声明与再次赋值"></a>重新声明与再次赋值</h2><p>题外话：上一节中最后一个示例展示了短声明 <code>:= </code>如何使用。 调用了 <code>os.Open</code> 的声明为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br></pre></td></tr></table></figure>
<p>该语句声明了两个变量 <code>f</code> 和 <code>err</code>。在几行之后，又通过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d, err := f.Stat()</span><br></pre></td></tr></table></figure>
<p>调用了 <code>f.Stat</code>。它看起来似乎是声明了 <code>d</code> 和 <code>err</code>。 注意，尽管两个语句中都出现了 <code>err</code>，但这种重复仍然是合法的：<code>err</code> 在第一条语句中被声明，但在第二条语句中只是被再次赋值罢了。也就是说，调用 <code>f.Stat</code> 使用的是前面已经声明的 <code>err</code>，它只是被重新赋值了而已。</p>
<p>在满足下列条件时，已被声明的变量 <code>v</code> 可出现在 <code>:=</code> 声明中：</p>
<p>本次声明与已声明的 <code>v</code> 处于同一作用域中（若 <code>v</code> 已在外层作用域中声明过，则此次声明会创建一个新的变量<code>§</code>），</p>
<ul>
<li>在初始化中与其类型相应的值才能赋予 v，且</li>
<li>在此次声明中至少另有一个变量是新声明的。</li>
<li>这个特性简直就是纯粹的实用主义体现，它使得我们可以很方面地只使用一个 err 值，例如，在一个相当长的 if-else 语句链中， 你会发现它用得很频繁。</li>
</ul>
<p><code>§</code>值得一提的是，即便<code>Go</code>中的函数形参和返回值在词法上处于大括号之外， 但它们的作用域和该函数体仍然相同。</p>
<h2 id="For"><a href="#For" class="headerlink" title="For"></a>For</h2><p><code>Go</code> 的 <code>for</code> 循环类似于<code>C</code>，但却不尽相同。它统一了 <code>for</code> 和 <code>while</code>，不再有 <code>do-while</code> 了。它有三种形式，但只有一种需要分号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如同C的for循环</span></span><br><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如同C的while循环</span></span><br><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如同C的for(;;)循环</span></span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>简短声明能让我们更容易在循环中声明下标变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若你想遍历数组、切片、字符串或者映射，或从信道中读取消息， <code>range</code> 子句能够帮你轻松实现循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">	newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若你只需要该遍历中的第一个项（键或下标），去掉第二个就行了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line">	<span class="keyword">if</span> key.expired() &#123;</span><br><span class="line">		<span class="built_in">delete</span>(m, key)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若你只需要该遍历中的第二个项（值），请使用空白标识符，即下划线来丢弃第一个值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">	sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空白标识符还有多种用法，它会在后面的小节中描述。</p>
<p>对于字符串，<code>range</code> 能够提供更多便利。它能通过解析 <code>UTF-8</code>， 将每个独立的 <code>Unicode</code> 码点分离出来。错误的编码将占用一个字节，并以符文 <code>U+FFFD</code> 来代替。 （名称“符文”和内建类型  <code>rune</code> 是 <code>Go</code> 对单个 <code>Unicode</code> 码点的成称谓。 详情见语言规范）。循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> <span class="string">"日本\x80語"</span> &#123; <span class="comment">// \x80 是个非法的UTF-8编码</span></span><br><span class="line">	fmt.Printf(<span class="string">"字符 %#U 始于字节位置 %d\n"</span>, char, pos)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字符 U+65E5 &#39;日&#39; 始于字节位置 0</span><br><span class="line">字符 U+672C &#39;本&#39; 始于字节位置 3</span><br><span class="line">字符 U+FFFD &#39;�&#39; 始于字节位置 6</span><br><span class="line">字符 U+8A9E &#39;語&#39; 始于字节位置 7</span><br></pre></td></tr></table></figure>
<p>最后，<code>Go</code> 没有逗号操作符，而 <code>++</code> 和 <code>--</code> 为语句而非表达式。 因此，若你想要在 <code>for</code> 中使用多个变量，应采用平行赋值的方式 （因为它会拒绝 <code>++</code> 和 <code>--</code> ）.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转 a</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">	a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p><code>Go</code> 的 <code>switch</code> 比 <code>C</code> 的更通用。其表达式无需为常量或整数，<code>case</code> 语句会自上而下逐一进行求值直到匹配为止。若 <code>switch</code> 后面没有表达式，它将匹配 <code>true</code>，因此，我们可以将 <code>if-else-if-else</code> 链写成一个 <code>switch</code>，这也更符合 <code>Go</code> 的风格。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhex</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>:</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">'0'</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'f'</span>:</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">10</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'F'</span>:</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch</code> 并不会自动下溯，但 <code>case</code> 可通过逗号分隔来列举相同的处理条件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldEscape</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> c &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">' '</span>, <span class="string">'?'</span>, <span class="string">'&amp;'</span>, <span class="string">'='</span>, <span class="string">'#'</span>, <span class="string">'+'</span>, <span class="string">'%'</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管它们在 <code>Go</code> 中的用法和其它类 <code>C</code> 语言差不多，但 <code>break</code> 语句可以使 <code>switch</code> 提前终止。不仅是 <code>switch</code>， 有时候也必须打破层层的循环。在 <code>Go</code> 中，我们只需将标签放置到循环外，然后 “蹦”到那里即可。下面的例子展示了二者的用法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Loop:</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="built_in">len</span>(src); n += size &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> src[n] &lt; sizeOne:</span><br><span class="line">			<span class="keyword">if</span> validateOnly &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			size = <span class="number">1</span></span><br><span class="line">			update(src[n])</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> src[n] &lt; sizeTwo:</span><br><span class="line">			<span class="keyword">if</span> n+<span class="number">1</span> &gt;= <span class="built_in">len</span>(src) &#123;</span><br><span class="line">				err = errShortInput</span><br><span class="line">				<span class="keyword">break</span> Loop</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> validateOnly &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			size = <span class="number">2</span></span><br><span class="line">			update(src[n] + src[n+<span class="number">1</span>]&lt;&lt;shift)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>当然，<code>continue</code> 语句也能接受一个可选的标签，不过它只能在循环中使用。</p>
<p>作为这一节的结束，此程序通过使用两个 <code>switch</code> 语句对字节数组进行比较：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compare 按字典顺序比较两个字节切片并返回一个整数。</span></span><br><span class="line"><span class="comment">// 若 a == b，则结果为零；若 a &lt; b；则结果为 -1；若 a &gt; b，则结果为 +1。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a, b []<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a) &amp;&amp; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> a[i] &gt; b[i]:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		<span class="keyword">case</span> a[i] &lt; b[i]:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(a) &lt; <span class="built_in">len</span>(b):</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h2><p><code>switch</code> 也可用于判断接口变量的动态类型。如 <code>类型选择</code> 通过圆括号中的关键字 <code>type</code> 使用类型断言语法。若 <code>switch</code> 在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Printf(<span class="string">"unexpected type %T"</span>, t)       <span class="comment">// %T 输出 t 是什么类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">	fmt.Printf(<span class="string">"boolean %t\n"</span>, t)             <span class="comment">// t 是 bool 类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">	fmt.Printf(<span class="string">"integer %d\n"</span>, t)             <span class="comment">// t 是 int 类型</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">bool</span>:</span><br><span class="line">	fmt.Printf(<span class="string">"pointer to boolean %t\n"</span>, *t) <span class="comment">// t 是 *bool 类型</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">int</span>:</span><br><span class="line">	fmt.Printf(<span class="string">"pointer to integer %d\n"</span>, *t) <span class="comment">// t 是 *int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h2><p><code>Go</code> 与众不同的特性之一就是函数和方法可返回多个值。这种形式可以改善 <code>C</code> 中一些笨拙的习惯： 将错误值返回（例如用 <code>-1</code> 表示 <code>EOF</code>）和修改通过地址传入的实参。</p>
<p>在<code>C</code>中，写入操作发生的错误会用一个负数标记，而错误码会隐藏在某个不确定的位置。 而在<code>Go</code>中，<code>Write</code> 会返回写入的字节数以及一个错误： “是的，您写入了一些字节，但并未全部写入，因为设备已满”。 在 <code>os</code> 包中，<code>File.Write</code> 的签名为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>正如文档所述，它返回写入的字节数，并在 <code>n != len(b)</code> 时返回一个非 <code>nil</code> 的 <code>error</code> 错误值。 这是一种常见的编码风格，更多示例见错误处理一节。</p>
<p>我们可以采用一种简单的方法。来避免为模拟引用参数而传入指针。 以下简单的函数可从字节数组中的特定位置获取其值，并返回该数值和下一个位置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="keyword">byte</span>, i <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(b) &amp;&amp; !isDigit(b[i]); i++ &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	x := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(b) &amp;&amp; isDigit(b[i]); i++ &#123;</span><br><span class="line">		x = x*<span class="number">10</span> + <span class="keyword">int</span>(b[i]) - <span class="string">'0'</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x, i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像下面这样，通过它扫描输入的切片 <code>b</code> 来获取数字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); &#123;</span><br><span class="line">    x, i = nextInt(b, i)</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可命名结果形参"><a href="#可命名结果形参" class="headerlink" title="可命名结果形参"></a>可命名结果形参</h2><p><code>Go</code>函数的返回值或结果 <code>“形参”</code> 可被命名，并作为常规变量使用，就像传入的形参一样。 命名后，一旦该函数开始执行，它们就会被初始化为与其类型相应的零值； 若该函数执行了一条不带实参的  <code>return</code> 语句，则结果形参的当前值将被返回。</p>
<p>此名称不是强制性的，但它们能使代码更加简短清晰：它们就是文档。若我们命名了 <code>nextInt</code> 的结果，那么它返回的 <code>int</code> 就值如其意了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="keyword">byte</span>, pos <span class="keyword">int</span>)</span> <span class="params">(value, nextPos <span class="keyword">int</span>)</span></span> &#123;</span><br></pre></td></tr></table></figure>
<p>由于被命名的结果已经初始化，且已经关联至无参数的返回，它们就能让代码简单而清晰。 下面的 <code>io.ReadFull</code> 就是个很好的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(buf) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nr <span class="keyword">int</span></span><br><span class="line">		nr, err = r.Read(buf)</span><br><span class="line">		n += nr</span><br><span class="line">		buf = buf[nr:]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h2><p><code>Go</code>的 <code>defer</code> 语句用于预设一个函数调用（即推迟执行函数）， 该函数会在执行 <code>defer</code> 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁互斥和关闭文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Contents 将文件的内容作为字符串返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contents</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	f, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()  <span class="comment">// f.Close 会在我们结束后运行。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result []<span class="keyword">byte</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := f.Read(buf[<span class="number">0</span>:])</span><br><span class="line">		result = <span class="built_in">append</span>(result, buf[<span class="number">0</span>:n]...) <span class="comment">// append 将在后面讨论。</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">""</span>, err  <span class="comment">// 我们在这里返回后，f 就会被关闭。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(result), <span class="literal">nil</span> <span class="comment">// 我们在这里返回后，f 就会被关闭。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推迟诸如 <code>Close</code> 之类的函数调用有两点好处：第一， 它能确保你不会忘记关闭文件。如果你以后又为该函数添加了新的返回路径时， 这种情况往往就会发生。第二，它意味着“关闭”离“打开”很近， 这总比将它放在函数结尾处要清晰明了。</p>
<p>被推迟函数的实参（如果该函数为方法则还包括接收者）在推迟执行时就会求值， 而不是在调用执行时才求值。这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行。下面是个简单的例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被推迟的函数按照后进先出（<code>LIFO</code>）的顺序执行，因此以上代码在函数返回时会打印 <code>4 3 2 1 0</code>。一个更具实际意义的例子是通过一种简单的方法， 用程序来跟踪函数的执行。我们可以编写一对简单的跟踪例程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="keyword">string</span>)</span></span>   &#123; fmt.Println(<span class="string">"entering:"</span>, s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">untrace</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123; fmt.Println(<span class="string">"leaving:"</span>, s) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像这样使用它们：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	trace(<span class="string">"a"</span>)</span><br><span class="line">	<span class="keyword">defer</span> untrace(<span class="string">"a"</span>)</span><br><span class="line">	<span class="comment">// 做一些事情....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以充分利用这个特点，即被推迟函数的实参在 <code>defer</code> 执行时才会被求值。 跟踪例程可针对反跟踪例程设置实参。以下例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"entering:"</span>, s)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"leaving:"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> un(trace(<span class="string">"a"</span>))</span><br><span class="line">	fmt.Println(<span class="string">"in a"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> un(trace(<span class="string">"b"</span>))</span><br><span class="line">	fmt.Println(<span class="string">"in b"</span>)</span><br><span class="line">	a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br></pre></td></tr></table></figure>
<p>对于习惯其它语言中块级资源管理的程序员，<code>defer </code>似乎有点怪异， 但它最有趣而强大的应用恰恰来自于其基于函数而非块的特点。在 <code>panic</code> 和 <code>recover</code> 这两节中，我们将看到关于它可能性的其它例子。</p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="new-分配"><a href="#new-分配" class="headerlink" title="new 分配"></a><code>new</code> 分配</h2><p><code>Go</code>提供了两种分配原语，即内建函数 <code>new</code> 和 <code>make</code>。 它们所做的事情不同，所应用的类型也不同。它们可能会引起混淆，但规则却很简单。 让我们先来看看 <code>new</code>。这是个用来分配内存的内建函数， 但与其它语言中的同名函数不同，它不会初始化内存，只会将内存置零。 也就是说，***<code>new(T)</code> 会为类型为 <code>T</code> 的新项分配已置零的内存空间***， 并返回它的地址，也就是一个类型为 <code>*T</code> 的值。用<code>Go</code>的术语来说，它返回一个指针， 该指针指向新分配的，类型为 <code>T</code> 的零值。</p>
<p>既然 <code>new</code> 返回的内存已置零，那么当你设计数据结构时， 每种类型的零值就不必进一步初始化了，这意味着该数据结构的使用者只需用 <code>new</code> 创建一个新的对象就能正常工作。例如，<code>bytes.Buffer </code>的文档中提到“零值的 <code>Buffer</code> 就是已准备就绪的缓冲区。” 同样，<code>sync.Mutex</code> 并没有显式的构造函数或 <code>Init</code> 方法， 而是零值的 <code>sync.Mutex</code> 就已经被定义为已解锁的互斥锁了。</p>
<p>“零值属性”可以带来各种好处。考虑以下类型声明。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock    sync.Mutex</span><br><span class="line">	buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SyncedBuffer</code> 类型的值也是在声明时就分配好内存就绪了。后续代码中， <code>p</code> 和 <code>v</code> 无需进一步处理即可正确工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(SyncedBuffer)  <span class="comment">// type *SyncedBuffer</span></span><br><span class="line"><span class="keyword">var</span> v SyncedBuffer      <span class="comment">// type  SyncedBuffer</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数与复合字面"><a href="#构造函数与复合字面" class="headerlink" title="构造函数与复合字面"></a>构造函数与复合字面</h2><p>有时零值还不够好，这时就需要一个初始化构造函数，如来自 <code>os</code> 包中的这段代码所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	f := <span class="built_in">new</span>(File)</span><br><span class="line">	f.fd = fd</span><br><span class="line">	f.name = name</span><br><span class="line">	f.dirinfo = <span class="literal">nil</span></span><br><span class="line">	f.nepipe = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里显得代码过于冗长。我们可通过复合字面来简化它， 该表达式在每次求值时都会创建新的实例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，返回一个局部变量的地址完全没有问题，这点与<code>C</code>不同。该局部变量对应的数据 在函数返回后依然有效。实际上，每当获取一个复合字面的地址时，都将为一个新的实例分配内存， 因此我们可以将上面的最后两行代码合并：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<p>复合字面的字段必须按顺序全部列出。但如果以 字段:值 对的形式明确地标出元素，初始化字段时就可以按任何顺序出现，未给出的字段值将赋予零值。 因此，我们可以用如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return &amp;File&#123;fd: fd, name: name&#125;</span><br></pre></td></tr></table></figure>
<p>少数情况下，若复合字面不包括任何字段，它将创建该类型的零值。表达式 <code>new(File)</code> 和 <code>&amp;File{}</code> 是等价的。</p>
<p>复合字面同样可用于创建数组、切片以及映射，字段标签是索引还是映射键则视情况而定。 在下例初始化过程中，无论 <code>Enone</code>、<code>Eio</code> 和 <code>Einval</code> 的值是什么，只要它们的标签不同就行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := [...]<span class="keyword">string</span>   &#123;Enone: <span class="string">"no error"</span>, Eio: <span class="string">"Eio"</span>, Einval: <span class="string">"invalid argument"</span>&#125;</span><br><span class="line">s := []<span class="keyword">string</span>      &#123;Enone: <span class="string">"no error"</span>, Eio: <span class="string">"Eio"</span>, Einval: <span class="string">"invalid argument"</span>&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;Enone: <span class="string">"no error"</span>, Eio: <span class="string">"Eio"</span>, Einval: <span class="string">"invalid argument"</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="make-分配"><a href="#make-分配" class="headerlink" title="make 分配"></a><code>make</code> 分配</h2><p>再回到内存分配上来。内建函数 <code>make(T, args)</code> 的目的不同于 <code>new(T)</code>。它<strong>只用于创建切片、映射和信道</strong>，并返回类型为 <code>T</code>（而非 <code>*T</code>）的一个已初始化 （而非置零）的值。 出现这种用差异的原因在于，这三种类型本质上为引用数据类型，它们在使用前必须初始化。 例如，切片是一个具有三项内容的描述符，包含一个指向（数组内部）数据的指针、长度以及容量， 在这三项被初始化之前，该切片为 nil。对于切片、映射和信道，<code>make</code> 用于初始化其内部的数据结构并准备好将要使用的值。例如，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>会分配一个具有100个 <code>int</code> 的数组空间，接着创建一个长度为10， 容量为100并指向该数组中前10个元素的切片结构。（生成切片时，其容量可以省略，更多信息见切片一节。） 与此相反，<code>new([]int)</code> 会返回一个指向新分配的，已置零的切片结构， 即一个指向 <code>nil</code> 切片值的指针。</p>
<p>下面的例子阐明了 <code>new</code> 和 <code>make</code> 之间的区别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)       <span class="comment">// 分配切片结构；*p == nil；基本没用</span></span><br><span class="line"><span class="keyword">var</span> v  []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>) <span class="comment">// 切片 v 现在引用了一个具有 100 个 int 元素的新数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没必要的复杂：</span></span><br><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line">*p = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 习惯用法：</span></span><br><span class="line">v := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>请记住，<code>make</code> 只适用于映射、切片和信道且不返回指针。若要获得明确的指针， 请使用 <code>new</code> 分配内存。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在详细规划内存布局时，数组是非常有用的，有时还能避免过多的内存分配， 但它们主要用作切片的构件。这是下一节的主题了，不过要先说上几句来为它做铺垫。<br>以下为数组在 <code>Go</code> 和 <code>C</code> 中的主要区别。在 <code>Go</code> 中，</p>
<ul>
<li><strong>数组是值</strong>。将一个数组赋予另一个数组会复制其所有元素。</li>
<li>特别地，若将某个数组传入某个函数，它将接收到该数组的一份副本而非指针。</li>
<li>数组的大小是其类型的一部分。类型 [10]int 和 [20]int 是不同的。<br>数组为值的属性很有用，但代价高昂；若你想要 <code>C</code> 那样的行为和效率，你可以传递一个指向该数组的指针。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a *[3]<span class="keyword">float64</span>)</span> <span class="params">(sum <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> *a &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array := [...]<span class="keyword">float64</span>&#123;<span class="number">7.0</span>, <span class="number">8.5</span>, <span class="number">9.1</span>&#125;</span><br><span class="line">x := Sum(&amp;array)  <span class="comment">// 注意显式的取址操作</span></span><br></pre></td></tr></table></figure>
但这并不是 <code>Go</code> 的习惯用法，切片才是。</li>
</ul>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。 除了矩阵变换这类需要明确维度的情况外，<code>Go</code> 中的大部分数组编程都是通过切片来完成的。</p>
<p>切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。 若某个函数将一个切片作为参数传入，则它对该切片元素的修改对调用者而言同样可见， 这可以理解为传递了底层数组的指针。因此，<code>Read</code> 函数可接受一个切片实参 而非一个指针和一个计数；切片的长度决定了可读取数据的上限。以下为 <code>os</code> 包中 <code>File</code> 类型的 <code>Read</code> 方法签名:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span> <span class="title">Read</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>该方法返回读取的字节数和一个错误值（若有的话）。若要从更大的缓冲区 <code>b</code> 中读取前32个字节，只需对其进行切片即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n, err := f.Read(buf[<span class="number">0</span>:<span class="number">32</span>])</span><br></pre></td></tr></table></figure>
<p>这种切片的方法常用且高效。若不谈效率，以下片段同样能读取该缓冲区的前32个字节。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i++ &#123;</span><br><span class="line">	nbytes, e := f.Read(buf[i:i+<span class="number">1</span>])  <span class="comment">// 读取一个字节</span></span><br><span class="line">	<span class="keyword">if</span> nbytes == <span class="number">0</span> || e != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = e</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	n += nbytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要切片不超出底层数组的限制，它的长度就是可变的，只需将它赋予其自身的切片即可。 切片的容量可通过内建函数 <code>cap</code> 获得，它将给出该切片可取得的最大长度。 以下是将数据追加到切片的函数。若数据超出其容量，则会重新分配该切片。返回值即为所得的切片。 该函数中所使用的 <code>len</code> 和 <code>cap</code> 在应用于 <code>nil</code> 切片时是合法的，它会返回0.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Append</span><span class="params">(slice, data[]<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(slice)</span><br><span class="line">	<span class="keyword">if</span> l + <span class="built_in">len</span>(data) &gt; <span class="built_in">cap</span>(slice) &#123;  <span class="comment">// 重新分配</span></span><br><span class="line">		<span class="comment">// 为了后面的增长，需分配两份。</span></span><br><span class="line">		newSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, (l+<span class="built_in">len</span>(data))*<span class="number">2</span>)</span><br><span class="line">		<span class="comment">// copy 函数是预声明的，且可用于任何切片类型。</span></span><br><span class="line">		<span class="built_in">copy</span>(newSlice, slice)</span><br><span class="line">		slice = newSlice</span><br><span class="line">	&#125;</span><br><span class="line">	slice = slice[<span class="number">0</span>:l+<span class="built_in">len</span>(data)]</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> data &#123;</span><br><span class="line">		slice[l+i] = c</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终我们必须返回切片，因为尽管 <code>Append</code> 可修改 <code>slice</code> 的元素，但切片自身（其运行时数据结构包含指针、长度和容量）是通过值传递的。</p>
<p>向切片追加东西的想法非常有用，因此有专门的内建函数 <code>append</code>。 要理解该函数的设计，我们还需要一些额外的信息，我们将稍后再介绍它。</p>
<h2 id="二维切片"><a href="#二维切片" class="headerlink" title="二维切片"></a>二维切片</h2><p><code>Go</code> 的数组和切片都是一维的。要创建等价的二维数组或切片，就必须定义一个数组的数组， 或切片的切片，就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transform [<span class="number">3</span>][<span class="number">3</span>]<span class="keyword">float64</span>  <span class="comment">// 一个 3x3 的数组，其实是包含多个数组的一个数组。</span></span><br><span class="line"><span class="keyword">type</span> LinesOfText [][]<span class="keyword">byte</span>     <span class="comment">// 包含多个字节切片的一个切片。</span></span><br></pre></td></tr></table></figure>
<p>由于切片长度是可变的，因此其内部可能拥有多个不同长度的切片。在我们的 <code>LinesOfText</code> 例子中，这是种常见的情况：每行都有其自己的长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text := LinesOfText&#123;</span><br><span class="line">	[]<span class="keyword">byte</span>(<span class="string">"Now is the time"</span>),</span><br><span class="line">	[]<span class="keyword">byte</span>(<span class="string">"for all good gophers"</span>),</span><br><span class="line">	[]<span class="keyword">byte</span>(<span class="string">"to bring some fun to the party."</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时必须分配一个二维数组，例如在处理像素的扫描行时，这种情况就会发生。 我们有两种方式来达到这个目的。一种就是独立地分配每一个切片；而另一种就是只分配一个数组， 将各个切片都指向它。采用哪种方式取决于你的应用。若切片会增长或收缩， 就应该通过独立分配来避免覆盖下一行；若不会，用单次分配来构造对象会更加高效。 以下是这两种方法的大概代码，仅供参考。首先是一次一行的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配顶层切片。</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, YSize) <span class="comment">// 每 y 个单元一行。</span></span><br><span class="line"><span class="comment">// 遍历行，为每一行都分配切片</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">	picture[i] = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, XSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在是一次分配，对行进行切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配顶层切片，和前面一样。</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, YSize) <span class="comment">// 每 y 个单元一行。</span></span><br><span class="line"><span class="comment">// 分配一个大的切片来保存所有像素</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="keyword">uint8</span>, XSize*YSize) <span class="comment">// 拥有类型 []uint8，尽管图片是 [][]uint8.</span></span><br><span class="line"><span class="comment">// 遍历行，从剩余像素切片的前面切出每行来。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">	picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射是方便而强大的内建数据结构，它可以关联不同类型的值。其键可以是任何相等性操作符支持的类型， 如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。 切片不能用作映射键，因为它们的相等性还未定义。与切片一样，<em><strong>映射也是引用类型</strong></em>。 若将映射传入函数中，并更改了该映射的内容，则此修改对调用者同样可见。</p>
<p>映射可使用一般的复合字面语法进行构建，其键-值对使用逗号分隔，因此可在初始化时很容易地构建它们。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeZone = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="string">"UTC"</span>:  <span class="number">0</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">"EST"</span>: <span class="number">-5</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">"CST"</span>: <span class="number">-6</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">"MST"</span>: <span class="number">-7</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">"PST"</span>: <span class="number">-8</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赋值和获取映射值的语法类似于数组，不同的是映射的索引不必为整数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset := timeZone[<span class="string">"EST"</span>]</span><br></pre></td></tr></table></figure>
<p>若试图通过映射中不存在的键来取值，就会返回与该映射中项的类型对应的零值。 例如，若某个映射包含整数，当查找一个不存在的键时会返回 0。 集合可实现成一个值类型为 <code>bool</code> 的映射。将该映射中的项置为 <code>true</code> 可将该值放入集合中，此后通过简单的索引操作即可判断是否存在。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">attended := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;</span><br><span class="line">	<span class="string">"Ann"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="string">"Joe"</span>: <span class="literal">true</span>,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> attended[person] &#123; <span class="comment">// 若某人不在此映射中，则为 false</span></span><br><span class="line">	fmt.Println(person, <span class="string">"正在开会"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时你需要区分某项是不存在还是其值为零值。如对于一个值本应为零的 “UTC” 条目，也可能是由于不存在该项而得到零值。你可以使用多重赋值的形式来分辨这种情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> seconds <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">seconds, ok = timeZone[tz]</span><br></pre></td></tr></table></figure>
<p>显然，我们可称之为“逗号 ok”惯用法。在下面的例子中，若 <code>tz</code> 存在， <code>seconds</code> 就会被赋予适当的值，且 ok 会被置为 true； 若不存在，seconds 则会被置为零，而 ok 会被置为 false。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">offset</span><span class="params">(tz <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> seconds, ok := timeZone[tz]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> seconds</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">"unknown time zone:"</span>, tz)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若仅需判断映射中是否存在某项而不关心实际的值，可使用空白标识符 （_）来代替该值的一般变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, present := timeZone[tz]</span><br></pre></td></tr></table></figure>
<p>要删除映射中的某项，可使用内建函数 <code>delete</code>，它以<em><strong>映射及要被删除的键为实参。 即便对应的键不在该映射中，此操作也是安全的</strong></em>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(timeZone, <span class="string">"PDT"</span>)  <span class="comment">// 现在用标准时间</span></span><br></pre></td></tr></table></figure>

<h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p><code>Go</code> 采用的格式化打印风格和 <code>C</code> 的 <code>printf</code> 族类似，但却更加丰富而通用。 这些函数位于 <code>fmt</code> 包中，且函数名首字母均为大写：如 <code>fmt.Printf</code>、<code>fmt.Fprintf</code>，<code>fmt.Sprintf</code> 等。 字符串函数（<code>Sprintf</code> 等）会返回一个字符串，而非填充给定的缓冲区。</p>
<p>你无需提供一个格式字符串。每个 <code>Printf</code>、<code>Fprintf</code> 和 <code>Sprintf</code> 都分别对应另外的函数，如 <code>Print</code> 与 <code>Println</code>。 这些函数并不接受格式字符串，而是为每个实参生成一种默认格式。<code>Println</code> 系列的函数还会在实参中插入空格，并在输出时追加一个换行符，而 <code>Print</code> 版本仅在操作数两侧都没有字符串时才添加空白。以下示例中各行产生的输出都是一样的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"Hello %d\n"</span>, <span class="number">23</span>)</span><br><span class="line">fmt.Fprint(os.Stdout, <span class="string">"Hello "</span>, <span class="number">23</span>, <span class="string">"\n"</span>)</span><br><span class="line">fmt.Println(<span class="string">"Hello"</span>, <span class="number">23</span>)</span><br><span class="line">fmt.Println(fmt.Sprint(<span class="string">"Hello "</span>, <span class="number">23</span>))</span><br></pre></td></tr></table></figure>
<p><code>fmt.Fprint</code> 一类的格式化打印函数可接受任何实现了 <code>io.Writer</code> 接口的对象作为第一个实参；变量 <code>os.Stdout</code> 与 <code>os.Stderr</code> 都是人们熟知的例子。</p>
<p>从这里开始，就与C有些不同了。首先，像 <code>%d</code> 这样的数值格式并不接受表示符号或大小的标记， 打印例程会根据实参的类型来决定这些属性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">uint64</span> = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">"%d %x; %d %x\n"</span>, x, x, <span class="keyword">int64</span>(x), <span class="keyword">int64</span>(x))</span><br></pre></td></tr></table></figure>
<p>将打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18446744073709551615 ffffffffffffffff; -1 -1</span><br></pre></td></tr></table></figure>
<p>若你只想要默认的转换，如使用十进制的整数，你可以使用通用的格式 <code>%v</code>（对应“值”）；其结果与 <code>Print</code> 和 <code>Println </code>的输出完全相同。此外，这种格式还能打印任意值，甚至包括数组、结构体和映射。 以下是打印上一节中定义的时区映射的语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, timeZone)  <span class="comment">// 或只用 fmt.Println(timeZone)</span></span><br></pre></td></tr></table></figure>
<p>这会输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]</span><br></pre></td></tr></table></figure>
<p>当然，映射中的键可能按任意顺序输出。当打印结构体时，<strong>改进的格式 <code>%+v</code> 会为结构体的每个字段添上字段名</strong>，而另一种格式 <strong><code>%#v</code> 将完全按照Go的语法打印值</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="keyword">int</span></span><br><span class="line">	b <span class="keyword">float64</span></span><br><span class="line">	c <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">t := &amp;T&#123; <span class="number">7</span>, <span class="number">-2.35</span>, <span class="string">"abc\tdef"</span> &#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, timeZone)</span><br></pre></td></tr></table></figure>
<p>将打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;7 -2.35 abc   def&#125;</span><br><span class="line">&amp;&#123;a:7 b:-2.35 c:abc     def&#125;</span><br><span class="line">&amp;main.T&#123;a:7, b:-2.35, c:&quot;abc\tdef&quot;&#125;</span><br><span class="line">map[string] int&#123;&quot;CST&quot;:-21600, &quot;PST&quot;:-28800, &quot;EST&quot;:-18000, &quot;UTC&quot;:0, &quot;MST&quot;:-25200&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（请注意其中的&amp;符号）当遇到 string 或 []byte 值时， 可使用 %q 产生带引号的字符串；而格式 %#q 会尽可能使用反引号。 （%q 格式也可用于整数和符文，它会产生一个带单引号的符文常量。） 此外，%x 还可用于字符串、字节数组以及整数，并生成一个很长的十六进制字符串， 而带空格的格式（% x）还会在字节之间插入空格。</p>
</blockquote>
<p>另一种实用的格式是 <code>%T</code>，它会打印某个值的类型.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, timeZone)</span><br></pre></td></tr></table></figure>
<p>会打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[string] int</span><br></pre></td></tr></table></figure>
<p>若你想控制自定义类型的默认格式，只需为该类型定义一个具有 <code>String() string</code> 签名的方法。对于我们简单的类型 <code>T</code>，可进行如下操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d/%g/%q"</span>, t.a, t.b, t.c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, t)</span><br></pre></td></tr></table></figure>
<p>会打印出如下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7&#x2F;-2.35&#x2F;&quot;abc\tdef&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（如果你需要像指向 T 的指针那样打印类型 T 的值， String 的接收者就必须是值类型的；上面的例子中接收者是一个指针， 因为这对结构来说更高效而通用。更多详情见指针vs.值接收者一节.）</p>
</blockquote>
<p>我们的 <code>String</code> 方法也可调用 <code>Sprintf</code>， 因为打印例程可以完全重入并按这种方式封装。不过要理解这种方式，还有一个重要的细节： 请勿通过调用 <code>Sprintf</code> 来构造 <code>String</code> 方法，因为它会无限递归你的的 <code>String </code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type MyString string</span><br><span class="line"></span><br><span class="line">func (m MyString) String() string &#123;</span><br><span class="line">	return fmt.Sprintf(&quot;MyString&#x3D;%s&quot;, m) &#x2F;&#x2F; 错误：会无限递归</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要解决这个问题也很简单：将该实参转换为基本的字符串类型，它没有这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type MyString string</span><br><span class="line">func (m MyString) String() string &#123;</span><br><span class="line">	return fmt.Sprintf(&quot;MyString&#x3D;%s&quot;, string(m)) &#x2F;&#x2F; 可以：注意转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化一节中，我们将看到避免这种递归的另一种技术。</p>
<p>另一种打印技术就是将打印例程的实参直接传入另一个这样的例程。<code>Printf</code> 的签名为其最后的实参使用了 <code>...interface{}</code> 类型，这样格式的后面就能出现任意数量，任意类型的形参了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br></pre></td></tr></table></figure>
<p>在 <code>Printf</code> 函数中，<code>v</code> 看起来更像是 <code>[]interface{}</code> 类型的变量，但如果将它传递到另一个变参函数中，它就像是常规实参列表了。 以下是我们之前用过的 <code>log.Println</code> 的实现。它直接将其实参传递给 <code>fmt.Sprintln</code> 进行实际的格式化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Println 通过 fmt.Println 的方式将日志打印到标准记录器。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	std.Output(<span class="number">2</span>, fmt.Sprintln(v...))  <span class="comment">// Output 接受形参 (int, string)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该 <code>Sprintln</code> 嵌套调用中，我们将 <code>...</code> 写在 <code>v</code> 之后来告诉编译器将 <code>v</code> 视作一个实参列表，否则它会将 <code>v</code> 当做单一的切片实参来传递。</p>
<p>还有很多关于打印知识点没有提及。详情请参阅 <code>godoc</code> 对 <code>fmt</code> 包的说明文档。</p>
<p>顺便一提，… 形参可指定具体的类型，例如从整数列表中选出最小值的函数 <code>min</code>，其形参可为 <code>...int</code> 类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span><span class="params">(a ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	min := <span class="keyword">int</span>(^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)  <span class="comment">// 最大的 int</span></span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">if</span> i &lt; min &#123;</span><br><span class="line">			min = i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h2><p>现在我们要对内建函数 <code>append</code> 的设计进行补充说明。<code>append</code> 函数的签名不同于前面我们自定义的 <code>Append</code> 函数。大致来说，它就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []T, 元素 ...T)</span> []<span class="title">T</span></span></span><br></pre></td></tr></table></figure>
<p>其中的 <code>T</code> 为任意给定类型的占位符。实际上，你无法在 <code>Go</code> 中编写一个类型 <code>T</code> 由调用者决定的函数。这也就是为何 <code>append</code> 为内建函数的原因：它需要编译器的支持。<br><code>append</code> 会在切片末尾追加元素并返回结果。我们必须返回结果， 原因与我们手写的 <code>Append</code> 一样，即底层数组可能会被改变。以下简单的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>
<p>将打印 <code>[1 2 3 4 5 6]</code>。因此 <code>append</code> 有点像 <code>Printf</code> 那样，可接受任意数量的实参。</p>
<p>但如果我们要像 <code>Append</code> 那样将一个切片追加到另一个切片中呢？ 很简单：在调用的地方使用 <code>...</code>，就像我们在上面调用 <code>Output</code> 那样。以下代码片段的输出与上一个相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := []<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, y...)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>
<p>如果没有 <code>...</code>，它就会由于类型错误而无法编译，因为 <code>y</code> 不是 <code>int</code> 类型的。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>尽管从表面上看，<code>Go</code> 的初始化过程与 <code>C</code> 或 <code>C++</code> 并不算太大，但它确实更为强大。 在初始化过程中，不仅可以构建复杂的结构，还能正确处理不同包对象间的初始化顺序。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><code>Go</code> 中的常量就是不变量。它们在编译时创建，即便它们可能是函数中定义的局部变量。 常量只能是数字、字符（符文）、字符串或布尔值。由于编译时的限制， 定义它们的表达式必须也是可被编译器求值的常量表达式。例如 <code>1&lt;&lt;3</code> 就是一个常量表达式，而 <code>math.Sin(math.Pi/4)</code> 则不是，因为对 <code>math.Si</code>n 的函数调用在运行时才会发生。</p>
<p>在 <code>Go</code> 中，枚举常量使用枚举器 <code>iota</code> 创建。由于 <code>iota</code> 可为表达式的一部分，而表达式可以被隐式地重复，这样也就更容易构建复杂的值的集合了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSize <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 通过赋予空白标识符来忽略第一个值</span></span><br><span class="line">    _           = <span class="literal">iota</span> <span class="comment">// ignore first value by assigning to blank identifier</span></span><br><span class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    MB</span><br><span class="line">    GB</span><br><span class="line">    TB</span><br><span class="line">    PB</span><br><span class="line">    EB</span><br><span class="line">    ZB</span><br><span class="line">    YB</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>由于可将 <code>String</code> 之类的方法附加在用户定义的类型上， 因此它就为打印时自动格式化任意值提供了可能性，即便是作为一个通用类型的一部分。 尽管你常常会看到这种技术应用于结构体，但它对于像 <code>ByteSize</code> 之类的浮点数标量等类型也是有用的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByteSize)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> b &gt;= YB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%.2fYB"</span>, b/YB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= ZB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%.2fZB"</span>, b/ZB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= EB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%.2fEB"</span>, b/EB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= PB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%.2fPB"</span>, b/PB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= TB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%.2fTB"</span>, b/TB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= GB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%.2fGB"</span>, b/GB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= MB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%.2fMB"</span>, b/MB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= KB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%.2fKB"</span>, b/KB)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%.2fB"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表达式 <code>YB</code> 会打印出 <code>1.00YB</code>，而 <code>ByteSize(1e13) </code>则会打印出 <code>9.09</code>。</p>
<p>在这里用 <code>Sprintf</code> 实现 <code>ByteSize</code> 的 <code>String</code> 方法很安全（不会无限递归），这倒不是因为类型转换，而是它以 <code>%f</code> 调用了 <code>Sprintf</code>，它并不是一种字符串格式：<code>Sprintf</code> 只会在它需要字符串时才调用 <code>String</code> 方法，而 <code>%f</code> 需要一个浮点数值。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的初始化与常量类似，但其初始值也可以是在运行时才被计算的一般表达式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	home   = os.Getenv(<span class="string">"HOME"</span>)</span><br><span class="line">	user   = os.Getenv(<span class="string">"USER"</span>)</span><br><span class="line">	gopath = os.Getenv(<span class="string">"GOPATH"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a><code>init</code> 函数</h2><p>最后，每个源文件都可以通过定义自己的无参数 <code>init</code> 函数来设置一些必要的状态。 （其实每个文件都可以拥有多个 <code>init</code> 函数。）而它的结束就意味着初始化结束： <strong>只有该包中的所有变量声明都通过它们的初始化器求值后 <code>init</code> 才会被调用， 而那些 <code>init</code> 只有在所有已导入的包都被初始化后才会被求值</strong>。</p>
<p>除了那些不能被表示成声明的初始化外，<code>init</code> 函数还常被用在程序真正开始执行前，检验或校正程序的状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> user == <span class="string">""</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"$USER not set"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> home == <span class="string">""</span> &#123;</span><br><span class="line">		home = <span class="string">"/home/"</span> + user</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gopath == <span class="string">""</span> &#123;</span><br><span class="line">		gopath = home + <span class="string">"/go"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// gopath 可通过命令行中的 --gopath 标记覆盖掉。</span></span><br><span class="line">	flag.StringVar(&amp;gopath, <span class="string">"gopath"</span>, gopath, <span class="string">"override default GOPATH"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="指针-vs-值"><a href="#指针-vs-值" class="headerlink" title="指针 vs. 值"></a>指针 vs. 值</h2><p>正如 <code>ByteSize</code> 那样，我们可以为任何已命名的类型（除了指针或接口）定义方法； 接收者可不必为结构体。</p>
<p>在之前讨论切片时，我们编写了一个 <code>Append</code> 函数。 我们也可将其定义为切片的方法。为此，我们首先要声明一个已命名的类型来绑定该方法， 然后使该方法的接收者成为该类型的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSlice []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(slice ByteSlice)</span> <span class="title">Append</span><span class="params">(data []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 主体和前面相同。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们仍然需要该方法返回更新后的切片。为了消除这种不便，我们可通过重新定义该方法， 将一个指向 <code>ByteSlice</code> 的指针作为该方法的接收者， 这样该方法就能重写调用者提供的切片了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span> <span class="title">Append</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	slice := *p</span><br><span class="line">	<span class="comment">// 主体和前面相同，但没有 return。</span></span><br><span class="line">	*p = slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们做得更好。若我们将函数修改为与标准 <code>Write</code> 类似的方法，就像这样，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	slice := *p</span><br><span class="line">	<span class="comment">// 依旧和前面相同。</span></span><br><span class="line">	*p = slice</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(data), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么类型 <code>*ByteSlice</code> 就满足了标准的 <code>io.Writer</code> 接口，这将非常实用。 例如，我们可以通过打印将内容写入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b ByteSlice</span><br><span class="line">fmt.Fprintf(&amp;b, <span class="string">"This hour has %d days\n"</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p>我们将 <code>ByteSlice</code> 的地址传入，因为只有 <code>*ByteSlice</code> 才满足 <code>io.Writer</code>。以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用。</p>
<p>之所以会有这条规则是因为指针方法可以修改接收者；通过值调用它们会导致方法接收到该值的副本， 因此任何修改都将被丢弃，因此该语言不允许这种错误。不过有个方便的例外：若该值是可寻址的， 那么该语言就会自动插入取址操作符来对付一般的通过值调用的指针方法。在我们的例子中，变量 <code>b</code> 是可寻址的，因此我们只需通过 <code>b.Write</code> 来调用它的 <code>Write</code> 方法，编译器会将它重写为 <code>(&amp;b).Write</code>。</p>
<p>顺便一提，在字节切片上使用 <code>Write</code> 的想法已被 <code>bytes.Buffer</code> 所实现。</p>
<h1 id="接口与其它类型"><a href="#接口与其它类型" class="headerlink" title="接口与其它类型"></a>接口与其它类型</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><code>Go</code> 中的接口为指定对象的行为提供了一种方法：如果某样东西可以完成这个， 那么它就可以用在这里。我们已经见过许多简单的示例了；通过实现 <code>String</code>方法，我们可以自定义打印函数，而通过 <code>Write</code> 方法，<code>Fprintf</code> 则能对任何对象产生输出。在 <code>Go</code> 代码中， 仅包含一两种方法的接口很常见，且其名称通常来自于实现它的方法， 如 <code>io.Writer</code> 就是实现了 <code>Write</code> 的一类对象。</p>
<p>每种类型都能实现多个接口。例如一个实现了 <code>sort.Interface</code> 接口的集合就可通过 <code>sort</code> 包中的例程进行排序。该接口包括 <code>Len()</code>、<code>Less(i, j int) bool</code> 以及 <code>Swap(i, j int)</code>，另外，该集合仍然可以有一个自定义的格式化器。 以下特意构建的例子 <code>Sequence</code> 就同时满足这两种情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sequence []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods required by sort.Interface.</span></span><br><span class="line"><span class="comment">// sort.Interface 所需的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s[i] &lt; s[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method for printing - sorts the elements before printing.</span></span><br><span class="line"><span class="comment">// 用于打印的方法 - 在打印前对元素进行排序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    sort.Sort(s)</span><br><span class="line">    str := <span class="string">"["</span></span><br><span class="line">    <span class="keyword">for</span> i, elem := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            str += <span class="string">" "</span></span><br><span class="line">        &#125;</span><br><span class="line">        str += fmt.Sprint(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="string">"]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><code>Sequence</code> 的 <code>String</code> 方法重新实现了 <code>Sprint</code> 为切片实现的功能。若我们在调用 <code>Sprint</code> 之前将 <code>Sequence</code> 转换为纯粹的 <code>[]int</code>，就能共享已实现的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	sort.Sort(s)</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint([]<span class="keyword">int</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法是通过类型转换技术，在 <code>String</code> 方法中安全调用 <code>Sprintf</code> 的另个一例子。若我们忽略类型名的话，这两种类型（<code>Sequence和 []int</code>）其实是相同的，因此在二者之间进行转换是合法的。 转换过程并不会创建新值，它只是值暂让现有的时看起来有个新类型而已。 （还有些合法转换则会创建新值，如从整数转换为浮点数等。）</p>
<p>在 <code>Go</code> 程序中，为访问不同的方法集而进行类型转换的情况非常常见。 例如，我们可使用现有的 <code>sort.IntSlice</code> 类型来简化整个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sequence []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // 用于打印的方法 - 在打印前对元素进行排序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	sort.IntSlice(s).Sort()</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint([]<span class="keyword">int</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，不必让 <code>Sequence</code> 实现多个接口（排序和打印）， 我们可通过将数据条目转换为多种类型<code>（Sequence、sort.IntSlice 和 []int）</code>来使用相应的功能，每次转换都完成一部分工作。 这在实践中虽然有些不同寻常，但往往却很有效。</p>
<h2 id="接口转换与类型断言"><a href="#接口转换与类型断言" class="headerlink" title="接口转换与类型断言"></a>接口转换与类型断言</h2><p>类型选择是类型转换的一种形式：它接受一个接口，在选择 <code>（switch）</code>中根据其判断选择对应的情况<code>（case）</code>， 并在某种意义上将其转换为该种类型。以下代码为 <code>fmt.Printf</code> 通过类型选择将值转换为字符串的简化版。若它已经为字符串，我们需要该接口中实际的字符串值； 若它有 <code>String</code> 方法，我们则需要调用该方法所得的结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 调用者提供的值。</span></span><br><span class="line"><span class="keyword">switch</span> str := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">case</span> Stringer:</span><br><span class="line">	<span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种情况获取具体的值，第二种将该接口转换为另一个接口。这种方式对于混合类型来说非常完美。</p>
<p>若我们只关心一种类型呢？若我们知道该值拥有一个 <code>string</code> 而想要提取它呢？ 只需一种情况的类型选择就行，但它需要类型断言。类型断言接受一个接口值， 并从中提取指定的明确类型的值。其语法借鉴自类型选择开头的子句，但它需要一个明确的类型， 而非 <code>type</code> 关键字：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value.(typeName)</span><br></pre></td></tr></table></figure>
<p>而其结果则是拥有静态类型 <code>typeName</code> 的新值。该类型必须为该接口所拥有的具体类型， 或者该值可转换成的第二种接口类型。要提取我们知道在该值中的字符串，可以这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str := value.(<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>
<p>但若它所转换的值中不包含字符串，该程序就会以运行时错误崩溃。为避免这种情况， 需使用<code>“逗号, ok”</code>惯用测试它能安全地判断该值是否为字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str, ok := value.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"字符串值为 %q\n"</span>, str)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"该值非字符串\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若类型断言失败，<code>str</code> 将继续存在且为字符串类型，但它将拥有零值，即空字符串。</p>
<p>作为对能量的说明，这里有个 <code>if-else</code> 语句，它等价于本节开头的类型选择。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> str, ok := value.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> str, ok := value.(Stringer); ok &#123;</span><br><span class="line">	<span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h2><p>若某种现有的类型仅实现了一个接口，且除此之外并无可导出的方法，则该类型本身就无需导出。 仅导出该接口能让我们更专注于其行为而非实现，其它属性不同的实现则能镜像该原始类型的行为。 这也能够避免为每个通用接口的实例重复编写文档。</p>
<p>在这种情况下，构造函数应当返回一个接口值而非实现的类型。例如在 <code>hash</code> 库中，<code>crc32.NewIEEE</code> 和 <code>adler32.New</code> 都返回接口类型 <code>hash.Hash32</code>。要在 <code>Go</code> 程序中用 <code>Adler-32</code> 算法替代 <code>CRC-32</code>， 只需修改构造函数调用即可，其余代码则不受算法改变的影响。</p>
<p>同样的方式能将 <code>crypto</code> 包中多种联系在一起的流密码算法与块密码算法分开。 <code>crypto/cipher</code> 包中的 <code>Block</code> 接口指定了块密码算法的行为， 它为单独的数据块提供加密。接着，和 <code>bufio</code> 包类似，任何实现了该接口的密码包都能被用于构造以 <code>Stream</code> 为接口表示的流密码，而无需知道块加密的细节。</p>
<p><code>crypto/cipher</code> 接口看其来就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">interface</span> &#123;</span><br><span class="line">	BlockSize() <span class="keyword">int</span></span><br><span class="line">	Encrypt(src, dst []<span class="keyword">byte</span>)</span><br><span class="line">	Decrypt(src, dst []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stream <span class="keyword">interface</span> &#123;</span><br><span class="line">	XORKeyStream(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是计数器模式 <code>CTR</code> 流的定义，它将块加密改为流加密，注意块加密的细节已被抽象化了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewCTR 返回一个 Stream，其加密/解密使用计数器模式中给定的 Block 进行。</span></span><br><span class="line"><span class="comment">// iv 的长度必须与 Block 的块大小相同。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCTR</span><span class="params">(block Block, iv []<span class="keyword">byte</span>)</span> <span class="title">Stream</span></span></span><br></pre></td></tr></table></figure>
<p><code>NewCTR</code> 的应用并不仅限于特定的加密算法和数据源，它适用于任何对 <code>Block</code> 接口和 <code>Stream</code> 的实现。因为它们返回接口值， 所以用其它加密模式来代替 <code>CTR</code> 只需做局部的更改。构造函数的调用过程必须被修改， 但由于其周围的代码只能将它看做 <code>Stream</code>，因此它们不会注意到其中的区别。</p>
<h2 id="接口和方法"><a href="#接口和方法" class="headerlink" title="接口和方法"></a>接口和方法</h2><p>由于几乎任何类型都能添加方法，因此几乎任何类型都能满足一个接口。一个很直观的例子就是 <code>http</code> 包中定义的 <code>Handler</code> 接口。任何实现了 <code>Handler</code> 的对象都能够处理 <code>HTTP</code> 请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ResponseWriter</code> 接口提供了对方法的访问，这些方法需要响应客户端的请求。 由于这些方法包含了标准的 <code>Write</code> 方法，因此 <code>http.ResponseWriter</code> 可用于任何 <code>io.Writer</code> 适用的场景。<code>Request</code> 结构体包含已解析的客户端请求。</p>
<p>为简单起见，我们假设所有的 <code>HTTP</code> 请求都是 <code>GET</code> 方法，而忽略 <code>POST</code> 方法， 这种简化不会影响处理程序的建立方式。这里有个短小却完整的处理程序实现， 它用于记录某个页面被访问的次数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的计数器服务。</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">	n <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctr *Counter)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	ctr.n++</span><br><span class="line">	fmt.Fprintf(w, <span class="string">"counter = %d\n"</span>, ctr.n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（紧跟我们的主题，注意 <code>Fprintf</code> 如何能输出到 <code>http.ResponseWriter</code>。） 作为参考，这里演示了如何将这样一个服务器添加到 <code>URL树</code> 的一个节点上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line">...</span><br><span class="line">ctr := <span class="built_in">new</span>(Counter)</span><br><span class="line">http.Handle(<span class="string">"/counter"</span>, ctr)</span><br></pre></td></tr></table></figure>
<p>但为什么 <code>Counter</code> 要是结构体呢？一个整数就够了。 <code>An integer is all that&#39;s needed. </code>（<em><strong>接收者必须为指针，增量操作对于调用者才可见</strong></em>。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的计数器服务。</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctr *Counter)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	*ctr++</span><br><span class="line">	fmt.Fprintf(w, <span class="string">"counter = %d\n"</span>, *ctr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当页面被访问时，怎样通知你的程序去更新一些内部状态呢？为Web页面绑定个信道吧。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次浏览该信道都会发送一个提醒。</span></span><br><span class="line"><span class="comment">// （可能需要带缓冲的信道。）</span></span><br><span class="line"><span class="keyword">type</span> Chan <span class="keyword">chan</span> *http.Request</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch Chan)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	ch &lt;- req</span><br><span class="line">	fmt.Fprint(w, <span class="string">"notification sent"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，假设我们需要输出调用服务器二进制程序时使用的实参 <code>/args</code>。 很简单，写个打印实参的函数就行了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArgServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们如何将它转换为 <code>HTTP</code> 服务器呢？我们可以将 <code>ArgServer</code> 实现为某种可忽略值的方法，不过还有种更简单的方法。 既然我们可以为除指针和接口以外的任何类型定义方法，同样也能为一个函数写一个方法。 <code>http</code> 包包含以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerFunc 类型是一个适配器，它允许将普通函数用做HTTP处理程序。</span></span><br><span class="line"><span class="comment">// 若 f 是个具有适当签名的函数，HandlerFunc(f) 就是个调用 f 的处理程序对象。</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(c, req).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">	f(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HandlerFunc</code> 是个具有 <code>ServeHTTP</code> 方法的类型， 因此该类型的值就能处理 <code>HTTP</code> 请求。我们来看看该方法的实现：接收者是一个函数 <code>f</code>，而该方法调用 <code>f</code>。这看起来很奇怪，但不必大惊小怪， 区别在于接收者变成了一个信道，而方法通过该信道发送消息。</p>
<p>为了将 <code>ArgServer</code> 实现成 <code>HTTP服务器</code>，首先我们得让它拥有合适的签名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实参服务器。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArgServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintln(w, os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ArgServer</code> 和 <code>HandlerFunc</code> 现在拥有了相同的签名， 因此我们可将其转换为这种类型以访问它的方法，就像我们将 <code>Sequence</code> 转换为 <code>IntSlice</code> 以访问 <code>IntSlice.Sort</code> 那样。 建立代码非常简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.Handle(<span class="string">"/args"</span>, http.HandlerFunc(ArgServer))</span><br></pre></td></tr></table></figure>
<p>当有人访问 <code>/args</code> 页面时，安装到该页面的处理程序就有了值 <code>ArgServer</code> 和类型 <code>HandlerFunc</code>。 <code>HTTP</code> 服务器会以 <code>ArgServer</code> 为接收者，调用该类型的 <code>ServeHTTP</code> 方法，它会反过来调用 <code>ArgServer</code>（通过 <code>f(c, req)</code>），接着实参就会被显示出来。</p>
<p>在本节中，我们通过一个结构体，一个整数，一个信道和一个函数，建立了一个 <code>HTTP</code> 服务器， 这一切都是因为接口只是方法的集和，而几乎任何类型都能定义方法。</p>
<h1 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h1><p>我们在 <code>for-range</code> 循环和映射中提过几次空白标识符。 空白标识符可被赋予或声明为任何类型的任何值，而其值会被无害地丢弃。它有点像 <code>Unix</code> 中的 <code>/dev/null</code> 文件：它表示只写的值，在需要变量但不需要实际值的地方用作占位符。 我们在前面已经见过它的用法了。</p>
<h2 id="多重赋值中的空白标识符"><a href="#多重赋值中的空白标识符" class="headerlink" title="多重赋值中的空白标识符"></a>多重赋值中的空白标识符</h2><p><code>for range</code> 循环中对空表标识符的用法是一种具体情况，更一般的情况即为多重赋值。</p>
<p>若某次赋值需要匹配多个左值，但其中某个变量不会被程序使用， 那么用空白标识符来代替该变量可避免创建无用的变量，并能清楚地表明该值将被丢弃。 例如，当调用某个函数时，它会返回一个值和一个错误，但只有错误很重要， 那么可使用空白标识符来丢弃无关的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s does not exist\n"</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你偶尔会看见为忽略错误而丢弃错误值的代码，这是种糟糕的实践。请务必检查错误返回， 它们会提供错误的理由。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 烂代码！若路径不存在，它就会崩溃。</span><br><span class="line">fi, _ :&#x3D; os.Stat(path)</span><br><span class="line">if fi.IsDir() &#123;</span><br><span class="line">	fmt.Printf(&quot;%s is a directory\n&quot;, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="未使用的导入和变量"><a href="#未使用的导入和变量" class="headerlink" title="未使用的导入和变量"></a>未使用的导入和变量</h2><p>若导入某个包或声明某个变量而不使用它就会产生错误。未使用的包会让程序膨胀并拖慢编译速度， 而已初始化但未使用的变量不仅会浪费计算能力，还有可能暗藏着更大的Bug。 然而在程序开发过程中，经常会产生未使用的导入和变量。虽然以后会用到它们， 但为了完成编译又不得不删除它们才行，这很让人烦恼。空白标识符就能提供一个工作空间。</p>
<p>这个写了一半的程序有两个未使用的导入（<code>fmt</code> 和 <code>io</code>）以及一个未使用的变量（<code>fd</code>），因此它不能编译， 但若到目前为止代码还是正确的，我们还是很乐意看到它们的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">"test.go"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use fd.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要让编译器停止关于未使用导入的抱怨，需要空白标识符来引用已导入包中的符号。 同样，将未使用的变量 <code>fd</code> 赋予空白标识符也能关闭未使用变量错误。 该程序的以下版本可以编译。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = fmt.Printf <span class="comment">// For debugging; delete when done. // 用于调试，结束时删除。</span></span><br><span class="line"><span class="keyword">var</span> _ io.Reader    <span class="comment">// For debugging; delete when done. // 用于调试，结束时删除。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">"test.go"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use fd.</span></span><br><span class="line">    _ = fd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照惯例，我们应在导入并加以注释后，再使全局声明导入错误静默，这样可以让它们更易找到， 并作为以后清理它的提醒。</p>
<h2 id="为副作用而导入"><a href="#为副作用而导入" class="headerlink" title="为副作用而导入"></a>为副作用而导入</h2><p>像前例中 <code>fmt</code> 或 <code>io</code> 这种未使用的导入总应在最后被使用或移除： 空白赋值会将代码标识为工作正在进行中。但有时导入某个包只是为了其副作用， 而没有任何明确的使用。例如，在 <code>net/http/pprof</code> 包的 <code>init</code> 函数中记录了 <code>HTTP</code> 处理程序的调试信息。它有个可导出的 <code>API</code>， 但大部分客户端只需要该处理程序的记录和通过 <code>Web</code> 页访问数据。只为了其副作用来导入该包， 只需将包重命名为空白标识符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></span><br></pre></td></tr></table></figure>
<p>这种导入格式能明确表示该包是为其副作用而导入的，因为没有其它使用该包的可能： 在此文件中，它没有名字。（若它有名字而我们没有使用，编译器就会拒绝该程序。）</p>
<h2 id="接口检查"><a href="#接口检查" class="headerlink" title="接口检查"></a>接口检查</h2><p>就像我们在前面接口中讨论的那样， 一个类型无需显式地声明它实现了某个接口。取而代之，该类型只要实现了某个接口的方法， 其实就实现了该接口。在实践中，大部分接口转换都是静态的，因此会在编译时检测。 例如，将一个 <code>*os.File</code> 传入一个预期的 <code>io.Reader</code> 函数将不会被编译， 除非 <code>*os.File</code> 实现了 <code>io.Reader</code> 接口。</p>
<p>尽管有些接口检查会在运行时进行。<code>encoding/json</code> 包中就有个实例它定义了一个 <code>Marshaler</code> 接口。当 <code>JSON</code> 编码器接收到一个实现了该接口的值，那么该编码器就会调用该值的编组方法， 将其转换为 <code>JSON</code> ，而非进行标准的类型转换。 编码器在运行时通过类型断言检查其属性，就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m, ok := val.(json.Marshaler)</span><br></pre></td></tr></table></figure>
<p>若只需要判断某个类型是否是实现了某个接口，而不需要实际使用接口本身 （可能是错误检查部分），就使用空白标识符来忽略类型断言的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := val.(json.Marshaler); ok &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"value %v of type %T implements json.Marshaler\n"</span>, val, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要确保某个包中实现的类型一定满足该接口时，就会遇到这种情况。 若某个类型（例如 <code>json.RawMessage</code>） 需要一种定制的 <code>JSON</code> 表现时，它应当实现 <code>json.Marshaler</code>， 不过现在没有静态转换可以让编译器去自动验证它。若该类型通过忽略转换失败来满足该接口， 那么 <code>JSON</code> 编码器仍可工作，但它却不会使用定制的实现。为确保其实现正确， 可在该包中用空白标识符声明一个全局变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ json.Marshaler = (*RawMessage)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>在此声明中，我们调用了一个 <code>*RawMessage</code> 转换并将其赋予了 <code>Marshaler</code>，以此来要求 <code>*RawMessage</code> 实现 <code>Marshaler</code>，这时其属性就会在编译时被检测。 若 <code>json.Marshaler</code> 接口被更改，此包将无法通过编译， 而我们则会注意到它需要更新。</p>
<p>在这种结构中出现空白标识符，即表示该声明的存在只是为了类型检查。 不过请不要为满足接口就将它用于任何类型。作为约定， 仅当代码中不存在静态类型转换时才能这种声明，毕竟这是种罕见的情况。</p>
<h1 id="内嵌"><a href="#内嵌" class="headerlink" title="内嵌"></a>内嵌</h1><p><code>Go</code> 并不提供典型的，类型驱动的子类化概念，但通过将类型&lt;内嵌到结构体或接口中， 它就能“借鉴”部分实现。</p>
<p>接口内嵌非常简单。我们之前提到过 <code>io.Reader</code> 和 <code>io.Writer </code>接口，这里是它们的定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>io</code> 包也导出了一些其它接口，以此来阐明对象所需实现的方法。 例如 <code>io.ReadWriter</code> 就是个包含 <code>Read</code> 和 <code>Write</code> 的接口。我们可以通过显示地列出这两个方法来指明 <code>io.ReadWriter</code>， 但通过将这两个接口内嵌到新的接口中显然更容易且更具启发性，就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadWriter 接口结合了 Reader 和 Writer 接口。</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如它看起来那样：<code>ReadWriter</code> 能够做任何 <code>Reader</code> 和 <code>Writer</code> 可以做到的事情，它是内嵌接口的联合体 （它们必须是不相交的方法集）。只有接口能被嵌入到接口中。</p>
<p>同样的基本想法可以应用在结构体中，但其意义更加深远。<code>bufio</code> 包中有 <code>bufio.Reader</code> 和 <code>bufio.Writer</code> 这两个结构体类型， 它们每一个都实现了与 <code>io</code> 包中相同意义的接口。此外，<code>bufio</code> 还通过结合 <code>reader/writer</code> 并将其内嵌到结构体中，实现了带缓冲的 <code>reader/writer</code>：它列出了结构体中的类型，但并未给予它们字段名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadWriter 存储了指向 Reader 和 Writer 的指针。</span></span><br><span class="line"><span class="comment">// 它实现了 io.ReadWriter。</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	*Reader  <span class="comment">// *bufio.Reader</span></span><br><span class="line">	*Writer  <span class="comment">// *bufio.Writer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内嵌的元素为指向结构体的指针，当然它们在使用前必须被初始化为指向有效结构体的指针。 <code>ReadWriter</code> 结构体和通过如下方式定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	reader *Reader</span><br><span class="line">	writer *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但为了提升该字段的方法并满足 <code>io</code> 接口，我们同样需要提供转发的方法， 就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *ReadWriter)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rw.reader.Read(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而通过直接内嵌结构体，我们就能避免如此繁琐。 内嵌类型的方法可以直接引用，这意味着 <code>bufio.ReadWriter</code> 不仅包括 <code>bufio.Reader</code> 和 <code>bufio.Writer</code> 的方法，它还同时满足下列三个接口： <code>io.Reader</code>、<code>io.Writer</code> 以及 <code>io.ReadWriter</code>。</p>
<p>还有种区分内嵌与子类的重要手段。当内嵌一个类型时，该类型的方法会成为外部类型的方法， 但当它们被调用时，该方法的接收者是内部类型，而非外部的。在我们的例子中，当 <code>bufio.ReadWriter</code> 的 <code>Read</code> 方法被调用时， 它与之前写的转发方法具有同样的效果；接收者是 <code>ReadWriter</code> 的 <code>reader</code> 字段，而非 <code>ReadWriter</code> 本身。</p>
<p>内嵌同样可以提供便利。这个例子展示了一个内嵌字段和一个常规的命名字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">	Command <span class="keyword">string</span></span><br><span class="line">	*log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Job</code> 类型现在有了 <code>Log</code>、<code>Logf</code> 和 <code>*log.Logger</code> 的其它方法。我们当然可以为 <code>Logger</code> 提供一个字段名，但完全不必这么做。现在，一旦初始化后，我们就能记录 <code>Job</code> 了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job.Log(<span class="string">"starting now..."</span>)</span><br></pre></td></tr></table></figure>
<p><code>Logger</code> 是 <code>Job</code> 结构体的常规字段， 因此我们可在 <code>Job</code> 的构造函数中，通过一般的方式来初始化它，就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewJob</span><span class="params">(command <span class="keyword">string</span>, logger *log.Logger)</span> *<span class="title">Job</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Job&#123;command, logger&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或通过复合字面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job := &amp;Job&#123;command, log.New(os.Stderr, <span class="string">"Job: "</span>, log.Ldate)&#125;</span><br></pre></td></tr></table></figure>
<p>若我们需要直接引用内嵌字段，可以忽略包限定名，直接将该字段的类型名作为字段名， 就像我们在 <code>ReaderWriter</code> 结构体的 <code>Read</code> 方法中做的那样。 若我们需要访问 <code>Job</code> 类型的变量 <code>job</code> 的 <code>*log.Logger</code>， 可以直接写作 <code>job.Logger</code>。若我们想精炼 <code>Logger</code> 的方法时， 这会非常有用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(job *Job)</span> <span class="title">Logf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	job.Logger.Logf(<span class="string">"%q: %s"</span>, job.Command, fmt.Sprintf(format, args...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内嵌类型会引入命名冲突的问题，但解决规则却很简单。首先，字段或方法 <code>X</code> 会隐藏该类型中更深层嵌套的其它项 <code>X</code>。若 <code>log.Logger</code> 包含一个名为 <code>Command</code> 的字段或方法，<code>Job</code> 的 <code>Command</code> 字段会覆盖它。</p>
<p>其次，若相同的嵌套层级上出现同名冲突，通常会产生一个错误。若 <code>Job</code> 结构体中包含名为 <code>Logger</code> 的字段或方法，再将 <code>log.Logger</code> 内嵌到其中的话就会产生错误。然而，若重名永远不会在该类型定义之外的程序中使用，那就不会出错。 这种限定能够在外部嵌套类型发生修改时提供某种保护。 因此，就算添加的字段与另一个子类型中的字段相冲突，只要这两个相同的字段永远不会被使用就没问题。</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="通过通信共享内存"><a href="#通过通信共享内存" class="headerlink" title="通过通信共享内存"></a>通过通信共享内存</h2><p>并发编程是个很大的论题。但限于篇幅，这里仅讨论一些 <code>Go</code> 特有的东西。</p>
<p>在并发编程中，为实现对共享变量的正确访问需要精确的控制，这在多数环境下都很困难。 <code>Go</code> 语言另辟蹊径，它将共享的值通过信道传递，实际上，多个独立执行的线程从不会主动共享。 在任意给定的时间点，只有一个<code>Go</code>程能够访问该值。数据竞争从设计上就被杜绝了。 为了提倡这种思考方式，我们将它简化为一句口号：</p>
<blockquote>
<p>不要通过共享内存来通信，而应通过通信来共享内存。</p>
</blockquote>
<p>这种方法意义深远。例如，引用计数通过为整数变量添加互斥锁来很好地实现。 但作为一种高级方法，通过信道来控制访问能够让你写出更简洁，正确的程序。</p>
<p>我们可以从典型的单线程运行在单 <code>CPU</code> 之上的情形来审视这种模型。它无需提供同步原语。 现在考虑另一种情况，它也无需同步。现在让它们俩进行通信。若将通信过程看做同步着， 那就完全不需要其它同步了。例如，<code>Unix</code> 管道就与这种模型完美契合。 尽管 <code>Go</code> 的并发处理方式来源于 <code>Hoare</code> 的通信顺序处理（<code>CSP</code>）， 它依然可以看做是类型安全的 <code>Unix</code> 管道的实现。</p>
<h2 id="Go程"><a href="#Go程" class="headerlink" title="Go程"></a>Go程</h2><p>我们称之为 <code>Go程</code> 是因为现有的术语—线程、协程、进程等等—无法准确传达它的含义。 <code>Go</code>程具有简单的模型：<strong>它是与其它 <code>Go</code> 程并发运行在同一地址空间的函数</strong>。它是轻量级的， 所有小号几乎就只有栈空间的分配。而且栈最开始是非常小的，所以它们很廉价， 仅在需要时才会随着堆空间的分配（和释放）而变化。</p>
<p><code>Go程</code> 在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待 <code>I/O</code> ， 那么其它的线程就会运行。Go程的设计隐藏了线程创建和管理的诸多复杂性。</p>
<p>在函数或方法前添加 <code>go</code> 关键字能够在新的 <code>Go程</code> 中调用它。当调用完成后， 该 <code>Go程</code> 也会安静地退出。（效果有点像 <code>Unix Shell</code> 中的 <code>&amp;</code> 符号，它能让命令在后台运行。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> list.Sort()  <span class="comment">// 并发运行 list.Sort，无需等它结束。</span></span><br></pre></td></tr></table></figure>
<p>函数字面在Go程调用中非常有用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Announce</span><span class="params">(message <span class="keyword">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(delay)</span><br><span class="line">		fmt.Println(message)</span><br><span class="line">	&#125;()  <span class="comment">// 注意括号 - 必须调用该函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Go</code> 中，函数字面都是闭包：其实现在保证了函数内引用变量的生命周期与函数的活动时间相同。</p>
<p>这些函数没什么实用性，因为它们没有实现完成时的信号处理。因此，我们需要信道。</p>
<h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信道与映射一样，也需要通过 <code>make</code> 来分配内存。其结果值充当了对底层数据结构的引用。 若提供了一个可选的整数形参，它就会为该信道设置缓冲区大小。默认值是零，表示不带缓冲的或同步的信道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ci := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)            <span class="comment">// 整数类型的无缓冲信道</span></span><br><span class="line">cj := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>)         <span class="comment">// 整数类型的无缓冲信道</span></span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> *os.File, <span class="number">100</span>)  <span class="comment">// 指向文件指针的带缓冲信道</span></span><br></pre></td></tr></table></figure>
<p>无缓冲信道在通信时会同步交换数据，它能确保（两个<code>Go</code>程的）计算处于确定状态。</p>
<p>信道有很多惯用法，我们从这里开始了解。在上一节中，我们在后台启动了排序操作。 信道使得启动的 <code>Go</code> 程等待排序完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  <span class="comment">// 分配一个信道</span></span><br><span class="line"><span class="comment">// 在Go程中启动排序。当它完成后，在信道上发送信号。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	list.Sort()</span><br><span class="line">	c &lt;- <span class="number">1</span>  <span class="comment">// 发送信号，什么值无所谓。</span></span><br><span class="line">&#125;()</span><br><span class="line">doSomethingForAWhile()</span><br><span class="line">&lt;-c   <span class="comment">// 等待排序结束，丢弃发来的值。</span></span><br></pre></td></tr></table></figure>
<p>接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前， 发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞； 若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。</p>
<p>带缓冲的信道可被用作信号量，例如限制吞吐量。在此例中，进入的请求会被传递给 <code>handle</code>，它从信道中接收值，处理请求后将值发回该信道中，以便让该 “信号量”准备迎接下一次请求。信道缓冲区的容量决定了同时调用 <code>process</code> 的数量上限，因此我们在初始化时首先要填充至它的容量上限。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sem = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, MaxOutstanding)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">	sem &lt;- <span class="number">1</span> <span class="comment">// 等待活动队列清空。</span></span><br><span class="line">	process(r)  <span class="comment">// 可能需要很长时间。</span></span><br><span class="line">	&lt;-sem    <span class="comment">// 完成；使下一个请求可以运行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		req := &lt;-queue</span><br><span class="line">		<span class="keyword">go</span> handle(req)  <span class="comment">// 无需等待 handle 结束。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于数据同步发生在信道的接收端（也就是说发送发生在&gt;接受之前，参见 <code>Go内存模型</code>），因此信号必须在信道的接收端获取，而非发送端。</p>
<p>然而，它却有个设计问题：尽管只有 <code>MaxOutstanding</code> 个 <code>Go</code> 程能同时运行，但 <code>Serve</code> 还是为每个进入的请求都创建了新的 <code>Go</code>程。其结果就是，若请求来得很快， 该程序就会无限地消耗资源。为了弥补这种不足，我们可以通过修改 <code>Serve</code> 来限制创建 <code>Go</code> 程，这是个明显的解决方案，但要当心我们修复后出现的 <code>Bug</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		sem &lt;- <span class="number">1</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			process(req) <span class="comment">// 这儿有Bug，解释见下。</span></span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Bug</code>出现在 <code>Go</code> 的 <code>for</code> 循环中，该循环变量在每次迭代时会被重用，因此 <code>req</code> 变量会在所有的 <code>Go</code> 程间共享，这不是我们想要的。我们需要确保 <code>req</code> 对于每个 <code>Go</code> 程来说都是唯一的。有一种方法能够做到，就是将 <code>req</code> 的值作为实参传入到该 <code>Go</code> 程的闭包中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		sem &lt;- <span class="number">1</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(req *Request)</span></span> &#123;</span><br><span class="line">			process(req)</span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;(req)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较前后两个版本，观察该闭包声明和运行中的差别。 另一种解决方案就是以相同的名字创建新的变量，如例中所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		req := req <span class="comment">// 为该Go程创建 req 的新实例。</span></span><br><span class="line">		sem &lt;- <span class="number">1</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			process(req)</span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的写法看起来有点奇怪</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req := req</span><br></pre></td></tr></table></figure>
<p>但在Go中这样做是合法且惯用的。你用相同的名字获得了该变量的一个新的版本， 以此来局部地刻意屏蔽循环变量，使它对每个Go程保持唯一。</p>
<p>回到编写服务器的一般问题上来。另一种管理资源的好方法就是启动固定数量的 <code>handle Go</code> 程，一起从请求信道中读取数据。<code>Go</code> 程的数量限制了同时调用 <code>process</code> 的数量。<code>Serve</code> 同样会接收一个通知退出的信道， 在启动所有 <code>Go程</code> 后，它将阻塞并暂停从信道中接收消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> r := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		process(r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(clientRequests <span class="keyword">chan</span> *Request, quit <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 启动处理程序</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; MaxOutstanding; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> handle(clientRequests)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-quit  <span class="comment">// 等待通知退出。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信道中的信道"><a href="#信道中的信道" class="headerlink" title="信道中的信道"></a>信道中的信道</h2><p><code>Go</code> 最重要的特性就是<strong>信道是一等值</strong>，它可以被分配并像其它值到处传递。 这种特性通常被用来实现安全、并行的多路分解。</p>
<p>在上一节的例子中，<code>handle</code> 是个非常理想化的请求处理程序， 但我们并未定义它所处理的请求类型。若该类型包含一个可用于回复的信道， 那么每一个客户端都能为其回应提供自己的路径。以下为 <code>Request</code> 类型的大概定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	args        []<span class="keyword">int</span></span><br><span class="line">	f           <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">	resultChan  <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端提供了一个函数及其实参，此外在请求对象中还有个接收应答的信道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		s += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request := &amp;Request&#123;[]<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, sum, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)&#125;</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">clientRequests &lt;- request</span><br><span class="line"><span class="comment">// 等待回应</span></span><br><span class="line">fmt.Printf(<span class="string">"answer: %d\n"</span>, &lt;-request.resultChan)</span><br></pre></td></tr></table></figure>
<p>On the server side, the handler function is the only thing that changes.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		req.resultChan &lt;- req.f(req.args)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使其实际可用还有很多工作要做，这些代码仅能实现一个速率有限、并行、非阻塞RPC系统的 框架，而且它并不包含互斥锁。</p>
<h2 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h2><p>这些设计的另一个应用是在多 <code>CPU</code> 核心上实现并行计算。如果计算过程能够被分为几块 可独立执行的过程，它就可以在每块计算结束时向信道发送信号，从而实现并行处理。</p>
<p>让我们看看这个理想化的例子。我们在对一系列向量项进行极耗资源的操作， 而每个项的值计算是完全独立的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vector []<span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将此操应用至 v[i], v[i+1] ... 直到 v[n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vector)</span> <span class="title">DoSome</span><span class="params">(i, n <span class="keyword">int</span>, u Vector, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> ; i &lt; n; i++ &#123;</span><br><span class="line">		v[i] += u.Op(v[i])</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- <span class="number">1</span>    <span class="comment">// 发信号表示这一块计算完成。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在循环中启动了独立的处理块，每个<code>CPU</code>将执行一个处理。 它们有可能以乱序的形式完成并结束，但这没有关系； 我们只需在所有<code>Go</code>程开始后接收，并统计信道中的完成信号即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NCPU = <span class="number">4</span>  <span class="comment">// CPU核心数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vector)</span> <span class="title">DoAll</span><span class="params">(u Vector)</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, NCPU)  <span class="comment">// 缓冲区是可选的，但明显用上更好</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NCPU; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> v.DoSome(i*<span class="built_in">len</span>(v)/NCPU, (i+<span class="number">1</span>)*<span class="built_in">len</span>(v)/NCPU, u, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 排空信道。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NCPU; i++ &#123;</span><br><span class="line">		&lt;-c    <span class="comment">// 等待任务完成</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 一切完成。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前<code>Go</code>运行时的实现默认并不会并行执行代码，它只为用户层代码提供单一的处理核心。 任意数量的<code>Go</code>程都可能在系统调用中被阻塞，而在任意时刻默认只有一个会执行用户层代码。 它应当变得更智能，而且它将来肯定会变得更智能。但现在，若你希望<code>CPU</code>并行执行， 就必须告诉运行时你希望同时有多少<code>Go</code>程能执行代码。有两种途径可意识形态，要么 在运行你的工作时将 <code>GOMAXPROCS</code> 环境变量设为你要使用的核心数， 要么导入 <code>runtime</code> 包并调用 <code>runtime.GOMAXPROCS(NCPU)</code>。 <code>runtime.NumCPU()</code> 的值可能很有用，它会返回当前机器的逻辑<code>CPU</code>核心数。 当然，随着调度算法和运行时的改进，将来会不再需要这种方法。</p>
<p>注意不要混淆并发和并行的概念：并发是用可独立执行的组件构造程序的方法， 而并行则是为了效率在多<code>CPU</code>上平行地进行计算。尽管<code>Go</code>的并发特性能够让某些问题更易构造成并行计算， 但<code>Go</code>仍然是种并发而非并行的语言，且<code>Go</code>的模型并不适合所有的并行问题。</p>
<h2 id="可能泄露的缓冲区"><a href="#可能泄露的缓冲区" class="headerlink" title="可能泄露的缓冲区"></a>可能泄露的缓冲区</h2><p>并发编程的工具甚至能很容易地表达非并发的思想。这里有个提取自 <code>RPC</code> 包的例子。 客户端 <code>Go</code> 程从某些来源，可能是网络中循环接收数据。为避免分配和释放缓冲区， 它保存了一个空闲链表，使用一个带缓冲信道表示。若信道为空，就会分配新的缓冲区。 一旦消息缓冲区就绪，它将通过 <code>serverChan</code> 被发送到服务器。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> freeList = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> serverChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">client</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> b *Buffer</span><br><span class="line">		<span class="comment">// 若缓冲区可用就用它，不可用就分配个新的。</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> b = &lt;-freeList:</span><br><span class="line">			<span class="comment">// 获取一个，不做别的。</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 非空闲，因此分配一个新的。</span></span><br><span class="line">			b = <span class="built_in">new</span>(Buffer)</span><br><span class="line">		&#125;</span><br><span class="line">		load(b)              <span class="comment">// 从网络中读取下一条消息。</span></span><br><span class="line">		serverChan &lt;- b   <span class="comment">// 发送至服务器。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器从客户端循环接收每个消息，处理它们，并将缓冲区返回给空闲列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		b := &lt;-serverChan    <span class="comment">// 等待工作。</span></span><br><span class="line">		process(b)</span><br><span class="line">		<span class="comment">// 若缓冲区有空间就重用它。</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> freeList &lt;- b:</span><br><span class="line">			<span class="comment">// 将缓冲区放大空闲列表中，不做别的。</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 空闲列表已满，保持就好。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端试图从 <code>freeList</code> 中获取缓冲区；若没有缓冲区可用， 它就将分配一个新的。服务器将 <code>b</code> 放回空闲列表 <code>freeList</code> 中直到列表已满，此时缓冲区将被丢弃，并被垃圾回收器回收。（<code>select</code> 语句中的 <code>default</code> 子句在没有条件符合时执行，这也就意味着 <code>selects</code> 永远不会被阻塞。）依靠带缓冲的信道和垃圾回收器的记录， 我们仅用短短几行代码就构建了一个可能导致缓冲区槽位泄露的空闲列表。</p>
<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>库例程通常需要向调用者返回某种类型的错误提示。之前提到过，<code>Go</code> 语言的多值返回特性， 使得它在返回常规的值时，还能轻松地返回详细的错误描述。按照约定，错误的类型通常为 <code>error</code>，这是一个内建的简单接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>库的编写者通过更丰富的底层模型可以轻松实现这个接口，这样不仅能看见错误， 还能提供一些上下文。例如，<code>os.Open</code> 可返回一个 <code>os.PathError</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PathError 记录一个错误以及产生该错误的路径和操作。</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Op <span class="keyword">string</span>    <span class="comment">// "open"、"unlink" 等等。</span></span><br><span class="line">	Path <span class="keyword">string</span>  <span class="comment">// 相关联的文件。</span></span><br><span class="line">	Err error    <span class="comment">// 由系统调用返回。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.Op + <span class="string">" "</span> + e.Path + <span class="string">": "</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PathError</code>的 <code>Error</code> 会生成如下错误信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open /etc/passwx: no such file or directory</span><br></pre></td></tr></table></figure>
<p>这种错误包含了出错的文件名、操作和触发的操作系统错误，即便在产生该错误的调用 和输出的错误信息相距甚远时，它也会非常有用，这比苍白的“不存在该文件或目录”更具说明性。</p>
<p>错误字符串应尽可能地指明它们的来源，例如产生该错误的包名前缀。例如在 <code>image</code> 包中，由于未知格式导致解码错误的字符串为 <code>“image: unknown format”</code> 。</p>
<p>若调用者关心错误的完整细节，可使用类型选择或者类型断言来查看特定错误，并抽取其细节。 对于 <code>PathErrors</code>，它应该还包含检查内部的 <code>Err</code> 字段以进行可能的错误恢复。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> try := <span class="number">0</span>; try &lt; <span class="number">2</span>; try++ &#123;</span><br><span class="line">	file, err = os.Create(filename)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC &#123;</span><br><span class="line">		deleteTempFiles()  <span class="comment">// 恢复一些空间。</span></span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的第二条 <code>if</code> 是另一种类型断言。若它失败， <code>ok</code> 将为 <code>false</code>，而 <code>e</code> 则为 <code>nil</code> . 若它成功，<code>ok</code> 将为 <code>true</code>，这意味着该错误属于 <code>*os.PathError</code> 类型，而 <code>e</code> 能够检测关于该错误的更多信息。</p>
<h2 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h2><p>向调用者报告错误的一般方式就是将 <code>error</code> 作为额外的值返回。 标准的 <code>Read</code> 方法就是个众所周知的实例，它返回一个字节计数和一个 <code>error</code>。但如果错误时不可恢复的呢？有时程序就是不能继续运行。</p>
<p>为此，我们提供了内建的 <code>panic</code> 函数，它会产生一个运行时错误并终止程序 （但请继续看下一节）。该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印。 它还能表明发生了意料之外的事情，比如从无限循环中退出了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用牛顿法计算立方根的一个玩具实现。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CubeRoot</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	z := x/<span class="number">3</span>   <span class="comment">// 任意初始值</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e6</span>; i++ &#123;</span><br><span class="line">		prevz := z</span><br><span class="line">		z -= (z*z*z-x) / (<span class="number">3</span>*z*z)</span><br><span class="line">		<span class="keyword">if</span> veryClose(z, prevz) &#123;</span><br><span class="line">			<span class="keyword">return</span> z</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 一百万次迭代并未收敛，事情出错了。</span></span><br><span class="line">	<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"CubeRoot(%g) did not converge"</span>, x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这仅仅是个示例，实际的库函数应避免 <code>panic</code>。若问题可以被屏蔽或解决， 最好就是让程序继续运行而不是终止整个程序。一个可能的反例就是初始化： 若某个库真的不能让自己工作，且有足够理由产生<code>Panic</code>，那就由它去吧。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">"USER"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> user == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"no value for $USER"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>当 <code>panic</code> 被调用后（包括不明确的运行时错误，例如切片检索越界或类型断言失败）， 程序将立刻终止当前函数的执行，并开始回溯Go程的栈，运行任何被推迟的函数。 若回溯到达Go程栈的顶端，程序就会终止。不过我们可以用内建的 <code>recover</code> 函数来重新或来取回 <code>Go</code> 程的控制权限并使其恢复正常执行。</p>
<p>调用 <code>recover</code> 将停止回溯过程，并返回传入 <code>panic</code> 的实参。 由于在回溯时只有被推迟函数中的代码在运行，因此 <code>recover</code> 只能在被推迟的函数中才有效。</p>
<p><code>recover</code> 的一个应用就是在服务器中终止失败的 <code>Go</code> 程而无需杀死其它正在执行的 <code>Go</code> 程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(workChan &lt;-<span class="keyword">chan</span> *Work)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> work := <span class="keyword">range</span> workChan &#123;</span><br><span class="line">		<span class="keyword">go</span> safelyDo(work)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(work *Work)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">"work failed:"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此例中，若 <code>do(work) </code>触发了 <code>Panic</code>，其结果就会被记录， 而该 <code>Go</code> 程会被干净利落地结束，不会干扰到其它 <code>Go</code> 程。我们无需在推迟的闭包中做任何事情， <code>recover</code> 会处理好这一切。</p>
<p>由于直接从被推迟函数中调用 <code>recover</code> 时不会返回 <code>nil</code>， 因此被推迟的代码能够调用本身使用了 <code>panic</code> 和 <code>recover</code> 的库函数而不会失败。例如在 <code>safelyDo</code> 中，被推迟的函数可能在调用 <code>recover</code> 前先调用记录函数，而该记录函数应当不受 <code>Panic</code> 状态的代码的影响。</p>
<p>通过恰当地使用恢复模式，<code>do</code> 函数（及其调用的任何代码）可通过调用 <code>panic</code> 来避免更坏的结果。我们可以利用这种思想来简化复杂软件中的错误处理。 让我们看看 <code>regexp</code> 包的理想化版本，它会以局部的错误类型调用 <code>panic</code> 来报告解析错误。以下是一个 <code>error</code> 类型的 <code>Error</code> 方法和一个 <code>Compile</code> 函数的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error 是解析错误的类型，它满足 error 接口。</span></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Error)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error 是 *Regexp 的方法，它通过用一个 Error 触发Panic来报告解析错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(regexp *Regexp)</span> <span class="title">error</span><span class="params">(err <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(Error(err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile 返回该正则表达式解析后的表示。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(regexp *Regexp, err error)</span></span> &#123;</span><br><span class="line">	regexp = <span class="built_in">new</span>(Regexp)</span><br><span class="line">	<span class="comment">// doParse will panic if there is a parse error.</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">			regexp = <span class="literal">nil</span>    <span class="comment">// 清理返回值。</span></span><br><span class="line">			err = e.(Error) <span class="comment">// 若它不是解析错误，将重新触发Panic。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> regexp.doParse(str), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若 <code>doParse</code> 触发了 <code>Panic</code> ，恢复块会将返回值设为 <code>nil</code> —被推迟的函数能够修改已命名的返回值。在 <code>err</code> 的赋值过程中， 我们将通过断言它是否拥有局部类型 <code>Error</code> 来检查它。若它没有， 类型断言将会失败，此时会产生运行时错误，并继续栈的回溯，仿佛一切从未中断过一样。 该检查意味着若发生了一些像索引越界之类的意外，那么即便我们使用了 <code>panic</code> 和 <code>recover</code> 来处理解析错误，代码仍然会失败。</p>
<p>通过适当的错误处理，<code>error</code> 方法（由于它是个绑定到具体类型的方法， 因此即便它与内建的 <code>error</code> 类型名字相同也没有关系） 能让报告解析错误变得更容易，而无需手动处理回溯的解析栈：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pos == <span class="number">0</span> &#123;</span><br><span class="line">	re.error(<span class="string">"'*' illegal at start of expression"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管这种模式很有用，但它应当仅在包内使用。<code>Parse</code> 会将其内部的 <code>panic</code> 调用转为 <code>error</code> 值，它并不会向调用者暴露出 <code>panic</code>。这是个值得遵守的良好规则。</p>
<p>顺便一提，这种重新触发 <code>Panic</code> 的惯用法会在产生实际错误时改变 <code>Panic</code> 的值。 然而，不管是原始的还是新的错误都会在崩溃报告中显示，因此问题的根源仍然是可见的。 这种简单的重新触发 <code>Panic</code> 的模型已经够用了，毕竟他只是一次崩溃。 但若你只想显示原始的值，也可以多写一点代码来过滤掉不需要的问题，然后用原始值再次触发 <code>Panic</code> 。 </p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如此，Go语言学习之旅的第一个阶段就结束了。</p>

    </div>

    
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- bottom ad -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-5714801576974230"
     data-ad-slot="5659053341"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Char 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Char 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5eacc50f0dcd8169" async="async"></script>
  </div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Char
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.xuebaonline.com/Go%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%9A2%E3%80%81Go%20%E5%AE%9E%E6%95%88%E7%BC%96%E7%A8%8B/" title="Go 入门篇：2、Go 实效编程">https://www.xuebaonline.com/Go 入门篇：2、Go 实效编程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/Bogon">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/connectme.JPG">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 基础语法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Go%20%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%9A1%E3%80%81Go%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%AA%8C%E8%AF%81/" rel="prev" title="Go 入门篇：1、Go 环境搭建与验证">
      <i class="fa fa-chevron-left"></i> Go 入门篇：1、Go 环境搭建与验证
    </a></div>
      <div class="post-nav-item">
    <a href="/iOS%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%9F%E8%83%BD%E7%95%8C%E9%9D%A2%E7%82%B9%E5%87%BB%E7%A9%BA%E7%99%BD%E5%A4%84%E9%9A%90%E8%97%8F%E7%9A%84%E4%BC%98%E9%9B%85%E8%A7%A3%E6%B3%95/" rel="next" title="iOS 自定义功能界面点击空白处隐藏的优雅解法">
      iOS 自定义功能界面点击空白处隐藏的优雅解法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例"><span class="nav-number">2.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#格式化"><span class="nav-number">3.</span> <span class="nav-text">格式化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#注释"><span class="nav-number">4.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#命名"><span class="nav-number">5.</span> <span class="nav-text">命名</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#包名"><span class="nav-number">5.1.</span> <span class="nav-text">包名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取器"><span class="nav-number">5.2.</span> <span class="nav-text">获取器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口名"><span class="nav-number">5.3.</span> <span class="nav-text">接口名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#驼峰记法"><span class="nav-number">5.4.</span> <span class="nav-text">驼峰记法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分号"><span class="nav-number">5.5.</span> <span class="nav-text">分号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制结构"><span class="nav-number">5.6.</span> <span class="nav-text">控制结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#If"><span class="nav-number">5.7.</span> <span class="nav-text">If</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重新声明与再次赋值"><span class="nav-number">5.8.</span> <span class="nav-text">重新声明与再次赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#For"><span class="nav-number">5.9.</span> <span class="nav-text">For</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Switch"><span class="nav-number">5.10.</span> <span class="nav-text">Switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型选择"><span class="nav-number">5.11.</span> <span class="nav-text">类型选择</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">6.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多值返回"><span class="nav-number">6.1.</span> <span class="nav-text">多值返回</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可命名结果形参"><span class="nav-number">6.2.</span> <span class="nav-text">可命名结果形参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Defer"><span class="nav-number">6.3.</span> <span class="nav-text">Defer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据"><span class="nav-number">7.</span> <span class="nav-text">数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#new-分配"><span class="nav-number">7.1.</span> <span class="nav-text">new 分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数与复合字面"><span class="nav-number">7.2.</span> <span class="nav-text">构造函数与复合字面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#make-分配"><span class="nav-number">7.3.</span> <span class="nav-text">make 分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">7.4.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切片"><span class="nav-number">7.5.</span> <span class="nav-text">切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二维切片"><span class="nav-number">7.6.</span> <span class="nav-text">二维切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#映射"><span class="nav-number">7.7.</span> <span class="nav-text">映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打印"><span class="nav-number">7.8.</span> <span class="nav-text">打印</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#追加"><span class="nav-number">7.9.</span> <span class="nav-text">追加</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#初始化"><span class="nav-number">8.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常量"><span class="nav-number">8.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">8.2.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#init-函数"><span class="nav-number">8.3.</span> <span class="nav-text">init 函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法"><span class="nav-number">9.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指针-vs-值"><span class="nav-number">9.1.</span> <span class="nav-text">指针 vs. 值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#接口与其它类型"><span class="nav-number">10.</span> <span class="nav-text">接口与其它类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#接口"><span class="nav-number">10.1.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-number">10.2.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口转换与类型断言"><span class="nav-number">10.3.</span> <span class="nav-text">接口转换与类型断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通用性"><span class="nav-number">10.4.</span> <span class="nav-text">通用性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口和方法"><span class="nav-number">10.5.</span> <span class="nav-text">接口和方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#空白标识符"><span class="nav-number">11.</span> <span class="nav-text">空白标识符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多重赋值中的空白标识符"><span class="nav-number">11.1.</span> <span class="nav-text">多重赋值中的空白标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未使用的导入和变量"><span class="nav-number">11.2.</span> <span class="nav-text">未使用的导入和变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为副作用而导入"><span class="nav-number">11.3.</span> <span class="nav-text">为副作用而导入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口检查"><span class="nav-number">11.4.</span> <span class="nav-text">接口检查</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内嵌"><span class="nav-number">12.</span> <span class="nav-text">内嵌</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发"><span class="nav-number">13.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#通过通信共享内存"><span class="nav-number">13.1.</span> <span class="nav-text">通过通信共享内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go程"><span class="nav-number">13.2.</span> <span class="nav-text">Go程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信道"><span class="nav-number">13.3.</span> <span class="nav-text">信道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信道中的信道"><span class="nav-number">13.4.</span> <span class="nav-text">信道中的信道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并行化"><span class="nav-number">13.5.</span> <span class="nav-text">并行化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可能泄露的缓冲区"><span class="nav-number">13.6.</span> <span class="nav-text">可能泄露的缓冲区</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误"><span class="nav-number">14.</span> <span class="nav-text">错误</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Panic"><span class="nav-number">14.1.</span> <span class="nav-text">Panic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#恢复"><span class="nav-number">14.2.</span> <span class="nav-text">恢复</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结语"><span class="nav-number">15.</span> <span class="nav-text">结语</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Char"
      src="http://cdn.xuebaonline.com/blog_avatar.JPG">
  <p class="site-author-name" itemprop="name">Char</p>
  <div class="site-description" itemprop="description">曾经沧海难为水，除却巫山不是云。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">176</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">143</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element">
    <a onclick="Chatra('openChat', true);"><i class="fa fa-comment"></i>
    联系我
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Bogon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Bogon" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhangqixcu@gmail.com" title="E-Mail → mailto:zhangqixcu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5640441479" title="新浪微博 → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5640441479" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/bogonbug" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;bogonbug" rel="noopener" target="_blank"><i class="fab fa-skype fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Bogon" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Bogon" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/4368897/qizhang" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;4368897&#x2F;qizhang" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      推荐阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://developer.apple.com/swift/" title="https:&#x2F;&#x2F;developer.apple.com&#x2F;swift&#x2F;" rel="noopener" target="_blank">Swift 5.4</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://developer.apple.com/documentation/objectivec" title="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;objectivec" rel="noopener" target="_blank">Objective-C</a>
        </li>
    </ul>
  </div>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- side ad -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-5714801576974230"
     data-ad-slot="8285216682"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备20011156号-1 </a>
      <img src="/images/beian.png" style="display: inline-block;"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41172402000135" rel="noopener" target="_blank">豫公网安备41172402000135号 </a>
  </div>

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Char</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">博客全站共1.5m字</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">23:04</span>
</div>

<!--
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5eacc50f0dcd8169" async="async"></script>
  </div>
-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>




  <script>
    (function(d, w, c) {
      w.ChatraID = 'PxGFNHLgjQ3C3Hmpo';
      var s = d.createElement('script');
      w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
      };
      s.async = true;
      s.src = 'https://call.chatra.io/chatra.js';
      if (d.head) d.head.appendChild(s);
    })(document, window, 'Chatra');
  </script>









  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'rfRdmQpsk2Crnz747tDDOu26-gzGzoHsz',
      appKey     : 'eyu1k9BeINgR5FuXzbc969UA',
      placeholder: "写出你的想法……",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>