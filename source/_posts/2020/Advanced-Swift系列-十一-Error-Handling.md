---
title: 'Advanced Swift系列(十一): Error Handling'
description: 'Advanced Swift系列(十一): Error Handling'
permalink: 'Advanced Swift系列(十一): Error Handling'
copyright: ture
date: 2020-05-08 19:27:02
keywords: iOS,Swift,Advanced Swift,Swift学习,Swift进阶,Protocols,协议编程,泛型,编程,多态,Collection Protocols,Error Handling
tags:
    - [iOS]
    - [Swift]
    - [Advanced Swift]
    - [Error Handling]
    - [Swift 5.0]
categories:
    - [iOS]
    - [Swift]
    - [Advanced Swift]
---

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为程序员，我们经常必须处理出现问题的地方：网络连接可能会断开，预期存在的文件可能不存在，依此类推。良好地处理故障是将好程序与坏程序区分开的无形因素之一，但是我们经常倾向于将错误处理视为从属任务，这是后来要添加的内容（随着最后期限的临近，这种情况通常会被削减）。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而且我们知道了：错误处理可能会很混乱，并且编写快乐路径的代码通常会更有趣。更为重要的是，编程语言提供了一种良好的错误处理体系结构，可以支持程序员执行此任务。我们认为这样的体系结构应该提供以下一些内容：

+ → **简洁** 。抛出错误的代码不应淹没幸福道路的代码。
+ → **传播** 。错误发生的地方不应该接受处理。通常，如果要从错误中恢复的逻辑与错误发生的地方相距甚远，通常会更好。错误处理体系结构应该使在调用堆栈中将错误传达到适当级别变得容易。优点是使中间函数（调用引发函数，但既不引发也不处理错误的函数）易于传递错误而又不需要进行大的语法更改。
+ → **文档** 。程序员可以轻松确定发生错误的位置以及可能发生的错误。
+ → **安全** 。程序员可以忽略意外错误。
+ → **通用性** 。指定可以进行错误抛出和处理的机制

<!-- more -->

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在所有情况下都可以使用。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们将在本章中看到的那样，`Swift`的本机错误处理体系结构具有`throw`，`try`和`catch`得分，满分为3.5分（满分为5分），它无法编码函数可以抛出的错误，并且不通用，因为它不适用于基于回调的异步`API`。相比之下，作为替代错误处理方法的`Result类型`确实缺少抛出功能，但在简明性，传播性和安全性方面却稍差一些（仅投掷函数需要尝试）。

# **错误类别**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;术语`“错误”`和`“故障”`可能意味着各种情况。让我们尝试提出一些`“可能出错的地方”`，通过我们通常在代码中的处理方式来区分它们：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**预期错误**是程序员期望（或应该期望）在正常操作期间发生的故障。其中包括网络问题（网络连接永远不会100％可靠），或者用户输入的字符串格式错误。我们可以通过失败原因的复杂性进一步细分预期的错误：

+ → **普通错误** 。某些操作完全符合预期的故障条件。例如，当您在字典中查找某个键时，该键要么存在（成功），要么不存在（失败）。在`Swift`中，我们倾向于从具有单个清晰且通常使用的`“未找到”`或`“无效输入”`错误条件的函数中返回可选值。返回丰富的错误值不会为调用者提供比可选值中已有的更多信息。\
\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假定失败原因对于调用者来说是显而易见的，则可选项在简洁性（部分原因在于可选项的语法糖），安全性（我们必须在使用它之前必须拆开值），文档（函数具有可选返回类型）方面表现良好），传播（可选的链接）和通用性（可选的选项无处不在）。

+ → **Richerrors** 。网络和文件系统操作是比“出了点问题”需要更多实质性错误信息的任务示例。在这种情况下，有很多不同的情况可能会失败，并且程序员会经常根据失败的类型做出不同的反应（例如，程序可能希望在超时时重试请求，但如果URL则向用户显示错误）不存在）。此类错误是本章的重点。\
\
尽管大多数可失败的标准库API返回的都是小错误（即可选错误），但Codable系统使用的错误丰富。编码和解码具有许多不同的错误条件，准确的错误信息对于客户找出错误原因非常有价值。编码和解码方法都带有抛出注释，以告知调用方为处理错误做准备。


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**意外错误**。程序员无法预期的情况发生了，这使得继续下去变得困难或不可能。这通常意味着程序员做出的假设（“这永远不可能发生”）被证明是错误的。标准库遵循此模式的示例包括访问具有越界索引的数组，创建一个上限小于下限的范围并除以零。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在`Swift`中处理意外错误的通常方法是让程序崩溃，因为继续执行未知程序状态将是不安全的。而且，这些情况被认为是应该在测试中发现的程序员错误-处理它们例如是不适当的。通过向用户显示错误。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在代码中，我们使用断言（即`assert`，`precondition`或`fatalError`）来验证我们的期望，并在假设不成立的情况下进行陷阱。我们在[***```“可选”```***]( "")一章中介绍了这些功能。断言是识别代码中的错误的好工具。如果使用得当，它们会在程序处于意想不到的状态时尽早向您显示。它们也是有用的文档工具：每个`assert`或`precondition`调用都使作者对程序状态的（通常是隐式的）假设对其他代码阅读者可见。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;断言永远不要用来表示预期的错误-这样做会使程序无法优雅地处理这些错误，因为程序无法从断言中恢复。相反，也应避免使用可选的或抛出函数来指出程序员错误的相反方法，因为与从源头上渗透到程序的其他层相比，从源头上抓住一个错误的假设会更好。
