---
title: 'Advanced Swift系列(一): Swift 简介'
description: 'Advanced Swift系列(一): Swift 简介'
permalink: 'Advanced Swift系列(一): Swift 简介'
copyright: ture
date: 2020-05-05 12:46:21
keywords: iOS,Swift,Advanced Swift,Swift学习, Swift进阶
tags:
    - [iOS]
    - [Swift]
    - [Advanced Swift]
categories:
    - [iOS]
    - [Swift]
    - [Advanced Swift]
---

# **简介**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Advanced Swift``` 是一本书的大胆标题，所以也许我们应该从它的意思开始。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们开始编写本书的第一版时， ```Swift``` 才刚满一岁。我们是在2.0版Beta发布之前这样做的-尽管只是暂时的，因为我们怀疑该语言在进入第二年后会继续发展。很少有语言（也许没有其他语言）被如此众多的开发人员如此迅速地采用。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这给人们留下了未解之谜。你如何编写“惯用”  ```Swift``` ？有正确的方法来做某些事情吗？标准库提供了一些线索，但是即使随着时间的推移，它也发生了变化，删除了一些约定并采用了其他约定。自从将近五年前 ```Swift``` 推出以来， ```Swift``` 取得了长足的发展，并且变得更加清晰。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于来自另一种语言的人， Swift 可以使他们喜欢他们所选择的语言。低级位扭曲看起来可能与C非常相似（并且可以与C一样性能），但是没有许多未定义的行为陷阱。  ```Rubyists``` 熟悉 ```map``` 或 ```lter``` 的轻量级 ```尾随闭包语法``` 。  ```Swift泛型``` 类似于 ```C++模板``` ，但是具有类型约束，以确保泛型函数在定义时（而不是在使用时）是正确的。高阶函数的灵活性和运算符重载意味着你​​可以编写与 ```Haskell``` 或 ```F＃``` 风格相似的代码。  ```@objc``` 和 ```dynamic``` 关键字允许你以与 ```Objective-C``` 相同的方式使用选择器和运行时动态性。


<!-- more -->



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到这些相似之处，很容易采用其他语言的习惯用法。恰当的例子： ```Objective-C``` 示例项目几乎可以机械地移植到 ```Swift``` 。  ```Java``` 或 ```C＃设计模式``` 以及大多数功能编程模式也是如此。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是随之而来的是沮丧。为什么我们不能将 协议扩展 与相关类型（如Java中的接口）一起使用？为什么数组不像我们期望的那样协变？为什么我们不能写 ```“ functor”``` ？有时答案是因为有关  ```Swift``` 的部分尚未实现。但是更常见的是，这是因为有一种类似 ```Swift``` 的方式来完成你想做的事情，或者是因为你认为 ```Swift``` 功能实际上与其他语言中的等效功能实际上并不完全一样。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Swift``` 是一种复杂的语言-大多数编程语言都是。但这很好地掩盖了这种复杂性。你可以在 ```Swift``` 中启动并运行开发应用程序，而无需了解 ```泛型``` 或 ```重载``` 或 ```静态``` 和 ```动态调度``` 之间的区别。你当然可以使用 ```Swift``` ，而无需调用 ```C库``` 或编写自己的集合类型，但是过了一会儿，我们认为你有必要了解
这些事情-是提高代码的性能，还是使其更优雅或更富表现力，或者仅仅是为了完成某些事情。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本书旨在进一步了解这些功能。我们打算回答许多“我该怎么做？”或“为什么Swift会那样表现？”我们在各种论坛上反复提出的问题。希望，一旦你阅读了我们的书，你将从了解语言的基础到了解许多高级功能以及对 ```Swift``` 的工作原理有更好的了解。熟悉所提供的材料可能是必要的，即使不够用，也要称自己为 ```高级Swift程序员``` 。

</br>

# **这本书是给谁的？**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本书面向有经验的（尽管不一定是专家） 程序员 ，例如现有的 ```Apple平台开发人员``` 。这也适用于那些来自其他语言（例如 ```Java``` 或 ```C++``` ）的人，他们希望将自己对 ```Swift``` 的知识提高到与“入门”语言相同的水平。此外，它适合刚开始使用 ```Swift``` 并熟悉基础知识并希望将其提升到新水平的新程序员。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这本书并不是要介绍 ```Swift``` 。假定你熟悉该语言的语法和结构。如果你希望对 ```Swift``` 的基础知识有一个很好的紧凑介绍，最好的资料是 ```Apple Swift官方``` 书（可在iBooks或Apple的网站上找到）。如果你已经是一名自信的程序员，则可以尝试同时阅读我们的书和Apple Swift书。
这也不是有关为macOS或iOS设备编程的书。当然，由于 ```Swift``` 在Apple平台上的开发用途很多，因此我们尝试提供一些实际使用的示例，但我们希望这本书对非Apple平台的程序员也有用。本书中的绝大多数示例在其他操作系统上应保持不变。那些根本不与Apple平台相关联的（因为它们使用iOS框架或依赖于Objective-C运行时），或者只需要很小的更改。从个人经验可以说， ```Swift``` 是编写运行在 ```Linux``` 上的服务器应用程序的绝佳语言，过去几年来，生态系统和社区不断发展，使之成为可行的选择。

</br>

# **主题**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本书的组织方式使每一章都涵盖一个特定的概念。关于一些基本的基本概念（例如，可选参数和字符串），有深入的章节，同时还深入探讨了诸如C互操作性之类的主题。但是在整本书中，希望有一些关于Swift的主题出现：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;***```Swift``` 桥接了多个抽象级别。***  ```Swift``` 是一种高级语言，它允许你使用 ```map``` 和 ```reduce``` 来编写与 ```Ruby``` 和 ```Python``` 类似的代码，并轻松编写自己的高阶函数。  ```Swift``` 还允许你编写快速代码，这些代码可以直接编译为本机二进制文件，其性能类似于用 ```C语言``` 编写的代码。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们兴奋的是，我们最欣赏的 ```Swift``` 方面是，你能够同时做这两项事情。将闭包表达式映射到数组上将编译为与循环访问连续内存块相同的汇编代码。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，要充分利用此功能，你需要了解一些事情。例如，对 ```结构``` 和 ```类``` 的差异有所了解，或者对 ```动态``` 和 ```静态方法``` 分配之间的区别有所了解，将使你受益（稍后我们将更深入地讨论诸如此类的主题）。而且，如果你需要降到较低的抽象层次并直接操作指针， ```Swift``` 也可以使你做到这一点。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ```Swift``` 是一种 ```多范式语言``` 。你可以使用它来使用不可变值编写面向对象的代码或纯函数代码，也可以使用指针算法编写类似 ```C``` 的 ```命令式代码``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这既是福也是祸。太好了，因为你有很多可用的工具，而且你不必被迫以一种方式编写代码。但这也使你面临用 ```Swift``` 编写 ```Java``` 或 ```C``` 或 ```Objective-C``` 的风险。
```Swift``` 仍然可以使用 ```Objective-C``` 的大多数功能，包括 ```消息发送``` ， ```运行时类型识别``` 和 ```键值观察``` 。但是 ```Swift``` 引入了许多在 ```Objective-C``` 中不可用的功能。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;著名的编程语言专家 ```Erik Meijer``` 在2015年10月发布了以下推文：
> 在这一点上，```@SwiftLang``` 可能是比 ```Haskell``` 更好，更有价值的学习 ```函数式编程``` 的工具。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Swift``` 通过使用 ```泛型``` ， ```协议``` ， ```值类型``` 和 ```闭包``` ，很好地介绍了一种更具功能性的编程风格。 甚至可以使用它来编写将 ```函数组合``` 在一起的 ```运算符``` 。 也就是说， ```Swift社区``` 中的大多数人似乎更喜欢命令式风格，同时融入了源于 ```函数式编程``` 的模式。  ```Swift``` 的 ```值类型``` ```可变性``` 概念及其 ```错误处理模型``` 是友好的命令式语法背后的语言“隐藏”功能概念的示例。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Swift``` 非常灵活。 在《关于Lisp的书》的简介中，Paul Graham写道：

> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经验丰富的 ```Lisp程序员``` 对程序进行了不同的划分。 除自上而下的设计外，它们还遵循可称为自下而上的设计的原则-更改语言以适应问题。 在 ```Lisp``` 中，你不仅要按照语言编写程序，还要按照程序编写语言。 在编写程序时，你可能会想“我希望Lisp拥有这样的运算符。” 所以你去写吧。 之后，你意识到使用 ```new运算符``` 将简化程序另一部分的设计，依此类推。 语言和程序一起发展。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Swift``` 与 ```Lisp``` 有很大的不同。但是，我们仍然感觉到 ```Swift``` 也具有鼓励“自下而上”编程的特征-简化编写非常通用的 可重用构建基块 ，然后将其组合成更大的功能，然后将其用于解决实际问题的特性。  ```Swift``` 特别擅长使这些构建基块看起来像原始语言，就像语言的一部分一样。这方面的一个很好的证明是，你可能认为许多基本功能（例如可选功能或基本运算符）的功能实际上是在库中定义的- ```Swift标准库``` -而不是直接在语言中定义。 尾随闭包 使你可以使用内置的功能扩展语言。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Swift``` 代码可以紧凑而简洁，同时仍然清晰。  ```Swift``` 使自己适合相对简洁的代码。这里有一个潜在的目标，那就是不能节省打字。这个想法是为了更快地解决问题，并通过删除很多
在其他语言中，你经常看到的“典范”样板模糊而不是澄清了代码的含义。
例如， ```类型推论``` 消除了从上下文显而易见的类型声明的混乱情况。没有什么价值的分号和括号都消失了。 ```泛型``` 和 ```协议扩展``` 鼓励你通过将常见操作打包到 ```可重用函数``` 中来避免重复。目的是一眼就能看懂代码。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，这可能会令人反感。如果你从未使用过 ```map``` ， ```maplter``` 和 ```reduce``` 之类的 ```函数``` ，那么它们可能比简单的 ```for循环难读``` 。但是我们希望这是一条短暂的学习曲线，而回报是代码，它可以带来更多
乍看之下“显然是正确的”。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Swift``` 会尝试尽可能实际地保持安全，直到你告知并非如此为止。这与 ```C``` 和 ```C++``` （你可能会因忘记做某事而很不安全）或 ```Haskell``` 或 ```Java``` （无论你是否喜欢它有时都是安全的）这样的语言不同。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```C＃``` 的主要设计师之一埃里克·利珀特（Eric Lippert）讲述了他对 ```C＃``` 的十个遗憾，包括以下课程：

> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，你需要实现仅适用于正在 ```构建基础架构``` 的专家的功能； 这些功能应清楚地标记为危险-不会与其他语言的功能相似。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;埃里克（Eric）特别是指 ```C＃``` 的 ```finalizers``` ，类似于 ```C++``` 的 ```析构函数``` 。 但是与 ```析构函数``` 不同的是，它们在 ```垃圾收集器``` 的要求下（并在 ```垃圾收集器``` 的线程上）在不确定的时间运行（也许永远不会）。 但是，被 ```引用计数的Swift``` 确实可以确定地 ```执行类的deinit``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Swift``` 以其他方式体现了这一观点。 默认情况下， **避免未定义和不安全的行为** 。 例如，变量必须在初始化之前才能使用，并且在 ```数组上``` 使用 ```越界下标``` 将被捕获，而不是继续使用可能的垃圾值。
当你确实需要它们时，可以使用许多“不安全”选项（例如 ```unsafeBitCast函数``` 或 ```UnsafeMutablePointer类型``` ）。 但是强大的力量带来了巨大的不确定行为。 例如，你可以编写以下内容：

``` Swift
var someArray = [1, 2, 3]
let uhOh = someArray.withUnsafeBufferPointer { ptr in
return ptr }
// Later...
print(uhOh[10])

```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它会编译，但是谁知道它会做什么。  ```ptr变量``` 仅在 ```闭包表达式``` 中有效，并且将其返回给调用者是非法的。但是，没有什么阻止你让它逃脱到野外。但是，你不能说没有人警告过你。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Swift``` 是一种自以为是的语言。作为作者，我们对编写 ```Swift``` 的“正确”方法有强烈的意见。你会在本书中看到许多这样的内容，有时甚至表示它们是事实。但它们只是我们的意见-随时可以不同意！ ```Swift``` 还是年轻的
语言，许多事情还没有解决。无论你正在阅读什么，最重要的事情就是亲自尝试一下，检查它们的行为，并决定你对它们的感觉。认真思考，并注意过时的信息。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```Swift``` 继续发展。年度语法大变动的时期已经过去，但是该语言的重要领域仍未完成（ ```字符串API``` ， ```泛型系统``` ）， ```不断变化（反射）``` 或 ```尚未解决（并发）``` 。

</br>

# **术语**

> 'When I use a word,’ Humpty Dumpty said, in rather a scornful tone, ‘it means just what I choose it to mean — neither more nor less.’\
— Through the Looking Glass, by Lewis Carroll

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序员经常抛出艺术术语。为 ```避免混淆``` ，以下是我们在本书中使用的一些术语定义。在可能的情况下，我们尝试遵守与官方文档相同的用法，有时甚至坚持 ```Swift社区``` 广泛采用的定义。这些定义中的许多定义将在后面的章节中更详细地介绍，因此请放心，如果不是所有事情都立即生效的话。如果你已经熟悉所有这些术语，那么最好还是先略过一遍，以确保你所接受的含义与我们的含义相同。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ```Swift``` 中，我们区分 ```值``` ， ```变量``` ， ```引用``` 和 ```常量``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```值``` 是永远不变的，永远不变。例如，1，true和[1,2,3]均为值。这些是文字的示例，但是值也可以在运行时生成。将数字5平方时得到的数字是一个值。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用 ```var x = [1,2]``` 为名称分配值时，我们将创建一个名为x的变量，其中包含值[1,2]。通过更改 ```x``` 通过执行 ```x.append（3）``` ，我们没有更改原始值。相反，我们将 ```x``` 所保存的值替换为新值[1,2,3]-至少在逻辑上，如果不在实际实现中（这实际上可能只是在一些现有内存的后面添加新条目）。我们称此为 ```变量变量``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以用 ```let``` 而不是 ```var声明常量变量（简称常量）``` 。一旦为常数分配了值，就永远不能为其分配新值。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们也不需要立即为 ```变量赋值``` 。我们可以先声明变量 ```（让x：Int ）```，然后再给它赋一个值 ```（x = 1）``` 。  ```Swift``` 强调 ```安全性``` ，将在读取变量值之前检查所有可能的代码路径是否导致为变量分配了值。没有一个变量具有尚未定义的值的概念。当然，如果变量用 ```let声明``` ，则只能赋给一次。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```结构``` 和 ```枚举``` 是 值类型 。当将一个结构变量分配给另一个时，两个变量将包含相同的值。你可以认为内容是被复制的，但是更准确地说，一个变量已更改为包含与另一个变量相同的值。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```引用``` 是一种特殊的值：它是一个 ```“指向”内存``` 中其他位置的值。因为两个引用可以引用相同的位置，所以这会导致存储在该位置的值立即被程序的两个不同部分 ```突变的可能性``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```类``` 是 ```引用类型``` 。你不能直接在 ```变量``` 中 ```保存类的实例``` （有时可能将其称为 ```对象``` ，这个术语充满了麻烦！）。相反，你必须在变量中保存对它的引用，然后通过该 ```引用``` 对其进行访问。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```引用类型``` 具有标识-你可以使用 ```===``` 检查两个变量是否引用了 ```完全相同的对象``` 。你也可以检查它们是否相等，假设为相关类型实现了 ```==``` 。具有不同身份的两个 ```对象仍然可以相等``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```值类型``` 没有身份。你无法检查 ```特定变量``` 是否与另一个 ```变量``` 具有“相同”的数字2。你只能检查它们是否都包含值2。 ```===``` 确实是在问：“这两个变量是否都具有与它们的值相同的引用？”在编程语言文献中， ```==``` 有时称为 ```结构相等``` ，而 ```===``` 有时又称为 ```指针相等``` 或 ```引用相等``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ```Swift``` 中， ```类引用``` 并不是唯一的一种引用。例如，还存在通过 ```UnsafeMutablePointer函数``` 等 ```访问的指针``` 。但是 ```类``` 是最简单的 ```引用类型``` ，部分原因是它们的类引用性质被语法糖部分地隐藏了，这意味着你不需要像使用其他语言的 ```指针``` 那样进行任何显式的 ```“解引用”``` 。 （我们将在“互操作性”一章中详细介绍其他类型的参考。）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用 ```let声明``` 保存引用的变量，即引用是 ```常量``` 。这意味着该变量 ```永远不能更改为引用其他内容``` 。但是-这很重要-并不意味着 ```它所指的对象不能更改``` 。因此，在将 ```变量称为常量``` 时，请小心-它 ```仅指向常量``` 。这并不意味着它指向的是  ```恒定的``` 。 （注意：如果最后几句话听起来像是双重说话，请不要担心，因为我们将在“结构和类”一章中再次介绍该内容。）不幸的是，这意味着当用 ```let查看变量``` 的声明时，你不能一眼就知道声明的内容是否完全不变。相反，你必须知道它是 ```值类型``` 还是 ```引用类型``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ```复制值类型``` 时，通常会执行 ```深度复制``` ，即，它包含的所有值也会 ```递归复制``` 。此副本可以急于发生（每当引入新变量时），也可能懒惰（每当变量被突变时）。执行 ```深拷贝的类型``` 被称为具有 ```值语义``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们遇到了另一个麻烦。如果 ```结构``` 包含 ```引用类型``` ，则将 ```结构``` 分配给新变量后， 不会自动复制引用的对象 。相反，仅 ```引用本身会被复制``` 。这些被称为 ```浅拷贝``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如， ```Foundation``` 中的 ```Data结构``` 是 ```存储实际字节``` 的类的 ```包装``` 。但是，只要 ```Data结构``` 发生突变， ```Data结构``` 的作者就会采取额外的步骤来执行 ```类实例``` 的 ```深层副本``` 。他们使用称为 ```写时复制``` 的技术有效地做到了这一点，我们将在 ```“结构和类”``` 一章中对此进行说明。目前，重要的是要知道这种 ```行为不是免费的``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```标准库``` 中的 ```集合``` 还包装了 ```引用类型``` ，并使用 ```写时复制``` 有效地提供了 ```值语义``` 。但是，如果集合中的元素是引用（例如，包含对象的数组），则不会复制对象。相反，仅引用被复制。这意味着Swift数组仅在其元素也具有值语义的情况下才具有值语义。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有些类是完全不可变的-也就是说，它们在创建后不提供更改其内部状态的方法。这意味着，即使它们是类，它们也具有值语义（因为即使它们是共享的，它们也永远不会改变）。但是要小心-只能保证最终类不会被添加了可变状态。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ```Swift``` 中， ```函数``` 也是值。你可以将 ```函数``` 分配给 ```变量``` ，具有 ```函数数组``` ，然后调用保留在变量中的函数。将其他函数作为 ```参数的函数``` （例如map，其使用对变换序列中每个元素的函数进行转换）或返回函数称为 ```高阶函数``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不必在顶层声明函数-你可以在另一个函数内或在 do 或其他范围内声明一个函数。在 外部作用域中 定义但从中传递出去的函数（例如，作为函数的返回值）可以“捕获”局部变量，在这种情况下，当局部作用域结束时，这些局部变量不会被破坏，并且该函数可以通过他们保持状态。此行为称为 ```closures``` 变量 ，执行此操作的函数称为 ```closures``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用 ```func关键字``` 或使用称为 ```闭包表达式``` 的速记 ```{}语法``` 来声明函数。有时将其简化为 ```“闭包”``` ，但不要让你给人以为只有闭包表达式才可以是 ```闭包``` 。使用 ```func关键字``` 声明的函数在作为 ```closures``` 外部变量时也属于 ```闭包``` 。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ```Functions``` 通过引用保留。这意味着将已捕获状态的函数分配给另一个变量不会复制该状态。它共享它，类似于 ```对象引用``` 。更重要的是，当两个闭包关闭同一个局部变量时，它们都共享该变量，因此它们共享状态。这可能非常令人惊讶，我们将在“功能”一章中对此进行更多讨论。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ```类``` 或 ```协议``` 内部定义的函数是方法，它们具有隐式的 ```self参数``` 。有时我们称函数为 ```非方法自由函数``` 。这是为了将它们与方法区分开。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ```Swift``` 中的标准函数名称不仅包括函数的基本名称（括号前的部分），还包括参数标签。例如，将集合索引移动许多步的方法的全名是 ```index（_：offsetBy :)``` ，指示此函数接受两个参数（由两个冒号表示），其中第一个没有标签（由下划线表示）。如果从上下文可以清楚地知道我们指的是什么功能，我们通常会省略书中的标签；编译器允许你执行相同操作。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ```自由函数``` 和在结构上调用的方法是 ```静态分派的``` 。这意味着将在编译时知道要调用的函数。这也意味着编译器可能能够 内联该函数 ，即根本不调用该函数，而是将其替换为该函数将执行的代码。 优化器 还可以 丢弃或简化 在编译时无法实际运行的代码。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ```类``` 或 ```协议``` 上的方法可能会 ```动态调度``` 。这意味着编译器不一定在编译时就知道哪个函数将运行。通过使用 ```vtables（类似于Java和C ++动态分配的工作方式）``` 或在某些 ```@objc类 ```和 ```协议``` 的情况下，通过使用 ```选择器``` 和 ```objc_msgSend``` 来完成此动态行为。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ```子类型化``` 和 ```方法重写``` 是获得 ```多态行为``` 的一种方法，
即根据所涉及的类型而变化的行为。第二种方法是 ```函数重载``` ，其中针对不同类型多次写入函数。 （重要的是不要混淆重写和重载，因为它们的行为截然不同。）第三种方式是通过 ```泛型``` ， ```泛型``` 是将 函数或方法编写一次 ，以采用任何提供某些函数或方法的类型，但是这些函数的实现可以变化。与方法重写不同， ```函数重载``` 和 ```泛型``` 的结果在编译时是 ```静态已知``` 的。我们将在“泛型”一章中对此进行详细介绍。

</br>

# **Swift风格指南**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编写本书以及为我们自己的项目编写 ```Swift代码``` 时，我们尝试遵循以下规则：
+ → 进行命名，在使用时进行清晰性是最重要的考虑因素。由于API的使用次数超过了声明的次数，因此，应针对API的名称进行优化，以确保它们在调用站点上的正常运行。熟悉《 Swift API设计指南》，并尝试在你自己的代码中遵守它们。
+ →Clarityisoft的简洁性可以帮助其实现，但简洁性不应成为其本身。
+ →始终向功能添加文档注释，尤其是通用名称。
+ →类型以UpperCaseLetters开头。函数，变量和枚举以lowerCaseLetters开头。
+ →使用类型推断。显式但显而易见的类型会影响可读性。
+ →不要在模棱两可的情况下使用类型推断，或者在定义合同时（
例如，这就是为什么func具有显式的返回类型）。
+ →默认值构造为实际上不包含类或功能的引用
语义。
+ →除非你已明确设计了MTBE可继承性，否则将其标记为“类”。如果要在内部使用继承，但不允许外部客户继承，则将类标记为public，但不要打开。
+ →使用尾随密封句法，除非紧接在另一开口括号之后。
+ →尽早使用保镖退出功能。
+ →Eschewforce展开并隐式展开可选的选项。有时
有用，但是经常需要它们通常是一个标志，这是错误的。
+ →不要自己重复。如果发现多次编写相同的代码片段，请将其提取到一个函数中。考虑将该功能作为协议扩展。
+ →收藏夹和过滤器。但是不要强制使用：在有意义时使用循环。高阶函数的目的是使代码更具可读性。当更简单的for循环更加清晰时，混淆地使用reduce会破坏此目的。
+ →Favorimmutable变量：默认为除非你知道你需要的突变。但是，在使代码更清晰或更高效时，请使用突变。再说一次，不要强迫：结构上的变异方法通常比返回全新的结构更惯用和有效。
+ + →Swift泛型（尤其是与协议约束组合）倾向于导致很长的函数签名。不幸的是，我们尚未找到将长函数声明分成多行的好方法。我们将尝试在示例代码中保持一致。
+ →离开自己。当你不进行编辑时。附件表示中存在自我。是一个明确的信号，表明自我正在被封闭所捕获。
+ →代替编写自由功能，写扩展名类型或协议（如果可以）。这有助于提高可读性和可发现性。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于本书中的代码示例的最后一点：为了节省空间并专注于要点，我们通常会省略使代码编译所需的 ```import``` 语句。如果你亲自尝试该代码，并且编译器告诉你它无法识别特定符号，请尝试添加 ```import Foundation``` 或 ```import UIKit``` 语句。




