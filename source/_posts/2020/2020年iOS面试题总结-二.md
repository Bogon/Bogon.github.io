---
title: 2020年iOS面试题总结(二)
description: 2020年iOS面试题总结(二)
permalink: 2020年iOS面试题总结(二)
copyright: ture
date: 2020-05-19 12:53:55
keywords: iOS,Swift,Swift Apprentice,Swift学习,Swift进阶,Protocols,协议编程,泛型,编程,多态,Collection Types,Arrays,Dictionaries,Sets,使用闭包集合迭代,Strings,构建自己的类型,Structures,结构体,Methods,Classes,Advanced Classes,面试题
tags:
    - [iOS]
    - [Swift]
    - [iOS面试题]
categories:
    - [iOS]
    - [Swift]
    - [iOS面试题]
---

# Runtime

## [什么是Runtime](https://www.jianshu.com/p/218a0666c896 "")

+ `runtime`是由`C`和`C++`、汇编实现的一套`API`，为`OC语言`加入了面向对象、运行时的功能

+ 运行时（`runtime`）将数据类型的确定由编译时推迟到了运行时

+ 平时编写的`OC`代码，在程序运行过程中，最终会转换成`runtime`的C语言代码——`runtime`是`Objective-C` 的幕后作者

如类结构中的`ro`和`rw`属性

+ `ro`（`read-only`）在编译时已经确定

+ `rw`（`read-write`）在运行时才确定，因此可以使用`runtime`进行修改


<!-- more -->

## [方法的本质是什么](https://www.jianshu.com/p/209ae13594d6 "")

方法的本质是发送消息`objc_msgSend`，即寻找`IMP`的过程

发送消息会有以下⼏个流程：

+ **快速查找流程** —— 通过汇编`objc_msgSend`查找缓存`cache_t`是否有`imp`实现

+ **慢速查找流程** —— 通过`C++`中`lookUpImpOrForward`递归查找**当前类和父类**的`rw`中`methodlist`的方法

+ **动态方法解析** —— 通过调用`resolveInstanceMethod`和`resolveClassMethod`来动态方法决议——实现消息动态处理

+ **快速转发流程** —— 通过`CoreFoundation`来触发消息转发流程，`forwardingTargetForSelector`实现快速转发，由其他对象来实现处理方法

+ **慢速转发流程** —— 先调用`methodSignatureForSelector`获取到方法的签名，生成对应的`invocation`；再通过`forwardInvocation`来进行处理

+ 以上流程均无法挽救就崩溃并报错

## [SEL和IMP的关系](https://www.jianshu.com/p/2e35c35dbed7 "")

`SEL`是方法编号，也是方法名，在`dyld加载镜像`到内存时，通过`_read_image方法`加载到内存的表中了

`IMP`是函数实现指针，找`IMP`就是找函数实现的过程

`SEL`和`IMP`的关系就可以解释为：

+ `SEL`就相当于书本的⽬录标题
+ `IMP`就是书本的⻚码
+ `函数`就是具体页码对应的内容

## [能否向运时创建的类中添加实例变量](https://www.jianshu.com/p/ac9e16fade79 "")

具体情况具体分析：

+ 编译好的类不能添加实例变量
+ 运行时创建的类可以添加实例变量，但若已注册到内存中就不行了

原因：

+ 编译好的实例变量存储的位置在ro，而ro是在编译时就已经确定了的
+ 编译完成，内存结构就完全确定就法修改
+ 只能修改rw中的方法或者可以通过关联对象的方式来添加属性

## [Category：从底层原理研究到面试题分析](https://juejin.im/post/5c0332ba6fb9a049d4418cac "")

## [利用runtime-API创建对象](https://www.jianshu.com/p/039a614f8791 "")

### API介绍

#### 动态创建类

``` objc
/**
 *创建类
 *
 *superClass: 父类，传Nil会创建一个新的根类
 *name: 类名
 *extraBytes: 额外的内存空间，一般传0
 *return:返回新类，创建失败返回Nil，如果类名已经存在，则创建失败
 */
Class FXPerson = objc_allocateClassPair([NSObject class], "LGPerson", 0);
```

#### 添加成员变量

``` objc
/**
*添加成员变量
*这个函数只能在objc_allocateClassPair和objc_registerClassPair之前调用。不支持向现有类添加一个实例变量
*这个类不能是元类，不支持在元类中添加一个实例变量
*实例变量的最小对齐为1 << align，实例变量的最小对齐依赖于ivar的类型和机器架构。对于任何指针类型的变量，请通过log2(sizeof(pointer_type))
*
*cls 往哪个类添加
*name 添加的名字
*size 大小
*alignment 对齐处理方式
*types 签名
*/
class_addIvar(FXPerson, "fxName", sizeof(NSString *), log2(sizeof(NSString *)), "@");
```

#### 注册到内存

``` objc
/**
 *往内存注册类
 *
 * cls 要注册的类
 */
 objc_registerClassPair(FXPerson);
```

#### 添加属性变量

``` objc
/**
*往类里面添加属性
*
*cls 要添加属性的类
*name 属性名字
*attributes 属性的属性数组。
*attriCount 属性中属性的数量。
*/
class_addProperty(targetClass, propertyName, attrs, 4);
```

#### 添加方法

``` objc
/**
 *往类里面添加方法
 *
 *cls 要添加方法的类
 *sel 方法编号
 *imp 函数实现指针
 *types 签名
 */
class_addMethod(FXPerson, @selector(setHobby), (IMP)fxSetter, "v@:@");
```

### 整体使用

``` objc
// hobby的setter-IMP
void fxSetter(NSString *value) {
    printf("%s/n",__func__);
}

// hobby的getter-IMP
NSString *fxHobby() {
    return @"iOS";
}

// 添加属性变量的封装方法
void fx_class_addProperty(Class targetClass, const char *propertyName) {
    objc_property_attribute_t type = { "T", [[NSString stringWithFormat:@"@\"%@\"",NSStringFromClass([NSString class])] UTF8String] }; //type
    objc_property_attribute_t ownership0 = { "C", "" }; // C = copy
    objc_property_attribute_t ownership = { "N", "" }; //N = nonatomic
    objc_property_attribute_t backingivar  = { "V", [NSString stringWithFormat:@"_%@",[NSString stringWithCString:propertyName encoding:NSUTF8StringEncoding]].UTF8String };  //variable name
    objc_property_attribute_t attrs[] = {type, ownership0, ownership, backingivar};
    class_addProperty(targetClass, propertyName, attrs, 4);
}

// 打印属性变量的封装方法
void fx_printerProperty(Class targetClass){
    unsigned int outCount, i;
    objc_property_t *properties = class_copyPropertyList(targetClass, &outCount);
    for (i = 0; i < outCount; i++) {
        objc_property_t property = properties[i];
        fprintf(stdout, "%s %s\n", property_getName(property), property_getAttributes(property));
    }
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // 动态创建类
        Class FXPerson = objc_allocateClassPair([NSObject class], "FXPerson", 0);
        // 添加成员变量
        class_addIvar(FXPerson, "name", sizeof(NSString *), log2(sizeof(NSString *)), "@");
        // 注册到内存
        objc_registerClassPair(FXPerson);
        // 添加属性变量
        fx_class_addProperty(FXPerson, "hobby");
        fx_printerProperty(FXPerson);
        // 添加方法（为属性方法添加setter、getter方法）
        class_addMethod(FXPerson, @selector(setHobby:), (IMP)fxSetter, "v@:@");
        class_addMethod(FXPerson, @selector(hobby), (IMP)fxHobby, "@@:");

        // 开始使用
        id person = [FXPerson alloc];
        [person setValue:@"Felix" forKey:@"name"];
        NSLog(@"FXPerson的名字是：%@ 爱好是：%@", [person valueForKey:@"name"], [person valueForKey:@"hobby"]);
    }
    return 0;
}
```

### 注意事项

+ 记得导入`<objc/runtime.h>`
+ 添加成员变量`class_addIvar`必须在`objc_registerClassPair`前，因为注册到内存时`ro`已经确定了，不能再往`ivars`添加（同第四个面试题）
+ 添加属性变量`class_addProperty`可以在注册内存前后，因为是往`rw`中添加的
+ `class_addProperty`中“属性的属性”——`nonatomic/copy`是根据属性的类型变化而变化的
+ `class_addProperty`不会自动生成`setter`和`getter`方法，因此直接调用`KVC`会崩溃

不只可以通过`KVC`打印来检验，也可以下断点查看`ro、rw`的结构来检验

## [关联对象分析](https://www.jianshu.com/p/882e5f93938e "")

>实则是为了解决分类创建属性的问题

### 分类直接添加属性的后果

+ 编译会出现警告：没有setter方法和getter方法
+ 运行会报错：-[FXPerson setName:]: unrecognized selector sent to instance 0x100f61180'

### 为什么不能直接添加属性

`Category`在`runtime`中是用一个结构体表示的：

``` objc
struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties;
    ...
};
```
里面虽然可以添加属性变量，但是这些`properties`并不会自动生成`Ivar`，也就是不会有 `@synthesize`的作用，`dyld`加载期间，这些分类会被加载并`patch`到相应的类中。这是一个动态过程，`Ivar`不能动态添加.

### 解决方案

手动实现setter、getter方法，关联对象

``` objc

- (void)setName:(NSString *)name {
    /**
    参数一：id object : 给哪个对象添加属性，这里要给自己添加属性，用self。
    参数二：void * == id key : 属性名，根据key获取关联对象的属性的值，在objc_getAssociatedObject中通过次key获得属性的值并返回。
    参数三：id value : 关联的值，也就是set方法传入的值给属性去保存。
    参数四：objc_AssociationPolicy policy : 策略，属性以什么形式保存。
    */
    objc_setAssociatedObject(self, @"name", name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (NSString *)name {
    /**
    参数一：id object : 获取哪个对象里面的关联的属性。
    参数二：void * == id key : 什么属性，与objc_setAssociatedObject中的key相对应，即通过key值取出value。
    */
    return objc_getAssociatedObject(self, @"name");
}
```

### 关联对象原理

#### setter方法——`objc_setAssociatedObject`分析

苹果设计接口时往往会加个中间层——即使底层实现逻辑发生变化也不会影响到对外接口

``` objc
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) {
    _object_set_associative_reference(object, (void *)key, value, policy);
}
```

跟进去看看`_object_set_associative_reference`实现

``` objc
void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    // This code used to work when nil was passed for object and key. Some code
    // probably relies on that to not crash. Check and handle it explicitly.
    // rdar://problem/44094390
    if (!object && !value) return;

    assert(object);

    if (object->getIsa()->forbidsAssociatedObjects())
        _objc_fatal("objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects", object, object_getClassName(object));

    // retain the new value (if any) outside the lock.
    // 在锁之外保留新值（如果有）。
    ObjcAssociation old_association(0, nil);
    // acquireValue会对retain和copy进行操作，
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        // 关联对象的管理类
        AssociationsManager manager;
        // 获取关联的 HashMap -> 存储当前关联对象
        AssociationsHashMap &associations(manager.associations());
        // 对当前的对象的地址做按位去反操作 - 就是 HashMap 的key (哈希函数)
        disguised_ptr_t disguised_object = DISGUISE(object);
        if (new_value) {
            // break any existing association.
            // 获取 AssociationsHashMap 的迭代器 - (对象的) 进行遍历
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i != associations.end()) {
                // secondary table exists
                ObjectAssociationMap *refs = i->second;
                // 根据key去获取关联属性的迭代器
                ObjectAssociationMap::iterator j = refs->find(key);
                if (j != refs->end()) {
                    old_association = j->second;
                    // 替换设置新值
                    j->second = ObjcAssociation(policy, new_value);
                } else {
                    // 到最后了 - 直接设置新值
                    (*refs)[key] = ObjcAssociation(policy, new_value);
                }
            } else {
                // create the new association (first time).
                // 如果AssociationsHashMap从没有对象的关联信息表，
                // 那么就创建一个map并通过传入的key把value存进去
                ObjectAssociationMap *refs = new ObjectAssociationMap;
                associations[disguised_object] = refs;
                (*refs)[key] = ObjcAssociation(policy, new_value);
                object->setHasAssociatedObjects();
            }
        } else {
            // setting the association to nil breaks the association.
            // 如果传入的value是nil，并且之前使用相同的key存储过关联对象，
            // 那么就把这个关联的value移除（这也是为什么传入nil对象能够把对象的关联value移除）
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i !=  associations.end()) {
                ObjectAssociationMap *refs = i->second;
                ObjectAssociationMap::iterator j = refs->find(key);
                if (j != refs->end()) {
                    old_association = j->second;
                    refs->erase(j);
                }
            }
        }
    }
    // release the old value (outside of the lock).
    // 最后把之前使用传入的这个key存储的关联的value释放（OBJC_ASSOCIATION_SETTER_RETAIN策略存储的）
    if (old_association.hasValue()) ReleaseValue()(old_association);
}
```

+ `ObjcAssociation old_association(0, nil)`处理传进来的值得到`new_value`

+ 获取到管理所有关联对象的hashmap总表的管理者`AssociationsManager`，然后拿到`hashmap`总表`AssociationsHashMap`
+ `DISGUISE(object)`对关联对象的地址进行取反操作得到哈希表对应的下标`index`
+ 如果`new_value`为空（即对属性赋值为`nil`）就直接找到相应的表进行删除
+ 如果`new_value`不为空，就拿到总表的迭代器通过拿到的下标`index`进行遍历查找；如果找到管理对象的关联属性哈希`map`表，然后再通过`key`去遍历取值
    - 如果取到了，就先把新值设置到`key`上，再将旧值释放掉
    - 如果没取到，就直接将新值设置在`key`上


#### getter方法——`objc_getAssociatedObject`分析

``` objc
id objc_getAssociatedObject(id object, const void *key) {
    return _object_get_associative_reference(object, (void *)key);
}
```

``` objc
id _object_get_associative_reference(id object, void *key) {
    id value = nil;
    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;
    {
        // 关联对象的管理类
        AssociationsManager manager;
        AssociationsHashMap &associations(manager.associations());
        // 生成伪装地址。处理参数 object 地址
        disguised_ptr_t disguised_object = DISGUISE(object);
        // 所有对象的额迭代器
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            ObjectAssociationMap *refs = i->second;
            // 内部对象的迭代器
            ObjectAssociationMap::iterator j = refs->find(key);
            if (j != refs->end()) {
                // 找到 - 把值和策略读取出来
                ObjcAssociation &entry = j->second;
                value = entry.value();
                policy = entry.policy();
                // OBJC_ASSOCIATION_GETTER_RETAIN - 就会持有一下
                if (policy & OBJC_ASSOCIATION_GETTER_RETAIN) {
                    objc_retain(value);
                }
            }
        }
    }
    if (value && (policy & OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {
        objc_autorelease(value);
    }
    return value;
}
```

## [weak置空原理](https://www.jianshu.com/p/f4938b1454a9 "")

在weak一行打下断点运行项目

``` objc
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        FXPerson *person = [[FXPerson alloc] init];
        id __weak person = object;
    }
    return 0;
}
```

`Xcode`菜单栏`Debug->Debug Workflow->Always show Disassembly`打上勾查看汇编——汇编代码会来到`libobjc`库的`objc_initWeak`

![app weak置空原理](https://cdn.xuebaonline.com/2020-ms2-stp1.png "")

### weak创建过程

**``objc_initWeak``**

+ `location`：表示`__weak`指针的地址（我们研究的就是`__weak`指针指向的内容怎么置为`nil`）

+ `newObj`：所引用的对象，即例子中的`person`

``` objc
id objc_initWeak(id *location, id newObj)
{
    if (!newObj) {
        *location = nil;
        return nil;
    }

    return storeWeak<DontHaveOld, DoHaveNew, DoCrashIfDeallocating>
        (location, (objc_object*)newObj);
}
```

## [method swizzing坑点](https://www.jianshu.com/p/4e834b209e95 "")

# Runloop

+ [`Runloop`和线程是什么关系？](https://www.jianshu.com/p/dc5f49ad3890 "")
    - 每条线程都有唯一的一个与之对应的RunLoop对象，其关系是保存在一个全局的 Dictionary 里；主线程的RunLoop已经自动创建，子线程的RunLoop需要主动创建；RunLoop在第一次获取时创建，在线程结束时销毁

+ [`Runloop`的`mode`作用是什么？](https://www.jianshu.com/p/1e03b2d354c9 "")
    - 指定事件在运行循环中的优先级的，线程的运行需要不同的模式，去响应各种不同的事件，去处理不同情境模式。(比如可以优化tableview的时候可以设置UITrackingRunLoopMode下不进行一些操作，比如设置图片等。)

+ [以`+scheduledTimerWithTimeInterval:`的方式触发的`timer`，在滑动页面上的列表时，`timer`会暂停回调， 为什么？](https://www.jianshu.com/p/8248c7f9f07c "")
    - 滑动`scrollView`时，主线程的`RunLoop`会切换到`UITrackingRunLoopMode`这个`Mode`，执行的也是`UITrackingRunLoopMode`下的任务（`Mode`中的`item`），而`timer`是添加在`NSDefaultRunLoopMode`下的，所以`timer`任务并不会执行，只有当`UITrackingRunLoopMode`的任务执行完毕，`runloop`切换到`NSDefaultRunLoopMode`后，才会继续执行`timer`。

+ [如何解决在滑动页面上的列表时，`timer`会暂停回调？](https://www.jianshu.com/p/d4128ce72bc9 "")
    - 将`Timer`放到`NSRunLoopCommonModes`中执行即可
        - [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];

        - [[NSRunLoop currentRunLoop] run];

+ [`NSTimer`使用时需要注意什么？](https://www.jianshu.com/p/dbd00b18e3ec "")
    - 注意timer添加到runloop时应该设置为什么mode
    - 注意timer在不需要时，一定要调用invalidate方法使定时器失效，否则得不到释放

+ [`RunLoop` 有哪些应用？]( "")
    - 常驻内存、`AutoreleasePool` 自动释放池

+ [`AutoreleasePool` 和 `RunLoop` 有什么联系？](https://www.jianshu.com/p/a5737956fe5e "")
    >iOS应用启动后会注册两个 Observer 管理和维护 AutoreleasePool。应用程序刚刚启动时默认注册了很多个Observer，其中有两个Observer的 callout 都是 _ wrapRunLoopWithAutoreleasePoolHandler，这两个是和自动释放池相关的两个监听。

    - 第一个 Observer 会监听 RunLoop 的进入，它会回调objc_autoreleasePoolPush() 向当前的 AutoreleasePoolPage 增加一个哨兵对象标志创建自动释放池。这个 Observer 的 order 是 -2147483647 优先级最高，确保发生在所有回调操作之前。

    - 第二个 Observer 会监听 RunLoop 的进入休眠和即将退出 RunLoop 两种状态，在即将进入休眠时会调用 objc_autoreleasePoolPop() 和 objc_autoreleasePoolPush() 根据情况从最新加入的对象一直往前清理直到遇到哨兵对象。而在即将退出 RunLoop 时会调用objc_autoreleasePoolPop() 释放自动自动释放池内对象。这个Observer 的 order 是 2147483647 ，优先级最低，确保发生在所有回调操作之后。


+ [`NSRunLoop` 和 `CFRunLoopRef `区别](https://www.jianshu.com/p/ed641677d6c3 "")
    - `CFRunLoopRef` 基于`C` 线程安全，`NSRunLoop `基于 `CFRunLoopRef` 面向对象的`API` 是不安全的


# Block

+ [`block`对对象变量的捕获](https://www.jianshu.com/p/5da03eba9372 "")

+ [`__main_block_copy_0` 和 `__main_block_dispose_0`](https://www.jianshu.com/p/a30789af0ee8 "")

+ [`block`内修改变量的值](https://www.jianshu.com/p/cc2ad5776e6d "")

+ [为什么要通过`__forwarding`获取`age`变量的值？](https://www.jianshu.com/p/fae3e3b43cf9 "")

+ [`__block`修饰对象类型](https://www.jianshu.com/p/ba4594890c0f "")

+ [`__block`内存管理](https://www.jianshu.com/p/cd3fd72b598c "")

+ [`__forwarding`指针](https://www.jianshu.com/p/f59516a5d22a "")

+ [被`__block`修饰的对象类型的内存管理](https://www.jianshu.com/p/de7d383f1c09 "")

+ [循环引用](https://www.jianshu.com/p/a1fbe115ea35 "")

+ [解决循环引用问题 - `ARC`](https://www.jianshu.com/p/79b6413ebd90 "")

+ [解决循环引用问题 - `MRC`](https://www.jianshu.com/p/43cc276096dc "")

# 多线程

+ [iOS 多线程 线程安全 线程间通信](https://www.jianshu.com/p/fc69da0dce7a "")

+ [面试题1](https://www.jianshu.com/p/fa2bf272fd25 "")
    
+ [面试题2](https://www.jianshu.com/p/328b612682d7 "")
    
+ [面试题3](https://www.jianshu.com/p/c7894f14ce1a "")
    
+ [面试题4](https://www.jianshu.com/p/fbcff31aadbd "")
    
+ [面试题5](https://www.jianshu.com/p/fad08588f174 "")
    
+ [面试题6](https://www.jianshu.com/p/eb470c9bf120 "")
    
+ [面试题7](https://www.jianshu.com/p/9f77a158e4ad "")

# 内存管理

+ [内存管理是什么？](https://www.jianshu.com/p/43a02ba53212 "")
    
+ [内存管理的三种方法？](https://www.jianshu.com/p/2abc68b88996 "")
    
+ [MRC是什么？管理原则是什么？存在的问题？](https://www.jianshu.com/p/95ee461538a7 "")
    
+ [ARC是什么？存在的问题？](https://www.jianshu.com/p/2905c9923c12 "")
    
+ [内存池是什么？](https://www.jianshu.com/p/a01b231974d0 "")
    
+ [三种方法的优缺点？](https://www.jianshu.com/p/a1ed000e9be2 "")

# 计算机系统题

+ [了解编译的过程么？分为哪几个步骤？](https://www.jianshu.com/p/f9d515ca0b60 "")

+ [静态链接了解么？静态库和动态库的区别？](https://www.jianshu.com/p/b2b94586e3c3 "")

+ [内存的几大区域，各自的职能分别是什么？](https://www.jianshu.com/p/037551599b10 "")

+ [static和const有什么区别？](https://www.jianshu.com/p/e59f0c77a505 "")

+ [了解内联函数么？](https://www.jianshu.com/p/bb9bd11c3d6d "")

+ [什么时候会出现死锁？如何避免？](https://www.jianshu.com/p/35a0979cd823 "")

+ [说一说你对线程安全的理解？](https://www.jianshu.com/p/d0941ee7ad42 "")

+ [列举你知道的线程同步策略？](https://www.jianshu.com/p/0fdf376f6cd4 "")

+ [有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说](https://www.jianshu.com/p/925f0e371b90 "")

# 数据结构&算法题

+ [链表和数组的区别是什么？插入和查询的时间复杂度分别是多少？](https://www.jianshu.com/p/0297c7be21dd "")
    
+ [哈希表是如何实现的？如何解决地址冲突？](https://www.jianshu.com/p/f597d181d5dd "")
    
+ [排序题：冒泡排序，选择排序，插入排序，快速排序（二路，三路）能写出那些？](https://www.jianshu.com/p/2f267dd9637f "")
    
+ [链表题：如何检测链表中是否有环？如何删除链表中等于某个值的所有节点？](https://www.jianshu.com/p/626cd4a23b17 "")
    
+ [数组题：如何在有序数组中找出和等于给定值的两个元素？如何合并两个有序的数组之后保持有序？](https://www.jianshu.com/p/4dda1d0f1901 "")
    
+ [二叉树题：如何反转二叉树？如何验证两个二叉树是完全相等的？](https://www.jianshu.com/p/31d98bdf1c2c "")

# 性能优化

+ [优化你是从哪几方面着手？](https://www.jianshu.com/p/25c8505c486e "")
    
+ [列表卡顿的原因可能有哪些？你平时是怎么优化的？](https://www.jianshu.com/p/1771792981c3 "")
    
+ [遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？](https://www.jianshu.com/p/29981bab5eb9 "")

# 设计模式

+ [如何设计一个时长统计框架？](https://www.jianshu.com/p/e4f5cecd600d "")
    
+ [如何设计一个图片缓存框架？](https://www.jianshu.com/p/340530f6bb58 "")
    
+ [编程中的六大设计原则？](https://juejin.im/post/5a52144d6fb9a01c9b65c651 "")

# 核心动画

+ [iOS核心动画高级技巧 - 1](http://www.cocoachina.com/articles/455500 "")
    
+ [iOS核心动画高级技巧 - 2](http://www.cocoachina.com/articles/464391 "")
    
+ [iOS核心动画高级技巧 - 3](http://www.cocoachina.com/articles/464421 "")
    
+ [iOS核心动画高级技巧 - 4](http://www.cocoachina.com/articles/485309 "")
    
+ [iOS核心动画高级技巧 - 5](http://www.cocoachina.com/articles/485757 "")
    
+ [iOS核心动画高级技巧 - 6](http://www.cocoachina.com/articles/490705 "")
    
+ [iOS核心动画高级技巧 - 7](http://www.cocoachina.com/articles/491987 "")
    
+ [iOS核心动画高级技巧 - 8](https://www.cnblogs.com/Julday/p/12083669.html "")
    
+ [用UIKit和UIView在视图上执行iOS动画](https://www.cnblogs.com/Julday/p/12566829.html "")


# SWIFT

+ [探讨SWIFT 5.2的新功能特性](https://juejin.im/post/5e687fcbe51d4527286482e2 "")
    
+ [SWIFT 5.1中的小而重大的改进](https://zhuanlan.zhihu.com/p/84148065 "")
    
+ [Swift的排序算法](https://zhuanlan.zhihu.com/p/82183279 "")
    
+ [在Swift中选择正确的数据结构](https://zhuanlan.zhihu.com/p/81177334 "")

# Flutter

+ [让阿里告诉你， iOS开发者为什么要学 Flutter ！](https://zhuanlan.zhihu.com/p/128550457 "")


# iOS 面试题

+ [2018 iOS面试题-----UI相关：事件传递，图像显示，性能优化，离屏渲染](https://www.jianshu.com/p/bdbf6e52aab3 "")
    
+ [2018 iOS面试题-----Objective_C语言特性相关问题](https://www.jianshu.com/p/b5491c0833c5 "")
    
+ [2018 iOS面试题-----runtime相关](https://www.jianshu.com/p/d54df3950966 "")
    
+ [2018 iOS面试题-----算法相关](https://www.jianshu.com/p/f5ca580a05e0 "")
    
+ [2019 iOS面试题-----内存管理、自动释放池与循环引用](https://www.jianshu.com/p/93107e0d2728 "")
    
+ [2019 iOS面试题-----Block原理、Block变量截获、Block的三种形式](https://www.jianshu.com/p/f539c017b0c8 "")
    
+ [2019 iOS面试题-----进程、线程、多进程、多线程、任务、队列、NSThread、GCD、NSOprationQueue...](https://www.jianshu.com/p/e6b6be4e49c1 "")
    
+ [2019 iOS面试题-----多线程相关之GCD、死锁、dispatch_barrier_async、dispatch_group_async、Dispatch Semaphore](https://www.jianshu.com/p/072953b811ab "")
    
+ [2019 iOS面试题-----多线程相关之NSOperation、NSOperationQueue、NSThread+runloop实现常驻线程、加锁](https://www.jianshu.com/p/c6141c5d35fb "")
    
+ [2019 iOS面试题-----RunLoop数据结构、RunLoop的实现机制、RunLoop的Mode、RunLoop与NSTimer和线程](https://www.jianshu.com/p/6ac19d86079e "")
    
+ [2019 iOS面试题-----网络相关之HTTP协议](https://www.jianshu.com/p/05010113a1d3 "")
    
+ [2019 iOS面试题-----网络相关之HTTPS、对称加密、非对称加密](https://www.jianshu.com/p/d39f56a928b7 "")
    
+ [2019 iOS面试题-----一个基于UDP的简单的聊天Demo（用C语言、python、GCDAsyncUdpSocket来实现UDP通信）](https://www.jianshu.com/p/b0e93885f937 "")
    
+ [2019 iOS面试题-----网络相关之UDP的特点、UDP的报文结构及差错检测](https://www.jianshu.com/p/38d2698bc642 "")
    
+ [2019 iOS面试题-----网络相关之TCP、三次握手、四次挥手](https://www.jianshu.com/p/94963692436e "")
    
+ [2019 iOS面试题-----网络相关之TCP进阶：可靠数据传输、流量控制(滑动窗口)、拥塞控制](https://www.jianshu.com/p/644c92dd84f8 "")
    
+ [2019 iOS面试题-----网络相关之DNS](https://www.jianshu.com/p/4daf0e2e54b3 "")
    
+ [2019 iOS面试题-----网络相关之Cookie和Session](https://www.jianshu.com/p/b889e039221d "")
    
+ [2019 iOS面试题-----网络相关之IP协议、IP数据报分片、IPv4编址、网络地址转换（NAT）](https://www.jianshu.com/p/62f1e3517642 "")
    
+ [2019 iOS面试题-----网络相关之IPv6、从IPv4到IPv6的迁移](https://www.jianshu.com/p/7e9d1cbd064f "")

# 算法

+ [七种常见的数组排序算法整理(C语言版本)](https://www.jianshu.com/p/a202a7184e4a "")
    
+ [2019 算法面试相关(leetcode)--数组和链表](https://www.jianshu.com/p/d675288f0b81 "")
    
+ [2019 算法面试相关(leetcode)--字符串](https://www.jianshu.com/p/3d07e9a91430 "")
    
+ [2019 算法面试相关(leetcode)--栈和队列](https://www.jianshu.com/p/e231c0d3c05e "")
    
+ [2019 算法面试相关(leetcode)--优先队列](https://www.jianshu.com/p/1bedaee726da "")
    
+ [2019 算法面试相关(leetcode)--哈希表](https://www.jianshu.com/p/d3a48852d5e3 "")
    
+ [2019 算法面试相关(leetcode)--树、二叉树、二叉搜索树](https://www.jianshu.com/p/47e632985f11 "")
    
+ [2019 算法面试相关(leetcode)--递归与分治](https://www.jianshu.com/p/c998bb6bdffe "")
    
+ [2019 算法面试相关(leetcode)--贪心算法](https://www.jianshu.com/p/1e1a9a81bbc0 "")
    
+ [2019 算法面试相关(leetcode)--动态规划(Dynamic Programming)](https://www.jianshu.com/p/af880bbba792 "")
    
+ [2019 算法面试相关(leetcode)--动态规划之背包问题](https://www.jianshu.com/p/d9a0624c05e7 "")



# main 函数之前做了什么

+ [iOS 程序 main 函数之前发生了什么](https://blog.sunnyxx.com/2014/08/30/objc-pre-main/ "")

+ [iOS 面试题·main () 之前的过程有哪些?](https://ioscaff.com/articles/191/what-are-the-processes-before-the-03-ios-interview-question-main "")

+ [深入理解iOS App的启动过程](https://www.tuicool.com/articles/RBBZjeU "")

+ [深入剖析WebSocket的原理](https://zhuanlan.zhihu.com/p/32845970 "")

# APP优化

+ [性能优化之安装包瘦身(App Thinning)](https://www.jianshu.com/p/39fd51f447ba "")

