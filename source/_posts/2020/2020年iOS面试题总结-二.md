---
title: 2020年iOS面试题总结(二)
description: 2020年iOS面试题总结(二)
permalink: 2020年iOS面试题总结(二)
copyright: ture
date: 2020-05-19 12:53:55
keywords: iOS,Swift,Swift Apprentice,Swift学习,Swift进阶,Protocols,协议编程,泛型,编程,多态,Collection Types,Arrays,Dictionaries,Sets,使用闭包集合迭代,Strings,构建自己的类型,Structures,结构体,Methods,Classes,Advanced Classes,面试题
tags:
    - [iOS]
    - [Swift]
    - [iOS面试题]
categories:
    - [iOS]
    - [Swift]
    - [iOS面试题]
---

# Runtime

## 什么是Runtime

+ `runtime`是由`C`和`C++`、汇编实现的一套`API`，为`OC语言`加入了面向对象、运行时的功能

+ 运行时（`runtime`）将数据类型的确定由编译时推迟到了运行时

+ 平时编写的`OC`代码，在程序运行过程中，最终会转换成`runtime`的C语言代码——`runtime`是`Objective-C` 的幕后作者

如类结构中的`ro`和`rw`属性

+ `ro`（`read-only`）在编译时已经确定

+ `rw`（`read-write`）在运行时才确定，因此可以使用`runtime`进行修改


<!-- more -->

## 方法的本质是什么

方法的本质是发送消息`objc_msgSend`，即寻找`IMP`的过程

发送消息会有以下⼏个流程：

+ **快速查找流程** —— 通过汇编`objc_msgSend`查找缓存`cache_t`是否有`imp`实现

+ **慢速查找流程** —— 通过`C++`中`lookUpImpOrForward`递归查找**当前类和父类**的`rw`中`methodlist`的方法

+ **动态方法解析** —— 通过调用`resolveInstanceMethod`和`resolveClassMethod`来动态方法决议——实现消息动态处理

+ **快速转发流程** —— 通过`CoreFoundation`来触发消息转发流程，`forwardingTargetForSelector`实现快速转发，由其他对象来实现处理方法

+ **慢速转发流程** —— 先调用`methodSignatureForSelector`获取到方法的签名，生成对应的`invocation`；再通过`forwardInvocation`来进行处理

+ 以上流程均无法挽救就崩溃并报错

## SEL和IMP的关系

`SEL`是方法编号，也是方法名，在`dyld加载镜像`到内存时，通过`_read_image方法`加载到内存的表中了

`IMP`是函数实现指针，找`IMP`就是找函数实现的过程

`SEL`和`IMP`的关系就可以解释为：

+ `SEL`就相当于书本的⽬录标题
+ `IMP`就是书本的⻚码
+ `函数`就是具体页码对应的内容

## 能否向运时创建的类中添加实例变量

具体情况具体分析：

+ 编译好的类不能添加实例变量
+ 运行时创建的类可以添加实例变量，但若已注册到内存中就不行了

原因：

+ 编译好的实例变量存储的位置在ro，而ro是在编译时就已经确定了的
+ 编译完成，内存结构就完全确定就法修改
+ 只能修改rw中的方法或者可以通过关联对象的方式来添加属性

## 利用runtime-API创建对象

### API介绍

#### 动态创建类

``` Objective-C
/**
 *创建类
 *
 *superClass: 父类，传Nil会创建一个新的根类
 *name: 类名
 *extraBytes: 额外的内存空间，一般传0
 *return:返回新类，创建失败返回Nil，如果类名已经存在，则创建失败
 */
Class FXPerson = objc_allocateClassPair([NSObject class], "LGPerson", 0);
```

#### 添加成员变量

``` Objective-C
/**
*添加成员变量
*这个函数只能在objc_allocateClassPair和objc_registerClassPair之前调用。不支持向现有类添加一个实例变量
*这个类不能是元类，不支持在元类中添加一个实例变量
*实例变量的最小对齐为1 << align，实例变量的最小对齐依赖于ivar的类型和机器架构。对于任何指针类型的变量，请通过log2(sizeof(pointer_type))
*
*cls 往哪个类添加
*name 添加的名字
*size 大小
*alignment 对齐处理方式
*types 签名
*/
class_addIvar(FXPerson, "fxName", sizeof(NSString *), log2(sizeof(NSString *)), "@");
```

#### 注册到内存

``` Objective-C
/**
 *往内存注册类
 *
 * cls 要注册的类
 */
 objc_registerClassPair(FXPerson);
```

#### 添加属性变量

``` Objective-C
/**
*往类里面添加属性
*
*cls 要添加属性的类
*name 属性名字
*attributes 属性的属性数组。
*attriCount 属性中属性的数量。
*/
class_addProperty(targetClass, propertyName, attrs, 4);
```

#### 添加方法

``` Objective-C
/**
 *往类里面添加方法
 *
 *cls 要添加方法的类
 *sel 方法编号
 *imp 函数实现指针
 *types 签名
 */
class_addMethod(FXPerson, @selector(setHobby), (IMP)fxSetter, "v@:@");
```

### 整体使用

``` Objective-C
// hobby的setter-IMP
void fxSetter(NSString *value) {
    printf("%s/n",__func__);
}

// hobby的getter-IMP
NSString *fxHobby() {
    return @"iOS";
}

// 添加属性变量的封装方法
void fx_class_addProperty(Class targetClass, const char *propertyName) {
    objc_property_attribute_t type = { "T", [[NSString stringWithFormat:@"@\"%@\"",NSStringFromClass([NSString class])] UTF8String] }; //type
    objc_property_attribute_t ownership0 = { "C", "" }; // C = copy
    objc_property_attribute_t ownership = { "N", "" }; //N = nonatomic
    objc_property_attribute_t backingivar  = { "V", [NSString stringWithFormat:@"_%@",[NSString stringWithCString:propertyName encoding:NSUTF8StringEncoding]].UTF8String };  //variable name
    objc_property_attribute_t attrs[] = {type, ownership0, ownership, backingivar};
    class_addProperty(targetClass, propertyName, attrs, 4);
}

// 打印属性变量的封装方法
void fx_printerProperty(Class targetClass){
    unsigned int outCount, i;
    objc_property_t *properties = class_copyPropertyList(targetClass, &outCount);
    for (i = 0; i < outCount; i++) {
        objc_property_t property = properties[i];
        fprintf(stdout, "%s %s\n", property_getName(property), property_getAttributes(property));
    }
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // 动态创建类
        Class FXPerson = objc_allocateClassPair([NSObject class], "FXPerson", 0);
        // 添加成员变量
        class_addIvar(FXPerson, "name", sizeof(NSString *), log2(sizeof(NSString *)), "@");
        // 注册到内存
        objc_registerClassPair(FXPerson);
        // 添加属性变量
        fx_class_addProperty(FXPerson, "hobby");
        fx_printerProperty(FXPerson);
        // 添加方法（为属性方法添加setter、getter方法）
        class_addMethod(FXPerson, @selector(setHobby:), (IMP)fxSetter, "v@:@");
        class_addMethod(FXPerson, @selector(hobby), (IMP)fxHobby, "@@:");

        // 开始使用
        id person = [FXPerson alloc];
        [person setValue:@"Felix" forKey:@"name"];
        NSLog(@"FXPerson的名字是：%@ 爱好是：%@", [person valueForKey:@"name"], [person valueForKey:@"hobby"]);
    }
    return 0;
}
```

### 注意事项

+ 记得导入`<objc/runtime.h>`
+ 添加成员变量`class_addIvar`必须在`objc_registerClassPair`前，因为注册到内存时`ro`已经确定了，不能再往`ivars`添加（同第四个面试题）
+ 添加属性变量`class_addProperty`可以在注册内存前后，因为是往`rw`中添加的
+ `class_addProperty`中“属性的属性”——`nonatomic/copy`是根据属性的类型变化而变化的
+ `class_addProperty`不会自动生成`setter`和`getter`方法，因此直接调用`KVC`会崩溃

不只可以通过`KVC`打印来检验，也可以下断点查看`ro、rw`的结构来检验

## 关联对象分析

>实则是为了解决分类创建属性的问题

### 分类直接添加属性的后果

+ 编译会出现警告：没有setter方法和getter方法
+ 运行会报错：-[FXPerson setName:]: unrecognized selector sent to instance 0x100f61180'

### 为什么不能直接添加属性

`Category`在`runtime`中是用一个结构体表示的：

``` Objective-C
struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties;
    ...
};
```
里面虽然可以添加属性变量，但是这些`properties`并不会自动生成`Ivar`，也就是不会有 `@synthesize`的作用，`dyld`加载期间，这些分类会被加载并`patch`到相应的类中。这是一个动态过程，`Ivar`不能动态添加.

### 解决方案

手动实现setter、getter方法，关联对象

``` Objective-C
- (void)setName:(NSString *)name {
    /**
    参数一：id object : 给哪个对象添加属性，这里要给自己添加属性，用self。
    参数二：void * == id key : 属性名，根据key获取关联对象的属性的值，在objc_getAssociatedObject中通过次key获得属性的值并返回。
    参数三：id value : 关联的值，也就是set方法传入的值给属性去保存。
    参数四：objc_AssociationPolicy policy : 策略，属性以什么形式保存。
    */
    objc_setAssociatedObject(self, @"name", name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (NSString *)name {
    /**
    参数一：id object : 获取哪个对象里面的关联的属性。
    参数二：void * == id key : 什么属性，与objc_setAssociatedObject中的key相对应，即通过key值取出value。
    */
    return objc_getAssociatedObject(self, @"name");
}
```

### 关联对象原理

#### setter方法——`objc_setAssociatedObject`分析

苹果设计接口时往往会加个中间层——即使底层实现逻辑发生变化也不会影响到对外接口

``` Objective-C
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) {
    _object_set_associative_reference(object, (void *)key, value, policy);
}
```

跟进去看看`_object_set_associative_reference`实现

``` Objective-C
void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    // This code used to work when nil was passed for object and key. Some code
    // probably relies on that to not crash. Check and handle it explicitly.
    // rdar://problem/44094390
    if (!object && !value) return;

    assert(object);

    if (object->getIsa()->forbidsAssociatedObjects())
        _objc_fatal("objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects", object, object_getClassName(object));

    // retain the new value (if any) outside the lock.
    // 在锁之外保留新值（如果有）。
    ObjcAssociation old_association(0, nil);
    // acquireValue会对retain和copy进行操作，
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        // 关联对象的管理类
        AssociationsManager manager;
        // 获取关联的 HashMap -> 存储当前关联对象
        AssociationsHashMap &associations(manager.associations());
        // 对当前的对象的地址做按位去反操作 - 就是 HashMap 的key (哈希函数)
        disguised_ptr_t disguised_object = DISGUISE(object);
        if (new_value) {
            // break any existing association.
            // 获取 AssociationsHashMap 的迭代器 - (对象的) 进行遍历
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i != associations.end()) {
                // secondary table exists
                ObjectAssociationMap *refs = i->second;
                // 根据key去获取关联属性的迭代器
                ObjectAssociationMap::iterator j = refs->find(key);
                if (j != refs->end()) {
                    old_association = j->second;
                    // 替换设置新值
                    j->second = ObjcAssociation(policy, new_value);
                } else {
                    // 到最后了 - 直接设置新值
                    (*refs)[key] = ObjcAssociation(policy, new_value);
                }
            } else {
                // create the new association (first time).
                // 如果AssociationsHashMap从没有对象的关联信息表，
                // 那么就创建一个map并通过传入的key把value存进去
                ObjectAssociationMap *refs = new ObjectAssociationMap;
                associations[disguised_object] = refs;
                (*refs)[key] = ObjcAssociation(policy, new_value);
                object->setHasAssociatedObjects();
            }
        } else {
            // setting the association to nil breaks the association.
            // 如果传入的value是nil，并且之前使用相同的key存储过关联对象，
            // 那么就把这个关联的value移除（这也是为什么传入nil对象能够把对象的关联value移除）
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i !=  associations.end()) {
                ObjectAssociationMap *refs = i->second;
                ObjectAssociationMap::iterator j = refs->find(key);
                if (j != refs->end()) {
                    old_association = j->second;
                    refs->erase(j);
                }
            }
        }
    }
    // release the old value (outside of the lock).
    // 最后把之前使用传入的这个key存储的关联的value释放（OBJC_ASSOCIATION_SETTER_RETAIN策略存储的）
    if (old_association.hasValue()) ReleaseValue()(old_association);
}
```

+ `ObjcAssociation old_association(0, nil)`处理传进来的值得到`new_value`

+ 获取到管理所有关联对象的hashmap总表的管理者`AssociationsManager`，然后拿到`hashmap`总表`AssociationsHashMap`
+ `DISGUISE(object)`对关联对象的地址进行取反操作得到哈希表对应的下标`index`
+ 如果`new_value`为空（即对属性赋值为`nil`）就直接找到相应的表进行删除
+ 如果`new_value`不为空，就拿到总表的迭代器通过拿到的下标`index`进行遍历查找；如果找到管理对象的关联属性哈希`map`表，然后再通过`key`去遍历取值
    - 如果取到了，就先把新值设置到`key`上，再将旧值释放掉
    - 如果没取到，就直接将新值设置在`key`上


#### getter方法——`objc_getAssociatedObject`分析

``` Objective-C
id objc_getAssociatedObject(id object, const void *key) {
    return _object_get_associative_reference(object, (void *)key);
}
```

``` Objective-C
id _object_get_associative_reference(id object, void *key) {
    id value = nil;
    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;
    {
        // 关联对象的管理类
        AssociationsManager manager;
        AssociationsHashMap &associations(manager.associations());
        // 生成伪装地址。处理参数 object 地址
        disguised_ptr_t disguised_object = DISGUISE(object);
        // 所有对象的额迭代器
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            ObjectAssociationMap *refs = i->second;
            // 内部对象的迭代器
            ObjectAssociationMap::iterator j = refs->find(key);
            if (j != refs->end()) {
                // 找到 - 把值和策略读取出来
                ObjcAssociation &entry = j->second;
                value = entry.value();
                policy = entry.policy();
                // OBJC_ASSOCIATION_GETTER_RETAIN - 就会持有一下
                if (policy & OBJC_ASSOCIATION_GETTER_RETAIN) {
                    objc_retain(value);
                }
            }
        }
    }
    if (value && (policy & OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {
        objc_autorelease(value);
    }
    return value;
}
```








