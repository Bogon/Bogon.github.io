<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在Swift中重构单例模式用法</title>
      <link href="/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/"/>
      <url>/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>清洁，模块化和可测试代码库的小技巧。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件开发中，不鼓励使用单例，并且对此表示反对，但这是有充分理由的。 它们很难测试或无法测试，并且在其他类中隐式使用它们时会纠缠你的代码库，从而使代码重用变得困难。 在大多数情况下，单例模式无非是对全局易变状态的保存。 每个人至少知道这是一个糟糕的主意。 但是，单例模式有时是不可避免和必要的错误。 我们如何以一种干净，模块化和可测试的方式将它们合并到我们的代码中？</p><a id="more"></a><h1 id="单例模式无处不在"><a href="#单例模式无处不在" class="headerlink" title="单例模式无处不在"></a><strong>单例模式无处不在</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 <code>Apple</code> 平台上，<code>Cocoa</code> 和 <code>Cocoa Touch</code> 框架中到处都有单例。 有 <code>UIApplication.shared</code>，<code>FileManager.default</code>，<code>NotificationCenter.default</code>，<code>UserDefaults.standard</code>，<code>URLSession.shared</code> 等。 设计模式甚至在 <code>Cocoa</code> 核心能力指南中都有自己的部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当你隐式引用这些（以及你自己的）单例时，将增加更改代码所需的工作量。 这也使测试代码变得困难或不可能，因为无法从使用它们的类之外更改或模拟这些单例。 这是你在iOS应用中都会看到的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentUser = <span class="type">CurrentUserManager</span>.shared.user</span><br><span class="line">        <span class="keyword">if</span> currentUser != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// do something with current user</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mySetting = <span class="type">UserDefaults</span>.standard.bool(forKey: <span class="string">"mySetting"</span>)</span><br><span class="line">        <span class="keyword">if</span> mySetting &#123;</span><br><span class="line">            <span class="comment">// do something with setting</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">URLSession</span>.shared.dataTask(with: <span class="type">URL</span>(string: <span class="string">"http://someResource"</span>)!) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// handle response</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">&lt;/br&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 这就是我所说 **隐式引用** 的意思-你只需在类中直接使用单例。 我们可以做得更好。 在<span class="type">Swift</span>中，有一种轻量级，简便且影响小的方式来改善这一点。 <span class="type">Swift</span>也使其优雅。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># **依赖注入**</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 简而言之，答案是[依赖注入](https:<span class="comment">//en.wikipedia.org/wiki/Dependency_injection "依赖注入")。 该原则表明你应该设计类和函数，以使所有输入都是显式的。 如果你重构上面的代码片段以使用依赖项注入，它将看起来像这样：</span></span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> userManager: <span class="type">CurrentUserManager</span></span><br><span class="line">    <span class="keyword">let</span> defaults: <span class="type">UserDefaults</span></span><br><span class="line">    <span class="keyword">let</span> urlSession: <span class="type">URLSession</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userManager: <span class="type">CurrentUserManager</span>, defaults: <span class="type">UserDefaults</span>, urlSession: <span class="type">URLSession</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">        <span class="keyword">self</span>.defaults = defaults</span><br><span class="line">        <span class="keyword">self</span>.urlSession = urlSession</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentUser = userManager.user</span><br><span class="line">        <span class="keyword">if</span> currentUser != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// do something with current user</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mySetting = defaults.bool(forKey: <span class="string">"mySetting"</span>)</span><br><span class="line">        <span class="keyword">if</span> mySetting &#123;</span><br><span class="line">            <span class="comment">// do something with setting</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        urlSession.dataTask(with: <span class="type">URL</span>(string: <span class="string">"http://someResource"</span>)!) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// handle response</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此类不再隐式（或显式）依赖于任何单例。 它显式依赖于 <code>CurrentUserManager</code>， <code>UserDefaults</code> 和 <code>URLSession</code> ，但是有关这些依赖项的任何内容均表示它们是单例。 这个细节不再重要，但是功能保持不变。 视图控制器仅知道这些对象的实例存在。 在需要使用该对象时，你可以传递单例。 同样，从类的角度来看，此细节无关紧要。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>(userManager: .shared, defaults: .standard, urlSession: .shared)</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p><strong>特别提示：<code>Swift</code> 类型推断在这里起作用。 除了编写 <code>URLSession.shared</code>，您还可以编写 <code>.shared</code> 。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你需要提供其他默认值（例如，如果你需要与<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW6" target="_blank" rel="noopener" title="应用组内共享数据">应用组共享数据</a>），则更改起来很容易。 实际上，你不必更改此类中的任何代码。 而不传递 <code>UserDefaults.standard</code>，而是传递 <code>UserDefaults（suiteName：“ com.myApp”）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，在单元测试中，你现在可以传递这些类的其他实例。 在Swift中无法进行真正的模拟，但是有一些解决方法。 这取决于您要如何构造代码。 你可以为 <code>CurrentUserManager</code> 使用协议，然后可以在测试中“模拟”该协议。 你可以为 <code>UserDefaults</code> 提供构造的方法类进行测试。 你可以将 <code>URLSession</code> 设置为可选，并在测试中传递 <code>nil</code>。</p><h1 id="重构陷阱"><a href="#重构陷阱" class="headerlink" title="重构陷阱"></a><strong>重构陷阱</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能对这个想法很感兴趣，现在你想解开并解放陷入困境的代码库。尽管依赖注入是理想的选择，并且可以为你提供更纯净的对象模型，但是实现它通常很困难。更重要的是，在首次编写代码时，很少会设计出适应这种情况的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们上面重构的内容现在更具模块化和可测试性-但确实存在问题。 <code>MyViewController</code> 的初始值设定项曾经是空的 <code>（init（））</code> ，但现在需要三个参数。每个调用位置都必须更改。构造此方法的干净而正确的方法是将实例从上到下或从以前的视图控制器传递到此实例。这将需要将数据从对象图的根传递到所有子类。特别是在iOS中，当你将数据从视图控制器传递到视图控制器时，这可能会引起很多麻烦。尤其是传统代码库将难以立即实现如此大的更改。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大多数类（尤其是视图控制器）的初始化程序都需要更改。当你意识到必须重构整个应用程序时，这种更改变得异常困难。要么一切都将被破坏，要么仅某些类将被更新以进行依赖注入，而其他一些类将继续隐式引用单例。这种不一致可能在将来引起问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在复杂、大型的旧版代码库中，这样的重构可能根本不可行-至少不能同时进行，而且也不能没有回归。因此，你可能会争辩说，你根本不应该重构并忍受这种情况。然后需要几个月或几年的时间你您必须支持多个用户-现在在实现切换帐户时 <code>CurrentUserManager</code> 无法正常工作。你如何应对？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一种更为先进的方式，也有一种从一开始就设计你要使用的类以适应下一次此类变化的方法。</p><h1 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a><strong>默认参数值</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最喜欢的Swift功能之一是默认参数值。 它们非常有用，可以为你的代码带来很大的灵活性。 使用默认参数，你可以解决上述问题，而不必担心依赖注入问题，也不会在代码库中引入过多的复杂性。 也许你的应用程序实际上只有一个用户，所以实现所有这种依赖注入是不必要的开销。</p><p>你可以给单例设置默认参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userManager: <span class="type">CurrentUserManager</span> = .shared, defaults: <span class="type">UserDefaults</span> = .standard, urlSession: <span class="type">URLSession</span> = .shared) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">        <span class="keyword">self</span>.defaults = defaults</span><br><span class="line">        <span class="keyword">self</span>.urlSession = urlSession</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，从方法调用的角度来看，初始化程序没有改变。 但是类本身存在很大的差异，它现在使用依赖项注入，不再引用单例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>()</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你从此更改中学到了什么？你可以使用此模式重构每个类，而无需更新任何调用的地方。语义上或功能上都没有改变。但是，你的类也在使用依赖注入。他们只是在内部使用实例。你可以如上所述测试它们并维护一个灵活的模块化API，同时公共接口保持不变。本质上，你可以继续在代码库中工作，就好像什么都没有改变一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有时间传入自定义非空参数，你可以执行此操作而无需更改任何类。你只需要更新调用的位置即可。此外，如果你决定使用成熟的依赖关系注入并从上至下传递每个单个依赖关系，则只需删除默认参数并从上方传递依赖关系。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要，你甚至可以选择加入或选择退出任何默认值。在以下示例中，我们提供了自定义 <code>UserDefaults</code>，但保留了 <code>CurrentUserManager</code> 和 <code>URLSession</code> 的默认参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appGroupDefaults = <span class="type">UserDefaults</span>(suiteName: <span class="string">"com.myApp"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>(defaults: appGroupDefaults)</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></bar><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 使这种“部分”依赖注入变得很方便实用。通过为类添加新属性和带有默认值的初始化参数，你可以使你的代码具有更大的模块化和可测试性，而不必重构，也不必完全使用成熟的依赖项注入。如果从一开始就设计这样的类，那么你会发现自己写出 <code>bug</code> 的概率降低了很多-当你遇到 <code>bug</code> 是，将更容易定位和解决。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 除了此处的简单示例（类，结构，枚举，函数）之外，你还可以将这些概念和设计应用于代码的所有区域。 <code>Swift</code> 中的每个函数都可以采用默认参数值。通过花一些时间来思考未来可能发生的变化，我们可以创建可以轻松适应变化的类型和功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 构建和设计好的软件意味着编写<strong>易于更改</strong>但<strong>难以破解的代码</strong>。这就是依赖项注入的动机，而 <code>Swift</code> 的默认参数可以帮助你快速，轻松且优雅地实现这一目标。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> Swift </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift单例模式</title>
      <link href="/Swift%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Singleto</code>n 是有史以来最受争议的设计模式。了解在 <code>iOS</code> 项目中使用 <code>Swift</code> 单例类的正确方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每个人都在批评的单例模式，大多数人都将其称为反模式。但是单例模式到底是什么，为什么这么差呢？</p><a id="more"></a><h1 id="Singleton-是什么"><a href="#Singleton-是什么" class="headerlink" title="Singleton 是什么?"></a><strong>Singleton 是什么?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于简单，这是一种非常流行且普遍采用的模式。在整个应用程序生命周期中，单例类只能有一个实例。单个实例只能通过静态属性访问，并且初始化后的对象通常在全局范围内共享。这就像一个全局变量。 🌏</p><h1 id="全局变量和状态"><a href="#全局变量和状态" class="headerlink" title="全局变量和状态"></a><strong>全局变量和状态</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式的声誉很差，因为他们共享全局可变的状态。即使在经验丰富的开发人员圈子中，始终会担心使用 <code>global</code> 关键字。全局状态和变量是副作用的温床。可以从程序的任何位置访问全局变量，因此使用它们的类将变为有状态，不安全，紧密耦合且难以调试。出于明显的原因，通过这种方式与对象共享状态不是一个好习惯。 🤮</p><h1 id="Singleton-的副作用"><a href="#Singleton-的副作用" class="headerlink" title="Singleton 的副作用"></a><strong>Singleton 的副作用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你应该尽可能确定范围和隔离变量，并最大程度地减少代码的状态性。这将消除副作用，使您的代码更安全地使用。考虑以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// method is written by someone else</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    global = x</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">global = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> result = square(<span class="number">5</span>)</span><br><span class="line">result += global <span class="comment">//we assume that global is 1</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">//wtf 30 it should be 26</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>square</code> 方法由其他人编写，由于某种原因，他们希望将输入存储在相同的全局变量中。现在，当您调用该函数时，除非您查看他的代码，否则您将一无所获。想象一下，在一个由多个代码作者编写的具有大量oop类的项目中的此类问题……GOOD LUCK! 🐛🐛🐛</p><h1 id="单例对象的生命周期"><a href="#单例对象的生命周期" class="headerlink" title="单例对象的生命周期"></a><strong>单例对象的生命周期</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 单例创建一次并永久存在，它们的工作几乎就像全局变量一样，这就是为什么你必须格外小心。你应该仅使用在应用程序整个生命周期内都能维持的单例状态来管理这些状态。例如，特定于用户的会话通常是不好的做法，你应该重新考虑设计。另外，默认情况下，Swift也不是线程安全的，因此，如果你使用单例，则还必须为多线程问题做好准备。但是，如果它们因此造成问题，我们难道不应该完全避免它们吗？答案是不。 🚫</p><h1 id="我们应该在什么时候使用单例类"><a href="#我们应该在什么时候使用单例类" class="headerlink" title="我们应该在什么时候使用单例类"></a><strong>我们应该在什么时候使用单例类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>UIApplication</code> 很可能是单例的，因为应该只有一个应用程序实例，并且该实例应该一直存在，直到你将其关闭为止。这就是单例的完美例子。另一个用例可以是 <code>Logger</code> 类。使用单例是安全的，因为无论记录器是否打开，你的应用程序的行为都不会有所不同。没有其他人会拥有或管理记录器，并且你只会将信息传递到记录器中，因此状态不会混乱。<strong>结论：对于单例模式的使用，控制台或记录器类是完全可以接受的方案。</strong> 👏</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Console</span>.<span class="keyword">default</span>.notice(<span class="string">"Hello I'm a singleton!"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apple 框架中有很多“单一”（并非一切都是真正的单例对象）用例，这是一个简短列表，因此您可以从中获得一些启发：</p><ul><li>HTTPCookieStorage.shared</li><li>URLCredentialStorage.shared</li><li>URLSessionConfiguration.default</li><li>URLSession.shared</li><li>FileManager.default</li><li>Bundle.main</li><li>UserDefaults.standard</li><li>NotificationCenter.default</li><li>UIScreen.main</li><li>UIDevice.current</li><li>UIApplication.shared</li><li>MPMusicPlayerController.systemMusicPlayer</li><li>GKLocalPlayer.localPlayer（）</li><li>SKPaymentQueue.default（）</li><li>WCSession.default</li><li>CKContainer.default（）</li><li>etc</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经看到许多管理器类以单例形式实现，例如网络，位置或核心数据管理器，但是这些对象通常不应该是单例，仅仅是因为它可以是多个单例。 💩</p><p><strong>单例模式可能非常有用，但应谨慎使用。</strong></p><p>如果要将某个类变成单例，请问自己以下问题：</p><ul><li>还有其他任何东西拥有，管理或负责吗？</li><li>是否将只有一个实例？</li><li>它会是一个全局状态变量吗？</li><li>我真的应该使用全局共享对象吗？</li><li>是否应该贯穿整个应用程序生命周期？</li><li>有其他选择吗？</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果以上所有内容的答案都是肯定的，那么您可以“安全地”使用单例或全局变量来存储数据。 🎉🎉🎉</p><h1 id="如何使用Swift创建一个单例"><a href="#如何使用Swift创建一个单例" class="headerlink" title="如何使用Swift创建一个单例?"></a><strong>如何使用Swift创建一个单例?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建单例对象确实很容易，但是在应用此设计模式之前，请务必三思而后行，并考虑其他选择。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Singleton</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// don't forget to make this private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> singleton = <span class="type">Singleton</span>.shared</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，我总是创建一个特定的单例对象，称为App。通过这种方式，我可以将与应用程序相关的全局状态属性连接到那个单例中。命名约定也有助于关联和理解其中的内容。 💡</p><h1 id="如何消除单例"><a href="#如何消除单例" class="headerlink" title="如何消除单例?"></a><strong>如何消除单例?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果还有其他方法，则应在大约90％的情况下使用该方法。单例模式最常见的替代解决方案是依赖注入。首先，你应该将单例方法抽象为协议，然后，如果仍然需要，可以将其用作默认实现。现在，您可以将单例或<a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/" title="重构对象">重构的对象</a>注入正确的位置。这样，你的代码就可以使用协议的模拟对象进行测试，甚至可以忽略单例本身。 😎</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">DataCompletionBlock</span> = (<span class="type">Data?</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. abstract away the required functions</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. make your "singleton" conform to the protocol</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSession</span>: <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> task = <span class="keyword">self</span>.dataTask(with: request) &#123; data, <span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            completionHandler(data)</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> session: <span class="type">Session</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. using dependency injection with the "singleton" object</span></span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">Session</span> = <span class="type">URLSession</span>.shared) &#123;</span><br><span class="line">        <span class="keyword">self</span>.session = session</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(<span class="number">_</span> request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.session.make(request: request, completionHandler: completionHandler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. create mock object</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockedSession</span>: <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        completionHandler(<span class="string">"Mocked data response"</span>.data(using: .utf8))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. write your tests</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> api = <span class="type">ApiService</span>(session: <span class="type">MockedSession</span>())</span><br><span class="line">    <span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)!)</span><br><span class="line">    api.load(request) &#123; data <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(data: data!, encoding: .utf8)!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像你看到的，单例模式非常容易实现，但是很难决定其应用程序形式。我并不是说这是一种反模式，因为显然不是这样，但是如果你打算使用单例模式，请当心。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> Swift </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSCODER和SWIFT初始化</title>
      <link href="/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您正在使用 <code>Swift</code> 并想对实现 <code>NSCoding</code> 的东西进行子类化（例如 <code>UIView</code>，<code>UIViewController</code> 等），则可能会遇到麻烦的情况。即，<code>NSCoding</code> 协议需要 <code>init(coder：aDecoder)</code> 初始化程序，这意味着如果你为超类重写了指定的初始化程序，则需要实现该初始化程序。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那就好了，但是 <code>Swift</code> 在确保对类的所有属性进行超级严格的调用之前，都要确保在 <code>init()</code> 中分配了一个值。这意味着，如果您想提供自己的初始化程序，则无法执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    name = <span class="string">"Bar"</span></span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle:<span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>init（coder :)</code> 初始值设定项未设置 <code>name</code> 属性，因此不会进行编译。你可以在两个初始值设定项中都重复初始化和设置名称，但是当你在init中进行了很多工作时，这很糟糕（如果希望尽可能避免使用可选属性，则应该这样做）。</p><p>在 Objective-C 中，如果要在多个 <code>init</code> 方法之间共享初始化逻辑，则只需定义一个通用的 <strong>“setup”</strong> 方法即可执行所有共享的东西，并从两个初始化器中调用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype) <span class="keyword">init</span> &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span> <span class="keyword">self</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype) initWithCoder:(<span class="type">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span> <span class="keyword">self</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) setup &#123;</span><br><span class="line">  <span class="keyword">self</span>.name = @<span class="string">"Foo"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  这种方式不会立即就创建出你想要的对象。问题在于，在这两个初始化程序中，我们都在调用    <code>[super init]</code> 之前，先给 <code>self.name</code> 分配了一个值，但这在 <code>Swift</code> 语法中是不可行的。我们也不能将对 <code>self.setup</code> 的调用移到对 <code>super.init（）</code> 的调用之上，因为在类通过调用 <code>super.init（）</code> 完全初始化之后，才允许您引用 <code>self</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  那么，如何将这只鸡从鸡蛋中取出并放到盘子上呢？好吧，我们要等到初始化后才能对 <code>self</code> 调用方法，但是只要我们从 <strong>“convienience”</strong> 初始化程序中调用它，就可以调用另一个 <code>init</code> 。仅通过示例进行解释可能更容易：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> coder: <span class="type">NSCoder?</span> = <span class="literal">nil</span>) &#123;</span><br><span class="line">    name = <span class="string">"Bar"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> coder = coder &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle:<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(coder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在指定的初始化程序中添加了一个可选的 <code>NSCoder</code> 参数，并将其默认设置为 <code>nil</code> ，因此我们仍然可以像以前一样在没有任何参数的情况下调用它。但是，现在已将<code>NSCoding</code> 协议中要求的 <code>init（coder :)</code> 初始值设定项标记为<strong>convienience</strong>，这意味着它可以调用指定的初始值设定项并传入编码器。</p><p>在指定的 <code>init</code> 中，我们检查 <code>coder</code> 是否为非 <code>nil</code> （如果让coder = conditional为条件），如果是，则调用 <code>super.init（coder :)</code> 。如果为 <code>nil</code>，我们将执行本来应该做的事情，并调用 <code>super.init（nibName：nil，bundle：nil）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，编译器很高兴在调用 <code>super.init（）</code> 之前为属性分配值，并且可以将初始化逻辑放在一个地方。如果要在情节提要中使用 <code>ViewController</code> ，则框架将调用init（coder :)，如果要以编程方式创建一个，则可以说 <code>let fooVC = FooViewController（）</code>。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIKit初始化模式</title>
      <link href="/UIKit%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/"/>
      <url>/UIKit%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>了解UIKit中两个常用类的初始化过程。了解UIViewcontroller和UIView初始化模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIKit</code> 是在iOS开发过程中必须也是使用频次最高的一个类库，里面包含了许多与用户直接交互的控件比如：<code>UIView</code>, <code>UITableView</code>, <code>UIScrollView</code> 等。在收到用户交互的设计图之后，我们要合理的使用这些控件，就能编写出交互良好的应用。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了类库中包含的基础控件之外，我们也能够对控件根据业务需要进行整合，也就是设计出一套适用于本公司的组件，提高开发速度。</p><h1 id="UIViewController-初始化"><a href="#UIViewController-初始化" class="headerlink" title="UIViewController 初始化"></a><strong>UIViewController 初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，<code>UIViewController</code> 的初始化非常简单。如果要完全控制，则只需要重写一些方法。这取决于你使用何种方式调用 <code>init</code> ，如果你使用一个 <code>storyboard</code> 初始化控制器，那么 <a href="http://www.xuebaonline.com/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/" title="NSCODER和SWIFT初始化">init(coder)</a> 是你所需要的。如果你尝试从外部 <code>nib</code> 文件启动控制器，则将调用 <code>init（nib，bundle）</code> 。你还有第三个选择，你可以通过代码以编程方式初始化控制器。简而言之，为了进行合理的初始化过程，这是你必须要做的。</p></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍两种 <code>UIViewControllers</code> 的初始化模式，第一种只是一个常见的init函数，在每种情况下都可以调用该函数来初始化控制器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(nibName nibNameOrNil: <span class="type">String?</span>, bundle nibBundleOrNil: <span class="type">Bundle?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do your stuff here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以在之后的子类中隐藏 <code>init（nib，bundle）</code> 和 <code>init（coder）</code> 方法。在子类中不必重写 <code>init（nib，bundle）</code>，并且可以将 <code>init（coder）</code> 标记为默认初始化程序。这个似乎是有点棘手的解决方案，使用起来不是很方便，但确实可以完成 <code>ViewController</code> 的初始化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do your stuff here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFutureViewController</span>: <span class="title">ViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> vc = <span class="type">MyFutureViewController</span>()</span><br></pre></td></tr></table></figure><hr></br><h1 id="UIView-初始化"><a href="#UIView-初始化" class="headerlink" title="UIView 初始化"></a><strong>UIView 初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通常为 <code>UIView</code> 创建一个通用的初始化程序，以使初始化过程更加轻松，使用起来更加方便。还会在该初始值设定项方法中将 <code>translate autoresizing mask</code> 属性设置为 <code>false</code> ，因为它是2017年，没有人再使用 <code>spring＆struts</code> 了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用自动布局助手也很不错，如果你想从nib文件中初始化视图，那么有一些便利的方法也很好。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(autolayout: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(autolayout: Bool = <span class="literal">true</span>)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _self = <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">let</span> view  = _self <span class="keyword">as</span> <span class="type">UIView</span></span><br><span class="line">        view.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">        <span class="keyword">return</span> _self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">createFromNib</span><span class="params">(owner: <span class="keyword">Any</span>? = <span class="literal">nil</span>, options: [AnyHashable: <span class="keyword">Any</span>]? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Bundle</span>.main.loadNibNamed(<span class="type">String</span>(describing: <span class="keyword">self</span>), owner: owner, options: options)?.last <span class="keyword">as</span>! <span class="type">UIView</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> view = <span class="type">UIView</span>(autolayout: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>使用这些代码片段，为所有 <code>UIKit</code> 类维护一个合理的初始化过程确实很容易，因为其中大多数都是从这两个 “主要” 类派生的。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端实践三:Ubuntu18.04安装Vapor4.0</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89:Ubuntu18.04%E5%AE%89%E8%A3%85Vapor4.0/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89:Ubuntu18.04%E5%AE%89%E8%A3%85Vapor4.0/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文章《<a href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/" title="后端实践二:Ubuntu18.04安装最新版Swift5.2">后端实践二:Ubuntu18.04安装最新版Swift5.2</a>》可以在 Ubuntu18.04 的服务器上顺利安装最新版本的 <code>Swift</code> 。我们参照 <a href="https://docs.vapor.codes/3.0/install/ubuntu/" target="_blank" rel="noopener">官网文档</a> 安装 <code>Vapor4.0</code> 的开发环境。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官网上的文档跟开发维护的速度有一定的版本误差，所以现在在官网上看到的安装方法是针对 <code>Vapor(&gt;3.0 &amp;&amp; &lt; 4.0)</code> 的版本。由于版本间差异比较大，在实践过程中，只会关注到 <code>Vapor(&gt;=4.0)</code> 以上版本的新特性。在创建工程和引入依赖库的过程中也会出现微小的差别，我们在后续的实践中会总结到。</p></blockquote><h1 id="验证-Swift-安装"><a href="#验证-Swift-安装" class="headerlink" title="验证 Swift 安装"></a><strong>验证 Swift 安装</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过访问 <code>Swift.org</code>，可以得到一份如何在 <code>Linux</code> 上安装 <code>Swift</code> 的文档。我们完成对 <code>Swift</code> 的安装之后，在终端中输入如下命令：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><a id="more"></a><p>如果在终端中输出如下信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Apple</span> <span class="type">Swift</span> version <span class="number">4.1</span>.<span class="number">0</span> (swiftlang-<span class="number">900.0</span>.<span class="number">69.2</span> clang-<span class="number">900.0</span>.<span class="number">38</span>)</span><br><span class="line"><span class="type">Target</span>: x86_64-apple-macosx10.<span class="number">9</span></span><br></pre></td></tr></table></figure><p>那么标识我们在 <code>Linux</code> 上成功安装 <code>Swift</code>。</p><h1 id="安装-Vapor-Toolbox"><a href="#安装-Vapor-Toolbox" class="headerlink" title="安装 Vapor Toolbox"></a><strong>安装 Vapor Toolbox</strong></h1><p>在 <code>Vapor 4.0</code> 发布之前，在 <code>Linux</code> 上安装，只需要在终端中敲入如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL apt.vapor.sh -o apt.vapor.sh</span><br></pre></td></tr></table></figure><p>这个执行安装的命令已经被废弃。</p><h2 id="Toolbox-源代码"><a href="#Toolbox-源代码" class="headerlink" title="Toolbox 源代码"></a><code>Toolbox</code> 源代码</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于之后的版本中，不在将该文件托管至软件源，所以我们在安装时需要做出如下操作获取到 <code>Toolbox</code> 源代码到本地文件夹中：</p><p>下载 <code>Toolbox</code> 源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vapor/toolbox.git</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-1stp.png" alt="Toolbox"></p><h2 id="编译-Vapor-可执行文件"><a href="#编译-Vapor-可执行文件" class="headerlink" title="编译 Vapor 可执行文件"></a>编译 <code>Vapor</code> 可执行文件</h2><p>进入到 <code>Toolbox</code> 工程的根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> toolbox/</span><br></pre></td></tr></table></figure><p>编译 <code>Toolbox</code>  发布版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build -<span class="built_in">c</span> release</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于获取的源代码中缺少部分文件，期间或存在报错发现 <code>Toolbox</code> 中没有 <code>LinuxMain.swift</code> 文件在 <code>Tests</code> 文件夹中，这时我们进入到 <code>XCTest</code> 文件夹中。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-2stp.png" alt="Vapor"></p><p>创建 <code>LinuxMain.swift</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch LinuxMain.swift</span><br></pre></td></tr></table></figure><p>编辑 <code>LinuxMain.swift</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim LinuxMain.swift</span><br></pre></td></tr></table></figure><p>向 <code>LinuxMain.swift</code> 文件中添加测试代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> AppTests</span><br><span class="line"></span><br><span class="line"><span class="type">XCTMain</span>([testCase(<span class="type">AppTests</span>.allTests)])</span><br></pre></td></tr></table></figure><p>保存修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq!</span><br></pre></td></tr></table></figure><p>重新执行如下命令，完成编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build -c release</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-3stp.png" alt="Vapor"></p><p>找到编译成功的 <code>Vapor</code> 文件</p><blockquote><p>执行完 <code>build</code> 命令之后，会在输出的文件中生成一个可执行的二进制文件。</p></blockquote><p>查找 <code>Vapor</code> 所在的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name vapor</span><br></pre></td></tr></table></figure><blockquote><p>这时会看到输出一个类似如下的文件夹 <code>.build/x86_64-unknown-linux/release/vapor</code> ,这个文件夹里就是我们要使用到的文件 <code>Vapor</code> 。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-4stp.png" alt="Vapor"></p><p>配置 <code>Vapor</code> 的环境变量</p><p>将包含可执行文件 <code>Vapor</code> 的文件目录添加在 <code>PATH</code> 中。</p><p>配置 <code>Vapor</code> 环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp vapor /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>验证是否配置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vapor --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-5stp.png" alt="Vaporhelp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此 <code>Vapor 4.0</code> 的环境配置已经完成。由于 <code>3.0</code> 和 <code>4.0</code> 版本差异比较大，在配置方面也有差异。在创建项目时更需要加上 <code>branch=4</code> 等。后续会加入：创建第一个 <code>Hello World</code> 工程。</p>]]></content>
      
      
      <categories>
          
          <category> Vapor4.0 </category>
          
          <category> Server </category>
          
          <category> Ubuntu18.04 </category>
          
          <category> Swift5.2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Server </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端实践二:Ubuntu18.04安装最新版Swift5.2</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文章《<a href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/" title="后端实践一:开发环境搭建VMware下安装Ubuntu18.04">后端实践一:开发环境搭建VMware下安装Ubuntu18.04</a>》可以完成在  <code>mac</code> 上搭建起可用的 <code>Ubuntu 18.04</code> 的服务器。接下来我们要在此基础上完善 <code>Vapor 4.0</code> 的开发环境。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ubuntu 18.04 安装 Swift 5.2.2 ，可在 Vapor 官网的引导完成。这篇文章就是讲解如何完成在 Ubuntu 上安装最新版本 Swift，构建出一个强大的云端服务器。</p></blockquote><h1 id="Ubuntu-系统环境搭建"><a href="#Ubuntu-系统环境搭建" class="headerlink" title="Ubuntu 系统环境搭建"></a><strong><code>Ubuntu</code> 系统环境搭建</strong></h1><h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里使用的SecureCRT作为终端连接服务器，也可以使用 <code>iTerm2</code> 连接服务器。</p></blockquote><a id="more"></a><p>使用 <code>SecureCRT</code> 提供的远程登录功能连接 <code>Ubuntu</code> 服务器的配置信息：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-1stop.png" alt="SecureCRT"></p><p>使用 <code>SecureCRT</code> 终端使用系统自带的远程登录功能连接 <code>Ubuntu</code> 服务器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-2stp.png" alt="使用SecureCRT"></p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-3stp.png" alt="使用SecureCRT"></p><p>使用 <code>iTerm2</code> 终端使用系统自带的远程登录功能连接Ubuntu 服务器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-4stp.png" alt="iTerm2"></p><p>查看当前服务器系统版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><blockquote><p>Swift 依赖一些三方类库。</p></blockquote><p>必须安装的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install clang libicu-dev -y</span><br><span class="line">sudo apt-get install libcurl3 libpython2.7 libpython2.7-dev</span><br></pre></td></tr></table></figure><h2 id="安装-Swift"><a href="#安装-Swift" class="headerlink" title="安装 Swift"></a>安装 <code>Swift</code></h2><p>在 <a href="https://swift.org/download/#releases" target="_blank" rel="noopener">Swift.org</a> 查找我们要安装的Swift对应版本的Toolchain，复制下载链接。</p><blockquote><p>在写这篇文章时最新版的Swift是v5.2.2。</p></blockquote><p>找到对应系统以及对应版本<a href="https://swift.org/builds/swift-5.2.2-release/ubuntu1804/swift-5.2.2-RELEASE/swift-5.2.2-RELEASE-ubuntu18.04.tar.gz" target="_blank" rel="noopener">下载链接</a>：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-5stp.png" alt="下载链接"></p><p>可以采用两种下载方式：</p><ul><li>在本机上使用上方链接，下载 <code>Toolchain</code> ，上传到 <code>Ubuntu</code> 服务器上，完成后续安装；</li><li>在 <code>Ubuntu</code> 上使用 <code>wget url</code> 的方式直接在服务器上安装。</li></ul><p>接下来 使用  <code>wget url</code> 下载 <code>swift</code> 安装包，并解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://swift.org/builds/swift-5.2.2-release/ubuntu1804/swift-5.2.2-RELEASE/swift-5.2.2-RELEASE-ubuntu18.04.tar.gz</span><br></pre></td></tr></table></figure><p>解压 <code>swift</code> 到文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf swift-5.2.2-RELEASE-ubuntu18.04.tar.gz</span><br></pre></td></tr></table></figure><p>将解压的文件保存在 <code>share</code> 目录下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv swift-5.2.2-RELEASE-ubuntu18.04 /usr/share/swift</span><br></pre></td></tr></table></figure><h2 id="配置-Swift-环境变量"><a href="#配置-Swift-环境变量" class="headerlink" title="配置 Swift 环境变量"></a>配置 <code>Swift</code> 环境变量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成以上操作即完成了 <code>swift</code> 的的安装，为了更方便的使用 <code>Swift</code> ，需要配置其在全局任意目录下可使用。</p><p>配置 <code>Swift</code> 环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=/usr/share/swift/usr/bin:<span class="variable">$PATH</span>"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h2><p>检查当前系统的 <code>Swift</code> 版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift -version</span><br></pre></td></tr></table></figure><ul><li>如果出现 <code>Command &#39;swift&#39; not found ...</code> 该提示，关闭连接终端，重新连接服务器，再次执行上述命令。</li></ul><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-6stp.png" alt="installSuccess"></p><h1 id="运行-Swift-程序"><a href="#运行-Swift-程序" class="headerlink" title="运行 Swift 程序"></a><strong>运行 <code>Swift</code> 程序</strong></h1><h2 id="在终端运行程序，简单测试环境是否达建成功。"><a href="#在终端运行程序，简单测试环境是否达建成功。" class="headerlink" title="在终端运行程序，简单测试环境是否达建成功。"></a>在终端运行程序，简单测试环境是否达建成功。</h2><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift</span><br></pre></td></tr></table></figure><p>此时进入到终端界面。</p><p>编辑一段 <code>Swift</code> 程序代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>, b = <span class="number">13</span>, <span class="built_in">c</span> = a + b</span><br></pre></td></tr></table></figure><p>在终端输入以下命令退出编辑模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:exit</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-7stp.png" alt="Swift"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成 <code>Swift</code> 在 <code>Ubuntu</code> 环境下的配置，接下来可以配置 <code>Vapor 4.0</code> 的开发环境。</p>]]></content>
      
      
      <categories>
          
          <category> Vapor4.0 </category>
          
          <category> Server </category>
          
          <category> Ubuntu18.04 </category>
          
          <category> Swift5.2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Server </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04替换国内源</title>
      <link href="/Ubuntu18.04%E6%9B%BF%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"/>
      <url>/Ubuntu18.04%E6%9B%BF%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再国内使用国外的软件源普遍会比较慢，但是国内也有很多的软件源可供选择。在修改软件源之前，查看系统软件源版本：</p><p><strong><em>查看版本：</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -c</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong><em>备份系统源配置文件：</em></strong></p><p>在修改之前要对系统的配置文件做好备份，这是个好习惯。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h1 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a><strong>阿里源</strong></h1><h2 id="更新源的配置文件"><a href="#更新源的配置文件" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multivers</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a><strong>中科大源</strong></h1><h2 id="更新源的配置文件-1"><a href="#更新源的配置文件-1" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="163源"><a href="#163源" class="headerlink" title="163源"></a><strong>163源</strong></h1><h2 id="更新源的配置文件-2"><a href="#更新源的配置文件-2" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-2"><a href="#更新-2" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a><strong>清华源</strong></h1><h2 id="更新源的配置文件-3"><a href="#更新源的配置文件-3" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-3"><a href="#更新-3" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Ubuntu18.04的配置中，更新了系统的软件源，国内源推荐使用清华源。</p>]]></content>
      
      
      <categories>
          
          <category> Vapor4.0 </category>
          
          <category> Server </category>
          
          <category> Ubuntu18.04 </category>
          
          <category> Ubuntu软件源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端实践一:开发环境搭建VMware下安装Ubuntu18.04</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Mac</code> 环境下使用 <code>VMware</code> 安装 <code>Ubuntu 18.04</code> 的主要目的是用于对后端开发框架：<code>Vapor 4.0</code> 的实践。由于 <code>Vapor 4.0</code> 框架支持 <code>MacOS</code> 和 <code>Ubuntu</code> ，所以实践时间，以使用 <code>Ubuntu</code> 为主。</p><a id="more"></a><blockquote><p>VMware  的下载和安装这里就不在赘述，自行下载安装即可。</p></blockquote><h1 id="下载-Ubuntu-的-ISO-文件"><a href="#下载-Ubuntu-的-ISO-文件" class="headerlink" title="下载 Ubuntu 的 ISO 文件"></a><strong>下载 <code>Ubuntu</code> 的 <code>ISO</code> 文件</strong></h1><h2 id="国内有很多镜像源，这里选用网易的镜像源。"><a href="#国内有很多镜像源，这里选用网易的镜像源。" class="headerlink" title="国内有很多镜像源，这里选用网易的镜像源。"></a>国内有很多镜像源，这里选用<a href="http://mirrors.163.com/ubuntu-releases/" target="_blank" rel="noopener" title="网易的镜像源">网易的镜像源</a>。</h2><p>这里建议使用 <code>Ubuntu 18.04</code> 版本，按照图示下载即可。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/163-source.png" alt="网易镜像源"></p><p>本次安装中使用的镜像为：<a href="http://mirrors.163.com/ubuntu-releases/18.04/ubuntu-18.04.4-live-server-amd64.iso" target="_blank" rel="noopener" title="Ubuntu18.04"><code>ubuntu-18.04.4-live-server-amd64.iso</code></a>。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/Ubuntu-1804-server.png" alt="Ubuntu1804"></p><h1 id="VMware-虚拟机配置"><a href="#VMware-虚拟机配置" class="headerlink" title="VMware 虚拟机配置"></a><strong><code>VMware</code> 虚拟机配置</strong></h1><p>在使用 <code>VMware</code> 安装 <code>Ubuntu</code>虚拟机时，按照引导安装即可。</p><h2 id="打开-VMware-软件"><a href="#打开-VMware-软件" class="headerlink" title="打开 VMware 软件"></a>打开 <code>VMware</code> 软件</h2><blockquote><p>根据提示我们在准备安装时，选择<strong>自定义安装</strong>。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-1stp.png" alt="自定义安装"></p><h2 id="选择虚拟的操作系统"><a href="#选择虚拟的操作系统" class="headerlink" title="选择虚拟的操作系统"></a>选择虚拟的操作系统</h2><p>这里选择 <code>Linux</code> -&gt; <code>Ubuntu</code> 64位。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们下载的系统就是 <code>Ubuntu 18.04</code> 64位。还有很重要的一点，因为安装这个操作系统的目的是作为 <code>Vapor 4.0</code> 的服务器，所以在选用操作系统时，我们不需要图形界面。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-2stp.png" alt="选择操作系统类型"></p><h2 id="选择固件类型"><a href="#选择固件类型" class="headerlink" title="选择固件类型"></a>选择固件类型</h2><p>选择固件类型其实就是选择磁盘引导方式。</p><blockquote><p>相对这两种方式进一步了解，可自行查资料。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-3stp.png" alt="选择引导方式"></p><h2 id="选择虚拟磁盘"><a href="#选择虚拟磁盘" class="headerlink" title="选择虚拟磁盘"></a>选择虚拟磁盘</h2><p>选择虚拟磁盘为虚拟操作系统在本机上开辟操作磁盘的空间。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为不会再虚拟机上做比较大的文件操作， <code>20G</code> 的磁盘空间已经够用。在开辟磁盘空间时，开辟的是空间使用上限，在虚拟操作系统文件所占用的空间以实际使用为准，并不是开辟了多少，就是用多少。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-4stp.png" alt="选择虚拟磁盘"></p><h2 id="完成配置"><a href="#完成配置" class="headerlink" title="完成配置"></a>完成配置</h2><p>点击继续即可完成虚拟机配置。</p><blockquote><p>虚拟机配置采用 <code>VMWare</code> 提供的默认配置即可，不用过多的操作。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-5stp.png" alt="完成配置"></p><h2 id="保存虚拟机文件"><a href="#保存虚拟机文件" class="headerlink" title="保存虚拟机文件"></a>保存虚拟机文件</h2><p>点击保存将虚拟机文件保存在默认文件夹中。</p><blockquote><p>文件的保存位置可以是默认位置，也可以是自定义的位置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-6stp.png" alt="完成配置"></p><h1 id="安装-Ubuntu-18-04"><a href="#安装-Ubuntu-18-04" class="headerlink" title="安装 Ubuntu 18.04"></a><strong>安装 <code>Ubuntu 18.04</code></strong></h1><p>在使用 <code>VMware</code> 完成对 <code>Ubuntu</code>虚拟机配置时，即会进入系统的安装界面。</p><h2 id="开启-CD-DVD-，并选取镜像"><a href="#开启-CD-DVD-，并选取镜像" class="headerlink" title="开启 CD/DVD ，并选取镜像"></a>开启 <code>CD/DVD</code> ，并选取镜像</h2><p>在完成对虚拟机配置之后，进入到引导界面，开启 <code>CD/DVD</code> ，并加载镜像。</p><blockquote><p>因为启动时未加载系统镜像，所在期初会出现引导出错的问题。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-7stp.png" alt="引导失败"></p><blockquote><p>开启CD/DVD，并加载镜像。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-8stp.png" alt="加载镜像"></p><h2 id="选择系统引导语言"><a href="#选择系统引导语言" class="headerlink" title="选择系统引导语言"></a>选择系统引导语言</h2><p>镜像加载完成，选择系统引导语言的默认语言。</p><blockquote><p>安装系统的提示比较简单，也见名知意，所以在安装的全过程，我们均会使用英文完成安装。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-9stp.png" alt="选择系统引导语言"></p><h2 id="选择系统语言"><a href="#选择系统语言" class="headerlink" title="选择系统语言"></a>选择系统语言</h2><p>镜像加载完成，选择操作系统的默认语言。</p><blockquote><p>因为是作为服务器使用，为了避免以后因为字符编码上造成不必要的麻烦，这里选择英文。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-10stp.png" alt="选择系统语言"></p><h2 id="选择键盘布局"><a href="#选择键盘布局" class="headerlink" title="选择键盘布局"></a>选择键盘布局</h2><p>选择键盘布局默认选择英文键盘。</p><blockquote><p>键盘布局选择英文，大部分的笔记本、台式电脑键盘采用英文布局。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-11stp.png" alt="选择键盘布局"></p><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>网络设置主要是设置操作系统的网络链接方式，这里采用默认跟随本机网络变化。</p><blockquote><p>因为是在虚拟软件中使用操作系统，网络配置采用默认配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-12stp.png" alt="网络设置"></p><h2 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h2><p>系统需要一个代理接口联网，默认网络链接走本机。</p><blockquote><p>代理网络可以设置链接特定的网络中，比如公司内网。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-13stp.png" alt="代理设置"></p><h2 id="设置系统镜像"><a href="#设置系统镜像" class="headerlink" title="设置系统镜像"></a>设置系统镜像</h2><p>这里的镜像是软件包的镜像源。</p><blockquote><p>在安装的过程中使用默认的软件包镜像源，后续推荐替换的国内镜像。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-14stp.png" alt="设置系统镜像"></p><h2 id="设置文件系统"><a href="#设置文件系统" class="headerlink" title="设置文件系统"></a>设置文件系统</h2><p>文件系统设置采用默认设置。</p><blockquote><p>选取使用整个磁盘空间。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-15stp.png" alt="设置文件系统"></p><blockquote><p>文件系统采用系统推荐的默认方式配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-16stp.png" alt="设置文件系统"></p><blockquote><p>文件系统分区采用默认的分区方式。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-17stp.png" alt="设置文件系统"></p><h2 id="个人信息设置"><a href="#个人信息设置" class="headerlink" title="个人信息设置"></a>个人信息设置</h2><p>个人信息设置主要是设置 <code>root</code> 账户密码，服务器名称，登录账户及密码。</p><blockquote><p>完成设置信息之后，建议对该信息进行备份保存。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-18stp.png" alt="个人信息设置"></p><h2 id="OpenSSH-设置"><a href="#OpenSSH-设置" class="headerlink" title="OpenSSH 设置"></a><code>OpenSSH</code> 设置</h2><p>OpenSSH可是系统支持远程登录，远程操作。</p><blockquote><p>建议安装，在以后的操作中会比较方便，远程操作软件推荐 <code>SecureCRT</code> 。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-19stp.png" alt="OpenSSH设置"></p><h2 id="服务软件"><a href="#服务软件" class="headerlink" title="服务软件"></a>服务软件</h2><p>这里可以选择性的安装。</p><blockquote><p>针对自己想用的软件进行安装，建议用到什么安装什么。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-20stp.png" alt="服务软件一览"></p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>完成所有的配置之后，系统机会进入安装界面，安装过程比较久。</p><blockquote><p>系统安装时间会长一些，具体看各自电脑配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-21stp.png" alt="安装系统"></p><h1 id="登录-Ubuntu18-04"><a href="#登录-Ubuntu18-04" class="headerlink" title="登录 Ubuntu18.04"></a><strong>登录 <code>Ubuntu18.04</code></strong></h1><p>完成安装之后，系统就会进入终端，输入用户名和密码进入系统。</p><h2 id="输入用户信息"><a href="#输入用户信息" class="headerlink" title="输入用户信息"></a>输入用户信息</h2><p>输入用户名和密码，按照提示输入。</p><blockquote><p>在 <code>2.9</code> 中的用户信息，就是需要的登录信息。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-22stp.png" alt="输入用户信息"></p><blockquote><p>成功进入 <code>Ubuntu</code> 系统中。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-23stp.png" alt="输入用户信息"></p><h1 id="Ubuntu-18-04-个性化配置"><a href="#Ubuntu-18-04-个性化配置" class="headerlink" title="Ubuntu 18.04 个性化配置"></a><strong><code>Ubuntu 18.04</code> 个性化配置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后续会加入一些实用的小技巧：国内的软件源，远程登录、配置数据库、安装 <code>Vapor 4.0</code> 开发环境等。</p>]]></content>
      
      
      <categories>
          
          <category> Vapor4.0 </category>
          
          <category> Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
