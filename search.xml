<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Advanced Swift系列(七): Strings</title>
      <link href="/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%83):%20Strings/"/>
      <url>/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%83):%20Strings/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有现代编程语言都支持  <code>Unicode字符串</code>，但这通常仅意味着本机字符串类型可以存储  <code>Unicode</code>数据-不能保证像获取字符串长度这样的简单操作都将返回“有意义的”结果。实际上，大多数语言以及使用这些语言编写的大多数字符串处理代码都对Unicode固有的复杂性表现出一定程度的否认。这可能会导致一些令人不愉快的错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <code>Swift</code>的字符串实现经过了英勇的努力，以尽可能地实现  <code>Unicode</code>正确。   <code>Swift</code>中的字符串是  <code>字符值的集合</code>，其中字符是文本的人类阅读者会认为是单个字符的字符，无论它由多少个  <code>Unicode标量</code>组成。结果，所有标准的  <code>Collection</code>操作（如  <code>count或prefix（5）</code>）都在用户感知的字符级别上工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这对于正确性来说是很棒的，但是要付出代价，主要是因为不熟悉。如果你习惯于使用其他语言的带有整数索引的字符串，那么  <code>Swift</code>的设计乍一看似乎很笨拙，这使你想知道：为什么我不能写  <code>str [999]</code>来访问字符串的千位字符？为什么  <code>str[idx + 1]</code>没有得到下一个字符？为什么我不能遍历一系列字符值，例如   <code>“a” ...“ z”</code>？它还对性能有影响：  <code>字符串不支持随机访问，即跳转到任意字符不是O(1)操作</code>。不可能是-当字符的宽度可变时，如果不查看前面的所有字符，字符串将不知道第n个字符的存储位置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本章中，我们将详细讨论  <code>字符串架构</code>，以及在  <code>功能</code>和  <code>性能</code>方面充分利用  <code>Swift字符串</code>的一些技术。但是，我们将首先概述所需的  <code>Unicode术语</code>。</p><a id="more"></a><h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><strong>Unicode</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事情曾经是如此简单。   <code>ASCII字符串</code>是一个介于  <code>0到127之间的整数序列</code>。如果将它们存储在8位字节中，你甚至还有一点空余！由于每个字符的大小都是固定的，因此  <code>ASCII字符串</code>可以是<strong>随机访问的</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果你使用英语以外的其他语言或针对非美国受众，则  <code>ASCII</code>还不够。其他国家/地区和语言需要其他字符（即使是英语为英语的英国也需要  <code>£符号</code>）。他们中的大多数人需要的字符数超过了7位。   <code>ISO 8859</code>占用了额外的位，并定义了  <code>ASCII</code>范围以上的16种不同编码，例如第1部分（  <code>ISO 8859-1，又名Latin-1</code>），涵盖了几种西欧语言；第5部分，介绍使用西里尔字母的语言。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，这仍然是有限的：如果你想使用  <code>ISO 8859</code>用土耳其语写有关古希腊的文字，那么你就不走运了，因为你需要选择第7部分（拉丁语/希腊语）或第9部分（土耳其语） 。而且八位仍然不足以编码多种语言。例如，第6部分（拉丁语/阿拉伯语）未包含书写阿拉伯文字（如乌尔都语或波斯语）所需的字符。同时，越南语（基于拉丁字母，但带有大量变音符号组合）只能通过替换下半部分的少数  <code>ASCII字符</code>而适合八位。对于其他东亚语言，这甚至不是一种选择。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你使用固定宽度编码的空间不足时，你可以选择：<strong>增大大小或切换到可变宽度编码</strong>。最初，  <code>Unicode</code>被定义为  <code>2字节固定宽度格式</code>，现在称为  <code>UCS-2</code>。这是在现实开始之前的，并且被接受的是即使两个字节（即约65,000个代码点）也不够用，而对于大多数用途来说，四个字节效率低下。因此，今天  <code>Unicode</code>是一种  <code>可变宽度格式</code>，它在两种不同的意义上是可变的：</p><ul><li>→ 单个字符（也称为扩展图字符集）由一个或多个Unicode标量组成。</li><li>→ 由一个或多个代码单位编码的 scalar。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要理解原因，我们需要弄清楚这些术语的含义。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Unicode</code>的基本构建块是代码点：  <code>Unicode</code>代码空间中的整数值，范围从  <code>0到0x10FFFF</code>（十进制表示法：  <code>1,114,111</code>）。   <code>Unicode</code>中的每个字符或其他脚本单位都分配有唯一的代码点。在  <code>Unicode 12.1</code>（于2019年5月发布）中，目前仅使用了  <code>110万</code>个可用代码点中的  <code>138,000</code>个，因此有很大的空间容纳更多表情符号。代码点通常以带有  <code>“U +”</code>前缀的十六进制表示法编写。例如，欧元符号位于代码点  <code>U+20AC</code>（或  <code>十进制的8364</code>）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Unicode标量</code>与代码点几乎相同，但不完全相同。它们是所有代码点，除了  <code>0xD800到0xDFFF</code>范围内的  <code>2,048</code>个替代代码点（UTF-16编码用来表示大于  <code>65,535</code>的代码点）。标量在  <code>Swift字符串</code>文字中表示为   <code>“\u{xxxx}”</code>，其中  <code>xxxx代表十六进制数字</code>。因此欧元符号可以在  <code>Swift</code>中写为  <code>“€”</code>或   <code>“\u{20AC}”</code>。相应的  <code>Swift类型</code>是  <code>Unicode.Scalar</code>，它是  <code>UInt32</code>值的包装。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用不同的编码方式来编码相同的  <code>Unicode数据</code>（即  <code>标量序列</code>），其中最常见的是  <code>UTF-8</code>和  <code>UTF-16</code>。<strong>编码中的最小实体称为代码单元</strong>。   <code>UTF-8编码</code>具有8位宽的代码单元，而  <code>UTF-16具有16位宽的代码单元</code>。   <code>UTF-8</code>的另一个好处是可以向后移动与8位ASCII兼容-这一功能帮助它取代了  <code>ASCII</code>，成为网络上和文件格式中最受欢迎的编码。代码单位与代码点或标量不同，因为单个标量通常使用多个代码单位进行编码。由于存在超过一百万个潜在代码点，因此  <code>UTF-8</code>只需  <code>1-4个代码单元</code>（一到四个字节）即可对单个标量进行编码，而  <code>UTF-16</code>则需要一个或两个代码单元（两个或四个字节）。   <code>Swift</code>将  <code>UTF-8</code>和  <code>UTF-16代码单元</code>分别表示为  <code>UInt8</code>和  <code>UInt16值</code>（别名为  <code>Unicode.UTF8.CodeUnit</code>和  <code>Unicode.UTF16.CodeUnit</code>）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要用单个代码单位表示每个标量，你需要一个  <code>21位编码方案</code>，该方案通常会四舍五入为  <code>32位</code>，即  <code>UTF-32</code>。这就是  <code>Unicode.Scalar</code>在  <code>Swift</code>中所做的事情。但是，即使那样也不能为你提供固定宽度的编码：在  <code>“字符”</code>方面，  <code>Unicode</code>仍然是可变宽度的格式。用户在屏幕上显示的  <code>“单个字符”</code>可能需要多个标量组合在一起。此类用户感知字符的  <code>Unicode术语</code>是一个（扩展的）字素簇。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标量如何形成字素簇的规则决定了文本的分割方式。例如，如果你敲击键盘上的  <code>Backspace键</code>，则你希望文本编辑器精确删除一个字素簇，即使该  <code>“字符”</code>由多个  <code>Unicode标量</code>组成，每个标量可能在其中使用不同数量的代码单元。文本在内存中的表示。字形簇在  <code>Swift</code>中用  <code>Character类型</code>表示，只要可以形成单个用户感知的字符，它就可以编码任意数量的标量。我们将在下一部分中看到一些示例。</p><h1 id="字素簇和规范对等"><a href="#字素簇和规范对等" class="headerlink" title="字素簇和规范对等"></a><strong>字素簇和规范对等</strong></h1><h2 id="组合标记"><a href="#组合标记" class="headerlink" title="组合标记"></a><strong><em>组合标记</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解 <code>String</code>如何处理 <code>Unicode</code>数据的一种快速方法是查看两种编写 <code>é</code>的不同方法。  <code>Unicode</code>将  <code>U+00E9</code>（带小写的拉丁小写字母e）定义为单个值。 但是，你也可以将其写为纯字母  <code>e</code> ，后跟 <code>U+0301</code>，并加上重音符号。 在这两种情况下，显示的都是 <code>é</code>，并且用户可能有一个合理的期望，即显示为 <code>“résumé”</code>的两个字符串不仅彼此相等，而且具有六个字符的“长度”，无论使用哪种技术在任一字符中产生 <code>é</code>。 它们将是 <code>Unicode</code>规范所描述的规范等效项。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code>中，这正是你得到的行为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> single = <span class="string">"Pok\u&#123;00E9&#125;mon"</span> <span class="comment">// Pokémon </span></span><br><span class="line"><span class="keyword">let</span> double = <span class="string">"Poke\u&#123;0301&#125;mon"</span> <span class="comment">// Pokémon</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它们都显示相同：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(single, double) <span class="comment">// ("Pokémon", "Pokémon")</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两者的字符数相同：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">single.<span class="built_in">count</span> <span class="comment">// 7 double.count // 7</span></span><br><span class="line">``` </span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此，它们也比较相等：</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line">single == double <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有下拉至基础表示的视图，你才能看到它们是不同的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">single.unicodeScalars.<span class="built_in">count</span> <span class="comment">// 7 </span></span><br><span class="line">double.unicodeScalars.<span class="built_in">count</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将其与 <code>Foundation</code>中的 <code>NSString</code>进行比较：两个字符串不相等，并且 <code>length</code>属性（许多 <code>Objective-C</code>程序员可能会用来计算要在屏幕上显示的字符数）会得出不同的结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nssingle = single <span class="keyword">as</span> <span class="type">NSString</span> nssingle.length <span class="comment">// 7</span></span><br><span class="line"><span class="keyword">let</span> nsdouble = double <span class="keyword">as</span> <span class="type">NSString</span> nsdouble.length <span class="comment">// 8</span></span><br><span class="line">nssingle == nsdouble <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里， <code>==</code>被定义为用于比较两个对象的版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: NSObject, rhs: NSObject)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.isEqual(rhs) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 <code>NSString</code>，这将在 <code>UTF-16</code>代码单元的级别上进行字面比较，而不是一个等效但组成不同的字符。 其他语言的大多数字符串 <code>API</code>也会以这种方式工作。 如果你确实想对两个 <code>NSString</code>执行规范比较，则必须使用 <code>NSString.compare（_ :)</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，比较代码单元有一个很大的好处：更快！ 通过 <code>utf8</code>视图，使用 <code>Swift字符串</code>仍然可以实现以下效果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">single.utf8.elementsEqual(double.utf8) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么 <code>Unicode</code>完全支持同一字符的多种表示形式？ 预组合字符的存在使 <code>Unicode</code>代码点的开放范围与 <code>Latin-1兼容</code>，后者已经具有 <code>é</code>和 <code>ñ</code>等字符。 尽管可能很难处理，但它使两种编码之间的转换变得简单快捷。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而且，抛弃预先合成的表格也无济于事，因为合成不仅会成对出现。 你可以一起写多个变音符号。 例如， <code>约鲁巴语（Yoruba）</code>具有字符 <code>ọ́</code>，可以用三种不同的方式书写：通过用点组成 <code>ó</code>，或用尖点组成,，或用尖点和点组成 <code>o</code>。 对于最后一个，这两个变音符号可以处于任何顺序！ 所以这些都相等：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> chars: [<span class="type">Character</span>] = [ </span><br><span class="line">    <span class="string">"\u&#123;1ECD&#125;\u&#123;300&#125;"</span>, <span class="comment">// ọ́ </span></span><br><span class="line">    <span class="string">"\u&#123;F2&#125;\u&#123;323&#125;"</span>, <span class="comment">// ọ́ </span></span><br><span class="line">    <span class="string">"\u&#123;6F&#125;\u&#123;323&#125;\u&#123;300&#125;"</span>, <span class="comment">// ọ́ </span></span><br><span class="line">    <span class="string">"\u&#123;6F&#125;\u&#123;300&#125;\u&#123;323&#125;"</span> <span class="comment">//ọ́</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> allEqual = chars.<span class="built_in">dropFirst</span>().allSatisfy &#123; $<span class="number">0</span> == chars.first &#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，可以无限地添加一些变音符号。 一个著名的互联网模因很好地说明了这一点：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zalgo = <span class="string">"so̐ ͜ ͅoͯ ͟n̽ ̢ ͇̫͉̰ͪ"</span></span><br><span class="line">zalgo.<span class="built_in">count</span> <span class="comment">// 4 </span></span><br><span class="line">zalgo.utf8.<span class="built_in">count</span> <span class="comment">// 68</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的代码中， <code>zalgo.count</code>（正确）返回4，而 <code>zalgo.utf8.count</code>返回68。如果你的代码不能与网状模因一起正常使用，那有什么用，真的吗？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你处理的所有字符串均为 <code>纯ASCII</code>时， <code>Unicode</code>的字素打破规则甚至会影响你： <code>CR + LF</code>（在Windows中通常用作换行符的回车符和换行符）是单个字素：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CR+LF is a single Character.</span></span><br><span class="line"><span class="keyword">let</span> crlf = <span class="string">"\r\n"</span> </span><br><span class="line">crlf.<span class="built_in">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a><strong><em>Emoji</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在各种其他编程语言中，包含表情符号的字符串也可能令人惊讶。 为许多表情符号分配了 <code>Unicode标量</code>，这些标量不适合单个 <code>UTF-16代码单元</code>。 将字符串表示为 <code>UTF-16代码单元</code>集合的语言（例如Java或C＃）会说字符串“:joy:”是两个“字符”长。 Swift可以正确处理这种情况：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneEmoji = <span class="string">":joy:"</span> <span class="comment">// U+1F602 </span></span><br><span class="line">oneEmoji.<span class="built_in">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，重要的是字符串如何暴露给程序，而不是如何存储在内存中。  <code>Swift</code>使用 <code>UTF-8</code>作为 <code>非ASCII字符串</code>的内部编码，但这是实现细节。 公用API基于字素簇。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他表情符号由多个标量组成。 表情符号标志是与 <code>ISO国家/地区代码</code>相对应的两个区域指示器符号的组合。 <code>Swift</code>将标志正确地视为一个字符(:cn::it:)：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flags = <span class="string">":cn: :it:"</span> </span><br><span class="line">flags.<span class="built_in">count</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要检查字符串组成的 <code>Unicode标量</code>，请使用 <code>unicodeScalars视图</code>。 在这里，我们以代码点的通用格式将标量值格式化为十六进制数字：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flags.unicodeScalars.<span class="built_in">map</span> &#123;  </span><br><span class="line">    <span class="string">"U+\(String($0.value, radix: 16, uppercase: true))"</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["U+1F1E7", "U+1F1F7", "U+1F1F3", "U+1F1FF"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;肤色将基本字符与五个肤色修改器（例如 :facepunch:，或4型肤色修改器）之一结合使用，以产生最终的表情符号（例如:person_with_blond_hair:）。 同样，Swift可以正确处理此问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> skinTone = <span class="string">" "</span> <span class="comment">//  </span></span><br><span class="line">skinTone.<span class="built_in">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;描绘家庭和夫妇的表情符号（例如和）对 <code>Unicode标准体系</code>提出了另一个挑战。 由于性别和群体人数的无数可能组合，为每种变化提供单独的代码点是有问题的。 结合每个人独特的肤色，就不可能了。  <code>Unicode</code>通过指定这些表情符号实际上是多个表情符号的序列以及不可见的零宽度连接符（ZWJ）字符（U+200D）来解决此问题。 因此，家庭实际上是男人 + ZWJ +女人+ ZWJ +女孩+ ZWJ +男孩。 ZWJ用作操作系统的指示符，它应使用单个字形（如果有）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以验证这确实是怎么回事：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> family1 = <span class="string">" "</span></span><br><span class="line"><span class="keyword">let</span> family2 = <span class="string">" \u&#123;200D&#125;   \u&#123;200D&#125;   \u&#123;200D&#125; "</span></span><br><span class="line">family1 == family2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再一次，Swift足够聪明，可以将这样的序列视为单个角色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">family1.<span class="built_in">count</span> <span class="comment">// 1 </span></span><br><span class="line">family2.<span class="built_in">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2016年推出的针对职业的新表情符号也是ZWJ序列。例如，女消防员由女性+ ZWJ +消防车组成，而男性卫生工作者由男性+ ZWJ + Aesculapius staff的职员组成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将这些序列渲染为单个字形是操作系统的任务。在2019年的Apple平台上，操作系统包括 <code>Unicode序列子集</code>的字形标准列为“推荐用于一般互换”（RGI），即“最有可能在多个平台上得到广泛支持的标准”。当没有字形可用于语法上有效的序列时，文本呈现系统将退回以将每个组件呈现为单独的字形。请注意，这可能会导致用户感知的字符与Swift视为字素簇的字符“在另一个方向上”不匹配；到目前为止，所有示例都与编程语言中字符过多有关，但在这里我们看到了相反的情况。例如，包含肤色的家族序列当前不属于RGI子集。但是，即使操作系统将这样的序列渲染为多个字形，Swift仍会将其视为单个字符，因为Unicode文本分段规则与渲染无关：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Family with skin tones is rendered as multiple glyphs // on most platforms in 2019.</span></span><br><span class="line"><span class="keyword">let</span> family3 = <span class="string">" \u&#123;200D&#125; \u&#123;200D&#125;   \u&#123;200D&#125; "</span> <span class="comment">// But Swift still counts it as a single Character. </span></span><br><span class="line">family3.<span class="built_in">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顺便说一下，微软已经可以将此图形和其他变体呈现为单个字形，并且其他操作系统供应商几乎肯定会很快推出。 但是问题仍然存在：无论字符串API的设计多么仔细，文本都非常复杂，以至于它可能永远无法抓住所有极端情况。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过去， <code>Swift</code>难以跟上 <code>Unicode</code>更改的步伐。  <code>Swift 3</code>误处理了肤色和ZWJ序列，因为其字素破坏算法基于旧版本的 <code>Unicode标准</code>。 从Swift 4开始，Swift使用操作系统的 <code>ICU库</code>。 因此，当用户更新其操作系统时，你的程序将自动采用新的 <code>Unicode规则</code>。 当然，另一方面，你不能依靠用户看到与开发期间相同的行为。 例如，当你在Linux上部署服务器端Swift代码时，代码的行为可能会有所不同，因为Linux发行版可能附带的ICU版本与开发计算机的版本不同。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节讨论的示例中，我们将字符串的长度作为代理，以解决当某种语言没有考虑到 <code>Unicode</code>的全部复杂性时可能出错的各种情况。 只是想一想，一个简单的任务（例如，反转字符串）可能会以一种编程语言产生，当字符串包含组成的字符序列时，该编程语言不会通过字素簇处理字符串。 这不是一个新问题，但是表情符号爆炸使由草率的文本处理引起的错误更有可能浮出水面，即使你的用户群主要是说英语，也会出现草率的文本处理问题。 错误的数量也增加了：十年前，一个重音符号变差会导致一个错误的产生，弄乱一个现代表情符号很容易导致结果偏离10个或更多“字符”。 例如，一个四人家庭表情符号的长度为 <code>11（UTF-16）</code>或 <code>25（UTF-8）</code>个代码单位：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">family1.<span class="built_in">count</span> <span class="comment">// 1 </span></span><br><span class="line">family1.utf16.<span class="built_in">count</span> <span class="comment">// 11 </span></span><br><span class="line">family1.utf8.<span class="built_in">count</span> <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并不是说其他语言根本没有 <code>Unicode</code>正确的API，大多数语言都没有。 例如， <code>NSString</code>具有 <code>enumerateSubstrings</code>方法，可用于通过字素簇在字符串中遍历。 但是违约很重要。 Swift的工作重点是默认情况下做正确的事。 而且，如果你需要降低到较低的抽象级别，则 <code>String</code>提供的视图可让你直接在 <code>Unicode标量</code>或代码单元上进行操作。 我们将在下面详细介绍。</p><h1 id="Strings-and-Collections"><a href="#Strings-and-Collections" class="headerlink" title="Strings and Collections"></a><strong>Strings and Collections</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如我们所见，<strong>String是Character值的集合</strong>。 在Swift成立的头三年，String在符合和不符合 <code>Collection协议</code>之间来回走动。 不增加一致性的理由是，程序员希望所有通用的集合处理算法都是完全安全且Unicode正确的，这不一定对所有边缘情况都适用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举一个简单的例子，你可以假设如果连接两个集合，则结果集合的长度将是两个源集合的长度之和。 但是，如果第一个字符串的后缀形成带有第二个字符串前缀的字素簇，则这不适用于字符串：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flagLetterJ = <span class="string">"🇯 "</span> </span><br><span class="line"><span class="keyword">let</span> flagLetterP = <span class="string">"🇵 "</span></span><br><span class="line"><span class="keyword">let</span> flag = flagLetterJ + flagLetterP <span class="comment">//</span></span><br><span class="line">flag.<span class="built_in">count</span> <span class="comment">// 1</span></span><br><span class="line">flag.<span class="built_in">count</span> == flagLetterJ.<span class="built_in">count</span> + flagLetterP.<span class="built_in">count</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为此，在 <code>Swift 2</code>和 <code>Swift 3</code>中， <code>String</code>本身不是一个 <code>Collection</code>。 字符集合视图已移至字符属性，与其他集合视图类似： <code>unicodeScalars</code>， <code>utf8</code>和 <code>utf16</code>。 选择一个特定的视图会提示你确认你已进入收集处理模式，并且应考虑将要运行的算法的后果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，对于某些与实际代码几乎不相关的极端情况，这种更改导致的可用性和可学习性的损失远远超过了正确性的获得（除非你正在编写文本编辑器）。 因此String在Swift 4中再次成为 <code>Collection</code>。</p><h2 id="双向而非随机访问"><a href="#双向而非随机访问" class="headerlink" title="双向而非随机访问"></a><strong><em>双向而非随机访问</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，出于上一节中的示例应该清楚的原因， <code>String</code>不是随机访问集合。当知道特定字符串的第n个字符在哪里时，会涉及评估该字符之前有多少个Unicode标量呢？因此， <code>String</code>仅符合 <code>BidirectionalCollection</code>。你可以从字符串的任意一端开始，向前或向后移动，并且代码将查看相邻字符的组成，并跳过正确的字节数。但是，你需要一次上下迭代一个字符。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编写字符串处理代码时，请记住这一点对性能的影响。依靠随机访问来维持其性能保证的算法与 <code>Unicode字符串</code>不是很好的匹配。考虑使用此 <code>String扩展名</code>来生成字符串前缀列表，该扩展名的工作方式是生成一个从零到字符串长度的整数范围，然后在该范围内映射以为每个长度创建前缀：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes1: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>...<span class="built_in">count</span>).<span class="built_in">map</span>(<span class="keyword">prefix</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> hello = <span class="string">"Hello"</span></span><br><span class="line">hello.allPrefixes1 <span class="comment">// ["", "H", "He", "Hel", "Hell", "Hello"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这段代码看起来很简单，但是效率很低。 它首先在字符串上遍历一次以计算长度，这很好。 但是然后，对 <code>prefix</code>的n +1个调用中的每一个都是另一个O（n）操作，因为 <code>prefix</code>总是从头开始，并且必须按照自己的方式工作通过字符串来计算所需的字符数。 在另一个线性循环内运行一个线性过程意味着该算法偶然为O（n2）-随着字符串长度的增加，该算法花费的时间成倍增加。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果可能的话，高效的字符串算法应该只遍历一个字符串，然后对字符串索引进行操作以表示其感兴趣的子字符串。以下是该算法的一个更好的版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes2: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">""</span>] + <span class="built_in">indices</span>.<span class="built_in">map</span> &#123; index <span class="keyword">in</span> <span class="keyword">self</span>[...index] &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">hello.allPrefixes2 <span class="comment">// ["", "H", "He", "Hel", "Hell", "Hello"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此代码还必须遍历字符串一次以生成索引集合。 但是一旦完成， <code>map</code>内部的下标操作为O（1）。 这使得整个算法为O（n）。</p><h2 id="范围可替换，不可更改"><a href="#范围可替换，不可更改" class="headerlink" title="范围可替换，不可更改"></a><strong><em>范围可替换，不可更改</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串也符合 <code>RangeReplaceableCollection</code>。 这是一个如何替换字符串的一部分的示例，该过程将首先根据字符串索引确定适当的范围，然后调用 <code>replaceSubrange</code>。 替换字符串的长度可以不同，甚至可以为空（这等效于调用 <code>removeSubrange</code>）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello, world!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> comma = greeting.firstIndex(of: <span class="string">","</span>) &#123;</span><br><span class="line">    greeting[..&lt;comma] <span class="comment">// Hello</span></span><br><span class="line">    greeting.replaceSubrange(comma..., with: <span class="string">" again."</span>) </span><br><span class="line">&#125;</span><br><span class="line">greeting <span class="comment">// Hello again.</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与往常一样，请记住，如果替换字符串的某些部分的结果可能令人惊讶在原始字符串中形成带有相邻字符的新字素簇。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串不提供的一种类似于集合的功能是 <code>MutableCollection</code>。除了get之外，该协议还向集合添加了一个功能-单元素下标集的功能。这并不是说字符串不是可变的-正如我们刚刚看到的那样，它们具有几种突变方法。但是，你不能使用下标运算符替换单个字符。原因回到了可变长度字符。就像 <code>Array</code>一样，大多数人可能会发现单元素下标更新将在恒定时间内发生。但是，由于字符串中的字符宽度可能可变，因此更新单个字符可能会花费与字符串长度成比例的线性时间：更改单个元素的宽度将需要在内存中向上或向下调整所有后面的元素。此外，替换后的索引将通过改组变得无效，这同样是不直观的。由于这些原因，即使你传递的范围只是一个字符，也必须使用 <code>replaceSubrange</code>。</p><h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a><strong><em>字符串索引</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与往常一样，请记住，如果替换字符串的某些部分的结果可能令人惊讶在原始字符串中形成带有相邻字符的新字素簇。<br>大多数编程语言都使用整数来下标字符串，例如 <code>str [5]</code>将返回str的第六个“字符”（无论该语言对“字符”的想法是什么）。  <code>Swift</code>不允许这样做。为什么？答案现在应该听起来对你很熟悉：下标应该花固定的时间（根据集合协议的要求直观地），并且如果不查看前面的所有字节，则查找第n个字符是不可能的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与往常一样，请记住，如果替换字符串的某些部分的结果可能令人惊讶在原始字符串中形成带有相邻字符的新字素簇。<br> <code>String.Index</code>是 <code>String及其视图使用的索引类型</code>，它是一个不透明的值，实际上将字节偏移量存储在字符串的内存表示形式（通常为UTF-8）中。如果要计算第n个字符的索引并必须从字符串的开头开始，它仍然是O（n）操作，但是一旦有了有效的索引，对字符串进行下标将只需要O（1）时间。至关重要的是，<strong>在现有索引之后查找下一个索引也很快，因为你可以从现有索引的字节偏移量开始-无需再次回到起始位置</strong>。这就是为什么按顺序（向前或向后）遍历字符串中的字符有效的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与往常一样，请记住，如果替换字符串的某些部分的结果可能令人惊讶在原始字符串中形成带有相邻字符的新字素簇。<br>字符串索引操作基于与其他集合相同的 <code>Collection API</code>。很容易错过这种对等关系，因为到目前为止我们使用的收藏最多—数组—使用整数索引，我们通常使用简单的算术来操作它们。  <code>index（after :)</code>方法返回下一个字符的索引：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"abcdef"</span></span><br><span class="line"><span class="keyword">let</span> second = s.index(after: s.startIndex) </span><br><span class="line">s[second] <span class="comment">// b</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与往常一样，请记住，如果替换字符串的某些部分的结果可能令人惊讶在原始字符串中形成带有相邻字符的新字素簇。<br>你可以通过 <code>index（_：offsetBy :)</code>方法一次性自动遍历多个字符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Advance 4 more characters.</span></span><br><span class="line"><span class="keyword">let</span> sixth = s.index(second, offsetBy: <span class="number">4</span>) </span><br><span class="line">s[sixth] <span class="comment">// f</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与往常一样，请记住，如果替换字符串的某些部分的结果可能令人惊讶在原始字符串中形成带有相邻字符的新字素簇。<br>如果存在前进到字符串末尾的风险，则可以添加一个 <code>limitedBy：</code>参数。 如果在达到目标索引之前达到极限，则该方法返回nil：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> safeIdx = s.index(s.startIndex, offsetBy: <span class="number">400</span>, limitedBy: s.endIndex) safeIdx <span class="comment">// nil</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与往常一样，请记住，如果替换字符串的某些部分的结果可能令人惊讶在原始字符串中形成带有相邻字符的新字素簇。<br>毫无疑问，这比简单的整数索引所需的代码更多，但这就是重点。 如果 <code>Swift</code>允许对字符串进行整数下标，那么无意编写极其低效的代码（例如通过在循环内使用整数下标）的诱惑将太大。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与往常一样，请记住，如果替换字符串的某些部分的结果可能令人惊讶在原始字符串中形成带有相邻字符的新字素簇。<br>不过，对于那些习惯于使用固定宽度字符的人来说，在 <code>Swift</code>中使用字符串乍一看似乎具有挑战性-在没有整数索引的情况下如何导航？ 确实，一些看似简单的任务（例如提取字符串的前四个字符）可能会变成这样的怪诞现象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[..&lt;s.index(s.startIndex, offsetBy: <span class="number">4</span>)] <span class="comment">// abcd</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与往常一样，请记住，如果替换字符串的某些部分的结果可能令人惊讶在原始字符串中形成带有相邻字符的新字素簇。<br>但是值得庆幸的是，能够通过 <code>Collection接口</code>访问该字符串还意味着你可以使用几种有用的技术。 在 <code>Array</code>上运行的大多数方法也可以在 <code>String</code>上运行。 使用 <code>prefix方法</code>，同一件事看起来更加清晰：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="keyword">prefix</span>(<span class="number">4</span>) <span class="comment">// abcd</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与往常一样，请记住，如果替换字符串的某些部分的结果可能令人惊讶在原始字符串中形成带有相邻字符的新字素簇。<br>（请注意，任何一个表达式都返回一个 <code>Substring</code>；你可以通过以下方式将其转换回 <code>String：</code>将其包装在 <code>String.init</code>中。 我们将在下一节中进一步讨论子字符串。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与往常一样，请记住，如果替换字符串的某些部分的结果可能令人惊讶在原始字符串中形成带有相邻字符的新字素簇。<br>作为稍微复杂一点的示例，可以从日期字符串中提取月份为完全完成而无需对字符串进行任何下标操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="string">"2019-09-01"</span> </span><br><span class="line">date.<span class="built_in">split</span>(separator: <span class="string">"-"</span>)[<span class="number">1</span>] <span class="comment">// 09 </span></span><br><span class="line">date.<span class="built_in">dropFirst</span>(<span class="number">5</span>).<span class="keyword">prefix</span>(<span class="number">2</span>) <span class="comment">// 09</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与往常一样，请记住，如果替换字符串的某些部分的结果可能令人惊讶在原始字符串中形成带有相邻字符的新字素簇。<br>要查找特定字符，可以使用 <code>firstIndex(of: )</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">"Hello!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> idx = hello.firstIndex(of: <span class="string">"!"</span>) &#123;</span><br><span class="line">    hello.insert(contentsOf: <span class="string">", world"</span>, at: idx) </span><br><span class="line">&#125;</span><br><span class="line">hello <span class="comment">// Hello, world!</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>insert(contentsOf: at:)</code>方法在给定索引之前插入另一个具有相同元素类型的集合（例如字符串的字符）。 这不必是另一个 <code>String</code>； 你可以轻松地将字符数组插入字符串中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，有些任务不能仅通过对字符串使用 <code>Collection API</code>来完成： <code>解析CSV文件</code>就是一个很好的例子。 我们不能简单地用逗号分隔一行，因为逗号也可能出现在用引号引起来的值中。 为了解决这样的任务，我们可以逐个字符地遍历字符串，同时跟踪某些状态。 本质上，我们正在编写一个非常简单的解析器：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(csv: String)</span></span> -&gt; [[<span class="type">String</span>]] &#123; </span><br><span class="line">    <span class="keyword">var</span> result: [[<span class="type">String</span>]] = [[]]</span><br><span class="line">    <span class="keyword">var</span> currentField = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> inQuotes = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> csv &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">c</span>, inQuotes) &#123; </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们将结果创建为字符串数组的数组。 每行由一个字符串数组表示，并且CSV字符串可以包含许多行。 当我们遍历字符串时，currentField变量充当缓冲区来收集一个字段的字符。 最后，inQuotes布尔值可跟踪我们当前是否在带引号的字符串中。 这是我们用于此简单解析器的唯一状态。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们要为 <code>switch语句</code>填写案例：</p><ul><li>→ <strong>(“,”，false)</strong> - 引号之外的逗号发送当前字段</li><li>→ <strong>(“ \ n”, false)</strong> - 引号外的逗号替换当前行</li><li>→ <strong>(“\”“, _)</strong> - 引号括起来的布尔型</li><li>→ <strong>默认值</strong> -在所有其他情况下，我们都将当前字符附加到 <code>currentField</code></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(csv: String)</span></span> -&gt; [[<span class="type">String</span>]] &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> csv &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">c</span>, inQuotes) &#123; </span><br><span class="line">            <span class="keyword">case</span> (<span class="string">","</span>, <span class="literal">false</span>):</span><br><span class="line">                result[result.endIndex-<span class="number">1</span>].append(currentField)</span><br><span class="line">                currentField.removeAll() <span class="keyword">case</span> (<span class="string">"\n"</span>, <span class="literal">false</span>):</span><br><span class="line">                result[result.endIndex-<span class="number">1</span>].append(currentField) currentField.removeAll()</span><br><span class="line">                result.append([])</span><br><span class="line">            <span class="keyword">case</span> (<span class="string">"\""</span>, <span class="number">_</span>):</span><br><span class="line">                inQuotes = !inQuotes</span><br><span class="line">                <span class="keyword">default</span>: currentField.append(<span class="built_in">c</span>)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    result[result.endIndex-<span class="number">1</span>].append(currentField)</span><br><span class="line">    <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(我们正在创建一个临时元组，以一次切换两个值。你可能还记得<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E5%85%AD):%20%20Enums/"><strong><em><code>Enums</code></em></strong></a>一章中的这项技术。)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在for循环之后，由于 <code>CSV字符串</code>可能不会以换行符结尾，因此在返回结果之前，我们仍然必须最后一次附加 <code>currentField</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们尝试一个示例的 <code>CSV解析器</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> csv = #<span class="string">"""</span></span><br><span class="line"><span class="string">"Values in quotes","can contain , characters" "Values without quotes work as well:",42 """</span>#</span><br><span class="line">parse(csv: csv)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[["Values in quotes", "can contain , characters"],</span></span><br><span class="line"><span class="comment">["Values without quotes work as well:", "42"]] */</span></span><br></pre></td></tr></table></figure><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的字符串文字使用扩展的定界符语法（将字符串文字包含在＃个字符中），这使我们能够在字符串文字中编写引号而不必对其进行转义。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能够编写像这样的小型解析器可以大大提高你的字符串处理技能。这样，使用 <code>Collection API</code>甚至正则表达式很难或不可能完成的任务通常变得很简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的 <code>CSV解析器</code>尚未完成，但已经很有用。这很短，因为我们不必跟踪很多状态；只有一个布尔变量。通过一些额外的工作，我们可以忽略空行，忽略带引号的字段周围的空格，并支持在带引号的字段内对引号进行转义（通过使用两个引号字符）。然后，我们将使用枚举明确区分所有可能的状态，而不是使用单个布尔值来跟踪解析器的状态。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，我们添加到解析器的状态越多，在实现中就容易出错。因此，仅在非常简单的分析任务中才建议在单个循环中进行这种分析。如果我们必须跟踪更多状态，则必须改变策略，从在单个循环中编写所有内容到将解析器分解为多个功能。</p><h2 id="Substrings"><a href="#Substrings" class="headerlink" title="Substrings"></a><strong><em>Substrings</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与所有集合一样， <code>String</code>具有名为 <code>Substring</code>的特定切片或 <code>SubSequence类型</code>。 子字符串非常类似于 <code>ArraySlice：</code>它是具有不同起始索引和结束索引的基本字符串的视图。 子字符串共享其基本字符串的文本存储。 切片字符串的好处是非常便宜的操作。 在以下示例中创建 <code>firstWord</code>变量不需要昂贵的副本或内存分配：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence = <span class="string">"The quick brown fox jumped over the lazy dog."</span> </span><br><span class="line"><span class="keyword">let</span> firstSpace = sentence.firstIndex(of: <span class="string">" "</span>) ?? sentence.endIndex </span><br><span class="line"><span class="keyword">let</span> firstWord = sentence[..&lt;firstSpace] <span class="comment">// The</span></span><br><span class="line">type(of: firstWord) <span class="comment">// Substring</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>廉价切片</code>在循环中非常重要，在循环中，你遍历整个（可能很长）字符串以提取其分量。 诸如查找文本中所有单词的出现或 <code>解析CSV文件之类</code>的任务都浮现在脑海。 在这种情况下，非常有用的字符串处理操作是拆分。 <code>split方法</code>是在 <code>Collection</code>和返回子序列的数组（即 <code>[Substring]</code>）。 其最常见的变体定义如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(separator: Element, maxSplits: Int = Int.<span class="built_in">max</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    omittingEmptySubsequences: Bool = <span class="literal">true</span>)</span></span> -&gt; [<span class="type">SubSequence</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以像这样使用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> poem = <span class="string">"""</span></span><br><span class="line"><span class="string">Over the wintry</span></span><br><span class="line"><span class="string">forest, winds howl in rage with no leaves to blow. """</span></span><br><span class="line"><span class="keyword">let</span> lines = poem.<span class="built_in">split</span>(separator: <span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">// ["Over the wintry", "forest, winds howl in rage", "with no leaves to blow."] </span></span><br><span class="line">type(of: lines) <span class="comment">// Array&lt;Substring&gt;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这可以起到类似于 <code>component(separatedBy: )</code>方法的作用， <code>String</code>从 <code>NSString</code>继承，并添加了有关是否删除空组件的配置。 同样，不复制输入字符串。 此外，由于 <code>split</code>的另一种变体需要关闭，因此它不仅可以比较字符，还可以做更多的事情。 这是原始自动换行算法的示例，其中的闭包捕获了到目前为止的行长计数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">wrapped</span><span class="params">(after maxLength: Int = <span class="number">70</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> lineLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> lines = <span class="keyword">self</span>.<span class="built_in">split</span>(omittingEmptySubsequences: <span class="literal">false</span>) &#123; character <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> character.isWhitespace &amp;&amp; lineLength &gt;= maxLength &#123;      </span><br><span class="line">                lineLength = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                lineLength += <span class="number">1</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lines.joined(separator: <span class="string">"\n"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sentence.wrapped(after: <span class="number">15</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The quick brown fox jumped over the lazy dog.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者，考虑编写采用多个分隔符序列的版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">split</span>&lt;S: Sequence&gt;<span class="params">(separators: S)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">    <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">S</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">split</span> &#123; separators.<span class="built_in">contains</span>($<span class="number">0</span>) &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，你可以编写以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello, world!"</span>.<span class="built_in">split</span>(separators: <span class="string">",! "</span>) <span class="comment">// ["Hello", "world"]</span></span><br></pre></td></tr></table></figure><h2 id="StringProtocol"><a href="#StringProtocol" class="headerlink" title="StringProtocol"></a><strong><em>StringProtocol</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子字符串具有与字符串几乎相同的接口。 这是通过一个通用的协议 <code>StringProtocol</code>来实现的，这两种类型都符合。 由于几乎整个字符串 <code>API</code>都是在 <code>StringProtocol上定义</code>的，因此你可以像处理 <code>String</code>一样使用 <code>Substring</code>。 不过，在某些时候，你必须将子字符串转换回 <code>String实例</code>； 与所有切片一样，子字符串仅用于短期存储，以避免在操作过程中产生昂贵的副本。 操作完成后，如果要存储结果或将结果传递给另一个子系统，则应创建一个新的 <code>String</code>。 你可以通过使用子字符串初始化 <code>String</code>来完成此操作，如本例所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastWord</span><span class="params">(<span class="keyword">in</span> input: String)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">    <span class="comment">// Process the input, working on substrings.</span></span><br><span class="line">    <span class="keyword">let</span> words = input.<span class="built_in">split</span>(separators: [<span class="string">","</span>, <span class="string">" "</span>])</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> lastWord = words.last <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Convert to String for return.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(lastWord) </span><br><span class="line">&#125;</span><br><span class="line">lastWord(<span class="keyword">in</span>: <span class="string">"one, two, three, four, five"</span>) <span class="comment">// Optional("five")</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;阻止长期存储子字符串的理由是，<strong>子字符串始终保留在整个原始字符串上</strong>。即使原始字符串的生命周期通常已经结束，代表巨大字符串的单个字符的子字符串也会将整个字符串保存在内存中。因此，<strong>子字符串的长期存储将有效地导致内存泄漏，因为即使原来的字符串不再可用，它们也必须保留在内存中</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过在操作过程中使用子字符串，并仅在最后创建新的字符串，我们将副本推迟到最后一刻，并确保仅产生那些实际需要的副本的成本。在上面的示例中，我们将整个（可能很长的）字符串拆分为子字符串，但是最后只花了一个短子字符串的单个副本的费用。 （请暂时忽略此算法的有效性；从最后开始迭代，直到找到第一个分隔符将是更好的方法。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遇到仅在要传递字符串时仅接受子字符串的函数的情况比较少见-大多数函数应采用字符串或任何符合 <code>StringProtocol的类型</code>。但是，如果确实需要传递 <code>Substring</code>，最快的方法是使用 <code>range运算符</code>对字符串进行下标…，而不指定任何边界：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Substring with identical start and end index as the base string.</span></span><br><span class="line"><span class="keyword">let</span> substring = sentence[...]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义Words集合时，我们已经在关于 <strong><code>集合协议</code></strong> 的章节中看到了这样的示例。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Substring类型</code>是在 <code>Swift 4</code>中引入的。在 <code>Swift 3</code>中， <code>String.CharacterView</code>曾经是它自己的切片类型。 这样做的好处是用户只需要了解一种类型，但这意味着存储的子字符串即使在正常情况下也可以保留整个原始字符串缓冲区。 通过引入 <code>Substring</code>， <code>Swift</code>在便利性方面付出了小小的损失，换来了廉价的切片操作和可预测的内存使用。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会想充分利用 <code>StringProtocol</code>的存在，并将所有 <code>API</code>转换为采用 <code>StringProtocol实例</code>而不是纯字符串。 但是Swift团队的建议是不要这样做：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的一般建议是坚持使用String。 大多数API仅使用String而不是通用即可（这本身会付出一定的代价），因此使用String会更加简单明了，并且在少数情况下需要用户转换并不是很大的负担。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此规则的例外是极有可能与子字符串一起使用的 <code>API</code>，同时又无法进一步推广到 <code>Sequence</code>或 <code>Collection级别</code>。 标准库中的一个示例是 <code>joind方法</code>。 标准库为符合 <code>StringProtocol</code>的元素的序列提供了重载：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">StringProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Returns a new string by concatenating the elements of the sequence, </span></span><br><span class="line">    <span class="comment">/// adding the given separator between each element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">joined</span><span class="params">(separator: String = <span class="string">""</span>)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这使你可以直接在子字符串数组上调用 <code>join</code>（例如，从拆分调用中获得），而不必映射到数组并将每个子字符串复制到新字符串中。 这样更方便，更快。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接受字符串并将其转换为数字的数字类型初始值设定项也采用 <code>StringProtocol</code>值。 同样，如果要处理子字符串数组，这特别方便：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> commaSeparatedNumbers = <span class="string">"1,2,3,4,5"</span></span><br><span class="line"><span class="keyword">let</span> numbers = commaSeparatedNumbers.<span class="built_in">split</span>(separator: <span class="string">","</span>)</span><br><span class="line">.compactMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125; </span><br><span class="line">numbers <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于子字符串旨在缩短寿命，因此通常不建议从函数中返回子字符串，除非我们谈论的是返回切片的 <code>Sequence API</code>或 <code>Collection API</code>。如果你编写了只对字符串有意义的类似函数，则让该函数返回一个子字符串会告诉读者它没有进行复制。创建需要内存分配的新字符串的函数（例如 <code>uppercased（）</code>）应始终返回 <code>String实例</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要使用新功能扩展 <code>String</code>，请将扩展名放在 <code>StringProtocol</code>上是使 <code>String</code>和 <code>Substring</code>之间的 <code>API</code>表面保持一致的一个好主意。  <code>StringProtocol</code>明确设计为可以在以前扩展 <code>String</code>时使用。如果要将现有扩展名从 <code>String</code>移到 <code>StringProtocol</code>，则唯一要做的更改是将 <code>self</code>的任何传递替换为采用 <code>String（self）</code>的具体 <code>String</code>的 <code>API</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是请记住， <code>StringProtocol</code>不能用作你自己的自定义字符串类型的一致性目标。该文档明确警告它：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要声明与 <code>StringProtocol</code>的新一致性。 仅标准库的 <code>String</code>和 <code>Substring类型</code>是有效的符合类型。</p></blockquote><h2 id="编码单元视图"><a href="#编码单元视图" class="headerlink" title="编码单元视图"></a><strong><em>编码单元视图</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，有必要降低到较低的抽象水平，并直接对 <code>Unicode标量</code>或代码单元进行操作，而不要对 <code>Swift字符</code>（即字素簇）进行操作。字符串为此提供了三个视图： <code>unicodeScalars</code>， <code>utf8</code>和 <code>utf16</code>。像 <code>String</code>一样，它们是双向集合，支持所有熟悉的操作。与子字符串一样，视图共享字符串的存储空间；它们只是以不同的方式表示基础字节。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有几种常见原因导致你需要处理其中一种视图。首先，也许你实际上需要代码单元，可能是为了呈现到 <code>UTF-8编码</code>的网页中，还是与需要特定编码的非 <code>Swift API</code>进行互操作。或者，你可能需要有关特定格式字符串的信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，假设你正在编写一个 <code>Twitter客户端</code>。尽管 <code>Twitter API</code>期望字符串采用 <code>UTF-8编码</code>，但 <code>Twitter</code>的字符计数算法是基于 <code>NFC标准化的标量</code>（至少以前是这样的-该算法最近变得越来越复杂，但我们会坚持使用就本例而言，是先前的方法。）因此，如果要向用户显示他们还剩下多少个字符，可以采用以下方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> tweet = <span class="string">"Having   in a cafe\u&#123;301&#125; in   and enjoying the   ."</span></span><br><span class="line"><span class="keyword">let</span> characterCount = tweet.precomposedStringWithCanonicalMapping</span><br><span class="line">    .unicodeScalars.<span class="built_in">count</span> </span><br><span class="line">characterCount <span class="comment">// 46</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>NFC规范化</code>将基本字母和组合标记（例如 <code>“cafe\u{301}”</code>中的e加重音）一起转换为它们的预组合形式。  <code>precomposedStringWithCanonicalMapping</code>属性在 <code>Foundation</code>中定义。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>UTF-8</code>是用于 <code>存储文本</code>或 <code>通过Internet发送文本的事实上的标准</code>。 由于 <code>utf8视图</code>是一个集合，因此你可以使用它将原始 <code>UTF-8字节</code>传递给其他任何接受字节序列的 <code>API</code>，例如 <code>Data</code>或 <code>Array</code>的初始化程序：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> utf8Bytes = <span class="type">Data</span>(tweet.utf8) </span><br><span class="line">utf8Bytes.<span class="built_in">count</span> <span class="comment">// 62</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串的 <code>UTF-8视图</code>在所有代码单元视图中的开销也最小，因为 <code>UTF-8</code>是 <code>Swift字符串</code>的本机内存格式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意， <code>utf8集合</code>不包含结尾的空字节。 如果需要以空值结尾的表示形式，请在字符串上使用 <code>withCString</code>方法或 <code>utf8CString属性</code>。 后者返回一个字节数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nullTerminatedUTF8 = tweet.utf8CString </span><br><span class="line">nullTerminatedUTF8.<span class="built_in">count</span> <span class="comment">// 63</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>withCString方法</code>调用你提供的函数，该函数提供了一个指向以 <code>Null</code>结尾的字符串的 <code>UTF-8</code>内容的指针。 如果你需要调用期望使用 <code>char *</code>的 <code>C API</code>，这将非常有用。 在许多情况下，你甚至不需要显式的 <code>withCString调用</code>，因为编译器可以自动将 <code>Swift字符串</code>转换为C字符串以进行函数调用。 例如，这是对C标准库中 <code>strlen函数</code>的调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen(tweet) <span class="comment">// 62</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将在 <code>“互操作性”</code>一章中看到更多示例。在大多数情况下（如果字符串的基础存储已经是UTF-8），这种转换几乎没有成本，因为 <code>Swift</code>可以将直接指针传递到字符串存储中的C语言。如果字符串具有不同的内存编码，则编译器将自动插入代码以对内容进行代码转换并将所述内容复制到临时缓冲区中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>utf16视图</code>具有特殊意义，因为 <code>Foundation API</code>传统上将字符串视为 <code>UTF-16代码单元</code>的集合。虽然 <code>NSString</code>接口透明地桥接到 <code>Swift.String</code>，从而为你隐式处理了转换，但其他基金会API（例如 <code>NSRegularExpression</code>或 <code>NSAttributedString</code>）通常希望输入的是UTF-16数据。我们将在“字符串和基础”部分中看到一个示例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用代码单元视图的第二个原因是，对代码单元而不是完全组成的字符进行操作会更快。这是因为 <code>Unicode字素</code>破坏算法相当复杂，并且需要额外的提前行才能识别下一个字素簇的开始。但是，近年来，将String作为字符进行遍历的速度越来越快，因此，请务必测量（相对较小的）加速是否值得失去Unicode正确性。下拉至其中一个代码单元视图后，必须确保你的特定算法可以在此基础上正常工作。例如， <code>使用UTF-8视图解析JSON应该没问题</code>，因为解析器感兴趣的所有特殊字符（例如逗号，引号或花括号）都可以在单个代码单元中表示； JSON数据中的某些字符串可能包含复杂的表情符号序列都没关系。另一方面，如果你希望搜索算法找到搜索字符串的不同归一化形式，则在代码单元视图中查找字符串中所有单词的出现均无法正常工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>代码单元视图均未提供的一项理想功能是随机访问</code>。结果是String及其视图与需要随机访问的算法不匹配。绝大多数的字符串处理任务应该可以在顺序遍历中正常工作，特别是因为算法始终可以存储其希望能够在恒定时间内重新访问的片段的子字符串。如果你绝对需要随机访问，则始终可以将字符串本身或其中的一个视图转换为数组并对其进行处理，就像使用  <code>Array(str)</code> 或 <code>Array(str.utf8)</code> 一样。</p><h2 id="索引共享"><a href="#索引共享" class="headerlink" title="索引共享"></a><strong><em>索引共享</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串及其视图共享相同的索引类型 <code>String.Index</code>。 这意味着你可以使用从字符串派生的索引对视图之一进行下标。 在下面的示例中，我们在字符串中搜索“é”（由两个标量，字母e和重音组成）。 结果索引引用Unicode标量视图中的第一个标量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pokemon = <span class="string">"Poke\u&#123;301&#125;mon"</span> <span class="comment">// Pokémon </span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> index = pokemon.firstIndex(of: <span class="string">"é"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> scalar = pokemon.unicodeScalars[index] <span class="comment">// e</span></span><br><span class="line">    <span class="type">String</span>(scalar) <span class="comment">// e </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要你沿抽象阶梯走下去（从字符到标量再到UTF-8或UTF-16代码单元），此方法就很好用。 采用另一种方法可能会产生令人惊讶的结果，因为并非其中一个代码单元视图中的每个有效索引都在Character边界上：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> family = <span class="string">" "</span></span><br><span class="line"><span class="comment">// This initializer creates an index at a UTF-16 offset.</span></span><br><span class="line"><span class="keyword">let</span> someUTF16Index = <span class="type">String</span>.<span class="type">Index</span>(utf16Offset: <span class="number">2</span>, <span class="keyword">in</span>: family)</span><br><span class="line">family[someUTF16Index] <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String.Index具有一组用于在视图之间转换索引的方法  <code>(samePosition(in: ))</code> 和失败的初始化器  <code>(String.Index.init?(_：within :))</code> 。 如果给定索引在指定视图中没有确切的对应位置，则它们返回 <code>nil</code>。 例如，尝试将标量视图中合并重音的位置转换为字符串中的有效索引会失败，因为合并字符在字符串中没有自己的位置：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> accentIndex = pokemon.unicodeScalars.firstIndex(of: <span class="string">"\u&#123;301&#125;"</span>) &#123;     </span><br><span class="line">    accentIndex.samePosition(<span class="keyword">in</span>: pokemon) <span class="comment">// nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Strings-and-Foundation"><a href="#Strings-and-Foundation" class="headerlink" title="Strings and Foundation"></a><strong><em>Strings and Foundation</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code>的 <code>String类型</code>与其基金会对应的 <code>NSString</code>有非常密切的关系。可以使用 <code>as运算符</code>将任何 <code>String实例</code>桥接到 <code>NSString</code>，采用或返回NSString的 <code>Objective-C API</code>会自动转换为使用String。但这还不是全部。从Swift 5.0开始，String仍然缺少NSString拥有的许多功能。由于字符串是这种基本类型，并且经常不得不转换为 <code>NSString</code>会很烦人，因此String会受到编译器的特殊对待：导入 <code>Foundation</code>时， <code>NSString成员</code>可以在String实例上直接访问，这使Swift字符串的功能大大增强了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拥有附加功能无疑是一件好事，但使用字符串可能会使你感到困惑。一方面，如果你忘记导入 <code>Foundation</code>，你可能会想知道为什么某些方法不可用。基金会作为 <code>Objective-C框架</code>的历史也趋向于使 <code>NSString API</code>在标准库旁边显得有些不合时宜，即使仅仅是因为不同的命名约定也是如此。最后但并非最不重要的一点是，两个库的功能集之间的重叠有时意味着存在两个名称完全不同的<code>API</code>，它们执行几乎相同的任务。如果你是一位长期的 <code>Cocoa开发人员</code>，并且在 <code>Swift</code>出现之前就已经学习了 <code>NSString API</code>，那么这可能没什么大不了的，但是对于新手来说，这将是令人困惑的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经看到了一个示例- <code>Foundation中标准库</code>的 <code>split方法</code>与 <code>components（separatedBy :)</code>的比较-还有许多其他不匹配之处： <code>Foundation</code>使用 <code>CompareResult枚举</code>作为比较谓词，而标准库是围绕布尔谓词设计的；诸如 <code>trimmingCharacters（in :)</code>和 <code>components（separatedBy :)</code>之类的方法将 <code>CharacterSet</code>作为参数，这在Swift中是不幸的错误称呼（稍后会详细介绍）；极其强大的 <code>enumerateSubstrings（in：options：_ :)方法</code>可以遍历大量字素簇，单词，句子或段落中的字符串，可以处理相应的 <code>标准库API</code>使用子字符串的字符串和范围。 （标准库还可以提供与延迟序列相同的功能，这非常酷。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的示例枚举字符串中的单词。每个发现的单词都会调用一次回调闭包：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence = <span class="string">"""</span></span><br><span class="line"><span class="string">The quick brown fox jumped \ over the lazy dog.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">var</span> words: [<span class="type">String</span>] = []</span><br><span class="line">sentence.enumerateSubstrings(<span class="keyword">in</span>: sentence.startIndex..., options: .byWords) &#123; (word, range, <span class="number">_</span>, <span class="number">_</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> word = word <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125; words.append(word)</span><br><span class="line">&#125;</span><br><span class="line">words</span><br><span class="line"><span class="comment">// ["The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要获得导入到String中的所有 <code>NSString成员</code>的概述，请在Swift源代码存储库中检出文件<a href="https://github.com/apple/swift/blob/swift-5.0-RELEASE/stdlib/public/SDK/Foundation/NSStringAPI.swift" target="_blank" rel="noopener"><strong><em><code>NSStringAPI.swift</code></em></strong></a>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>Swift字符串（UTF-8）</code>和 <code>NSString（UTF-16）</code>的本地内存编码之间不匹配，因此当 <code>Swift字符串</code>必须桥接到NSString时，会产生额外的性能成本。 这意味着将原生Swift字符串传递给诸如 <code>enumerateSubstrings（in：options：using :)之类</code>的 <code>Foundation API</code>可能不如传递 <code>NSString</code>那样快-该方法可能假定能够以UTF- 在固定时间内偏移16个偏移量，但这将是对Swift字符串的线性时间操作。 为了减轻这种影响，Swift实现了复杂的索引缓存以实现摊销的恒定时间特性。</p><h2 id="其他与字符串相关的Foundation-API"><a href="#其他与字符串相关的Foundation-API" class="headerlink" title="其他与字符串相关的Foundation API"></a><strong><em>其他与字符串相关的Foundation API</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，原生 <code>NSString API</code>通常适合与 <code>Swift字符串</code>配合使用，因为大多数桥接工作都是为你完成的。许多其他处理字符串的 <code>Foundation API</code>都很难使用，因为Apple尚未为它们编写特殊的 <code>Swift覆盖</code>。考虑一下 <code>NSAttributedString</code>，这是用于以格式表示富文本的 <code>Foundation类</code>。要从Swift成功使用归因字符串，你必须注意以下几点：</p><ul><li><p>→ 有两个类 -  <code>NSAttributedString</code>用于不可变字符串， <code>NSMutableAttributedString</code>用于可变字符串。它们具有引用语义，而不是Swift的标准集合具有值语义。</p></li><li><p>→ 尽管虽然所有 <code>NSAttributedStringAPI</code>最初都采用了 <code>NSStringnowtakea Swift.String</code>，但整个API仍基于 <code>NSString的UTF-16代码单元集合</code>的概念，并且String和NSString之间的频繁桥接可能会带来意外的性能损失。有关详细信息，请参阅<a href="https://developer.apple.com/videos/play/wwdc2018/229/?time=1978" target="_blank" rel="noopener"><strong><em><code>WWDC 2018 的会议229</code></em></strong></a>。</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，用于查询特定位置的格式设置属性的 <code>attributes（at：Int，effectiveRange：NSRangePointer？）</code>方法期望整数索引（以UTF-16单位度量），而不是 <code>String.Index</code>，并且有效指针通过指针返回是一个 <code>NSRange</code>，而不是 <code>Range &lt;String.Index&gt;</code>。对于传递给 <code>NSMutableAttributedString.addAttribute（_：value：range :)</code>的范围，情况也是如此。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>NSRange</code>是包含两个整数字段，位置和长度的结构：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">NSRange</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> location: <span class="type">Int</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> length: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在字符串的上下文中，字段以UTF-16代码单位指定字符串段。 与以前的版本相比，Swift 4使使用·的工作稍微容易一些，因为现在有了用于在  <code>Range&lt;String.Index&gt;</code> 和  <code>NSRange</code> 之间进行转换的初始化程序； 但是，这不会缩短来回翻译所需的额外代码。 以下是有关如何创建和修改属性字符串的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">" 👉 Click here for more info."</span> </span><br><span class="line"><span class="keyword">let</span> linkTarget = <span class="type">URL</span>(string: <span class="string">"https://www.youtube.com/watch?v=DLzxrzFCyOs"</span>! </span><br><span class="line"><span class="comment">// Object is mutable despite  `let ` (reference semantics).</span></span><br><span class="line"><span class="keyword">let</span> formatted = <span class="type">NSMutableAttributedString</span>(string: text)</span><br><span class="line">    <span class="comment">// Modify attributes of a part of the text.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> linkRange = formatted.string.range(of: <span class="string">"Click here"</span>) &#123;</span><br><span class="line">    <span class="comment">// Convert Swift range to NSRange.</span></span><br><span class="line">    <span class="comment">// Note that the start of the range is 3 because the preceding emoji // character doesn't fit in a single UTF-16 code unit.</span></span><br><span class="line">    <span class="keyword">let</span> nsRange = <span class="type">NSRange</span>(linkRange, <span class="keyword">in</span>: formatted.string) <span class="comment">// &#123;3, 10&#125; // Add the attribute.</span></span><br><span class="line">    formatted.addAttribute(.link, value: linkTarget, range: nsRange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此代码将链接添加到字符串的“单击此处”部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在属性字符串中查询特定字符的格式设置属性是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Query attributes at start of the word "here."</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> queryRange = formatted.string.range(of: <span class="string">"here"</span>) &#123;</span><br><span class="line">    <span class="comment">// Convert Swift range to NSRange.</span></span><br><span class="line">    <span class="keyword">let</span> nsRange = <span class="type">NSRange</span>(queryRange, <span class="keyword">in</span>: formatted.string)</span><br><span class="line">    <span class="comment">// Prepare NSRange variable to receive effective attributes range. </span></span><br><span class="line">    <span class="keyword">var</span> attributesRange = <span class="type">NSRange</span>()</span><br><span class="line">    <span class="comment">// Execute query.</span></span><br><span class="line">    <span class="keyword">let</span> attributes = formatted.attributes(at: nsRange.location,</span><br><span class="line">    effectiveRange: &amp;attributesRange) </span><br><span class="line">    attributesRange <span class="comment">// &#123;3, 10&#125;</span></span><br><span class="line">    <span class="comment">// Convert NSRange back to Range&lt;String.Index&gt;.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> effectiveRange = <span class="type">Range</span>(attributesRange, <span class="keyword">in</span>: formatted.string) &#123;  <span class="comment">// The substring spanned by the attribute. </span></span><br><span class="line">        formatted.string[effectiveRange] <span class="comment">// Click here</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们认为你会同意，要使这段代码看起来像是惯用的Swift，还有很长的路要走。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了 <code>NSAttributedString</code>，另一个具有非常相似的阻抗失配的 <code>Foundation类</code>是 <code>NSRegularExpression</code>。  <code>Swift</code>可能会在不久的将来获得本机正则表达式语法，但是在那之前，我们将不得不使用笨拙的 <code>Foundation API</code>。</p><h2 id="Ranges-of-Characters"><a href="#Ranges-of-Characters" class="headerlink" title="Ranges of Characters"></a><strong><em>Ranges of Characters</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（强制转换为 <code>Character</code>很重要，因为字符串文字的默认类型是String；我们需要告诉类型检查器我们想要一个 <code>Character范围</code>。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%8C):%20Build-in%20Collections/"><strong><em><code>“内置集合”</code></em></strong></a>一章中讨论了失败的原因：字符不符合 <code>Strideable协议</code>，这是使范围变得可计数并因此成为集合的要求。 你可以对一个字符范围进行的操作就是将其他字符与该字符进行比较，即检查一个字符是否在该范围内：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lowercaseLetters.<span class="built_in">contains</span>(<span class="string">"A"</span>) <span class="comment">// false </span></span><br><span class="line">lowercaseLetters.<span class="built_in">contains</span>(<span class="string">"é"</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可数范围的概念确实有意义的一种类型是 <code>Unicode.Scalar</code>，至少在你坚持使用 <code>ASCII</code>或 <code>Unicode</code>目录的其他顺序良好的子集的情况下。 标量在其代码点值中具有明确定义的顺序，并且在任何两个边界之间始终存在有限数量的标量。  <code>Unicode</code>标量默认情况下不是“可扩展的”，但我们可以追溯添加一致性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Unicode</span>.<span class="title">Scalar</span>: <span class="title">Strideable</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Stride</span> = <span class="type">Int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">distance</span><span class="params">(to other: Unicode.Scalar)</span></span> -&gt; <span class="type">Int</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(other.value) - <span class="type">Int</span>(<span class="keyword">self</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">advanced</span><span class="params">(by n: Int)</span></span> -&gt; <span class="type">Unicode</span>.<span class="type">Scalar</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Unicode</span>.<span class="type">Scalar</span>(<span class="type">UInt32</span>(<span class="type">Int</span>(value) + n))!</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（我们忽略了这样的事实，即代代码点 <code>0xD800</code>到 <code>0xDFFF</code>不是有效的 <code>Unicode标量值</code>。构造与该区域重叠的范围是程序员的错误。）</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将你不拥有的类型与你不拥有的协议相一致可能会产生问题，通常不建议这样做，因为如果你使用的其他库添加相同的扩展名，或者如果原始供应商以后添加了相同的一致性，则可能会导致冲突。 一个可能不同的实现）。 创建包装类型并将协议一致性添加到该类型通常是一个更好的主意。 我们将在“协议”一章中对此进行更深入的介绍。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为 <code>Unicode</code>添加可跨越的一致性。标量允许我们使用一系列 <code>Unicode标量</code>作为生成字符数组的一种非常方便的方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lowercase = (<span class="string">"a"</span> <span class="keyword">as</span> <span class="type">Unicode</span>.<span class="type">Scalar</span>)...<span class="string">"z"</span> </span><br><span class="line"><span class="type">Array</span>(lowercase.<span class="built_in">map</span>(<span class="type">Character</span>.<span class="keyword">init</span>))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",</span></span><br><span class="line"><span class="comment">"o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"] */</span></span><br></pre></td></tr></table></figure><h1 id="CharacterSet"><a href="#CharacterSet" class="headerlink" title="CharacterSet"></a><strong>CharacterSet</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看一下最后一种有趣的 <code>Foundation类型</code>，那就是 <code>CharacterSet</code>。 我们已经在<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%8C):%20Build-in%20Collections/"><strong><em><code>“内置集合”</code></em></strong></a>一章中提到过，该结构实际上应称为 <code>UnicodeScalarSet</code>，因为它就是这样：一种有效的数据结构，用于表示 <code>Unicode标量集</code>。 它与字符类型完全不兼容。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过使用几个复杂的表情符号创建一个集合来说明这一点。 似乎该集合仅包含我们放入的两个表情符号，但是测试第三个表情符号的成员资格是成功的，因为消防员表情符号实际上是女性+ ZWJ +消防车的序列：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteEmoji = <span class="type">CharacterSet</span>(<span class="string">"     "</span>.unicodeScalars) <span class="comment">// Wrong! Or is it?</span></span><br><span class="line">favoriteEmoji.<span class="built_in">contains</span>(<span class="string">"   "</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>CharacterSet</code>提供了许多工厂初始化程序，例如 <code>.alphanumerics</code>和 <code>.whitespacesAndNewlines</code>。 其中大多数对应于正式的 <code>Unicode字符</code>类别（为每个代码点分配了一个类别，例如“字母”或“无间距标记”）。 类别涵盖所有脚本，而不仅仅是 <code>ASCII</code>或 <code>Latin-1</code>，因此这些预定义集中的成员数通常很大。 由于 <code>CharacterSet符合SetAlgebra</code>，因此我们可以通过使用诸如联合或相交之类的集合操作来组合多个字符集。</p><h2 id="Unicode属性"><a href="#Unicode属性" class="headerlink" title="Unicode属性"></a><strong><em>Unicode属性</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift 5</code>中， <code>CharacterSet</code>的部分功能已集成到 <code>Unicode.Scalar</code>中。我们不再需要 <code>Foundation类型</code>来测试正式 <code>Unicode类</code>别中的成员资格的标量，因为现在这些已直接作为 <code>Unicode.Scalar</code>上的属性公开。  <code>isEmoji</code>或 <code>isWhitespace</code>。 为避免使主要 <code>Unicode.Scalar</code>名称空间混乱， <code>Unicode属性</code>在名称属性下命名：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">" "</span> <span class="keyword">as</span> <span class="type">Unicode</span>.<span class="type">Scalar</span>).properties.isEmoji <span class="comment">// true </span></span><br><span class="line">(<span class="string">"∫∫"</span> <span class="keyword">as</span> <span class="type">Unicode</span>.<span class="type">Scalar</span>).properties.isMath <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请查看<a href="https://developer.apple.com/documentation/swift/unicode/scalar/properties" target="_blank" rel="noopener"><strong><em><code>Unicode.Scalar.Properties</code></em></strong></a>的文档以获取完整列表。 这些属性大多数都是布尔型的，但不是全部：诸如age（引入标量时的Unicode版本），name（正式的Unicode名称），numericalValue（适用于具有自己代码点的分数） 或非拉丁文字中的数字）和generalCategory（描述标量的“一阶，最常用的分类”的枚举）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，列出组成字符串的每个标量的代码点，名称和常规类别，只需要一点点字符串格式即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"I’m a  😀 ."</span>.unicodeScalars.<span class="built_in">map</span> &#123; scalar -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> codePoint = <span class="string">"U+\(String(scalar.value, radix: 16, uppercase: true))"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name = scalar.properties.name ?? <span class="string">"(no name)"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(codePoint): \(name) – \(scalar.properties.generalCategory)"</span> </span><br><span class="line">&#125;.joined(separator: <span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">U+49: LATIN CAPITAL LETTER I – uppercaseLetter</span></span><br><span class="line"><span class="comment">U+2019: RIGHT SINGLE QUOTATION MARK – finalPunctuation U+6D: LATIN SMALL LETTER M – lowercaseLetter</span></span><br><span class="line"><span class="comment">U+20: SPACE – spaceSeparator</span></span><br><span class="line"><span class="comment">U+61: LATIN SMALL LETTER A – lowercaseLetter</span></span><br><span class="line"><span class="comment">U+20: SPACE – spaceSeparator</span></span><br><span class="line"><span class="comment">U+1F469: WOMAN – otherSymbol</span></span><br><span class="line"><span class="comment">U+1F3FD: EMOJI MODIFIER FITZPATRICK TYPE-4 – modifierSymbol U+200D: ZERO WIDTH JOINER – format</span></span><br><span class="line"><span class="comment">U+1F692: FIRE ENGINE – otherSymbol</span></span><br><span class="line"><span class="comment">U+2E: FULL STOP – otherPunctuation</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Unicode标量</code>属性级别较低，有意使用 <code>Unicode标准</code>有时含糊的术语。 在 <code>“角色”</code>级别上设置相似的类别通常很有用，因此Swift 5还为“角色”添加了许多相关属性。 这里有些例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Character</span>(<span class="string">"4"</span>).isNumber <span class="comment">// true </span></span><br><span class="line"><span class="type">Character</span>(<span class="string">"$"</span>).isCurrencySymbol <span class="comment">// true </span></span><br><span class="line"><span class="type">Character</span>(<span class="string">"\n"</span>).isNewline <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与Unicode标量属性不同，“字符”上的这些类别不是Unicode规范的正式组成部分，因为Unicode仅对标量进行分类，而不对扩展字素簇进行分类。 标准库尽最大努力提供有关字符性质的明智信息，但是由于支持的脚本数量众多，并且Unicode具有将标量以无限组合的方式进行组合的能力，因此这些类别并不精确，可能与其他工具或编程不匹配语言提供。 它们也可能随着时间而发展。</p><h2 id="字符串和字符的内部结构"><a href="#字符串和字符的内部结构" class="headerlink" title="字符串和字符的内部结构"></a><strong><em>字符串和字符的内部结构</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与标准库中的其他集合类型一样，<strong>字符串是具有值语义的写时复制集合</strong>。 String实例存储对缓冲区的引用，该缓冲区保存实际的字符数据。复制字符串时（通过赋值）或通过将其传递给函数）或创建子字符串，所有这些实例共享同一缓冲区。仅当某个实例与一个或多个其他实例共享其字符缓冲区时发生突变时，才复制字符数据。有关写时复制的更多信息，请参见<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%94):%20Structs%20and%20Classes/"><strong><em><code>“结构和类”</code></em></strong></a>一章。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从Swift 5开始，String使用 <code>UTF-8作为本机Swift字符串</code>的内存表示形式。如果你需要最佳性能，则可以利用这些知识来发挥自己的优势-遍历UTF-8视图可能比UTF-16或Unicode标量视图快一点。同样，UTF-8是大多数字符串处理的自然格式，因为来自文件或Web的大多数源数据都使用UTF-8编码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 <code>Objective-C</code>接收的字符串由 <code>NSString</code>支持。在这种情况下，NSString直接充当Swift字符串的缓冲区，以提高桥接效率。当NSString支持的String发生突变时，它将转换为原生Swift字符串。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于最多 <code>15个UTF-8代码单元</code>（或在32位平台上为10个代码单元）的小字符串，有一项特殊的优化措施，可避免完全分配后备缓冲区。由于字符串的宽度为16个字节，因此可以内联存储小字符串的代码单元。尽管15个UTF-8代码单元听起来可能不多，但足以容纳很多字符串。例如，在JSON之类的机器可读格式中，许多键和值（例如数字和布尔值）都适合此长度，特别是因为它们通常仅使用ASCII字符。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个小的字符串优化还用于 <code>Character类型</code>的内部表示（从<a href="https://github.com/apple/swift/blob/swift-5.0-RELEASE/stdlib/public/core/Character.swift%23L65" target="_blank" rel="noopener"><strong><em><code>标准库源简化</code></em></strong></a>）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Character</span> </span>&#123; </span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _str: <span class="type">String</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(unchecked str: <span class="type">String</span>) &#123; </span><br><span class="line">        <span class="keyword">self</span>._str = str</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，一个字符在内部表示为长度为一的字符串。 在 <code>Swift 5</code>进行小字符串优化之前， <code>Character类型</code>本身实现了两层策略：可内联存储63位以下的字符，而将较大的字符存储在缓冲区中。 从Swift 5.0开始，<strong>Character仅依靠小字符串优化来达到类似的效果</strong>。</p><h2 id="String-Literals"><a href="#String-Literals" class="headerlink" title="String Literals"></a><strong><em>String Literals</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本章中，我们一直在互换使用 <code>String（“ blah”）</code>和 <code>“ blah”</code>，但它们是不同的。 “”是字符串文字，就像 <code>“集合协议”</code>一章中介绍的数组文字一样。你可以通过遵 <code>ExpressibleByStringLiteral</code>，从字符串文字中初始化类型。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串文字比数组文字稍微复杂一点，因为它们属于三个协议的层次结构的一部分： <code>ExpressibleByStringLiteral</code>， <code>ExpressibleByExtendedGraphemeClusterLiteral</code>和 <code>ExpressibleByUnicodeScalarLiteral</code>。每个都定义一个用于从每种文字创建类型的 <code>init</code>，但是除非你真的需要根据是否从单个标量/集群创建值而需要细粒度的逻辑，否则你只需要实现字符串版本即可；其他的则由引用字符串文字初始值设定项的默认实现覆盖。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为采用 <code>ExpressibleByStringLiteral协议</code>的自定义类型的示例，我们定义了 <code>SafeHTML</code>类型。这实际上只是一个字符串包装，但具有附加的类型安全性。当我们使用这种类型的值时，我们可以确保它包含的潜在危险 <code>HTML标记</code>已被转义，以免造成安全风险：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> htmlEscaped: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="comment">// Replace all opening and closing brackets.</span></span><br><span class="line">    <span class="comment">// A "real" implementation would be more complicated. </span></span><br><span class="line">    <span class="keyword">return</span> replacingOccurrences(of: <span class="string">"&lt;"</span>, with: <span class="string">"&amp;lt;"</span>)</span><br><span class="line">            .replacingOccurrences(of: <span class="string">"&gt;"</span>, with: <span class="string">"&amp;gt;"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SafeHTML</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> value: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(unsafe html: <span class="type">String</span>) &#123; </span><br><span class="line">        <span class="keyword">self</span>.value = html.htmlEscaped</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用这种类型来确保视图的 <code>API</code>仅接受正确转义的值。 缺点是我们将不得不在 <code>SafeHTML</code>的代码中手动包装许多字符串文字。 幸运的是，我们可以遵循 <code>ExpressibleByStringLiteral</code>来避免这种开销：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SafeHTML</span>: <span class="title">ExpressibleByStringLiteral</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">StringLiteralType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设代码中的字符串文字始终是安全的（这是一个合理的假设，因为我们自己输入了字符串文字）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> safe: <span class="type">SafeHTML</span> = <span class="string">"&lt;p&gt;Angle brackets in literals are not escaped&lt;/p&gt;"</span> </span><br><span class="line"><span class="comment">// SafeHTML(value: "&lt;p&gt;Angle brackets in literals are not escaped&lt;/p&gt;")</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面，我们必须明确指定 <code>SafeHTML类型</code>，否则 <code>safe</code>将为 <code>String类型</code>。 但是，我们可以在编译器已经知道类型的上下文中省略显式类型，例如属性分配或函数调用。</p><h2 id="String-Interpolation"><a href="#String-Interpolation" class="headerlink" title="String Interpolation"></a><strong><em>String Interpolation</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自开始以来，字符串插值即将表达式放入字符串文字中（例如“a*b = (a * b)”）。 Swift 5引入了一个公共API，以利用字符串插值来定制类型。 我们可以使用此API从上面改进SafeHTML类型。 我们经常不得不编写包含HTML标签的字符串文字，并在两者之间添加一些用户输入数据：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> input = ... <span class="comment">// received from user, unsafe! </span></span><br><span class="line"><span class="keyword">let</span> html = <span class="string">"&lt;li&gt;Username: \(input)&lt;/li&gt;"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入必须转义，因为它来自不受信任的来源，但是字符串文字段应保持不变，因为我们要在其中编写HTML标签。我们可以通过为 <code>SafeHTML类型</code>实现自定义字符串插值规则来实现此目的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swift的字符串插值API由两个协议组成： <code>ExpressibleByStringInterpolation</code>和 <code>StringInterpolationProtocol</code>。前者必须采用应通过字符串插值构造的类型。后者可以采用相同的类型，也可以采用单独的类型，并且包含几种逐步构建字符串插值值的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>ExpressibleByStringInterpolation</code>继承自 <code>ExpressibleByStringLiteral</code>，我们在上面已经使它符合 <code>SafeHTML类型</code>。因此，我们可以通过实现可以从 <code>StringInterpolationProtocol</code>值构造 <code>SafeHTML值</code>的初始化程序，来立即符合 <code>ExpressibleByStringInterpolation</code>。在此示例中，我们将使用相同的类型 <code>SafeHTML</code>来符合 <code>StringInterpolationProtocol</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SafeHTML</span>: <span class="title">ExpressibleByStringInterpolation</span> </span>&#123; </span><br><span class="line">    <span class="keyword">init</span>(stringInterpolation: <span class="type">SafeHTML</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = stringInterpolation.value </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>StringInterpolationProtocol</code>协议具有三个要求： <code>初始化程序</code>， <code>appendLiteral方法</code>和 <code>一个或多个appendInterpolation方法</code>。  <code>Swift</code>具有符合此协议的默认类型 <code>DefaultStringInterpolation</code>，该类型处理我们从标准库免费获得的字符串插值。 我们想提供一个带有 <code>appendInterpolation方法</code>的自定义类型，该方法可以对插值进行转义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SafeHTML</span>: <span class="title">StringInterpolationProtocol</span> </span>&#123; </span><br><span class="line">    <span class="keyword">init</span>(literalCapacity: <span class="type">Int</span>, interpolationCount: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = <span class="string">""</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendLiteral</span><span class="params">(<span class="number">_</span> literal: String)</span></span> &#123; </span><br><span class="line">        value += literal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span>&lt;T&gt;<span class="params">(<span class="number">_</span> x: T)</span></span> &#123; </span><br><span class="line">        <span class="keyword">self</span>.value += <span class="type">String</span>(describing: x).htmlEscaped</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化程序通知插值类型有关存储所有组合文字所需的近似容量，以及我们必须期望的插值次数。 我们忽略这两个参数，只用一个空字符串初始化值。 但是，如果出于性能方面的考虑，我们可以使用此信息提前保留容量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>appendLiteral方法</code>只是将字符串追加到 <code>value属性</code>，因为默认情况下我们认为字符串文字是安全的（就像上面的 <code>ExpressibleByStringLiteral</code>一样）。  <code>appendInterpolation（_ :)</code>方法采用任何类型的输入参数，并且使用 <code>String（describing :)</code>将其转换为字符串。 在将此字符串附加到 <code>value</code>之前，我们先对其进行转义。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>appendInterpolation方法</code>的参数上没有标签，因此可以像使用 <code>Swift</code>的默认字符串插值一样使用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unsafeInput = <span class="string">"&lt;script&gt;alert('Oops!')&lt;/script&gt;"</span></span><br><span class="line"><span class="keyword">let</span> safe: <span class="type">SafeHTML</span> = <span class="string">"&lt;li&gt;Username: \(unsafeInput)&lt;/li&gt;"</span> </span><br><span class="line">safe</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SafeHTML(value: "&lt;li&gt;Username: &amp;lt;script&amp;gt;alert(\'Oops!\')&amp;lt;/script&amp;gt;&lt;/li&gt;")</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译器将插值后的字符串转换为对自定义 <code>StringInterpolationProtocol类型</code>的一系列 <code>appendLiteral</code>和 <code>appendInterpolation</code>调用，使我们有机会按自己认为合适的方式存储此数据。处理完所有文字和插值段后，将结果值传递到 <code>init（stringInterpolation :)</code>初始化程序以创建 <code>SafeHTML值</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的例子中，我们选择使 <code>ExpressibleByStringInterpolation</code>和 <code>StringInterpolationProtocol</code>都使用相同的类型，因为它们共享相同的结构（都只需要一个字符串属性）。但是，当构建字符串插值所需的数据结构与通过插值构造的类型的结构不同时，使用单独类型的功能将很有用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管我们可以用字符串插值做更多的事情。本质上， <code>\（...）</code>语法是 <code>appendInterpolation</code>方法调用的简写，即我们可以使用多个参数和标签。我们可以利用此行为来添加“原始”插值，该插值允许我们插值而不转义它们：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SafeHTML</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span>&lt;T&gt;<span class="params">(raw x: T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value += <span class="type">String</span>(describing: x) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> star = <span class="string">"&lt;sup&gt;*&lt;/sup&gt;"</span></span><br><span class="line"><span class="keyword">let</span> safe2: <span class="type">SafeHTML</span> = <span class="string">"&lt;li&gt;Username\(raw: star): \(unsafeInput)&lt;/li&gt;"</span> </span><br><span class="line">safe2</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SafeHTML(value: "&lt;li&gt;Username&lt;sup&gt;*&lt;/sup&gt;: &amp;lt;script&amp;gt;alert(\'Oops!\')&amp;lt;/script&amp;gt;&lt;/li&gt;") */</span></span><br></pre></td></tr></table></figure><h2 id="自定义字符串说明"><a href="#自定义字符串说明" class="headerlink" title="自定义字符串说明"></a><strong><em>自定义字符串说明</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;诸如 <code>print</code>， <code>String（describing :)</code>和字符串插值之类的函数可以采用任何类型，无论如何。 即使没有任何自定义，你返回的结果也可以接受，因为结构默认情况下会打印其属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> safe: <span class="type">SafeHTML</span> = <span class="string">"&lt;p&gt;Hello, World!&lt;/p&gt;"</span> </span><br><span class="line"><span class="built_in">print</span>(safe)</span><br><span class="line"><span class="comment">// prints out SafeHTML(value: "&lt;p&gt;Hello, World!&lt;/p&gt;")</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再说一遍，你可能需要一些漂亮的东西，特别是如果你的类型包含不想显示的私有变量时。 但是不要害怕！ 在传递给打印时，只需一分钟即可为你的自定义类型提供格式良好的输出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SafeHTML</span>: <span class="title">CustomStringConvertible</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，如果有人通过各种方式将 <code>SafeHTML值</code>转换为字符串（将其与诸如 <code>print</code>之类的流函数一起使用，将其传递给 <code>String（describing :)</code>或在某些字符串插值中使用），它将仅打印其字符串值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(safe) <span class="comment">// &lt;p&gt;Hello, World!&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一个 <code>CustomDebugStringConvertible</code>，可以在有人调用 <code>String（reflecting :)</code>时实现，以提供用于调试目的的不同输出格式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SafeHTML</span>: <span class="title">CustomDebugStringConvertible</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> debugDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"SafeHTML: \(value)"</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果未实现 <code>CustomDebugStringConvertible</code>，则 <code>String（rectioning :)</code>会回退到使用 <code>CustomStringConvertible</code>，反之亦然。同样，如果 <code>CustomStringConvertible</code>不可用，则 <code>String（describing :)</code>会退回到 <code>CustomDebugStringConvertible</code>。通常，如果你的类型简单，则不值得实施 <code>CustomDebugStringConvertible</code>。但是，如果你的自定义类型是容器，则礼貌地遵守 <code>CustomDebugStringConvertible</code>以便打印该类型所包含元素的调试版本。并且，如果出于调试目的在打印时做任何与众不同的事情，请确保也实现 <code>CustomStringConvertible</code>。但是，如果你的 <code>description</code>和 <code>debugDescription</code>的实现是相同的，则可以选择其中一个而忽略另一个。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顺便说一句，即使通过 <code>String（describing :)</code>进行调用， <code>Array</code>也会始终打印出其元素的调试描述。原因是数组的描述无论如何都不会呈现给用户，因此可以优化描述的输出以进行调试。而且，如果没有带引号的 <code>String.description</code>省略，则空字符串数组将看起来是错误的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鉴于符合 <code>CustomStringConvertible</code>意味着类型具有漂亮的打印输出，你可能会想编写类似以下通用函数的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomethingAttractive</span>&lt;T: CustomStringConvertible&gt;<span class="params">(with value: T)</span></span> &#123; </span><br><span class="line">    <span class="comment">// Print out something incorporating value, safe in the knowledge</span></span><br><span class="line">    <span class="comment">// it will print out sensibly.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是你不应该以这种方式使用 <code>CustomStringConvertible</code>。 你不必使用类型来确定它们是否具有 <code>description属性</code>，而应该使用 <code>String（describing :)</code>来代替，如果类型不符合协议，则应使用难看的输出。 这将永远不会失败任何类型。 而且，只要你编写的不是一个非常简单的类型，这就是实现 <code>CustomStringConvertible</code>的一个很好的理由。 只需要几行。</p><h2 id="文字输出流"><a href="#文字输出流" class="headerlink" title="文字输出流"></a><strong><em>文字输出流</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准库中的打印和转储功能会将文本记录到标准输出中。 这是如何运作的？ 这些函数的默认版本转发给名为 <code>print（_：to :)</code>和 <code>dump（_：to :)</code>的重载。  <code>to：</code>参数是输出目标； 它可以是符合 <code>TextOutputStream协议</code>的任何类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">print</span>&lt;Target: TextOutputStream&gt;</span></span><br><span class="line"><span class="function"><span class="params">(<span class="number">_</span> items: <span class="keyword">Any</span>..., separator: String = <span class="string">" "</span>, terminator: String = <span class="string">"\n"</span>, to output: <span class="keyword">inout</span> Target)</span></span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准库维护一个内部文本输出流，该流将流到它的所有内容写入标准输出。 你还能写些什么？ 嗯，字符串是标准库中唯一一个输出流的类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vars=<span class="string">""</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] </span><br><span class="line"><span class="built_in">print</span>(numbers, to: &amp;s) </span><br><span class="line">s <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要将打印和转储功能的输出重新路由到字符串中，此功能很有用。 顺便说一句，标准库还利用输出流来允许Xcode捕获所有标准输出日志记录。 看一下标准库中的此全局变量声明：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> _playgroundPrintHook: ((<span class="type">String</span>) -&gt; <span class="type">Void</span>)?</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果非零，则 <code>print</code>将使用特殊的输出流，该输出流会将所有已打印的内容都路由到标准输出和此函数。 该声明甚至是公开的，因此你可以将其用于自己的恶作剧：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printCapture = <span class="string">""</span> </span><br><span class="line">_playgroundPrintHook = &#123; text <span class="keyword">in</span></span><br><span class="line">    printCapture += text </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"This is supposed to only go to stdout"</span>) </span><br><span class="line">printCapture <span class="comment">// This is supposed to only go to stdout</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是不要依赖它！ 它完全没有记录，并且我们不知道当你重新分配Xcode时哪些功能会中断。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以制作自己的输出流。 该协议只有一个要求：一种写方法，该方法接受一个字符串并将其写入流中。 例如，此输出流缓冲写入数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArrayStream</span>: <span class="title">TextOutputStream</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> buffer: [<span class="type">String</span>] = []</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(<span class="number">_</span> string: String)</span></span> &#123;</span><br><span class="line">        buffer.append(string) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stream = <span class="type">ArrayStream</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello"</span>, to: &amp;stream)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"World"</span>, to: &amp;stream)</span><br><span class="line">stream.buffer <span class="comment">// ["", "Hello", "\n", "", "World", "\n"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该文档明确允许写入输出流的函数在每个写入操作中多次调用 <code>write（_ :)</code>。 因此，上例中的数组缓冲区包含用于换行符甚至是空字符串的单独元素。 这是打印功能的实现细节，在将来的版本中可能会更改。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种可能性是扩展 <code>Data</code>，以使其采用流，并将其写入为 <code>UTF-8编码</code>的输出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Data</span>: <span class="title">TextOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(<span class="number">_</span> string: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.append(contentsOf: string.utf8) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> utf8Data = <span class="type">Data</span>()</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"café"</span> utf8Data.write(string)</span><br><span class="line"><span class="type">Array</span>(utf8Data) <span class="comment">// [99, 97, 102, 195, 169]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出流的源可以是符合 <code>TextOutputStreamable协议</code>的任何类型。 该协议需要通用方法 <code>write（to :)</code>，该方法可以接受任何符合 <code>TextOutputStream的类型</code>并将其自身写入其中。 在标准库中， <code>String</code>， <code>Substring</code>， <code>Character</code>和 <code>Unicode.Scalar</code>符合 <code>TextOutputStreamable</code>，但你也可以为自己的类型添加符合性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如我们所见，在内部，打印在标准输出上使用了一些符合 <code>TextOutputStream的包装器</code>。 你可以为标准错误编写类似的内容，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StdErr</span>: <span class="title">TextOutputStream</span> </span>&#123; </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(<span class="number">_</span> string: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !string.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Strings can be passed directly into C functions that take a // const char* — see the interoperability chapter for more! </span></span><br><span class="line">    fputs(string, stderr)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> standarderror = <span class="type">StdErr</span>() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"oops!"</span>, to: &amp;standarderror)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;流还可以保持状态，它们可以潜在地转换其输出，并且可以将它们链接在一起。 以下输出流用给定的替换项替换了所有出现的指定短语。 像 <code>String</code>一样，它也符合 <code>TextOutputStreamable</code>，使其成为文本流操作的目标和源：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReplacingStream</span>: <span class="title">TextOutputStream</span>, <span class="title">TextOutputStreamable</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> toReplace: <span class="type">KeyValuePairs</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> output = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(replacing toReplace: <span class="type">KeyValuePairs</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;) &#123; </span><br><span class="line">        <span class="keyword">self</span>.toReplace = toReplace</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(<span class="number">_</span> string: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> toWrite = toReplace.<span class="built_in">reduce</span>(string) &#123; partialResult, pair <span class="keyword">in</span></span><br><span class="line">                partialResult.replacingOccurrences(of: pair.key, with: pair.value) </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(toWrite, terminator: <span class="string">""</span>, to: &amp;output) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">write</span>&lt;Target: TextOutputStream&gt;<span class="params">(to target: <span class="keyword">inout</span> Target)</span></span> &#123;     </span><br><span class="line">        output.write(to: &amp;target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> replacer = <span class="type">ReplacingStream</span>(replacing: [</span><br><span class="line"><span class="string">"in the cloud"</span>: <span class="string">"on someone else's computer"</span></span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> source = <span class="string">"People find it convenient to store their data in the cloud."</span></span><br><span class="line"><span class="built_in">print</span>(source, terminator: <span class="string">""</span>, to: &amp;replacer)</span><br><span class="line"><span class="keyword">var</span> output = <span class="string">""</span></span><br><span class="line"><span class="built_in">print</span>(replacer, terminator: <span class="string">""</span>, to: &amp;output)</span><br><span class="line">output</span><br><span class="line"><span class="comment">// People find it convenient to store their data on someone else's computer.</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码中使用 <code>KeyValuePairs</code>代替常规字典。 如果你希望能够使用 <code>[key：value]</code>文字语法，但又不想使用 <code>Dictionary</code>会带来两个副作用，那就是很有用：消除重复的键和重新排列键。  <code>KeyValuePairs</code>是配对数组的不错选择即 <code>[（key，value）]</code>，允许调用者使用更方便的 <code>[：]</code>语法。</p><h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a><strong>概括</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swift中的字符串与几乎所有其他主流编程语言中的字符串都非常不同。当你习惯于有效地将字符串作为代码单元的数组使用时，需要花一些时间才能将心态切换到Swift的将Unicode正确性优先于简单性的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终，我们认为Swift是正确的选择。 Unicode文本比其他语言假装的要复杂得多。从长远来看，避免原本要编写的错误所节省的时间可能会超过取消学习整数索引所花费的时间。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们习惯于随机访问“字符”，以至于我们可能没有意识到在字符串处理代码中真正需要此功能的情况很少。我们希望本章中的示例能使你相信，对于大多数常见操作而言，简单的有序遍历非常合适。强制你明确说明要使用的字符串表示形式—字形簇，Unicode标量，UTF-8代码单元或UTF-16代码单元<br>—是另一项安全措施；你的代码的读者将不胜感激。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;克里斯·拉特纳（Chris Lattner）在2016年7月概述Swift字符串实现的目标时，他以以下观点告终：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的目标是比Perl更好地处理字符串！</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift 5</code>还不存在-缺少太多理想的功能，包括将更多的字符串 <code>API</code>从 <code>Foundation</code>转移到标准库，对正则表达式的本地语言支持以及用于格式化和解析字符串的 <code>API</code>。 好消息是， <code>Swift</code>团队已表示有兴趣在将来解决所有这些主题。 现在，完成用于内存中表示的从 <code>UTF-16</code>切换到 <code>UTF-8</code>的艰巨任务已经完成，重点将转移到充实API。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Advanced Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Advanced Swift </tag>
            
            <tag> Swift 5.0 </tag>
            
            <tag> Strings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Swift系列(六):  Enums</title>
      <link href="/Advanced%20Swift%E7%B3%BB%E5%88%97(%E5%85%AD):%20%20Enums/"/>
      <url>/Advanced%20Swift%E7%B3%BB%E5%88%97(%E5%85%AD):%20%20Enums/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在上一章中讨论过的结构和类是记录类型的示例。一条记录由零个或多个字段（属性）组成，每个字段都有自己的类型。元组也属于此类：元组实际上是功能较少的轻量级匿名结构。记录是一个很明显的概念，我们认为它们是理所当然的。几乎所有的编程语言都允许你定义这种复合类型（BASIC的早期版本和原始Lisp可能是最著名的例外）。即使没有语言支持，即使汇编程序员也一直使用记录的概念在内存中构造数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swift的一个或多个枚举属于根本不同的类别，有时称为标记联合或变量类型。尽管其概念与记录一样强大，但对变体的支持在主流编程语言中却很少普及。但是，它们在函数式语言中很常见，并已在诸如Rust的较新语言中流行。我们认为，枚举是Swift的最佳功能之一。</p><a id="more"></a><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a><strong>总览</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个枚举由零个或多个  <code>case</code> 组成，每个  <code>case</code> 都有一个可选的元组样式的关联值列表。 在本章中，我们有时会使用单数形式当我们谈论单个  <code>case</code>  的关联值时，称为“关联值”。 一个  <code>case</code>  可以具有多个关联值，但是你可以将它们视为一个元组。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个简单的枚举，没有关联的值来表示段落的对齐方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TextAlignment</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">left</span></span><br><span class="line">    <span class="keyword">case</span> center</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在 <a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%89):%20%20Optionals/"><strong>* <code>“可选”</code>*</strong></a> 一章中看到，“可选”是一个通用枚举，包含两种情况：“无”和“有”。 在某些情况下，具有与框值相关的值：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@_frozen <span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123; </span><br><span class="line">    <span class="comment">/// The absence of a value.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="comment">/// The presence of a value, stored as  `Wrapped `.</span></span><br><span class="line">    <span class="keyword">case</span> some(<span class="type">Wrapped</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（暂时忽略 <code>@_frozen</code>属性。稍后我们将在“Frozen and Non-Frozen Enums”中进行讨论。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Result类型</code>的目的是代表操作的成功或失败，其形状类似，但是为失败情况添加了第二个关联值（和相应的通用参数），从而使其能够捕获详细的错误信息：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">Success</span>, <span class="title">Failure</span>: <span class="title">Error</span>&gt; </span>&#123; </span><br><span class="line">    <span class="comment">/// A success, storing a  `Success ` value. </span></span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">Success</span>)</span><br><span class="line">    <span class="comment">/// A failure, storing a  `Failure ` value. </span></span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Failure</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将在“错误处理”一章中详细讨论“结果”，并且还将在本章的许多示例中使用它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以通过指定其中一个  <code>case</code>  来创建枚举值，以及该  <code>case</code>  的关联值（如果有）的值：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alignment = <span class="type">TextAlignment</span>.<span class="keyword">left</span></span><br><span class="line"><span class="keyword">let</span> download: <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">NetworkError</span>&gt; = .success(<span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，在第二行中，我们必须提供完整的类型注释，包括所有通用参数。 诸如 <code>Result.success（htmlText）</code>之类的表达式会产生错误，除非编译器可以从上下文中推断出另一个通用参数的具体类型 <code>Failure</code>。 一旦指定了完整的类型，我们就可以使用前导点语法依靠类型推断。 （NetworkError的定义未在此处显示。）</p><h1 id="枚举是值类型"><a href="#枚举是值类型" class="headerlink" title="枚举是值类型"></a><strong>枚举是值类型</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>枚举是值类型</strong>，就像结构一样。它们具有结构几乎具有的所有相同功能：</p><ul><li>→枚举具有方法，计算的属性和下标。 </li><li>→方法可以声明为变异或非变异。</li><li>→你可以编写扩展名。</li><li>→枚举符合协议。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，枚举不能具有存储的属性。一个枚举的状态完全由其大小写以及该大小写的关联值表示。将关联的值视为特定情况下的存储属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举上的变异方法的工作方式与它们对结构相同。我们在<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%94):%20Structs%20and%20Classes/"><strong>* <code>《结构和类》</code>*</strong></a>一章中介绍，在一个变异方法中，自我被传出并因此变得可变。由于枚举没有存储的属性，并且无法直接更改  <code>case</code>  的关联值，因此我们通过直接向self分配新值来更改枚举。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举不需要显式的初始化程序，因为初始化枚举变量的通常方法是为其分配大小写。但是，可以在类型定义或扩展名中添加其他 <code>“便捷”</code>初始化程序。例如，使用 <code>Foundation</code>的 <code>Locale API</code>，我们可以向 <code>TextAlignment</code>枚举添加一个初始化程序，该初始化程序为给定的语言环境设置默认的文本对齐方式：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TextAlignment</span> </span>&#123; </span><br><span class="line">    <span class="keyword">init</span>(defaultFor locale: <span class="type">Locale</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> language = locale.languageCode <span class="keyword">else</span> &#123; <span class="comment">// Default value if language is n/a.</span></span><br><span class="line">        <span class="keyword">self</span> = .<span class="keyword">left</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> <span class="type">Locale</span>.characterDirection(forLanguage: language) &#123; </span><br><span class="line">        <span class="keyword">case</span> .rightToLeft:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="keyword">right</span></span><br><span class="line">        <span class="comment">// Left is the default for everything else.</span></span><br><span class="line">        <span class="keyword">case</span> .leftToRight, .topToBottom, .bottomToTop, .unknown:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="keyword">left</span> </span><br><span class="line">        @unknown <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="keyword">left</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> english = <span class="type">Locale</span>(identifier: <span class="string">"en_AU"</span>) <span class="type">TextAlignment</span>(defaultFor: english) <span class="comment">// left let arabic = Locale(identifier: "ar_EG") </span></span><br><span class="line"><span class="type">TextAlignment</span>(defaultFor: arabic) <span class="comment">// right</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（我们将在 <code>“Frozen and Non-Frozen Enums”</code>部分介绍 <code>@unknown</code>默认  <code>case</code>  ）。</p><h1 id="Sum-Types-and-Product-Types"><a href="#Sum-Types-and-Product-Types" class="headerlink" title="Sum Types and Product Types"></a><strong>Sum Types and Product Types</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>枚举值</code>正好包含其中一种情况（如果有，则加上该情况的关联值）。实际上，在 <code>Swift</code>成立之初（首次公开发布之前），枚举曾经被称为 <code>“一个”</code>，后来被称为 <code>“联合”</code>。更具体地说， <code>“结果”</code>值包含成功值或失败值，但不包含两者（且永不包含）。相反，记录类型的实例包含其所有字段的值： <code>（String，Int）</code>元组包含一个字符串和一个整数。 （请注意，此处我们讨论的是具有多个字段的复合记录； UInt8也是一个结构，你可能会说它将实例限制为 <code>“ 0 ... 255之一”</code>。但这不是我们的意思。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种对 <code>“或”</code>关系进行建模的能力非常独特，这正是枚举非常有用的原因。它使我们能够编写更安全，更具表达力的代码，从而在通常无法用结构，元组或类清晰地表达的情况下，充分利用强类型的优势。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们说 <code>“相当独特”</code>是因为 <code>协议和子类</code>可以用于相同的目的，尽管折衷和应用情况非常不同。协议类型的变量（也称为存在变量）可以是符合协议的任何类型的变量。同样， <code>iOS</code>上的 <code>UIView类型</code>的对象也可以引用 <code>UIView</code>的任何 <code>直接或间接子</code>类，例如 <code>UILabel</code>或 <code>UIButton</code>。使用此类对象时，我们可以使用在基本类型上定义的公共接口（等效于在枚举上定义的调用方法），也可以尝试将实例向下转换为具体的子类型，以访问该子类型唯一的数据（相当于切换一个枚举）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同之处在于哪种方法更常见（通过 <code>协议和类的公共接口进行动态调度</code>，为枚举进行切换），以及构造具有的特定功能和局限性。例如，枚举的情况列表是固定的，不能追溯扩展，而你始终可以使一个类型符合协议或添加另一个子类（尽管跨模块边界的子类是受限制的，除非你明确声明一个类为open ）。是否这个自由是理想的，甚至是必需的，取决于要解决的问题。作为值类型，枚举通常也更轻量且更适合于建模“普通旧值”。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两类类型（ <code>“或”和“与”</code>）与加法和乘法的数学概念之间有着巧妙的对应关系。知道它对于成为一名优秀的Swift程序员并不是必不可少的，但是在设计自定义类型时，我们发现它很有帮助。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;术语 <code>“类型”</code>有许多可能的定义。这里是一个：<strong>类型是其实例可以假设的所有可能值或  <code>inhabitants</code> 的集合</strong>。布尔有两个  <code>inhabitants</code> ，即假和真。  <code>UInt8</code>有 2^8 = 256个  <code>inhabitants</code> 。  <code>Int64</code>有264位  <code>inhabitants</code> ，约合18.4亿  <code>inhabitants</code> 。诸如 <code>String</code>之类的类型有无数的  <code>inhabitants</code> -你总是可以通过添加一个字符来创建另一个字符串（至少直到你填满计算机的内存为止）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在考虑两个布尔字段的元组：（布尔，布尔）。有多少  <code>inhabitants</code> 这个类型有吗？答案是四个：（假，假），（真，假），（假，真）和（真，真）。除了这四个值，不可能构造其他任何类型的值。如果我们添加另一个布尔（布尔，布尔，布尔）怎么办？由于前四个  <code>inhabitants</code> 中的每一个都可以分别与false和true结合使用，因此  <code>inhabitants</code> 的数量增加了一倍，达到8个。当然，这不仅适用于布尔。 （布尔，UInt8）对具有2×256 = 512个  <code>inhabitants</code> ，因为256个UInt8  <code>inhabitants</code> 中的每一个都可以与两个布尔值之一配对。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般而言，元组（或结构或类）的  <code>inhabitants</code> 数量等于其成员的  <code>inhabitants</code> 产品。因此，结构，类和元组也称为  <code>product types</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将此与枚举进行对比。 这是一个包含三种情况的枚举：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PrimaryColor</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> red</span><br><span class="line">    <span class="keyword">case</span> yellow</span><br><span class="line">    <span class="keyword">case</span> blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种类型有三个  <code>inhabitants</code> ，每个  <code>case</code>  一个。 除了 <code>.red</code>， <code>.yellow</code>或 <code>.blue</code>之外，无法构造其他任何 <code>PrimaryColor值</code>。 如果将关联的值添加到组合中会发生什么？ 让我们添加第四种情况，该情况允许我们指定介于0（黑色）和255（白色）之间的灰度值：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ExtendedColor</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> red</span><br><span class="line">    <span class="keyword">case</span> yellow</span><br><span class="line">    <span class="keyword">case</span> blue</span><br><span class="line">    <span class="keyword">case</span> gray(brightness: <span class="type">UInt8</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅.gray  <code>case</code> 就有256个可能的值，导致整个枚举的3 + 256 = 259个  <code>inhabitants</code> 。 一般而言，一个枚举的  <code>inhabitants</code> 人数等于其  <code>case</code> 中所有  <code>inhabitants</code> 的总数。 这就是为什么枚举也称为求和类型的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将字段添加到结构中会使可能的状态数量成倍增加，通常非常大。 将  <code>case</code>  添加到枚举只会添加一个额外的  <code>inhabitants</code> （或者，如果  <code>case</code>  具有关联值，则为其  <code>inhabitants</code> ）。 这是编写安全代码的非常有用的属性。 本章后面的 <code>“用枚举设计”</code>部分是关于如何在我们的代码中利用此属性的。</p><h1 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a><strong>Pattern Matching</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了对枚举值做一些有用的事情，我们通常必须检查其大小写并提取关联的值。以 <code>Optionals</code>为例：涉及 <code>Optionals</code>的每个操作（如 <code>if-let绑定</code>， <code>Optional链接</code>或调用 <code>Optional.map</code>）都是解开某些  <code>case</code> 的关联值并进一步处理它的简写。如果检查的值为无，则该操作通常会中止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检查枚举的最常见方法是使用 <code>switch语句</code>，它使我们可以将一个值与单个语句中的多个候选值进行比较。作为额外的好处， <code>switch</code>具有方便的语法，用于将值与特定情况进行比较并一次性提取关联的值。这种机制称为模式匹配。模式匹配不是 <code>switch</code>语句专用的，但它们是其最突出的用例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>模式匹配</code>非常有用，因为它使我们能够通过数据结构而不是仅通过其内容来分解数据结构。将纯匹配与值绑定结合在一起的能力使其特别强大。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>switch语句</code>中的每种情况都以与输入值匹配的一个或多个模式开头。模式描述值的结构。例如，以下示例中的模式 <code>.success（42，_</code>）与枚举的成功  <code>case</code> 匹配，其中关联值是一对第一个元素等于42的对。下划线是通配符模式-该对的第二个元素可以是任何值。除了简单匹配，我们还可以提取复合值的一部分并将其绑定到变量。模式 <code>.failure（let error）</code>匹配失败情况，并将关联的值绑定到新的局部常量错误：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result: <span class="type">Result</span>&lt;(<span class="type">Int</span>, <span class="type">String</span>), <span class="type">Error</span>&gt; = ...</span><br><span class="line"><span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="number">42</span>, <span class="number">_</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Found the magic number!"</span>) </span><br><span class="line">    <span class="keyword">case</span> .success(<span class="number">_</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Found another number"</span>) </span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error: \(error)"</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看一下<a href="https://docs.swift.org/swift-book/ReferenceManual/Patterns.html" target="_blank" rel="noopener"><strong>* <code>Swift支持的模式类型</code>*</strong></a>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>通配符模式</strong> - 下划线_匹配任何值并忽略它。通配符通常用于忽略关联值的一部分，而匹配另一部分。我们在上面看到了一个带有 <code>.success（42，_）</code>的示例。在 <code>switch</code>语句中， <code>case _</code>等效于默认关键字：两者都匹配任何值，并且仅在 <code>switch</code>的最后一种情况下才有意义。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>元组模式</strong> — 用逗号分隔的零个或多个子模式列表匹配元组。例如， <code>（let x，0，_）</code>将一个具有三个元素的元组匹配，其中第二个元素为0，并将第一个元素绑定到x。元组模式本身仅与元组的结构匹配，即用括号括起来的逗号分隔值。元组内容是分别匹配的子模式（在此示例中，为值绑定模式，表达模式和通配符模式）。元组模式对于在单个 <code>switch</code>语句中切换多个值非常有用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>枚举大小写模式</strong>  —匹配指定的枚举大小写。该模式可以包括关联值的子模式，无论是用于相等性检查 <code></code>（.success（42）） <code></code>还是用于值绑定 <code>（.failure（让错误））</code>。要忽略关联的值，请使用下划线或完全忽略模式，例如 <code>.success（_）</code>和 <code>.success</code>是等效的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>枚举</code>case <code>模式</code>是提取枚举的关联值或与  <code>case</code> 匹配而忽略关联值的唯一方法。 （用于与特定情况进行比较（具有特定的关联值），你也可以在if语句中使用==（假设枚举是等值的。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>值绑定模式</strong> - 将匹配值的部分或全部绑定到新的常数或变量。语法为 <code>someIdentifier</code>或 <code>varsomeIdentifier</code>。新变量的作用域是出现在其中的大小写块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为单个模式中多个值绑定的简写，你可以在模式前添加一个let前缀，而不是对每个绑定重复let。模式让（x，y）和（让x，让y）等价。注意在单个模式中使用值绑定和相等匹配时的细微差别：模式（let x，y）将元组的第一个元素绑定到新常量，但将元组的第二个元素与现有变量y比较。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要将值绑定与绑定值必须满足的其他条件结合起来，可以使用where子句扩展值绑定模式。例如，<br>.success（let httpStatus）其中 <code>200 .. &lt;300〜= httpStatus</code>仅匹配关联值落在指定范围内的成功值。至关重要的是， <code>where子句</code>是在值绑定步骤之后求值的，因此我们可以在 <code>where子句</code>中使用绑定变量。 （有关 <code>模式匹配运算符〜=</code>的更多信息，请参见下面的表达式模式。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在一  <code>case</code> 例中包含多个模式，则所有模式在其值绑定中必须使用相同的名称和类型。假设你要切换以下枚举：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> line(from: <span class="type">Point</span>, to: <span class="type">Point</span>)</span><br><span class="line">    <span class="keyword">case</span> rectangle(origin: <span class="type">Point</span>, width: <span class="type">Double</span>, height: <span class="type">Double</span>) </span><br><span class="line">    <span class="keyword">case</span> circle(center: <span class="type">Point</span>, radius: <span class="type">Double</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，每个  <code>case</code> 的关联值都包含形状的原点，但是其他参数根据形状的种类而有所不同。 尽管如此，仍可以使用包含三种模式的单个case语句提取形状的原点：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> shape &#123;</span><br><span class="line">    <span class="keyword">case</span> .line(<span class="keyword">let</span> origin, <span class="number">_</span>), .rectangle(<span class="keyword">let</span> origin, <span class="number">_</span>, <span class="number">_</span>), .circle(<span class="keyword">let</span> origin, <span class="number">_</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Origin point:"</span>, origin) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下，你不能包含其他值绑定，例如圆的半径，因为当其中一种模式匹配时，编译器保证每个绑定变量都包含一个有效值。因此，编译器必须能够为每个变量分配一个有效值，并且如果形状变为直线或矩形，则它不能针对半径执行此操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>可选模式</strong> — 通过使用熟悉的问号语法提供语法糖，用于匹配和展开可选值。模式让价值 <code>？</code>等价于 <code>.some（let value）</code>，即当可选参数为非 <code>nil</code>时匹配，并将未包装的值绑定到常量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们在<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%89):%20%20Optionals/"><strong>* <code>“可选内容”</code>*</strong></a> 一章中看到的那样，我们也可以使用 <code>nil</code>来匹配可选内容的 <code>none</code>大小写。该速记不需要特殊的编译器魔术。因为标准库包括〜=运算符的重载，用于将可选内容与 <code>nil</code>进行比较，所以它可以用作正则表达式模式（请参见下文）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>类型转换模式</strong>-如果值的运行时类型与指定的类型或该类型的子类相同，则模式为 <code>SomeType</code>匹配。  <code>let</code>值作为 <code>SomeType</code>执行相同的检查，并将匹配的值强制转换为指定的类型，而只是检查类型：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> input: <span class="type">Any</span> = ... <span class="keyword">switch</span> input &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> integer <span class="keyword">as</span> <span class="type">Int</span>: ... <span class="comment">// integer has type Int.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> string <span class="keyword">as</span> <span class="type">String</span>: ... <span class="comment">// string has type String.</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">fatalError</span>(<span class="string">"Unexpected runtime type: \(type(of: input)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式模式</strong> - 通过将输入值和模式提供给在标准库中定义的模式匹配运算符 <code>〜=</code>来与表达式匹配。  <code>Equatable类型</code>的 <code>〜=</code>的默认实现转发到 <code>==</code>; 这就是简单的相等性检查在模式中的工作方式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准库还提供范围的 <code>〜=重载</code>。 这使得检查值是否落在范围内（尤其是与单面范围组合时）的非常好的语法成为可能。 以下switch语句测试数字是正数，负数还是零：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> randomNumber = <span class="type">Int8</span>.random(<span class="keyword">in</span>: .<span class="built_in">min</span>...(.<span class="built_in">max</span>)) </span><br><span class="line"><span class="keyword">switch</span> randomNumber &#123;</span><br><span class="line">    <span class="keyword">case</span> ..&lt;<span class="number">0</span>: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(randomNumber) is negative"</span>) </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(randomNumber) is zero"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>...: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(randomNumber) is positive"</span>) </span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Can never happen"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，编译器迫使我们包括默认情况，因为它无法确定这三个具体情况涵盖了所有可能的输入（即使它们确实涵盖了），并且 <code>switch语句</code>必须始终是详尽的。 我们将在“用枚举设计”部分中详细讨论穷举性检查。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>重载〜=运算符</code>不仅限于标准库。 我们可以通过为自定义类型 <code>重载〜=来扩展模式匹配系统</code>。 实现 <code>〜=的函数</code>必须具有以下形状：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ~=<span class="params">(pattern: ???, value: ???)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>参数类型</strong>可以自由选择（甚至不必相同）。 编译器将选择最适合输入值类型的重载。 对于编译器遇到的每个表达式模式，编译器都会评估表达式模式 <code>〜= value</code>，其中 <code>value</code>是我们要切换的值，而 <code>pattern</code>是 <code>case语句</code>中的模式。 如果表达式返回 <code>true</code>，则匹配成功。 参数的类型可以自由选择。 编译器将选择最适合输入类型的实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们应该注意，除了玩具示例之外，我们从未发现有必要以这种方式 <code>扩展模式匹配</code>。 标准库很好地涵盖了基础知识，而超出基础知识的任何内容都因无法将基于自定义 <code>〜=的模式匹配</code>与 <code>值绑定和通配符模式相结合</code>而遭受太多痛苦。</p><h2 id="上下文中的模式匹配"><a href="#上下文中的模式匹配" class="headerlink" title="上下文中的模式匹配"></a><strong><em>上下文中的模式匹配</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>模式匹配</strong>是<strong>从枚举中提取关联值的唯一方法</strong>。但是模式匹配不是枚举所独有的，也不是 <code>switch语句</code>独有的。实际上，一个简单的赋值（例如let x = 1）可以看作是赋值运算符左侧与右侧表达式匹配的值绑定模式。其他模式匹配示例包括：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>解构作业中的元组</strong>，例如 <code>let（word，pi）=（“ Hello”，3.1415）</code>-并循环执行，例如字典 <code>{...}</code>中的（键，值）。请注意，for循环不使用let来表示值绑定。在这种情况下，默认情况下，所有 <code>标识符都是值绑定</code>。 for循环还支持where子句。例如，对于1 … 10中的n，其中 <code>n.isMultiple（of：3）{...}</code>仅执行3、6和9的循环体。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>元组模式</code>可以嵌套以破坏嵌套元组中的值，但是当嵌套元组具有标签时，有时你需要通过在模式中重复这些标签来帮助编译器（这不是必需的）。例如，仅在你包含外部元组的 <code>key：和value：</code>标签，而 <code>offset：和element：</code>标签的情况下才对 <code>dictionary.enumerated（）{...}</code>中的 <code>（num，（key：k，value：v））</code>进行编译可以省略。这是一个已知错误，将在Swift 5.1中修复。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用通配符忽略我们不感兴趣的值。例如，对于1中的<em>… 3，执行三次循环时不会为循环计数器创建变量，并且  `</em> = someFunction（） `在我们要执行具有副作用的函数时会禁止编译器的“未使用的结果”警告。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在catch子句中捕获错误： <code>do {...}</code>将let错误作为 <code>NetworkError {...}</code>捕获。有关更多信息，请参见错误处理一章。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>if case和guard case语句</code>类似于仅包含一个 <code>case</code>的 <code>switch语句</code>。这些有时是有用的，因为它们需要的行数少于  <code>switch</code> ，尽管我们在很多情况下更喜欢后者，以便利用编译器的详尽性检查。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>if / guard case [let]</code>的语法通常是 <code>Swift</code>新手的一大障碍。我们认为这是因为它使用 <code>赋值运算符=</code>进行基本的比较操作，并且仅可选地包括 <code>值绑定</code>。例如，以下测试枚举是否为特定情况，但忽略关联值：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color: <span class="type">ExtendedColor</span> = ...</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> .gray = color &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Some shade of gray"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以将赋值运算符认为是 <code>“执行右侧值与左侧模式的模式匹配”</code>。 当你包含使用相同语法的值绑定（仅 <code>添加let或var</code>）时，它将变得更加清晰：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> .gray(<span class="keyword">let</span> brightness) = color &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Gray with brightness \(brightness)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果让 <code>x = x</code>用于可选内容的语法，则与熟悉的代码没有太大区别。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>for case</code>和 <code>while case循环</code>的工作方式与 <code>if case</code>类似。 它们仅允许你在模式匹配成功时执行循环。 有关示例，请参阅<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%89):%20%20Optionals/"><strong>* <code>“可选”</code>*</strong></a>一章。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后， <code>闭包表达式</code>中的参数列表有时看起来像模式，因为它们还 <code>支持某种元组分解</code>。 例如，即使传递给 <code>map</code>的函数被指定为具有单个 <code>Element参数</code>（ <code>Dictionary.Element</code>是（Key，Value）），我们也可以在字典上映射并在 <code>转换闭包内</code>使用（key，value）参数列表 元组类型）：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dictionary.<span class="built_in">map</span> &#123; (key, value) <span class="keyword">in</span> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，（  <code>(key, value)</code> 看起来像元组，但不是），它是一个包含两个项目的函数参数列表。 之所以可以将<strong>参数组内的元组解包，是由于编译器中的特殊处理与模式匹配无关</strong>。 如果没有此功能，我们将不得不使用单项参数列表（例如 <code>{element in ...}</code>），然后在单独的行中将 <code>element</code>（现在是真正的元组）分解为键和值。</p><h1 id="Designing-with-Enums"><a href="#Designing-with-Enums" class="headerlink" title="Designing with Enums"></a><strong>Designing with Enums</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于<strong>枚举与结构和类属于不同的类型类别</strong>，因此它们适合于不同的设计模式。 而且，由于真正的总和类型在主流编程语言中相对较少（如果正在迅速增长），因此你可能不像传统的面向对象方法那样习惯使用它们。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们看一下我们可以在代码中使用的一些模式，以充分利用枚举。 我们将其分为六个要点：</p><ul><li>1.彻底切换</li><li>2.不可能的非法状态</li><li>3.用建模的状态</li><li>4.在枚举和结构之间进行选择</li><li>5.枚举和协议之间的平行</li><li>6.使用枚举模型递归数据结构</li></ul><h2 id="彻底切换"><a href="#彻底切换" class="headerlink" title="彻底切换"></a><strong><em>彻底切换</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在大多数情况下，对于具有 <code>多个if条件条件</code>的 <code>if case语句</code>， <code>switch</code>只是更方便的语法。除了语法差异外，还有一个重要的区别：<strong>switch语句必须是详尽无遗的，即它的大小写必须覆盖所有可能的输入值</strong>。编译器强制执行此操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>穷举性检查是编写安全代码并随着程序更改而保持代码正确性的重要工具</strong>。每次将  <code>case</code> 添加到现有枚举时，编译器都会提醒你切换该枚举的所有位置，并需要处理新  <code>case</code> 。不对 <code>if语句</code>执行穷举检查，也不能在包含默认情况的 <code>switch语句</code>中使用穷举检查-由于默认值匹配任何值，因此这种开关永远不能穷举。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，我们建议你尽可能避免在 <code>switch语句</code>中使用默认情况。你无法完全避免它们，因为编译器并不总是很聪明，无法确定一组情况是否实际上是详尽的。当我们切换一个 <code>Int8</code>时，我们在上面看到了一个例子，我们的范围模式涵盖了所有可能的值。编译器只会在安全方面犯错误，也就是说，绝不会将一组非穷尽的模式报告为穷举性（除非编译器实现中存在错误）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，在切换枚举时，假阴性并不是问题。穷举检查对于以下类型是完全可靠的：</p><ul><li>→ 布尔</li><li>→ 枚举，只要详尽检查了任何关联的值，或者你将它们与匹配任何值的模式（通配符或值绑定模式）相匹配</li><li>→ 仔细检查元组的成员类型</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看一个例子。 在这里，我们切换上面定义的 <code>Shape枚举</code>：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shape: <span class="type">Shape</span> = ... </span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> shape &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .line(from, to) <span class="keyword">where</span> from.y == to.y: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Horizontal line"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .line(from, to) <span class="keyword">where</span> from.x == to.x: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Vertical line"</span>)</span><br><span class="line">    <span class="keyword">case</span> .line(<span class="number">_</span>, <span class="number">_</span>): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Oblique line"</span>)</span><br><span class="line">    <span class="keyword">case</span> .rectangle, .circle: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Rectangle or circle"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们包括两个where子句，将水平线（等于y坐标）和垂直线（等于x坐标）视为特例。这两种情况不足以完全覆盖 <code>.line</code>情况，因此我们需要另一个能够捕获所有剩余行的情况。尽管我们不希望在此处区分 <code>.rectangle和.circle</code>，但与使用默认大小写情况相比，我们更愿意明确列出其余情况，因为这使我们能够利用<strong>穷举性检查</strong>的优势。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顺便说一句，编译器还验证了交换机中的每个模式都具有其权重。如果编译器可以证明某个模式永远不会匹配，则会发出警告，因为该模式已经被一个或多个前面的模式完全覆盖。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果枚举和使用该枚举的代码同步发展（即，每次将一个  <code>case</code> 添加到枚举时，切换该枚举的代码都可以同时更新），则穷举检查具有最大的优势。如果你可以访问程序依赖项的源代码并且该程序及其依赖项一起编译，则通常会如此。当以二进制形式分发库时，事情变得更加复杂，并且使用该库的程序必须准备好使用比该程序编译时已知的版本更高的库。在这种情况下，即使在其他详尽的开关中，也有必要始终包含默认情况。我们将在本章稍后的“Frozen and Non-Frozen Enums”部分中再次讨论这一点。</p><h2 id="不可能的非法状态"><a href="#不可能的非法状态" class="headerlink" title="不可能的非法状态"></a><strong><em>不可能的非法状态</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用静态类型的编程语言（例如Swift）有很多充分的理由。 性能是一种：<strong>编译器对程序中变量类型的了解越多，生成代码的速度就越快（通常）</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样重要的另一个原因是<strong>类型可以指导开发人员如何使用API</strong>。 如果将错误类型的值传递给函数，则编译器将立即抱怨。 我们可能将这种技术称为编译器驱动的开发-将编译器视为不是你必须与之抗衡的敌人，而是将其视为一种通过使用类型信息将你神奇地引导至正确解决方案的工具：</p><ul><li><p>→ 仔细选择输入和输出类型的函数可减少使用空间，因为类型为函数的行为建立了 <code>“上限”</code>。 例如，如果你要实现一个以非可选对象作为参数的函数，则可以确保该对象在函数体内永远不会为零。 效果如何取决于我们可以如何严格限制类型以仅接受有效值。 枚举通常是精确定义允许值范围的理想工具。</p></li><li><p>→ <strong>静态检查的类型可以防止某些错误类别</strong>；因为违反类型系统设置的约束而无法编译的代码将永远不必在运行时处理。</p></li><li><p>→ <strong>类型的文档永远同步</strong>。不像注释那样，人们在修改代码时可能会忘记更新，这些类型是程序的组成部分，并且始终是最新的。</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，并不是每个方面都可以在类型系统中表示出来。例如， <code>Swift</code>不提供任何传达功能纯净（即没有副作用）或其性能特征的支持。这就是为什么我们仍然需要文档的原因，开发人员在更新现有代码时必须注意不要违反文档记载的保证。但是很明显，可以从编译器获得的帮助量随类型系统的功能而增长。 （我们应该注意，编程语言当然有可能超越它。向编译器提供更多信息需要开发人员进行更多工作，尽管通常会有所帮助，但有时可能会妨碍你解决实际任务。此外，更精细针对特定用例调整类型，你需要编写更多代码以在类型之间转换值。我们认为 <code>Swift</code>尚未达到这一点，但没有免费的午餐。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们建议你设计自定义类型，以便最大程度地从编译器中获得帮助：<strong>使用类型可以使非法状态无法表示</strong>。之前我们在 <code>Sum Types</code>和 <code>Product Types</code>部分中看到，将一个个案添加到一个枚举中将为该类型恰好增加一个可能的值。你无法获得比这更细粒度的信息，这使得枚举对此非常有用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规范的示例是 <code>Optional</code>，在所有情况下都不会为包装类型添加一个  <code>inhabitants</code>。这正是在不诉诸哨兵价值观的情况下表示缺乏价值所需要的。我们在<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%89):%20%20Optionals/"><strong><em><code>“可选”</code></em></strong></a> 一章中讨论了带有哨兵值的问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看一下一个 <code>API</code>，它比上面的指南难用，它比它应该使用的难。  <code>Apple</code>的 <code>iOS SDK</code>中异步操作（例如执行网络请求）的常见模式是将完成处理程序（回调函数）传递给你所调用的方法。然后，该方法将在任务完成时调用处理程序，并传递操作结果。由于大多数异步操作都可能失败，因此结果通常可以是表示成功的某个值，例如服务器的响应或错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑 <code>Apple</code>的 <code>Core Location框架</code>中的地址解析 <code>API</code>。你为其传递一个地址字符串和一个回调函数。地理编码器与服务器联系，该服务器返回地址的匹配地标对象。然后，地理编码器会使用地标或错误调用完成处理程序：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLGeocoder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">geocodeAddressString</span><span class="params">(<span class="number">_</span> addressString: String,</span></span></span><br><span class="line"><span class="function"><span class="params">    completionHandler: @escaping <span class="params">([CLPlacemark]?, Error?)</span></span></span> -&gt; <span class="type">Void</span>) </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察完成处理程序的类型， <code>([CLPlacemark]?, Error?) -&gt; Void</code> 。它的两个参数都是可选的。这意味着该功能可以有四种可能的状态与调用方通信： <code>（.some，.none）</code>， <code>（.none，.some）</code>， <code>（.ome，.some）</code>或 <code>（.none，.none）</code>。 （这是一个简化的视图；  <code>.some</code>状态确实具有无限多个可能的值，但我们只关心它们是 <code>nil</code>还是 <code>nonnil</code>。）问题在于，在四个合法状态中，只有前两个状态在实践中有意义。如果开发人员收到一系列地标和错误，应该怎么办？更糟糕的是，如果两个值都返回零，该怎么办？编译器在这里无法为你提供帮助，因为类型的精度不如预期。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在， <code>Apple</code>在实现此方法时可能会小心，不要再返回这些无效状态之一，因此在实践中永远不会发生。但是 <code>API</code>的用户不能确定这一点，即使今天是正确的，也不能保证在下一个 <code>SDK版本</code>中它仍然是正确的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>地理编码API</code>用  <code>Result &lt;[CLPlacemark]，Error&gt;</code> 值替换了两个可选参数，则它将对开发人员更加友好：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CLGeocoder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">geocodeAddressString</span><span class="params">(<span class="number">_</span> addressString: String,</span></span></span><br><span class="line"><span class="function"><span class="params">    completionHandler: @escaping <span class="params">(Result&lt;[CLPlacemark], Error&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Result类型表示成功或失败，但从不表示成功和失败。</strong>通过使用一种使无效状态无法表示的类型，API变得更易于使用，并且由于编译器不允许它们，因此根本不会发生所有潜在的错误。苹果的许多 <code>iOS API</code>均未利用 <code>Swift</code>的类型系统，因为它们是用 <code>Objective-C</code>编写的，而 <code>Object-C</code>的概念不等同于带有关联值的枚举。但这并不意味着我们无法在 <code>Swift</code>中做得更好。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编写函数时，请仔细考虑参数和返回类型。你可以将类型约束为有效的输入和输出值的集合越紧密，编译器可以为你（实现函数时）和 <code>API</code>用户（调用时）提供更多帮助。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顺便说一下，到目前为止，我们一直忽略了 <code>地理编码API</code>中的另一个有趣状态：如果返回的地标数组为空怎么办？文档似乎说这永远都不会发生，即，如果服务器找不到与输入字符串匹配的内容，则该函数将返回错误。但是还有另一种可能的解释：一个空数组可能表明请求本身已成功（没有网络错误等），但未找到匹配项。仅查看类型，我们就无法确定哪种解释正确。如果我们想对类型系统中的第一个解释进行编码，则需要一个数组类型，该类型可以提供编译时保证永远不会为空。标准库不提供此功能，但我们可以编写自己的库。基本思想是编写一个结构，该结构对数组的第一个元素（称为head）使用单独的属性，对其余元素（尾部）使用标准数组（可以为空）：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NonEmptyArray</span>&lt;<span class="title">Element</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> head: <span class="type">Element</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> tail: [<span class="type">Element</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>head</code>是非可选的，因此无法创建不包含至少一个元素的 <code>NonEmptyArray</code>值。  <code>NonEmptyArray</code>的完整实现应符合 <code>Array</code>采用的所有相同协议，尤其是 <code>Collection</code>。 这将使它与普通数组一样方便使用-有时甚至更方便，因为我们可以重载某些 <code>Collection API</code>（例如，第一个和最后一个）以返回非可选值。 如果你想尝试一下吗，请查看Brandon Williams和Stephen Celis编写的 <code>NonEmpty库</code>。 这种模式的实现在包装的集合类型上是通用的（例如，你也可以有一个非空字符串）。 有关 <code>Swift的Collection集协议</code>的深入讨论，请参阅 <code>“Collection协议”</code>一章。</p><h2 id="使用枚举建模状态"><a href="#使用枚举建模状态" class="headerlink" title="使用枚举建模状态"></a><strong><em>使用枚举建模状态</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以将使非法值无法代表的这一目标应用于应用程序设计的另一个主要方面：<strong>如何在程序中建立状态模型</strong>。程序的状态是给定时间点所有变量的内容，加上（隐式）其当前的执行状态，即正在运行的线程和正在执行的指令。状态“记住”诸如应用程序处于哪种模式，正在显示哪些数据，当前正在处理的用户交互等内容。除了最琐碎的程序之外，所有程序都是有状态的：<strong>执行特定指令时，接下来会发生什么取决于系统所处的当前状态</strong>。（ <code>HTTP是无状态协议的示例</code>，这意味着服务器必须处理HTTP请求而无需考虑先前的请求Web开发人员必须使用Cookie之类的功能来记住多个请求的状态。但是，即使HTTP是无状态的，处理HTTP请求的程序仍然可以保持其内部状态。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序运行时，它会响应外部事件（例如用户交互或来自网络的传入数据）而更改其状态。这可以在开发人员无需过多考虑的情况下隐式地发生-毕竟，状态突变一直在发生。但是随着应用程序变得越来越复杂，最好有意识地定义程序（或其子系统之一）可能处于的状态以及状态之间的合法过渡。<strong>系统可以处于的状态集也称为其状态空间</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尝试使程序的状态空间尽可能小。状态空间越小，开发人员的工作就越容易-状态空间越小，减少了代码必须处理的情况。由于枚举对有限数量的状态进行建模，因此它们是建模状态和状态之间转换的理想选择。而且，由于每个状态（或枚举案例）都带有自己的数据（以关联值的形式），因此很容易使非法状态组合无法表示，就像我们在上一节中看到的那样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（我们应该注意，程序的状态空间在技术上很可能是无限大的，特别是如果你接受文本或上传的图像等形式的用户输入。这些数据类型自然地具有无限或几乎无限多个  <code>inhabitants</code>。但是就像在上一节中，我们仅关心值是否为nil或nonnil，这是通常不是问题。大多数系统状态的基本部分通常是有限的，而且数量通常很少。否则，我们将无法在代码中对它们进行建模。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看一个例子。假设我们正在编写一个聊天应用程序。当用户打开聊天频道时，该应用应在从网络加载消息列表时显示微调框。网络请求完成后，如果请求失败，则UI会转换为显示消息或显示错误。<br>首先，让我们考虑一下如何在不使用枚举的情况下以传统方式为应用程序状态建模（从技术上讲，我们仍在使用枚举，因为我们将使用可选选项，但你会明白的）。我们可以使用三个变量-在网络请求进行时将其设置为true的布尔值，以及消息列表和错误的两个可选值：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StateStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isLoading: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> messages: [<span class="type">Message</span>]? </span><br><span class="line">    <span class="keyword">var</span> error: <span class="type">Error?</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set initial state.</span></span><br><span class="line"><span class="keyword">var</span> structState = <span class="type">StateStruct</span>(isLoading: <span class="literal">true</span>, messages: <span class="literal">nil</span>, error: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载时，消息和错误均应为零，然后在网络请求完成时为其中之一分配一个值。它们绝不能同时为非 <code>nil</code>，当任何一个为 <code>非nil</code>时， <code>isLoading</code>也不应为 <code>true</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回想一下我们关于总和类型与产品类型以及如何确定一种类型的  <code>inhabitants</code>数量的讨论。  <code>StateStruct结构</code>是一种产品类型，具有2×2×2 = 8个可能的状态：布尔值true或false的任意组合，以及两个可选值中的任一个的none或some的任何组合（再次，我们忽略了的无限多个状态某些情况，因为它们与本次讨论无关）。这是一个问题，因为我们的应用程序仅需要处理这八个状态中的三个： <code>加载</code>，显 <code>示消息列表或显示错误</code>）。其他五个是无效的组合，如果我们正确编写程序，就永远不会发生这种组合，但是我们不能期望编译器会提供任何帮助来避免创建无效状态。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们将状态建模为自定义枚举，并加载，加载和失败三种状态：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">StateEnum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> loading</span><br><span class="line">    <span class="keyword">case</span> loaded([<span class="type">Message</span>])</span><br><span class="line">    <span class="keyword">case</span> failed(<span class="type">Error</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set initial state.</span></span><br><span class="line"><span class="keyword">var</span> enumState = <span class="type">StateEnum</span>.loading</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你会立即注意到，设置初始状态变得更加简洁，因为我们不必担心与初始状态无关的属性。 此外，我们完全消除了以无效状态结束的机会。 由于每个状态都有自己的关联数据，因此加载和失败的关联值不必是可选的。 结果，除非我们的代码中实际上有一个·，否则不可能转换到失败状态。（对于装入状态，事情不太清楚，因为你始终可以分配一个空数组，但这并不是你很可能会意外地执行的操作。）当程序处于特定状态时，我们可以确定所有该状态的必要数据也可用。 我们的 <code>StateEnum枚举</code>充当状态机的基础。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>枚举不是完整的有限状态机，因为它们缺乏指定非法状态转换的能力</strong>-例如，在我们的简单示例中，应该不可能从加载状态转换为失败状态，反之亦然。 实际上，除非拥有所有关联数据的有效值，否则无法实例化状态几乎是一样好的：在一个设计良好的程序中，不太可能在代码中找到很多地方状态可用，但转换到该状态仍然是无效操作。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，每次我们的代码需要访问某些状态相关的数据（例如 <code>messages数组</code>）时，我们现在都被迫切换状态枚举以提取关联的值。 有时可能会感到不便，因为 <code>switch语法</code>过于笨拙。 但这是一项重要的安全功能，因为它迫使我们始终处理所有可能的状态-至少在遵守准则的情况下，不要在switch语句中使用默认情况。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顺便说一句，你可能已经注意到，我们开始时使用的结构以及我们替换为它的枚举并不是建模此状态的唯一方法。 实际上， <code>StateStruct.isLoading</code>属性是多余的，因为在我们的设计中，当且仅当消息和错误均为零时， <code>isLoading</code>才为true。 我们可以使 <code>isLoading</code>计算属性不丢失任何内容：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StateStruct2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> messages: [<span class="type">Message</span>]? <span class="keyword">var</span> error: <span class="type">Error?</span></span><br><span class="line">    <span class="keyword">var</span> isLoading: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> messages == <span class="literal">nil</span> &amp;&amp; error == <span class="literal">nil</span> </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            messages = <span class="literal">nil</span></span><br><span class="line">            error = <span class="literal">nil</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样可以将可能的状态数从8种减少到4种，仅留下一个无效状态（当消息和错误为非零时）—并不完美，但是比我们开始时要好。通常很难注意到这样的冗余属性，但这是类型的  <code>inhabitants</code>与代数之间的联系真正可以帮助我们的地方。如本例所示，如果我们确定我们的自定义类型有2×2×2个  <code>inhabitants</code>，但其中只有三个有效，那么很容易看出其中一个因素是多余的：2×2足以容纳三个州，因此必须有可能消除一种成分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具有两个互斥的可选值的模式可能还会使你想起上一节中用Result &lt;[CLPlacemark]，Error&gt;替换的示例（[CLPlacemark] ?, Error？）。将相同的模式应用于我们的示例将产生Result &lt;[Message]，Error&gt;，但是请注意，两种情况并不完全相同。聊天应用需要第三个状态“正在加载”，其中消息和错误均为零。将Result嵌套在一个可选变量中可以完成此操作（回想一下，将一个类型包装在一个可选变量中总是会恰好增加一个  <code>inhabitants</code>），从而得到我们状态的这种替代表示形式：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// nil means "loading."</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">State2</span> = <span class="type">Result</span>&lt;[<span class="type">Message</span>], <span class="type">Error</span>&gt;?</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这等效于我们的自定义枚举，即它是一种具有三个状态且这些状态的有效载荷相同的类型。 （ <code>Result &lt;[Message] ?, Error&gt;</code>是另一个等效的变体。）但是从语义上讲，这可以说是一个较弱的解决方案，因为尚不能立即清楚nil代表“加载”状态。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的示例仅将应用程序的单个子系统的状态建模为枚举。但是你可以进一步推动这种模式，并将整个程序的状态建模为单个枚举-通常，该程序具有大量嵌套的枚举和破坏该枚举的结构。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指出各个子系统的状态。这个想法是有一个单一的变量来捕获程序的全部状态。所有状态更改都会通过一个变量，你可以观察到该变量（例如，使用 <code>didSet</code>），以在状态更改时更新应用的用户界面。这种设计还可以轻松地将整个应用程序状态写入磁盘，并在下次启动时将其读回，从而使你可以免费进行状态还原。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管你可以将整个应用程序状态建模为枚举，但按状态枚举模式的好处是你无需全力以赴即可从中受益。你可以从转换单个子系统（例如一个视图控制器）开始，然后看看它是如何工作的。然后，通过将子系统的状态枚举包装在一个新的枚举（每个子系统有一个案例）中，逐步向上处理层次结构。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总而言之，<strong>枚举非常适合建模状态</strong>。它可以在很大程度上防止无效状态，并且将子系统（甚至整个程序）的整个状态都保留在单个变量中，使状态转换不易出错。此外，穷举切换使编译器可以在添加新状态或更改其关联值时指出需要更新的代码路径。</p><h2 id="在枚举和结构之间选择"><a href="#在枚举和结构之间选择" class="headerlink" title="在枚举和结构之间选择"></a><strong><em>在枚举和结构之间选择</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在本章前面讨论了枚举和结构如何具有非常不同的属性：枚举值恰好表示其情况之一（加上其关联值），而结构值表示其所有属性的值。 尽管存在这些差异，但是遇到可以使用枚举或结构解决的问题并不少见。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将使用枚举和结构为分析事件创建数据类型。 这是枚举变量：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AnalyticsEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> loginFailed(reason: <span class="type">LoginFailureReason</span>) </span><br><span class="line">    <span class="keyword">case</span> loginSucceeded</span><br><span class="line">    ... <span class="comment">// more cases.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后使用几个计算属性扩展该枚举，这些属性将切换该枚举并返回该类型的用户所需的数据，即应发送到服务器的实际字符串和字典：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AnalyticsEvent</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .loginSucceeded:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"loginSucceeded"</span> <span class="keyword">case</span> .loginFailed:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"loginFailed"</span> <span class="comment">// ... more cases.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> metadata: [<span class="type">String</span>: <span class="type">String</span>] &#123; </span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者，我们可以将相同的分析事件建模为结构，将其名称和元数据存储在两个属性中。 我们提供静态方法（与上面的枚举情况相对应）来创建特定事件的实例：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnalyticsEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> metadata: [<span class="type">String</span> : <span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(name: <span class="type">String</span>, metadata: [<span class="type">String</span>: <span class="type">String</span>] = [:]) &#123; </span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.metadata = metadata</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">loginFailed</span><span class="params">(reason: LoginFailureReason)</span></span> -&gt; <span class="type">AnalyticsEvent</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="type">AnalyticsEvent</span>(</span><br><span class="line">                name: <span class="string">"loginFailed"</span></span><br><span class="line">            metadata: [<span class="string">"reason"</span> : <span class="type">String</span>(describing: reason)] )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> loginSucceeded = <span class="type">AnalyticsEvent</span>(name: <span class="string">"loginSucceeded"</span>) </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于我们已将初始化方法声明为私有方法，因此公共接口与 <code>enum变体</code>相同：在 <code></code>enum <code></code>公开 <code>.loginFailed（reason :)</code>或 <code>.loginSucceeded</code>之类的情况下，该结构公开静态方法或属性。名称和元数据属性在两种变体中都可用，既可以作为计算属性（在枚举中），也可以作为存储属性（在 <code>struct</code>中）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，每个版本的 <code>AnalyticsEvent类型</code>都有其独特的特征，根据你的要求，这些特征可能成为优点或缺点：</p><ul><li><p>→ 如果我们将结构的初始化程序设为内部或公共状态，则该结构可以扩展到其他文件或什至具有附加静态方法或属性的其他模块中，从而向API添加新的分析事件。枚举变体无法做到这一点：你无法追溯地向枚举添加新案例。</p></li><li><p>→ 枚举可以更精确地对数据建模；它只能代表其预定义的情况，而该结构可能在其两个属性中表示无限数量的值。如果要对事件进行进一步处理（例如合并事件序列），则枚举的精度和安全性会派上用场。</p></li><li><p>→ 该结构可以拥有私有的 <code>“用例”</code>（即并非对所有客户端可见的静态方法或静态属性），而枚举的用例始终具有与枚举本身相同的可见性。</p></li><li><p>→ 你可以在整个枚举上进行详尽的切换，以确保事件类型不为错。但是由于切换枚举的严格性，向该枚举添加其他事件类型对于此API的用户来说是潜在的破坏源代码的更改，而你可以将新事件类型的静态方法添加到结构中，而不影响其他代码。</p></li></ul><h2 id="枚举与协议之间的并行"><a href="#枚举与协议之间的并行" class="headerlink" title="枚举与协议之间的并行"></a><strong>枚举与协议之间的并行</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乍一看，枚举和协议似乎并没有太多共同点。 但是实际上，这两个概念之间存在一些有趣的相似之处。 在 <code>“求和类型和乘积类型”</code>部分中，我们提到了<strong>枚举不是唯一可以表达“一种”关系的构造； 协议也可以用于此目的</strong>。 在本节中，我们将看一个例子，并讨论这两种方法之间的差异。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从本章前面使用的类型开始-一个枚举，以在绘图应用程序中建模许多不同的形状：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> line(from: <span class="type">Point</span>, to: <span class="type">Point</span>)</span><br><span class="line">    <span class="keyword">case</span> rectangle(origin: <span class="type">Point</span>, width: <span class="type">Double</span>, height: <span class="type">Double</span>) </span><br><span class="line">    <span class="keyword">case</span> circle(center: <span class="type">Point</span>, radius: <span class="type">Double</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;形状可以是直线，矩形或圆形。 为了将这些形状渲染到  <code>Core Graphics</code> 上下文中，我们在扩展中添加了  <code>render</code> 方法。 实现必须切换自我并针对每种情况执行适当的绘图命令：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">render</span><span class="params">(into context: CGContext)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .line(from, to): </span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .rectangle(origin, width, height): </span><br><span class="line">                <span class="comment">// ... </span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .circle(center, radius): </span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，我们可以使用协议将形状定义为可以将自身呈现到 <code>Core Graphics</code>上下文中的任何类型：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">render</span><span class="params">(into context: CGContext)</span></span></span><br><span class="line">&#125;</span><br><span class="line"> ``` </span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们上面以枚举形式表示的形状类型现在变为符合 `<span class="type">Shape</span>协议 `的具体类型。 每个符合类型的类型都实现自己的 `render（into :) `方法：</span><br><span class="line"></span><br><span class="line"> ``` <span class="type">Swift</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>: <span class="title">Shape</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> from: <span class="type">Point</span> </span><br><span class="line">    <span class="keyword">var</span> to: <span class="type">Point</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">render</span><span class="params">(into context: CGContext)</span></span> &#123;</span><br><span class="line">         <span class="comment">/* ... */</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span>: <span class="title">Shape</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> origin: <span class="type">Point</span></span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">render</span><span class="params">(into context: CGContext)</span></span> &#123; </span><br><span class="line">        <span class="comment">/* ... */</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  `Circle ` type omitted.</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管在功能上是等效的，但有趣的是要考虑如何使用 <code>枚举或协议</code>来组织这两种方法，以及如何使用新功能对其进行扩展。基于枚举的实现按方法分组：所有类型的 <code>CGContext</code>呈现代码都位于 <code>render（into :)</code>方法中的单个 <code>switch</code>语句中。另一方面，基于协议的实现按“案例”进行分组：每种具体的形状类型都实现其自己的 <code>render（into :)</code>方法，其中包含其特定的渲染代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就可扩展性而言，这将产生重要的后果： <code>使用enum变体</code>，我们可以轻松添加新的渲染方法，例如 <code>渲染为SVG文件</code>-稍后在 <code>Shape的扩展中</code>，甚至在其他模块中也是如此。但是，除非我们控制包含枚举声明的源代码，否则我们无法向枚举添加新的形状。即使我们可以更改枚举的定义，对于切换该枚举的所有方法，添加新的用例也将是一项破坏源代码的更改。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一方面，我们可以轻松地使用 <code>协议变体添加新的形状</code>：我们只需创建一个新结构并将其符合 <code>Shape协议</code>即可。但是，除了修改原始的 <code>Shape协议</code>外，我们无法添加新的渲染方法，因为我们无法在协议声明之外添加新的协议要求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（我们可以在扩展程序中向协议中添加新方法，但是正如我们将在 <code>“协议”</code>一章中看到的那样，扩展方法通常不适合向协议中添加新功能，因为它们不会动态分配。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实证明，在这种情况下， <code>枚举和协议具有互补的优点和缺点</code>。每个解决方案在一个维度上都是可扩展的，而在另一个维度上则缺乏灵活性。如果API的声明及其用法在同一模块中发生，枚举和协议之间的可扩展性差异就不那么重要了。不过，如果你在编写库代码，则应考虑扩展性的哪个维度更重要：<strong>添加新案例或添加新方法</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你对跨模块边界的可扩展性这一特定问题感兴趣，请查看我们与布兰登·凯斯（Brandon Kase）录制的有关该主题的<a href="https://talk.objc.io/episodes/S01E88-extensible-libraries-1-enums-vs-classes" target="_blank" rel="noopener"><strong><em><code>Swift Talk集</code></em></strong></a>。在这些情节中，我们探索了一种使我们能够同时在两个维度上获得可扩展性的技术。</p><h2 id="使用枚举为递归数据结构建模"><a href="#使用枚举为递归数据结构建模" class="headerlink" title="使用枚举为递归数据结构建模"></a><strong><em>使用枚举为递归数据结构建模</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>枚举非常适合建模递归数据结构</strong>，即 <code>“包含”</code>自身的数据结构。 想一想树的结构：一棵树有多个分支，每个分支是另一棵树，它再次分支成多个子树，依此类推，直到到达叶子为止。 许多常见的数据格式是树结构，例如 HTML，XML和JSON。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为递归数据结构的一个示例，让我们实现一个比树还要简单的结构： <code>一个单链表</code>。 链接列表节点是以下两件事之一：<strong>具有值和对下一个节点的引用的节点，或指示列表结尾的节点</strong>。  <code>“或”</code>或 <code>“或”</code>关系强烈表明求和类型（即枚举）非常适合为该数据结构定义类型。 这是在其元素上通用的List类型的定义：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A singly linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> end</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> node(<span class="type">Element</span>, next: <span class="type">List</span>&lt;<span class="type">Element</span>&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，间接关键字是进行此编译所必需的。 间接告诉编译器将节点的情况表示为参考，从而使递归起作用。 要了解原因，请记住<strong>枚举是值类型</strong>。 值类型不能包含自身，因为允许它在计算类型的大小时会产生无限递归。 编译器必须能够确定每种类型的固定大小和有限大小。 将递归的情况作为参考来解决此问题，因为参考增加了一个间接级别。 编译器知道任何引用的存储大小始终为8字节（在64位系统上）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>间接语法仅适用于枚举</strong>。 如果它不可用，或者我们想对递归结构建模，我们可以通过将递归值装在类中来复制相同的行为，从而手动创建间接寻址。 这是一个通用类，可用作任何值的参考框：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> unbox: <span class="type">A</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">A</span>) &#123; </span><br><span class="line">        <span class="keyword">self</span>.unbox = value </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，我们可以编写List枚举而不使用间接的：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BoxedList</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> end</span><br><span class="line">    <span class="keyword">case</span> node(<span class="type">Element</span>, next: <span class="type">Box</span>&lt;<span class="type">BoxedList</span>&lt;<span class="type">Element</span>&gt;&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于我们必须一直执行手动装箱和拆箱操作，因此该枚举的使用不太方便，但它几乎等同于“列表”类型。 之所以说“几乎”，是因为间接点从整个节点case移到关联值的下一个元素，而完全相同的解决方案会将整个关联值包装在框中，如下所示： <code>case node(Box&lt;(Element, next: BoxedList&lt;Element&gt;)&gt;)</code> 。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以将间接添加到枚举声明本身，即间接枚举列表 <code>{...}</code>。 这是一种较短的语法，用于在所有具有关联值的情况下启用间接寻址（间接仅应用于关联值，而从未应用于枚举用于区分其情况的标记位）。 对于我们的List类型，这两个变量都是等效的，因为没有与值关联但不应该间接存储的个案。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;展望未来，我们将继续利用原始列表枚举，该枚举可利用间接枚举。 手动装箱的弯路只是为了向你显示间接只是语法糖，而不是编译器魔术。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们讨论一下如何使用 <code>List枚举</code>。 我们通过创建一个新节点将元素添加到列表的前面，并将下一个值设置为当前节点：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyList = <span class="type">List</span>&lt;<span class="type">Int</span>&gt;.end</span><br><span class="line"><span class="keyword">let</span> oneElementList = <span class="type">List</span>.node(<span class="number">1</span>, next: emptyList) </span><br><span class="line"><span class="comment">// node(1, next: List&lt;Swift.Int&gt;.end)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使此过程更容易一些，我们可以创建一个用于添加元素的方法。 我们将此方法命名为 <code>cons</code>，因为这是Lisp中的操作的名称（它是 <code>“construct”</code>的缩写，将元素添加到列表的前面有时称为 <code>“consing”</code>）：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Return a new list by prepending a node with value  `x ` to the </span></span><br><span class="line">    <span class="comment">/// front of a list.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cons</span><span class="params">(<span class="number">_</span> x: Element)</span></span> -&gt; <span class="type">List</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .node(x, next: <span class="keyword">self</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A 3-element list, of (3 2 1).</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="type">List</span>&lt;<span class="type">Int</span>&gt;.end.cons(<span class="number">1</span>).cons(<span class="number">2</span>).cons(<span class="number">3</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">node(3, next: List&lt;Swift.Int&gt;.node(2, next: List&lt;Swift.Int&gt;.node(1,</span></span><br><span class="line"><span class="comment">next: List&lt;Swift.Int&gt;.end))) */</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接语法可以清楚地说明列表的构造方式，但也很丑陋。 我们可以为 <code>ExpressibleByArrayLiteral</code>添加一致性，以便能够使用数组文字初始化列表。 该实现首先反转输入数组（因为列表是从末尾开始构建的），然后使用 <code>reduce</code>从 <code>.end</code>节点开始将 <code>reduce</code>元素逐个添加到列表中：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">List</span>: <span class="title">ExpressibleByArrayLiteral</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(arrayLiteral elements: <span class="type">Element</span>...) &#123;</span><br><span class="line">        <span class="keyword">self</span> = elements.reversed().<span class="built_in">reduce</span>(.end) &#123; </span><br><span class="line">            partialList, element <span class="keyword">in</span> partialList.cons(element)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> list2: <span class="type">List</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">node(3, next: List&lt;Swift.Int&gt;.node(2, next: List&lt;Swift.Int&gt;.node(1,</span></span><br><span class="line"><span class="comment">next: List&lt;Swift.Int&gt;.end))) */</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此列表类型具有一个有趣的属性： <code>“持久”</code>。 节点是不可变的，一旦创建，就无法更改它们。 将另一个元素包含在列表中不会复制该列表。 它只是为你提供了一个链接到现有列表前面的新节点。<br>这意味着两个列表可以共享一条尾巴：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/aseu-stp1.png" alt="Memeory" title="List Sharing"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列表的不变性在这里很关键。 如果可以更改列表（例如，删除最后一个条目或更新节点中保留的元素），则此共享将是一个问题-x可能会更改列表，而更改会影响y。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，我们可以在List上定义诱变方法来推送和弹出元素：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> x: Element)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="keyword">self</span>.cons(x) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123; </span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .end: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .node(x, next: tail):</span><br><span class="line">                <span class="keyword">self</span> = tail</span><br><span class="line">                <span class="keyword">return</span> x </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们不是只说清单必须是不变的，才能使持久性发挥作用吗？ 它怎么有突变方法？ 这些变异方法不会更改列表。 相反，它们只是更改变量引用的列表部分：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack: <span class="type">List</span>&lt;<span class="type">Int</span>&gt; = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] </span><br><span class="line"><span class="keyword">var</span> a = stack</span><br><span class="line"><span class="keyword">var</span> b = stack</span><br><span class="line">a.pop() <span class="comment">// Optional(3) </span></span><br><span class="line">stack.pop() <span class="comment">// Optional(3) </span></span><br><span class="line">stack.push(<span class="number">4</span>)</span><br><span class="line">b.pop() <span class="comment">// Optional(3) </span></span><br><span class="line">b.pop() <span class="comment">// Optional(2) </span></span><br><span class="line">stack.pop() <span class="comment">// Optional(4) s</span></span><br><span class="line">tack.pop() <span class="comment">// Optional(2)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变异方法使我们可以更改self所引用的值，但是这些值本身（列表的节点）是不可变的。 从这个意义上讲，通过间接，变量已成为列表的迭代器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/aseu-stp2.png" alt="Memeory" title="List Iteration"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>“Collection协议”</code>一章中，我们将回到使用列表作为迭代器的想法，在此我们使列表枚举与序列协议保持一致。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，你可以使用let而不是var来声明变量，在这种情况下，变量将是常量（即，设置后便无法更改其持有的值）。 但是让我们来谈谈变量，而不是值。 根据定义，值是恒定的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，这只是事物运作方式的逻辑模型。 实际上，这些节点实际上位于彼此指向的内存中。 而且它们占用了空间，如果不再需要, Swift使用自动引用计数（ARC）进行管理，并为不再使用的节点释放内存：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/aseu-stp3.png" alt="Memeory" title=" List Memory Management"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于递归枚举的另一个示例，请查看 <code>“互操作性”</code>一章，在该章节中，我们使用枚举构建表示 <code>Markdown文本</code>的数据结构。 你会注意到，尽管我们建立的两个枚举都是递归的，但它们不需要 <code>indirect</code>关键字。 这是因为它们的子节点是数组。 由于数组在内部使用引用类型作为其存储，因此它们已经提供了所需的间接级别，从而使间接不必要。</p><h1 id="Raw-Values"><a href="#Raw-Values" class="headerlink" title="Raw Values"></a><strong>Raw Values</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时最好将枚举的每种情况与数字或其他值相关联。 默认情况下， <code>C</code>或 <code>Objective-C</code>中的枚举都是这样的-实际上，它们实际上只是整数。 <code>Swift枚举</code>不能与任意整数互换，但是我们可以选择声明枚举的大小写与原始值之间的一对一映射。 这对于与 <code>C API</code>互操作或以 <code>JSON之类</code>的数据格式对枚举值进行编码很有用（我们将在 <code>“编码和解码”</code>一章中讨论的 <code>Codable系统</code>可以自动为具有 <code>原始值的枚举合成Codable一致性</code>） ）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给出枚举原始值包括将原始值类型（由冒号与类型名称分隔）添加到类型声明中。 然后，你可以使用赋值语法为每种情况分配一个原始值。 这是原始状态类型为 <code>Int</code>的 <code>HTTP状态代码</code>的枚举示例：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTPStatus</span>: <span class="title">Int</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> ok = <span class="number">200</span></span><br><span class="line">    <span class="keyword">case</span> created = <span class="number">201</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> movedPermanently = <span class="number">301</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> notFound = <span class="number">404</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个案例必须具有唯一的原始值。 如果我们不提供一种或多种情况的值，则编译器将尝试选择合理的默认值。 在这个例子中，我们可以省略所创建案例的显式原始值分配。 编译器会通过增加前一个案例的原始值来选择相同的值201。</p><h2 id="The-RawRepresentable-Protocol"><a href="#The-RawRepresentable-Protocol" class="headerlink" title="The RawRepresentable Protocol"></a><strong><em>The RawRepresentable Protocol</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原始可表示类型获得两个新的API： <code>rawValue属性</code>和失败的初始化程序  <code>(init?(rawValue:))</code> 。 这些在 <code>RawRepresentable协议</code>中声明（编译器自动为具有原始值的枚举实现此协议）：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A type that can be converted to and from an associated raw value.</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RawRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The type of the raw values, such as Int or String. associatedtype RawValue</span></span><br><span class="line">    <span class="keyword">init</span>?(rawValue: <span class="type">RawValue</span>)</span><br><span class="line">    <span class="keyword">var</span> rawValue: <span class="type">RawValue</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化程序可能失败，因为对于每个 <code>RawValue类型</code>的居民，可能没有一个有效的符合类型的值。 例如，只有几十个整数是有效的 <code>HTTP状态代码</code>。 对于所有其他输入， <code>HTTPStatus.init？（rawValue :)</code>必须返回nil：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HTTPStatus</span>(rawValue: <span class="number">404</span>) <span class="comment">// Optional(HTTPStatus.notFound) </span></span><br><span class="line"><span class="type">HTTPStatus</span>(rawValue: <span class="number">1000</span>) <span class="comment">// nil </span></span><br><span class="line"><span class="type">HTTPStatus</span>.created.rawValue <span class="comment">// 201</span></span><br></pre></td></tr></table></figure><h2 id="RawRepresentable-Conformance"><a href="#RawRepresentable-Conformance" class="headerlink" title="RawRepresentable Conformance"></a><strong><em>RawRepresentable Conformance</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述将原始值分配给枚举的语法仅适用于一组有限的类型； 原始值类型可以是字符串，字符或任何整数或浮点类型。 这涵盖了很多用例，但这并不意味着这些类型是唯一可能的原始值类型。 因为以上语法只是  <code>RawRpresentable一致性</code> 的语法糖，所以如果需要更大的灵活性，始终可以选择手动实现一致性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的示例定义一个枚举，该枚举表示逻辑坐标系中的点，其中x和y坐标可以采用介于-1（左/下）和1（右/上）之间的值。 该坐标系有点类似于 <code>Apple</code>的 <code>Core Animation框架</code>中 <code>CALayer</code>的 <code>anchorPoint属性</code>。 我们使用一对整数作为原始值类型，并且由于便捷语法不支持元组，因此我们手动实现 <code>RawRepresentable</code>：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AnchorPoint</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> center</span><br><span class="line">    <span class="keyword">case</span> topLeft </span><br><span class="line">    <span class="keyword">case</span> topRight </span><br><span class="line">    <span class="keyword">case</span> bottomLeft </span><br><span class="line">    <span class="keyword">case</span> bottomRight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AnchorPoint</span>: <span class="title">RawRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">RawValue</span> = (x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rawValue: (x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123; </span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .center: <span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">case</span> .topLeft: <span class="keyword">return</span> (-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">case</span> .topRight: <span class="keyword">return</span> (<span class="number">1</span>, <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">case</span> .bottomLeft: <span class="keyword">return</span> (-<span class="number">1</span>, -<span class="number">1</span>) </span><br><span class="line">            <span class="keyword">case</span> .bottomRight: <span class="keyword">return</span> (<span class="number">1</span>, -<span class="number">1</span>) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>?(rawValue: (x: <span class="type">Int</span>, y: <span class="type">Int</span>)) &#123; </span><br><span class="line">        <span class="keyword">switch</span> rawValue &#123;</span><br><span class="line">            <span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>): <span class="keyword">self</span> = .center </span><br><span class="line">            <span class="keyword">case</span> (-<span class="number">1</span>, <span class="number">1</span>): <span class="keyword">self</span> = .topLeft</span><br><span class="line">            <span class="keyword">case</span> (<span class="number">1</span>, <span class="number">1</span>): <span class="keyword">self</span> = .topRight </span><br><span class="line">            <span class="keyword">case</span> (-<span class="number">1</span>, -<span class="number">1</span>): <span class="keyword">self</span> = .bottomLeft </span><br><span class="line">            <span class="keyword">case</span> (<span class="number">1</span>, -<span class="number">1</span>): <span class="keyword">self</span> = .bottomRight </span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这还需要编写一些代码，但这并不困难。 这正是编译器在自动 <code>RawRepresentable</code>综合中为我们生成的代码。 不足为奇的是，在两种情况下，枚举用户的行为都是相同的：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnchorPoint</span>.topLeft.rawValue <span class="comment">// (x: -1, y: 1) </span></span><br><span class="line"><span class="type">AnchorPoint</span>(rawValue: (x: <span class="number">0</span>, y: <span class="number">0</span>)) <span class="comment">// Optional(AnchorPoint.center) </span></span><br><span class="line"><span class="type">AnchorPoint</span>(rawValue: (x: <span class="number">2</span>, y: <span class="number">1</span>)) <span class="comment">// nil</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;手动实现 <code>RawRepresentable</code>时要注意的一件事是<strong>重复的原始值的分配</strong>。 自动综合要求原始值是唯一的-重复会导致编译错误。 但是，在手动实施中，编译器不会阻止你为多个枚举案例返回相同的原始值。 使用重复的原始值可能有充分的理由（例如，当枚举使用多个大小写作为彼此的同义词时，也许是为了向后兼容），但这是例外。 切换枚举总是匹配枚举的大小写，而不匹配原始值。 换句话说，即使一个案例具有相同的原始价值，你也无法将其匹配。</p><h2 id="RawRepresentable用于结构和类"><a href="#RawRepresentable用于结构和类" class="headerlink" title="RawRepresentable用于结构和类"></a><strong><em>RawRepresentable用于结构和类</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顺便说一句， <code>RawRepresentable</code>不仅限于枚举； 你还可以遵循结构或类。 对于为保护类型安全而引入的简单包装类型， <code>RawRepresentable一致性</code>通常是一个不错的选择。 例如，程序可以使用字符串在内部表示用户ID。 最好直接定义一种新的UserID类型，以防止与其他字符串变量意外混合，而不是直接使用String。 仍然可以使用字符串初始化UserID并提取其字符串值。  <code>RawRepresentable</code>非常适合以下要求：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserID</span>: <span class="title">RawRepresentable</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> rawValue: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里， <code>rawValue属性</code>满足两个协议要求之一，但是第二个要求（初始化程序）的实现又去了哪里呢？ 它由 <code>Swift</code>的针对结构的自动成员初始化器提供。 编译器足够聪明，可以接受（不失败的） <code>init（rawValue :)</code>作为协议所需的失败初始化程序的实现。 这具有很好的副作用，即从字符串创建UserID时，我们不必处理可选参数。 如果要验证输入字符串（也许并非所有字符串都是有效的用户ID），我们都必须为 <code>init？（rawValue :)</code>提供我们自己的实现。</p><h3 id="原始值的内部表示"><a href="#原始值的内部表示" class="headerlink" title="原始值的内部表示"></a><strong><em>原始值的内部表示</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了添加的 <code>RawRepresentable API</code>和自动可编码综合之外，带有原始值的枚举实际上与所有其他枚举没有什么不同。 特别是，具有原始值的枚举将保留其完整的类型标识。 与C语言不同，在C语言中，你可以将任意整数值分配给枚举类型的变量，而带有Int原始值的Swift枚举不会“成为”整数。 枚举实例只能具有的值是枚举的大小写。 获取原始值的唯一方法是通过 <code>rawValue</code>和 <code>init？（rawValue :) API</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拥有原始值也不会改变枚举的内存表示形式。 我们可以通过定义一个带有String原始值的枚举并查看类型的大小来验证这一点：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MenuItem</span>: <span class="title">String</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> undo = <span class="string">"Undo"</span> </span><br><span class="line">    <span class="keyword">case</span> cut = <span class="string">"Cut"</span></span><br><span class="line">    <span class="keyword">case</span> copy = <span class="string">"Copy"</span> </span><br><span class="line">    <span class="keyword">case</span> paste = <span class="string">"Paste"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">MenuItem</span>&gt;.size <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MenuItem类型只有一个字节大。 这告诉我们MenuItem实例不在内部存储原始值-如果是这样，则必须至少大16个字节（在64位平台上为String的大小）。 rawValue的编译器生成的实现就像一个计算属性一样，类似于上面显示的AnchorPoint的实现。</p><h2 id="Enumerating-Enum-Cases"><a href="#Enumerating-Enum-Cases" class="headerlink" title="Enumerating Enum Cases"></a><strong>Enumerating Enum Cases</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的  <code>Sum Types and Product Types</code>中，我们讨论了一种类型的居民：类型实例可以具有的所有可能值的集合。 将这些值作为一个集合来操作通常很有用，例如 遍历它们或计数它们。  <code>CaseIterable协议</code>通过添加名为 <code>allCases</code>的静态属性（即在类型而非实例上调用的属性）来对此功能进行建模：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A type that provides a collection of all of its values.</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CaseIterable</span> </span>&#123; </span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">AllCases</span>: <span class="type">Collection</span></span><br><span class="line">    <span class="keyword">where</span> <span class="type">AllCases</span>.<span class="type">Element</span> == <span class="type">Self</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> allCases: <span class="type">AllCases</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于没有关联值的枚举，编译器可以自动生成 <code>CaseIterable实现</code>。 我们要做的就是声明符合性。 让我们对上一部分中的 <code>MenuItem类型</code>进行此操作：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MenuItem</span>: <span class="title">String</span>, <span class="title">CaseIterable</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> undo = <span class="string">"Undo"</span></span><br><span class="line">    <span class="keyword">case</span> cut = <span class="string">"Cut"</span></span><br><span class="line">    <span class="keyword">case</span> copy = <span class="string">"Copy"</span></span><br><span class="line">    <span class="keyword">case</span> paste = <span class="string">"Paste"</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为 <code>allCases属性</code>是一个 <code>Collection</code>，所以它具有你从数组和其他集合中了解的所有常规属性和功能。 在以下示例中，我们使用 <code>allCases</code>获取所有菜单项的计数并将其转换为适合在用户界面中显示的字符串（为简单起见，我们将原始值直接用作菜单项标题； 实际应用会将原始值用作存储本地化标题的查找表的键）：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MenuItem</span>.allCases</span><br><span class="line"><span class="comment">// [MenuItem.undo, MenuItem.cut, MenuItem.copy, MenuItem.paste] </span></span><br><span class="line"><span class="type">MenuItem</span>.allCases.<span class="built_in">count</span> <span class="comment">// 4</span></span><br><span class="line"><span class="type">MenuItem</span>.allCases.<span class="built_in">map</span> &#123; $<span class="number">0</span>.rawValue &#125; <span class="comment">// ["Undo", "Cut", "Copy", "Paste"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与其他编译器综合协议实现（例如 <code>Equatable</code>和 <code>Hashable</code>）相似，自动生成的 <code>CaseIterable一致性</code>的最大好处不是代码本身的困难（编写手动实现很简单），而是由编译器生成的代码这一事实。 始终保持最新状态–每次添加或删除案例时都必须更新手动一致性，这很容易忘记。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>CaseIterable协议</code>没有在 <code>allCases集合</code>中规定值的特定顺序，但是 <code>CaseIterable</code>的文档保证了合成的一致性按声明顺序提供了案例。</p><h2 id="Manual-CaseIterable-Conformance"><a href="#Manual-CaseIterable-Conformance" class="headerlink" title="Manual CaseIterable Conformance"></a><strong><em>Manual CaseIterable Conformance</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>CaseIterable</code>对于没有关联值的纯枚举特别有用，并且这些是自动编译器综合涵盖的唯一类型。 这是有道理的，因为向枚举添加关联的值会使枚举可能具有无限数量的居民数量。 但是，只要我们能提出一种产生所有居民集合的方法，我们就始终可以手动实现一致性。 实际上，我们甚至不限于枚举。 尽管名称 <code>CaseIterable</code>和 <code>allCases</code>暗示此功能主要用于枚举（没有其他类型具有大小写），但是编译器很乐意接受符合该协议的结构或类。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编写手动 <code>CaseIterable</code>实现的最简单类型之一是 <code>Bool</code>：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Bool</span>: <span class="title">CaseIterable</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> allCases: [<span class="type">Bool</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="literal">false</span>, <span class="literal">true</span>] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Bool</span>.allCases <span class="comment">// [false, true]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一些整数类型也是很好的匹配。 请注意， <code>allCases</code>的返回类型不必是数组，它可以是任何 <code>Collection</code>。 当一个范围可以用更少的内存表示同一集合时，生成每个可能的整数的数组将是非常浪费的：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt8</span>: <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> allCases: <span class="type">ClosedRange</span>&lt;<span class="type">UInt8</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> .<span class="built_in">min</span> ... .<span class="built_in">max</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">UInt8</span>.allCases.<span class="built_in">count</span> <span class="comment">// 256</span></span><br><span class="line"><span class="type">UInt8</span>.allCases.<span class="keyword">prefix</span>(<span class="number">3</span>) + <span class="type">UInt8</span>.allCases.suffix(<span class="number">3</span>) <span class="comment">// [0, 1, 2, 253, 254, 255]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照相同的逻辑，如果你要为具有大量居民的类型或生成值非常昂贵的类型编写  <code>CaseIterable</code> 实现，请考虑返回一个惰性集合，以免预先执行不必要的工作。 我们将在 <code>“Collection协议”</code>一章中讨论延迟收集。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，这两个示例都忽略了通用规则，即不将你不拥有的类型与你不拥有的协议相一致。 在生产代码中违反此规则之前，请考虑与此相关的权衡。 有关更多信息，请参阅协议一章。</p><h1 id="Frozen-and-Non-Frozen-Enums"><a href="#Frozen-and-Non-Frozen-Enums" class="headerlink" title="Frozen and Non-Frozen Enums"></a><strong>Frozen and Non-Frozen Enums</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本章中，我们反复强调，枚举的最佳品质之一是能够在其上进行彻底切换。很明显，如果编译器在编译时知道枚举可能具有的所有可能情况，则只能执行其详尽性检查。对于与切换它们的代码在同一模块中的枚举声明，这确实是正确的。如果枚举声明位于另一个库中，但是该库与客户端代码一起编译，也是如此-每次添加或删除大小写时，枚举声明和客户端代码都将重新编译，从而允许编译器重新检查所有switch语句。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，在某些情况下，我们希望从以二进制形式链接到程序的模块中切换枚举。标准库是最突出的例子：即使标准库的源代码是免费提供的，我们通常也会使用 <code>Swift</code>发行版或操作系统附带的二进制文件。 Swift附带的其他库（包括 <code>Foundation</code>和 <code>Dispatch</code>）也是如此。最后， <code>Apple</code>和其他公司希望以二进制形式发布Swift库。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以标准库类型为例，假设我们要在代码中切换 <code>DecodingError</code>实例。从 <code>Swift 5.0</code>开始， <code>DecodingError</code>是一个枚举，它具有四种情况来指示不同的错误情况：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> error: <span class="type">DecodingError</span> = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exhaustive at compile time, but possibly not at runtime.</span></span><br><span class="line"><span class="keyword">switch</span> error &#123;</span><br><span class="line">    <span class="keyword">case</span> .typeMismatch: ... </span><br><span class="line">    <span class="keyword">case</span> .valueNotFound: ... </span><br><span class="line">    <span class="keyword">case</span> .keyNotFound: ... </span><br><span class="line">    <span class="keyword">case</span> .dataCorrupted: ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着 <code>Codable</code>系统的扩展，未来的Swift版本也将添加更多的案例。但是，如果我们构建了一个包含此代码的应用程序并将其交付给客户，则其中的某些客户最终可能会在具有包含另一个 <code>DecodingError</code>案例的较新 <code>Swift版本</code>的较新 <code>OS</code>上运行该可执行文件。在这种情况下，我们的程序会崩溃，因为它遇到了无法处理的条件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一个将来可能会获得新案例的枚举称为非冻结枚举</strong>。为了使程序能够抵抗非冻结枚举的更改，从另一个模块切换非冻结枚举的代码必须始终包含默认子句，以便能够处理将来的情况。在Swift 5.0中，如果省略默认情况，则编译器仅发出警告（不是错误），但这只是暂时的情况，使现有代码的迁移更加容易。在将来的版本中它将成为错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你接受编译器的警告修复程序，则会注意到它在默认情况下添加了 <code>@unknown属性</code>：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> error &#123; ...</span><br><span class="line">    <span class="keyword">case</span> .dataCorrupted: ... </span><br><span class="line">    @unknown <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// Handle unknown cases.</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>@unknown default</code>在运行时的行为类似于普通的 <code>default</code>子句，但这也向编译器发出信号，表明默认情况仅用于处理在编译时未知的枚举情况。如果默认大小写与编译时已知的大小写匹配，我们仍会收到警告。这意味着我们将来在较新的库接口上重新编译程序时，仍然可以从穷举检查中受益。如果自上次更新以来将一个案例添加到库API中，我们将收到警告以更新所有 <code>switch</code>语句以显式处理新案例。 <code>@unknown</code>默认值可为你提供两全其美的优势：<strong>编译时穷举性检查和运行时安全性</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift 5.0</code>中，仅对标准库， <code>Apple框架</code>的 <code>Swif</code>t叠加层以及从 <code>C</code>和 <code>Objective-C</code>导入的枚举启用了 <code>冻结和非冻结枚举</code>之间的区别。标准库和覆盖以特殊的弹性模式编译，该模式由 <code>-enable-resilience</code>编译器标志触发。弹性库中的枚举（即旨在维护版本之间的二进制兼容性的库）默认情况下未冻结。还有一个未记录的属性 <code>@_frozen</code>，用于将特定的枚举声明标记为冻结。通过使用此属性，库的开发人员保证永远不会在该枚举中添加其他大小写，否则将破坏二进制兼容性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准库中的冻结枚举示例包括 <code>“Optional”</code>和 <code>“Result”</code>；如果它们没有冻结，那么切换它们将始终需要一个默认子句，这将是一个很大的麻烦。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着 <code>Swift</code>的用于构建弹性库的功能集在将来的版本中不断发展，很可能每个人都可以选择构建弹性二进制库。在撰写本文时，正在审查一项实现此目的的 <code>Swift Evolution</code>提案，其中包括将 <code>@frozen</code>属性（现在带有正式的，非下划线的名称）公开。</p><h1 id="技巧和窍门"><a href="#技巧和窍门" class="headerlink" title="技巧和窍门"></a><strong>技巧和窍门</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们以一些提示和技巧结束本章。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽量避免嵌套 <code>switch语句</code>。 你可以使用元组一次切换多个值。 例如，假设你要基于两个布尔值设置变量。 一次又一次地切换 <code>Bools</code>，需要重复内部开关，这很快就变得很丑陋：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isImportant: <span class="type">Bool</span> = ... </span><br><span class="line"><span class="keyword">let</span> isUrgent: <span class="type">Bool</span> = ...</span><br><span class="line"><span class="keyword">let</span> priority: <span class="type">Int</span> </span><br><span class="line"><span class="keyword">switch</span> isImportant &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">        <span class="keyword">switch</span> isUrgent &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">true</span>: </span><br><span class="line">                priority = <span class="number">3</span> </span><br><span class="line">            <span class="keyword">case</span> <span class="literal">false</span>: </span><br><span class="line">                priority = <span class="number">2</span> </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">        <span class="keyword">switch</span> isUrgent &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">true</span>: </span><br><span class="line">                priority = <span class="number">1</span> </span><br><span class="line">            <span class="keyword">case</span> <span class="literal">false</span>: </span><br><span class="line">                priority = <span class="number">0</span> </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将两个 <code>Bools</code>放入一个元组并进行切换会更短且更易读：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> priority2: <span class="type">Int</span></span><br><span class="line"><span class="keyword">switch</span> (isImportant, isUrgent) &#123; </span><br><span class="line">    <span class="keyword">case</span> (<span class="literal">true</span>, <span class="literal">true</span>): </span><br><span class="line">        priority2 = <span class="number">3</span> </span><br><span class="line">    <span class="keyword">case</span> (<span class="literal">true</span>, <span class="literal">false</span>): </span><br><span class="line">        priority2 = <span class="number">2</span> </span><br><span class="line">    <span class="keyword">case</span> (<span class="literal">false</span>, <span class="literal">true</span>): </span><br><span class="line">        priority2 = <span class="number">1</span> </span><br><span class="line">    <span class="keyword">case</span> (<span class="literal">false</span>, <span class="literal">false</span>): </span><br><span class="line">        priority2 = <span class="number">0</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>利用明确的初始化检查</strong>。再看一下前面的代码示例。这种在切换之前声明但不初始化let常量，然后在每种情况下都进行初始化的模式，利用了编译器的明确初始化检查功能。编译器会验证变量在首次使用前是否已完全初始化-如果我们忘记在一个或多个代码路径中进行初始化，它将发出错误。这种样式比将优先级设为 <code>var</code>并为其分配两次（一次在声明站点，然后再次在开关内部）的天真的选择要安全得多。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像 <code>if</code>一样， <code>switch</code>是一个语句，而不是一个表达式，尽管我们经常希望它是后者。  <code>Swift</code>没有方便的语法来设置由于切换枚举而导致的变量。在每种情况下，在 <code>switch</code>语句之前声明一个常量并分配给它是我们所能做的最好的事情。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;避免将枚举案例命名为  <code>none</code> or  <code>some</code>。这些是枚举案例的诱人名称；但是，由于在模式匹配上下文中与 <code>Optional</code>的案例名称可能会发生冲突，因此我们建议你避免使用它们。因此，这是一个有问题的枚举定义：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Selection</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span> </span><br><span class="line">    <span class="keyword">case</span> some </span><br><span class="line">    <span class="keyword">case</span> all</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们有一个类型为 <code>Selection</code>的变量？ （即可选），并希望将其与模式匹配：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalSelection: <span class="type">Selection?</span> = ...</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> .some = optionalSelection &#123; </span><br><span class="line">    <span class="comment">// Some items selected? Or?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它只匹配 <code>Selection.some</code>还是匹配 <code>Optional.some</code>，即任何非nil值？ 答案是后者，但这很容易出错，特别是考虑到Swift喜欢将非可选值隐式提升为可选值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于带有保留字的案例名称，请使用反引号。 如果你使用某些关键字作为案例名称（例如默认名称），则类型检查器会抱怨，因为它无法解析代码。 你可以将单词包装在反引号中以使用它：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> custom</span><br><span class="line">    <span class="keyword">case</span>  `<span class="keyword">default</span> ` <span class="comment">// requires backticks.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样做的好处是，在类型检查器可以消除你的意思歧义的地方，不需要反引号。 这是完全正确的：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strategy = <span class="type">Strategy</span>.<span class="keyword">default</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举大小写可以像工厂方法一样使用。 如果枚举案例具有关联的值，则案例名称将单独构成具有签名 <code>（AssocValue）-&gt; Enum</code>的函数。 使用此枚举来表示两种颜色空间（RGB或灰度）之一中的颜色：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OpaqueColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> rgb(red: <span class="type">Float</span>, green: <span class="type">Float</span>, blue: <span class="type">Float</span>) </span><br><span class="line">    <span class="keyword">case</span> gray(intensity: <span class="type">Float</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>OpaqueColor.rgb</code>是一个函数，它需要三个Float并产生一个 <code>OpaqueColor</code>：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OpaqueColor</span>.rgb <span class="comment">// (Float, Float, Float) -&gt; OpaqueColor</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以将这些函数传递给高阶函数，例如 <code>map</code>。 在这里，我们通过将枚举案例直接传递给 <code>map</code>作为工厂方法来创建从黑色到白色的灰度颜色渐变：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gradient = <span class="built_in">stride</span>(from: <span class="number">0.0</span>, through: <span class="number">1.0</span>, by: <span class="number">0.25</span>).<span class="built_in">map</span>(<span class="type">OpaqueColor</span>.gray) <span class="comment">/*</span></span><br><span class="line"><span class="comment">[OpaqueColor.gray(intensity: 0.0), OpaqueColor.gray(intensity: 0.25),</span></span><br><span class="line"><span class="comment">OpaqueColor.gray(intensity: 0.5), OpaqueColor.gray(intensity: 0.75), OpaqueColor.gray(intensity: 1.0)]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>不要使用关联的值来伪造存储的属性。 改用结构。</strong> 枚举不能存储属性。 这听起来像是一个重大限制，但事实并非如此。 如果考虑一下，添加 <code>类型T</code>的存储属性实际上与为每种情况添加相同类型的关联值没有什么不同。 例如，让我们通过为每种情况指定一个更多的关联值，从上方将 <code>alpha</code>通道添加到我们的 <code>OpaqueColor类型</code>：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AlphaColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> rgba(red: <span class="type">Float</span>, green: <span class="type">Float</span>, blue: <span class="type">Float</span>, alpha: <span class="type">Float</span>) </span><br><span class="line">    <span class="keyword">case</span> gray(intensity: <span class="type">Float</span>, alpha: <span class="type">Float</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以，但是现在从 <code>AlphaColor实例</code>中提取 <code>Alpha</code>量不是很方便-我们必须切换该实例并从每种情况中提取值，即使我们知道每个 <code>AlphaColor</code>都具有 <code>Alpha成分</code>。 我们可以将此逻辑包装在一个计算属性中，但是更好的解决方案可能是首先避免该问题-让我们将原始的 <code>OpaqueColor</code>枚举包装在结构中，并将 <code>alpha</code>用作该结构的存储属性：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">OpaqueColor</span> </span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Float</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一种通用模式：当你看到一个枚举，其中每个个案的有效载荷中都有相同的数据时，请考虑将枚举包装在结构中并拉出公用属性。 这会改变结果类型的形状，但不会改变其基本性质。 与在数学方程式中排除一个公因子相同： <code>a×b + a×c = a×（b + c）</code>。 与代数的对应关系就是为什么总和与乘积类型的总称是 <code>“代数数据类型”</code>的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>不要过度使用相关的值要素。</strong> 在本章中，我们将关联值与多个元组样式的组件一起使用，例如 <code>OpaqueColor.rgb（red：green：blue :)</code>。 这对于简短的示例很方便，但是在生产代码中，针对每种情况编写自定义结构通常是更好的选择。 比较上面我们在“模式匹配”部分中使用的 <code>Shape类型</code>的两个版本。 首先，这是原始的元组样式：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> line(from: <span class="type">Point</span>, to: <span class="type">Point</span>)</span><br><span class="line">    <span class="keyword">case</span> rectangle(origin: <span class="type">Point</span>, width: <span class="type">Double</span>, height: <span class="type">Double</span>) </span><br><span class="line">    <span class="keyword">case</span> circle(center: <span class="type">Point</span>, radius: <span class="type">Double</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一种选择，每个案例有一个自定义结构：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> from: <span class="type">Point</span> </span><br><span class="line">    <span class="keyword">var</span> to: <span class="type">Point</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> origin: <span class="type">Point</span> </span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Double</span> </span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shape2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> line(<span class="type">Line</span>)</span><br><span class="line">    <span class="keyword">case</span> rectangle(<span class="type">Rectangle</span>) </span><br><span class="line">    <span class="keyword">case</span> circle(<span class="type">Circle</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后一个示例首先需要编写一些代码，但是它将清除 <code>enum声明</code>以及 <code>switch语句</code>中的模式。 此外，这些结构具有自己的标识； 我们可以扩展它们并使它们符合协议。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用无大小写的枚举作为名称空间。 除了由模块形成的隐式名称空间之外， <code>Swift</code>并没有内置的名称空间。我们可以将枚举用作“假”名称空间。 由于类型定义可以嵌套，因此外部类型充当它们包含的所有声明的名称空间。 正如我们在<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%89):%20%20Optionals/"><strong>* <code>“可选内容”</code>*</strong></a>一章中看到的，没有实例化的枚举（例如从不）不能被实例化。 这使空无一枚枚举的枚举成为定义自定义名称空间的最佳选择。 标准库也这样做，例如使用Unicode“命名空间”：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A namespace for Unicode utilities.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Unicode</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Scalar</span> </span>&#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> _value: <span class="type">UInt32</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不幸的是，无大小写的枚举并不是缺少适当名称空间的完美解决方案：<strong>协议不能嵌套在其他声明中</strong>，这就是为什么相关标准库协议命名为 <code>UnicodeCodec</code>而不是 <code>Unicode.Codec</code>的原因。</p><h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a><strong>概括</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>枚举是求和类型</strong>。 在定义自定义类型时，枚举是避免纯粹基于产品类型的设计的有害状态组合爆炸的重要工具。 仔细考虑类型的居民有助于我们做出更好的设计决策。 如果你需要一种精确地针对你要解决的问题（例如，为程序状态建模）的类型，则枚举或嵌套枚举和结构的组合通常是最佳选择。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与更熟悉的记录类型相比，枚举适合于不同的设计模式。 你的目标应该是使非法程序状态无法在你的类型中表示。 这减少了代码必须准备处理的状态集，并使编译器在编写新代码时为你提供指导。 尽可能利用编译器的详尽性检查。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Advanced Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Advanced Swift </tag>
            
            <tag> Swift 5.0 </tag>
            
            <tag> Enums </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Swift系列(五): Structs and Classes</title>
      <link href="/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%94):%20Structs%20and%20Classes/"/>
      <url>/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%94):%20Structs%20and%20Classes/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设计数据类型时，<code>Swift</code>让我们在表面上看起来相似的两个替代方案之间进行选择：<strong>结构和类</strong>。 两者都可以具有存储和计算的属性，并且都可以具有在其上定义的方法。 此外，两者都具有初始化程序，我们可以在它们上定义扩展，并使它们符合协议。 有时，当我们将class关键字更改为struct或反之时，我们的代码甚至会继续编译。 但是，表面上的相似性具有欺骗性，因为结构和类具有根本不同的行为。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>结构是值类型</strong>，而<strong>类是引用类型</strong>。 即使我们不这么认为，我们都对日常工作中值和引用行为的熟悉。 在下一节中，我们将尝试利用这种隐含的理解来对值类型和一般引用类型之间的正式区别以及结构和类之间的形式区别有所了解。</p><a id="more"></a><h1 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a><strong>值类型和引用类型</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从最简单的类型之一开始：整数。 考虑以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int</span> = <span class="number">3</span> </span><br><span class="line"><span class="keyword">var</span> b=a </span><br><span class="line">b+=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的值是什么？ 可以肯定地说，即使我们将b增加到4，我们都希望a仍然保持值3。其他任何事情都将是一个很大的惊喜。 这确实是正确的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a <span class="comment">// 3 </span></span><br><span class="line">b <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种行为是<strong>值类型的本质：赋值复制值</strong>。 换句话说，<strong>每个值类型变量都拥有自己的独立值</strong>。 如果类型以这种方式运行，则它也被称为<strong>具有值语义</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看标准库中Int的定义，我们确实可以看到它是一个结构（因此具有值语义）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Int</span>: <span class="title">FixedWidthInteger</span>, <span class="title">SignedInteger</span> </span>&#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在继续之前，让我们退后一步，从更底层的角度看待这种行为。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们所说的“变量”是什么意思？ 我们可以说<strong>变量是内存中某个位置的名称</strong>，其中包含某种类型的值。 在上面的示例中，我们使用名称<code>a</code>指代<code>Int类型</code>的内存中当前持有值3的位置。第二个变量b是内存中不同位置的名称，同等Int类型并包含该值 初始分配后为3。 语句b + = 1然后获取存储在称为b的内存位置中的值，将其加1，然后将其写回到内存中的同一位置。 因此，b现在包含值4。由于增量语句仅修改b变量的值，因此a不受此语句影响。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/awsc-stp1.png" alt="Memeory" title="值类型变量是直接包含值的内存中位置的名称。"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值类型的特征在于变量和值之间的这种直接关系：<strong>值（也称为值类型的实例）直接位于变量后面的内存中的位置</strong>。 这适用于简单的值类型（例如整数），也适用于更复杂的类型（例如具有多个属性的自定义结构）（在机器代码级别上，由于编译器的优化，这可能不成立，但对开发人员而言是不透明的，因此我们的描述是 语义上最不准确）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们来看一下视图类，作为典型引用类型的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> view1 = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)) </span><br><span class="line"><span class="keyword">var</span> view2 = view1</span><br><span class="line">view2.frame.origin = <span class="type">CGPoint</span>(x: <span class="number">50</span>, y: <span class="number">50</span>)</span><br><span class="line">view1.frame.origin <span class="comment">// (50, 50)</span></span><br><span class="line">view2.frame.origin <span class="comment">// (50, 50)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管我们为<code>view2.frame.origin</code>分配了新的原点，但我们自然希望<code>view1</code>的框架也发生变化。 实际上，在某种意义上，我们希望<code>view1</code>和<code>view2</code>是同一件事–它们都代表我们在屏幕上看到的相同视图。 这是说<code>UIView是引用类型</code>，并且<code>view1</code>和<code>view2</code>变量包含指向内存中相同底层UIView实例的引用的一种随意的说法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们重新分配view2变量时，就像这样，</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view2 = <span class="type">UILabel</span>()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>view1</code>仍引用以前创建的视图，而<code>view2变量</code>现在引用新创建的标签实例。 换句话说，重新分配<code>已更改了view2变量指向的实例（或对象）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是引用类型的本质：<strong><em>变量本身不包含“事物”（例如，UIView或URLSession的实例），而是对其的引用</em></strong>。 其他变量也可以包含对同一基础实例的引用，并且该实例可以通过其任何引用变量进行突变。具有这些属性的类型也被称为具有<strong>参考语义</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与值类型相比，间接作用级别更高。 值类型变量包含值本身时，引用类型变量包含指向其他位置值的引用。 这种间接允许我们在程序的不同部分之间共享对对象的访问。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/awsc-stp2.png" alt="Memeory" title="引用类型变量包含指向内存中其他地方实际实例的指针。"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们以定义的自定义类型为例，从一个类开始观察值类型和引用类型的不同行为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> home: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> guest: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(home: <span class="type">Int</span>, guest: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.home = home</span><br><span class="line">        <span class="keyword">self</span>.guest = guest </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> score1 = <span class="type">ScoreClass</span>(home: <span class="number">0</span>, guest: <span class="number">0</span>) </span><br><span class="line"><span class="keyword">var</span> score2 = score1</span><br><span class="line">score2.guest += <span class="number">1</span></span><br><span class="line">score1.guest <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变量<code>score1</code>和<code>score2</code>都引用了相同的<code>Score</code>基础实例。 因此，通过<code>score2</code>变量更改来宾的分数也会更改我们通过<code>score1</code>访问来宾的分数时看到的值。 我们还可以将<code>score2</code>传递给执行突变的函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scoreGuest</span><span class="params">(<span class="number">_</span> score: ScoreClass)</span></span> &#123; </span><br><span class="line">    score.guest += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">scoreGuest(score1) </span><br><span class="line">score1.guest <span class="comment">// 2 </span></span><br><span class="line">score2.guest <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们改为将分数类型定义为结构，则行为会改变：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScoreStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> home: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> guest: <span class="type">Int</span></span><br><span class="line">    <span class="comment">// Memberwise initializer synthesized by the compiler.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> score3 = <span class="type">ScoreStruct</span>(home: <span class="number">0</span>, guest: <span class="number">0</span>) </span><br><span class="line"><span class="keyword">var</span> score4 = score1</span><br><span class="line">score4.guest += <span class="number">1</span></span><br><span class="line">score3.guest <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们在上面的整数中看到的那样，将结构分配给另一个变量会创建该值的独立副本。因此，通过score2变量更改来宾的分数不会影响来宾在score1中的分数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用Score版本的结构版本，我们无法定义与上面类似的<code>classGuest函数</code>相同的<code>scoreGuest函数</code>。首先，将值类型作为函数的参数传递会创建该值的独立副本，就像分配给变量一样。其次，函数参数在函数中是不变的（就像使用let声明的变量一样），因此我们无法更改其属性。要创建类似的函数，我们必须使用<code>inout参数</code>，我们将在下一部分“突变”中介绍该参数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们希望对<code>结构和类</code>的行为的初步概述能够突出它们的不同性质，尽管它们在语法和共享功能上相似。在本章的其余部分，我们将探讨结构与类之间的权衡。尽管类是功能更强大的工具，但其功能却要付出一定的代价。另一方面，结构有更多的限制，但是这些限制也可能是有益的。</p><h1 id="变种"><a href="#变种" class="headerlink" title="变种"></a><strong><em>变种</em></strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在控制可变性方面，结构和类有很大的不同。 刚开始时这可能并不直观，但是鉴于<strong>结构是值类型和类是引用类型之间的区别是有道理的</strong>。 作为示例，我们将再次从上方使用<code>ScoreClass</code>和<code>ScoreStruct</code>类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> home: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> guest: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(home: <span class="type">Int</span>, guest: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.home = home</span><br><span class="line">        <span class="keyword">self</span>.guest = guest </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScoreStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> home: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> guest: <span class="type">Int</span></span><br><span class="line">    <span class="comment">// Memberwise initializer synthesized by the compiler.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个版本都有使用var关键字声明的home和guest属性。 如果我们创建两者的实例并将其存储在var变量中，则可以自由更改属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scoreClass = <span class="type">ScoreClass</span>(home: <span class="number">0</span>, guest: <span class="number">0</span>) </span><br><span class="line"><span class="keyword">var</span> scoreStruct = <span class="type">ScoreStruct</span>(home: <span class="number">0</span>, guest: <span class="number">0</span>) </span><br><span class="line">scoreClass.home += <span class="number">1</span></span><br><span class="line">scoreStruct.guest += <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，在变更类别和struct版本之间，有一个重要的区别：<strong>struct突变始终是我们要突变的变量的局部变量，即仅更改了局部变量scoreStruct的值</strong>。 <strong>更改类实例具有潜在的全局影响：任何持有相同实例引用的人都将受到更改的影响</strong>。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果将实例存储在let变量中，我们仍然可以更改类实例，但不能更改struct实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> scoreClass = <span class="type">ScoreClass</span>(home: <span class="number">0</span>, guest: <span class="number">0</span>) </span><br><span class="line"><span class="keyword">let</span> scoreStruct = <span class="type">ScoreStruct</span>(home: <span class="number">0</span>, guest: <span class="number">0</span>) </span><br><span class="line">scoreClass.home += <span class="number">1</span> <span class="comment">// works </span></span><br><span class="line">scoreStruct.guest += <span class="number">1</span></span><br><span class="line"><span class="comment">// Error: Left side of mutating operator isn't mutable: </span></span><br><span class="line"><span class="comment">// 'scoreStruct' is a 'let' constant.</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>使用let声明变量意味着初始化后不能更改其值</strong>。由于scoreClass变量的值是对ScoreClass实例的引用，因此这仅意味着我们无法为ScoreClass变量分配其他引用。但是，要对我们创建的ScoreClass实例的属性进行突变，就无需对scoreClass的值进行突变。我们只使用scoreClass中的引用来获取实例，在该实例中我们可以更改属性，因为它们在类中被声明为var。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就结构而言，它的工作原理大不相同。由于<strong>结构是值类型</strong>，因此scoreStruct变量不仅包含对其他地方实例的引用；还包括对实例的引用。实际上，它实际上包含ScoreStruct实例本身。由于在初始分配后无法更改let变量的值，因此即使在结构中使用var声明属性，我们也无法再对其进行更改。原因是<strong>在结构上更改属性在语义上等同于将整个新的结构实例分配给变量</strong>。所以上面的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoreStruct.guest += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等效于：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoreStruct = <span class="type">ScoreStruct</span>(home: scoreStruct.home, guest: scoreStruct.guest + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这不仅适用于更改struct实例的直接属性，还适用于更改任何嵌套属性。 例如，为矩形原点的x坐标分配一个新值在语义上等同于为该变量分配一个全新的矩形值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = <span class="type">CGRect</span>(origin: .zero, size: <span class="type">CGSize</span>(width: <span class="number">100</span>, height: <span class="number">100</span>)) rect.origin.x = <span class="number">10</span> <span class="comment">// this is the same as...</span></span><br><span class="line">rect = <span class="type">CGRect</span>(origin: <span class="type">CGPoint</span>(x: <span class="number">10</span>, y: <span class="number">0</span>), size: rect.size)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果使用let声明属性，但是使用var声明scoreClass和scoreStruct变量，会发生什么？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> home: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> guest: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(home: <span class="type">Int</span>, guest: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.home = home</span><br><span class="line">        <span class="keyword">self</span>.guest = guest </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScoreStruct</span> </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> home: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> guest: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scoreClass = <span class="type">ScoreClass</span>(home: <span class="number">0</span>, guest: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> scoreStruct = <span class="type">ScoreStruct</span>(home: <span class="number">0</span>, guest: <span class="number">0</span>) </span><br><span class="line">scoreClass.home += <span class="number">1</span></span><br><span class="line"><span class="comment">// Error: Left side of mutating operator isn't mutable: </span></span><br><span class="line"><span class="comment">// 'home' is a 'let' constant.</span></span><br><span class="line">scoreStruct.guest += <span class="number">1</span></span><br><span class="line"><span class="comment">// Error: Left side of mutating operator isn't mutable: </span></span><br><span class="line"><span class="comment">// 'guest' is a 'let' constant.</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使使用var声明scoreClass，该突变在类情况下也将失败。 原因是变量声明上的var仅意味着我们可以更改变量的值。 但是，在类情况下，变量的值是对实例的引用，因此我们可以更改引用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoreClass = <span class="type">ScoreClass</span>(home: <span class="number">2</span>, guest: <span class="number">1</span>) <span class="comment">// works</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，我们无法更改scoreClass所引用实例的home属性，因为该属性已用let定义。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;突变在struct情况下也失败：由于使用let定义了属性，因此即使scoreStruct是var，我们也无法再使用它们来更改scoreStruct中的值。 但是，我们仍然可以为someStruct变量分配一个新的结构：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoreStruct = <span class="type">ScoreStruct</span>(home: <span class="number">2</span>, guest: <span class="number">1</span>) <span class="comment">// works</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，如果我们使用let定义属性和变量，则编译器将不再允许进行任何形式的更改：我们无法将新实例分配给someClass或someStruct变量，也无法更改实例属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们建议默认在结构中使用var属性。这允许通过使用var或let在变量级别上控制结构实例的可变性，从而为你提供更大的灵活性。与类相反，在结构中使用var属性不会引入潜在的全局可变状态，因为突变struct属性实际上只会创建一个具有更改字段的结构的副本。即使在实例存储在var变量中的情况下，let也应谨慎而有意地用于在初始化后实际上不应该进行更改的属性（例如，因为对单个属性进行更改会使结构进入无效状态）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理解let和var属性和变量的所有不同组合的关键是要记住两点：</p><ul><li>→类变量的值是对实例的引用，而结构变量的值是结构实例本身。</li><li>→甚至通过多个级别的嵌套更改适当的结构，就像将整个新的结构实例分配给变量一样。</li></ul><h1 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a><strong>变异方法</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>使用 <code>func关键字</code> 定义的结构体的常规方法不能使该结构体的任何属性发生突变</strong>。 这是因为默认情况下，隐式传递给每个方法的self参数是不可变的。 我们必须明确地说要使用func来创建允许突变的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ScoreStruct</span> </span>&#123; </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">scoreGuest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.guest += <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scoreStruct2 = <span class="type">ScoreStruct</span>(home: <span class="number">0</span>, guest: <span class="number">0</span>) </span><br><span class="line">scoreStruct2.scoreGuest()</span><br><span class="line">scoreStruct2.guest <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一种变异方法中，我们可以将self视为var，因此只要我们也使用var声明了self的属性，就可以对其进行更改。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>编译器使用<code>mutating关键字</code>作为标记来决定哪些方法不能在let常量上调用</strong>。 我们只能在用var声明的变量上调用变异方法，因为调用变异方法就像为变量分配新值（事实上，在变异方法中也可以为self赋一个全新的值）。 如果我们尝试在let变量上调用<code>mutating方法</code>，则编译器<br>会显示一个错误，即使该方法实际上并未使自身发生变异-变异注释足以禁止调用。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性和下标设置器是隐式变异的。 在极少数情况下，你想使用不可变的setter来实现计算属性（例如，因为你的结构是全局资源的包装器，而setter仅突变全局状态），则可以使用不变异的set来注释setter。 编译器允许你在let常量上调用此类setter。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类没有也不需要突变方法：如上所述，即使通过let声明的变量，我们也可以对类实例的属性进行突变。 同样，self的行为类似于类的方法中的let变量。 我们无法重新分配self，但是只要使用var声明这些属性，就可以使用它来改变self所引用实例的属性。</p><h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a><strong>输入参数</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面我们提到，结构上的变异方法可以访问可变的<code>self</code>，因此可以更改self上的任何var属性。 使用<code>inout参数</code>，我们可以编写可以改变其参数中任何一个参数的函数，而不仅仅是self。 举例来说，让我们将<code>mutation ScoreGuest</code>方法编写为自由函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scoreGuest</span><span class="params">(<span class="number">_</span> score: ScoreStruct)</span></span> &#123;</span><br><span class="line">    score.guest += <span class="number">1</span></span><br><span class="line">    <span class="comment">// Error: Left side of mutating operator isn't mutable:</span></span><br><span class="line">    <span class="comment">// 'score' is a 'let' constant.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，函数参数（如let变量）是不可变的。 当然，我们可以将参数复制到本地var中，但是对该变量进行更改不会影响传入的原始值。要解决此问题，我们将<code>inout关键字</code>添加到参数的类型中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scoreGuest</span><span class="params">(<span class="number">_</span> score: <span class="keyword">inout</span> ScoreStruct)</span></span> &#123; </span><br><span class="line">    score.guest += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scoreStruct3 = <span class="type">ScoreStruct</span>(home: <span class="number">0</span>, guest: <span class="number">0</span>)</span><br><span class="line">scoreGuest(&amp;scoreStruct) </span><br><span class="line">scoreStruct3.guest <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使用<code>inout参数</code>调用scoreGuest函数，我们必须做两件事：首先，必须将作为inout参数传递的变量定义为var，其次，必须在变量名前加上<code>＆</code>传递给函数时。所需的<code>＆字符</code>使调用站点很清楚该函数现在可以更改此变量的值了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管<code>“＆”号</code>可以使你想起<code>C</code>或<code>Objective-C</code>中的操作符地址，或者<code>C ++</code>中的引用传递，但这不是这种情况。 <strong><code>inout参数</code>与常规参数一样作为副本传递</strong>，但在函数返回时会被复制回。换句话说，当函数多次更改inout参数时，调用者将仅看到一个更改，因为新值将被复制回去。按照相同的逻辑，即使函数根本不更改其<code>inout参数</code>，调用方仍将看到一个突变（即，<code>将触发任何willSet和didSet观察者</code>）。</p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在生命周期管理方面，结构和类非常不同</strong>。在这方面，结构要简单得多，因为它们不能有多个所有者。它们的生存期与包含该结构的变量的生存期相关。当变量超出范围时，将释放其内存，并且结构消失。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相反，一个类的实例可以由多个所有者引用，这需要更复杂的内存管理模型。 Swift使用自动引用计数（ARC）来跟踪对特定实例的引用数。当引用计数下降到零时（因为所有保存引用的变量都超出范围或已设置为nil），Swift运行时将调用对象的<code>deinit</code>并释放内存。因此，可以使用类对最终释放时执行清理工作的共享实体进行建模，例如文件句柄（必须在某个时候关闭其基础文件描述符）或视图控制器（可能需要进行各种清理工作） ，例如取消注册观察员）。</p><h2 id="Reference-Cycles"><a href="#Reference-Cycles" class="headerlink" title="Reference Cycles"></a><strong><em>Reference Cycles</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用周期是指两个或多个对象之间相互强烈引用，以防止它们被释放（除非开发人员明确中断周期）。这会造成内存泄漏，并阻止执行潜在的清理任务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于结构是简单的值，因此无法在它们之间创建引用循环（因为没有对结构的引用）。一方面，这是一个优点，而另一方面，它是一个局限性：无需担心，但也意味着我们无法使用结构为循环数据结构建模。对于类，相反的情况适用：由于同一个实例可以具有多个所有者，因此我们可以使用类为周期性数据结构建模，但是我们必须注意不要创建引用周期。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用循环可以采用多种形式-从两个相互强烈引用的对象，到由许多对象和对对象进行闭合的闭包组成的复杂循环。我们首先来看一个涉及窗口及其根视图的简单示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First version</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rootView: <span class="type">View?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">Window</span> </span><br><span class="line">    <span class="keyword">init</span>(window: <span class="type">Window</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.window = window </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> window: <span class="type">Window?</span> = <span class="type">Window</span>() <span class="comment">// refcount: 1</span></span><br><span class="line">window = <span class="literal">nil</span> <span class="comment">// refcount: 0, deallocating</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第一行之后，引用计数为1。 当我们将变量设置为nil时，Window实例的引用计数为零，并且实例被释放。 但是，如果我们还创建一个视图并将其分配给窗口的rootView属性，则引用计数永远不会再降为零。 让我们逐行跟踪参考计数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，创建窗口。 窗口的引用计数现在为1：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> window: <span class="type">Window?</span> = <span class="type">Window</span>() <span class="comment">// window: 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，创建视图并保留对窗口的强烈引用，因此窗口的引用计数现在为2，视图的引用计数为1：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> view: <span class="type">View?</span> = <span class="type">View</span>(window: window!) <span class="comment">// window: 2, view: 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将视图分配为窗口的rootView会使视图的引用计数增加一。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，视图和窗口的引用计数均为2：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window?.rootView = view <span class="comment">// window: 2, view: 2</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将两个变量都设置为nil之后，它们的引用计数仍为1：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view = <span class="literal">nil</span> <span class="comment">// window: 2, view: 1 </span></span><br><span class="line">window = <span class="literal">nil</span> <span class="comment">// window: 1, view: 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使无法再通过变量访问它们，它们也会相互引用。 这称为循环引用，当处理类似图形的数据结构时，我们需要非常注意通过周期造成内存泄漏的可能性。 由于循环引用的关系，这两个对象在程序的生存期内将永远不会被释放。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a><strong><em>弱引用</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了打破循环引用，我们需要使引用之一变弱或失去所有权。 将对象分配给弱变量不会改变其引用计数。 Swift中的弱引用始终为零：一旦释放了所引用的对象，变量将自动设置为nil-这就是为什么弱引用必须始终是可选的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了修复上面的示例，我们将使窗口的rootView属性变弱，这意味着它不会强引用该视图，因此，一旦取消分配该视图，它将自动变为nil。 要查看发生了什么，我们可以在类的反初始化器中添加一些打印语句。 在类取消分配之前，将调用deinit：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Second version</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> rootView: <span class="type">View?</span> </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Deinit Window"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">Window</span> </span><br><span class="line">    <span class="keyword">init</span>(window: <span class="type">Window</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.window = window </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Deinit View"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的代码中，我们再次创建一个窗口和一个视图。 和以前一样，视图强烈引用该窗口。 但是由于该窗口的rootView被声明为弱，因此该窗口不再强烈引用该视图。 这样，我们没有引用循环，并且当我们将变量设置为nil时，两个对象都被释放了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> window: <span class="type">Window?</span> = <span class="type">Window</span>()</span><br><span class="line"><span class="keyword">var</span> view: <span class="type">View?</span> = <span class="type">View</span>(window: window!) </span><br><span class="line">window?.rootView = view</span><br><span class="line">window = <span class="literal">nil</span></span><br><span class="line">view = <span class="literal">nil</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Deinit View Deinit Window</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;弱引用在与代表一起工作时非常有用，这在<code>Cocoa</code>中很常见。 委托对象（例如表格视图）需要对其委托的引用，但它不应拥有委托，因为这很可能会创建一个循环引用。 因此，委托引用通常较弱，并且另一个对象（例如，视图控制器）负责确保委托在需要的时间内待命。</p><h2 id="Unowned-References"><a href="#Unowned-References" class="headerlink" title="Unowned References"></a><strong><em>Unowned References</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有时我们会希望使用非严格的参考，这不是可选的。 例如，也许我们知道视图将始终有一个窗口（因此该属性不应是可选的），但我们不希望视图强烈引用该窗口。 在这些情况下，有一个 <code>unowned</code> 关键字：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Third version</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rootView: <span class="type">View?</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Deinit Window"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">var</span> window: <span class="type">Window</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(window: <span class="type">Window</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.window = window </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Deinit View"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的代码中，我们可以看到两个对象都被释放了，如上一个示例中的弱引用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> window: <span class="type">Window?</span> = <span class="type">Window</span>()</span><br><span class="line"><span class="keyword">var</span> view: <span class="type">View?</span> = <span class="type">View</span>(window: window!) </span><br><span class="line">window?.rootView = view</span><br><span class="line">view = <span class="literal">nil</span></span><br><span class="line">window = <span class="literal">nil</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Deinit Window Deinit View</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 <code>Unowned References</code> ，我们有责任确保 <code>“referencee”</code> 的寿命超过 <code>“referencer”</code> 的时间。 在此示例中，我们必须确保窗口不在视图中。 如果在访问视图和未拥有的变量之前将窗口释放，则程序将崩溃。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，这与未定义的行为不同。 Swift运行时在对象中保留第二个引用计数，以跟踪未拥有的引用。 当所有强引用都消失时，该对象将释放其所有资源（例如，对其他对象的任何引用）。 但是，对象本身的内存仍将保留在那里，直到所有未拥有的引用也都消失了。 内存被标记为无效（有时也称为僵尸内存），并且每当我们尝试访问未拥有的引用时，都会发生运行时错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过使用 <code>unowned（不安全）</code> 来规避此保护措施。 如果我们访问标记为未拥有（不安全）的无效引用，则会得到不确定的行为。</p><h1 id="Closures-and-Reference-Cycles"><a href="#Closures-and-Reference-Cycles" class="headerlink" title="Closures and Reference Cycles"></a><strong>Closures and Reference Cycles</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Swift中，类并不是唯一的引用类型。 <strong>函数（也包括闭包）也是引用类型</strong>。 <strong>如果一个闭包捕获到一个持有引用类型的变量，则该闭包将保持对其的强引用</strong>。 在上一个示例旁边，这是将<strong>引用循环</strong>引入代码的另一种主要方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常的模式是这样的：对象A引用对象B，但是对象B存储了一个引用对象A的闭包（实际上，引用循环可能涉及多个中间对象和闭包）。 作为示例，我们从上方向窗口类添加可选的onRotate回调：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> rootView: <span class="type">View?</span> </span><br><span class="line">    <span class="keyword">var</span> onRotate: (() -&gt; ())? = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们配置onRotate回调并在其中使用视图，则我们引入了一个参考周期：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> window: <span class="type">Window?</span> = <span class="type">Window</span>()</span><br><span class="line"><span class="keyword">var</span> view: <span class="type">View?</span> = <span class="type">View</span>(window: window!) </span><br><span class="line">window?.onRotate = &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"We now also need to update the view: \(view)"</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该视图引用该窗口，该窗口引用该回调，而该回调引用该视图：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/awsc-stp3.png" alt="Memeory" title="视图，窗口和回调之间的引用周期"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以在三个位置中断此引用周期（每个位置对应于上图中的箭头）：</p><ul><li>→我们可以使该视图对窗口的引用变弱。不幸的是，该窗口将被立即释放，因为没有其他引用可以使该窗口保持活动状态。</li><li>→最好不要在轮换属性上标记弱，但<code>Swift</code>不能将函数属性标记为弱。</li><li>→我们可以通过使用弱捕获视图的捕获列表来确保关闭视图不会严格引用该视图。 在此示例中，这是唯一正确的选项。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window?.onRotate = &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"We now also need to update the view: \(view)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;捕获列表所要做的不仅仅是将变量标记为弱变量或未拥有变量。 例如，如果我们想要一个弱引用窗口的变量，我们可以在捕获列表中对其进行初始化，或者甚至可以定义完全不相关的变量，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window?.onRotate = &#123; [<span class="keyword">weak</span> view, <span class="keyword">weak</span> myWindow=window, x=<span class="number">5</span>*<span class="number">5</span>] <span class="keyword">in</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"We now also need to update the view: \(view)"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Because the window \(myWindow) changed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这与在闭包上方定义变量几乎相同，除了在捕获列表中，变量的范围仅是闭包的范围。 在闭包之外无法使用。</p><h2 id="在Unowned引用和弱引用之间进行选择"><a href="#在Unowned引用和弱引用之间进行选择" class="headerlink" title="在Unowned引用和弱引用之间进行选择"></a><strong><em>在Unowned引用和弱引用之间进行选择</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该在自己的API中使用 <code>Unowned引用</code> 还是 <code>弱引用</code> ？最终，这个问题归结为所涉及对象的生命周期。如果对象具有独立的生存期（也就是说，如果你无法假设哪个对象的寿命超过另一个），则弱引用是唯一安全的选择。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一方面，如果你可以保证未严格引用的对象与它的对应对象具有相同的生存期，或者将始终超过该对象的生存期，则 <code>Unowned所有权引用</code> 通常会更方便。这是因为它不一定是可选的，并且可以使用let声明变量，而<strong>弱引用必须始终是可选的var</strong>。相同寿命的情况非常普遍，尤其是当两个对象具有父子关系时。当父母通过强引用来控制孩子的一生时，并且你可以保证没有其他对象知道该孩子，则该孩子对其父的反向引用始终是 <code>Unowned</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与弱引用相比，<code>Unowned</code> 引用的开销也较小，因此访问属性或在 <code>Unowned</code> 引用上调用方法的速度会稍快一些。就是说，这仅是非常关键性能的代码路径中的一个因素。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，首选 <code>Unowned</code> 引用的不利之处在于，如果你在生命周期假设中犯了一个错误，则程序可能会崩溃。就个人而言，我们经常发现自己更喜欢 <code>weak</code> ，即使可以使用 <code>Unowned</code>  ，因为前者迫使我们明确检查引用在每个使用点是否仍然有效。特别是在重构代码时，很容易打破以前的使用期限假设并引入崩溃的错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是也有一个争论，就是始终使用修饰符来捕获你希望代码具有的生命周期特征，以使其明确。如果以后你或其他人以使这些假设无效的方式更改代码，则可以认为硬崩溃是提醒你注意问题的明智方法-假设你在测试期间发现了错误。</p><h2 id="在结构和类之间决定"><a href="#在结构和类之间决定" class="headerlink" title="在结构和类之间决定"></a><strong><em>在结构和类之间决定</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计类型时，我们必须考虑是否必须在程序的不同部分之间共享这种类型的特定实例的所有权，或者是否可以互换使用多个实例，只要它们表示相同的值即可。<strong>要共享特定实例的所有权，我们必须使用一个类。否则，我们可以使用一个结构</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，URL的实例不能共享，因为URL是一个结构。每次我们将URL分配给变量或将URL传递给函数时，编译器都会进行复制。但是，这不是问题，因为如果两个URL实例表示相同的URL，我们认为它们是可以互换的。这同样适用于其他结构，例如整数，布尔值和字符串：我们不在乎两个整数或两个字符串是否由同一块内存支持；我们关心它们是否代表相同的价值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相比之下，我们不认为两个UIView实例是可互换的。即使它们的所有属性都相同，它们仍然在视图层次结构的不同位置代表屏幕上的不同<code>“对象”</code>。因此，UIView被建模为一个类，以便我们可以将对特定实例的引用传递给程序的多个部分：特定视图由其超级视图引用，但也可以由其子视图作为其超级视图引用。此外，我们可以存储对该视图的其他引用，例如在视图控制器中。可以通过所有引用来操纵同一个视图实例，并且这些更改会自动通过所有引用反映出来。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;话虽如此，<strong>当我们设计不需要共享所有权的类型时，我们不必使用结构</strong>。我们还可以将其建模为一个类，从而可能提供不可变的<code>API</code>，以便<strong>该类型本质上具有值语义</strong>。从这个意义上讲，我们可以只使用类而不必大幅度改变我们设计程序的方式。当然，我们会失去一些围绕可变性的编译时强制性要求，并且可能会产生额外的引用计数操作费用，但是我们可以使其正常运行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一方面，如果我们没有可用的类（或一般的引用），我们将失去共享所有权的整个概念，我们将不得不从头到尾重新设计我们的程序（假设我们依靠在上课之前）。因此，尽管我们可以将结构建模为具有一些折衷的类，但情况不一定相反。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结构是我们工具箱中的一种工具，故意比类功能要弱。作为回报，结构提供了简单性：没有引用，没有生命周期，没有子类型。这意味着我们不不得不担心引用循环，通过共享引用产生的副作用和竞争条件以及继承规则（仅举几个例子）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，结构有望带来更好的性能，尤其是对于较小的值。例如，如果Int是一个类，则Ints数组将占用更多内存来存储对实际实例的引用（指针），以及每个实例所需的额外开销（例如，存储其引用计数）。更重要的是，遍历该数组的速度会慢得多，因为代码将必须遵循每个元素的附加间接级别，因此可能无法有效利用CPU缓存，尤其是在内存中的位置将Int实例分配得完全不同的情况下。</p><h2 id="Classes-with-Value-Semantics"><a href="#Classes-with-Value-Semantics" class="headerlink" title="Classes with Value Semantics"></a><strong><em>Classes with Value Semantics</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面我们概述了结构具有<code>值语义</code>（即<code>每个变量包含一个独立的值</code>），而类具有引用语义（即<code>多个变量都可以指向同一个基础类实例</code>）。 没错，我们可以编写行为更像值类型的不可变类，并且可以编写实际上表现得不像值类型的结构-至少乍一看。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当编写一个类时，我们可以将其锁定到其引用语义不再对其行为产生影响的程度。 首先，我们将所有属性声明为let，使它们不可变。 然后我们将类定为final，以禁止子类化，以防止潜在的子类重新引入任何可变行为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> home: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> guest: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(home: <span class="type">Int</span>, guest: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.home = home</span><br><span class="line">        <span class="keyword">self</span>.guest = guest </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> score1 = <span class="type">ScoreClass</span>(home: <span class="number">0</span>, guest: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> score2 = score1</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score1和score2变量仍然包含对同一基础ScoreClass实例的引用-这毕竟是类的工作方式。 但是，出于所有实际目的，我们可以使用score1和score2就像它们包含独立的值一样，因为基础实例无论如何都是完全不可变的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>Foundation</code>中的<code>NSArray类</code>。 <code>NSArray</code>本身不公开任何变异<code>API</code>，因此其实例实际上可以当作值使用。 由于<code>NSArray</code>有一个可变的子类<code>NSMutableArray</code>，因此实际情况要复杂一些，如果我们自己创建<code>NSArray实例</code>，就不能假设我们真的在处理<code>NSArray实例</code>。 这就是为什么我们在上述类中将我们的类声明为<code>“ nal”</code>，也是为什么建议在对它进行其他任何处理之前，先从不受控制的<code>API</code>中复制收到的<code>NSArray</code>的原因。</p><h2 id="Structs-with-Reference-Semantics"><a href="#Structs-with-Reference-Semantics" class="headerlink" title="Structs with Reference Semantics"></a><strong><em>Structs with Reference Semantics</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相反，包含引用类型属性的结构也表现出令人惊讶的行为。 让我们扩展 <code>ScoreStruct</code> 类型，使其包括一个计算<code>属性pretty</code>，它为当前分数提供格式正确的字符串：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScoreStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> home: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> guest: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> scoreFormatter: <span class="type">NumberFormatter</span></span><br><span class="line">    <span class="keyword">init</span>(home: <span class="type">Int</span>, guest: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.home = home</span><br><span class="line">        <span class="keyword">self</span>.guest = guest</span><br><span class="line">        scoreFormatter = <span class="type">NumberFormatter</span>() </span><br><span class="line">        scoreFormatter.minimumIntegerDigits = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pretty: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> h = scoreFormatter.string(from: home <span class="keyword">as</span> <span class="type">NSNumber</span>)! </span><br><span class="line">        <span class="keyword">let</span> g = scoreFormatter.string(from: guest <span class="keyword">as</span> <span class="type">NSNumber</span>)! <span class="keyword">return</span> <span class="string">"\(h) – \(g)"</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> score1 = <span class="type">ScoreStruct</span>(home: <span class="number">2</span>, guest: <span class="number">1</span>) </span><br><span class="line">score1.pretty <span class="comment">// 02 – 01</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在初始化程序中，我们创建一个数字格式化程序，即使分数小于10，该数字格式化程序也将显示至少两个整数。我们在pretty属性中使用此格式化程序以生成格式化的输出。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们制作一份score1的副本，然后在该副本上重新配置数字格式器：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> score2 = score1 </span><br><span class="line">score2.scoreFormatter.minimumIntegerDigits = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管我们对score2进行了更改，但score1.pretty的输出也发生了变化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score1.pretty <span class="comment">// 002 – 001</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因是<code>NumberFormatter</code>是一个类，即结构中的<code>scoreFormatter</code>属性包含对数字格式器实例的引用。当我们将<code>score1</code>分配给新的<code>score2</code>变量时，将复制一份<code>score1</code>。但是，结构的副本是其所有属性值的副本，而<code>scoreFormatter</code>的值仅是引用。因此，score2中的ScoreStruct值包含对与score1相同的基础数字格式化程序实例的引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从技术上讲，<code>ScoreStruct</code>仍然具有值语义：<strong>当你将实例分配给另一个变量或将其作为函数参数传递时，将复制整个值</strong>。但是，这取决于我们认为是什么值。如果我们故意将引用存储为该结构的属性之一，也就是说，我们正在将引用本身视为值，那么上面的结构将准确显示预期的行为。但是我们可能希望该结构包括数字格式化程序实例本身，以便副本具有自己的格式化程序。在这种情况下，上述结构的行为是不正确的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了避免上面示例中的意外行为，我们可以将类型更改为类（以使该类型的用户不希望使用值语义），也可以将数字格式化程序设置为私有实现细节，以便不能更改它。但是，后者并不是一个完美的解决方案：我们仍然可以（偶然地）在类型上公开其他公共方法，该方法将在内部改变数字格式器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们建议在结构中存储引用时要非常小心，因为这样做通常会导致意外的行为。但是，在某些情况下，有意存储引用是你的有意需求，而正是你真正需要的是存储引用，主要是作为性能优化的实现细节。在下一部分中，我们将介绍一个示例，其中涵盖了<strong>写时复制</strong>。</p><h1 id="写时复制优化"><a href="#写时复制优化" class="headerlink" title="写时复制优化"></a><strong>写时复制优化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值类型需要大量复制，因为赋值或将其作为函数参数传递会创建一个副本。 尽管编译器会尝试在此方面保持聪明，并在可以证明这样做安全的情况下避免使用副本，但是值类型的作者可以进行另一项优化，那就是使用称为<code>写时复制</code>的技术来实现该类型。 这对于可容纳大量数据的类型尤其重要，例如标准库的集合类型（数组，字典，集合和字符串）。 它们都是使用写时复制实现的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入时复制意味着结构中的数据最初在多个变量之间共享； <strong>数据复制将推迟到实例更改其数据之前</strong>。 由于数组是使用写时复制实现的，因此，如果我们创建一个数组并将其分配给另一个变量，则该数组的数据实际上尚未被复制：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"><span class="keyword">var</span> y=x</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在内部，<code>x和y中的数组值包含对同一内存缓冲区的引用</code>。 该缓冲区是存储数组实际元素的位置。 但是，在我们对x（或y）进行突变的那一刻，数组检测到它正在与一个或多个其他变量共享其缓冲区，并在应用突变之前复制了缓冲区。 这意味着我们可以独立地对两个变量进行突变，而元素的潜在昂贵副本仅在必须执行以下操作时发生：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x.append(<span class="number">5</span>) </span><br><span class="line">y.removeLast() </span><br><span class="line">x <span class="comment">// [1, 2, 3, 5]</span></span><br><span class="line">y <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于自己的类型，写时复制行为并不是免费的； 我们必须自己实现它，就像标准库为其集合类型实现它一样。 但是，仅在极少数情况下才需要为自定义结构实现写时复制，因为标准库已经提供了处理大量数据的最常见类型。 即使我们定义了一个可以包含大量数据的结构，我们也经常会使用内置的集合类型在内部表示此数据，因此，我们将从其写时复制优化中受益。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，了解如何实现写时复制有助于总体上了解Swift的集合类型的行为以及我们应注意的一些极端情况。</p><h2 id="Copy-On-Write-Tradeoffs"><a href="#Copy-On-Write-Tradeoffs" class="headerlink" title="Copy-On-Write Tradeoffs"></a><strong><em>Copy-On-Write Tradeoffs</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在研究写时复制的实现之前，我们要注意写时复制有其自身的权衡。<strong>值类型的优点之一是它们不会产生引用计数的开销</strong>。但是，<strong>写时复制结构依赖于内部存储引用，并且对于创建的每个结构副本，内部引用计数都必须增加</strong>。因此，我们实际上是在放弃值类型的优势-无需进行引用计数-以减轻值类型的另一属性-复制语义的潜在成本。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;递增或递减引用计数是一个相对较慢的操作（例如，与将几个字节复制到堆栈上的另一个位置相比），因为此类操作必须是线程安全的，因此会导致锁定开销。由于标准库中的所有可变大小类型（数组，字典，集合和字符串）内部都依赖于写时复制，因此包含这些类型属性的所有结构也会在每个副本上产生引用计数成本，甚至可能多次当类型包含多个此类属性时（这是一个例外，最大长度为15个UTF-8代码单元的小字符串，Swift为此进行了优化，避免了完全分配后备缓冲区的情况）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个实际的例子来自SwiftNIO项目：一个HTTP请求曾经在SwiftNIO中被建模为一个结构，并且包含多个属性，例如HTTP方法，标头等。当复制这样的结构时，不仅所有结构都被复制了。字段必须复制，但是所有内部数组，字典和字符串的引用计数也必须增加。与传递建模为类的HTTP请求相比，传递此类值（这是非常常见的操作）时，此开销导致性能显着降低（因为对类的引用所需要的数据量较少）比HTTP请求结构的所有字段进行复制，并且只需要更新一个引用计数）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面，我们将探讨在这种特殊情况下如何使用写时复制技术结合两个方面的优势：值语义和使用类的性能优势。 SwiftNIO团队的Johannes Weiss在<a href="https://www.youtube.com/watch?v=iLDldae64xE" target="_blank" rel="noopener"><strong><em><code>dotSwift 2019</code></em></strong></a>上也发表了精彩的演讲。</p><h2 id="Implementing-Copy-On-Write"><a href="#Implementing-Copy-On-Write" class="headerlink" title="Implementing Copy-On-Write"></a><strong><em>Implementing Copy-On-Write</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们从HTTP请求结构的极其简化的版本开始：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HTTPRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> path: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> headers: [<span class="type">String</span>: <span class="type">String</span>] <span class="comment">// other fields omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了最大程度地减少上面概述的引用计数开销，我们首先将所有属性包装在私有存储类中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HTTPRequest</span> </span>&#123; <span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> path: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> headers: [<span class="type">String</span>: <span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(path: <span class="type">String</span>, headers: [<span class="type">String</span>: <span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.path = path</span><br><span class="line">        <span class="keyword">self</span>.headers = headers &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> storage: <span class="type">Storage</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(path: <span class="type">String</span>, headers: [<span class="type">String</span>: <span class="type">String</span>]) &#123; </span><br><span class="line">        storage = <span class="type">Storage</span>(path: path, headers: headers)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，我们的<code>HTTPRequest结构</code>仅包含一个属性，存储，并且只需要对内部存储实例的一个引用计数在复制时就递增。 为了公开内部存储实例的私有路径和标头属性，我们将计算的属性添加到struct中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HTTPRequest</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> path: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> storage.path </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; </span><br><span class="line">            <span class="comment">/* to do */</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> headers: [<span class="type">String</span>: <span class="type">String</span>] &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> storage.headers </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; </span><br><span class="line">            <span class="comment">/* to do */</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重要的部分是这些属性的设置器的实现：我们不应该仅在内部存储实例上设置新值，因为此对象可能在多个变量之间共享。 由于将请求的数据存储在类实例中应该是私有的实现细节，因此我们必须确保基于类的结构的行为与原始结构完全相同。 这意味着，更改HTTP请求变量的属性仅应更改该变量的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步，每次调用<code>setter</code>时，我们都可以创建内部存储类的副本。 要进行复制，我们在存储上添加一个复制方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HTTPRequest</span>.<span class="title">Storage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">()</span></span> -&gt; <span class="type">HTTPRequest</span>.<span class="type">Storage</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Making a copy..."</span>) <span class="comment">// For debugging</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">HTTPRequest</span>.<span class="type">Storage</span>(path: path, headers: headers) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们可以在设置新值之前将当前存储的副本分配给storage属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HTTPRequest</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> path: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> storage.path</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            storage = storage.copy()</span><br><span class="line">            storage.path = newValue</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> headers: [<span class="type">String</span>: <span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> storage.headers</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            storage = storage.copy()</span><br><span class="line">            storage.headers = newValue </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，HTTPRequest结构完全由类实例支持，但它仍显示值语义，就好像其所有属性都是结构本身的属性一样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> req1 = <span class="type">HTTPRequest</span>(path: <span class="string">"/home"</span>, headers: [:]) </span><br><span class="line"><span class="keyword">var</span> req2 = req1</span><br><span class="line">req2.path = <span class="string">"/users"</span></span><br><span class="line"><span class="built_in">assert</span>(req1.path == <span class="string">"/home"</span>) <span class="comment">// passes</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，当前的实现仍然效率低下。 无论何时有任何其他变量引用相同的存储，我们都会在进行更改时创建内部存储的副本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="type">HTTPRequest</span>(path: <span class="string">"/home"</span>, headers: [:]) </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span>&#123;</span><br><span class="line">    req.headers[<span class="string">"X-RequestId"</span>] = <span class="string">"\(x)"</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Making a copy... </span></span><br><span class="line"><span class="comment">Making a copy... </span></span><br><span class="line"><span class="comment">Making a copy... </span></span><br><span class="line"><span class="comment">Making a copy... </span></span><br><span class="line"><span class="comment">Making a copy...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次我们更改请求时，都会制作另一个副本。 但是所有这些副本都是不必要的； req中只有一个HTTPRequest值引用了内部存储实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了提供有效的写时复制行为，我们需要知道对象（在本例中为Storage实例）是否被唯一引用，即，它是否具有单个所有者。 如果是这样，我们可以在适当位置修改对象。 否则，我们将在修改对象之前创建该对象的副本。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用<code>isKnownUniquelyReferenced</code>函数来查找引用是否只有一个所有者。 如果将Swift类的实例传递给此函数，并且没有其他人对象有很强的引用，该函数返回true。 如果还有其他强引用，则返回false。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>isKnownUniquelyReferenced</code>时，有几点需要牢记：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该函数是线程安全的，但是你必须确保该变量正在从另一个线程访问正在传递的代码。 （isKnownUniquelyReferenced在这方面并不特殊；此限制适用于Swift中的每个inout参数。）换句话说，<code>isKnownUniquelyReferenced</code>不能防止竞争条件-此代码并不安全，因为两个队列同时对同一变量进行了变异。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line">queue1.async &#123; </span><br><span class="line">    numbers.append(<span class="number">4</span>) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">queue2.async &#123; </span><br><span class="line">    numbers.append(<span class="number">5</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>isKnownUniquelyReferenced</code>使用<code>inout参数</code>，因为这是Swift中在函数参数上下文中引用变量的唯一方法。 如果正常传递了参数，则在调用函数时，编译器将始终创建一个副本，这意味着永远无法在函数体内唯一引用要测试的对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不考虑Unowned引用和弱引用，即我们必须确保不存在对所讨论实例的此类引用。<code>isKnownUniquelyReferenced</code>不适用于<code>Objective-C</code>类。 要解决此限制，我们可以在Swift类中包装一个Objective-C类实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用此知识，我们现在可以编写<code>HTTPRequest</code>的变体，以检查存储是否在更改之前被唯一引用。 为了避免在每个属性设置器中编写这些检查，我们将逻辑包装在<code>storageForWriting</code>属性中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HTTPRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> storageForWriting: <span class="type">HTTPRequest</span>.<span class="type">Storage</span> &#123;</span><br><span class="line">        <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !isKnownUniquelyReferenced(&amp;storage) &#123;</span><br><span class="line">                <span class="keyword">self</span>.storage = storage.copy() </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> storage</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> path: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> storage.path &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; storageForWriting.path = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> headers: [<span class="type">String</span>: <span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> storage.headers &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; storageForWriting.headers = newValue &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了测试我们的代码，让我们再次编写循环：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="type">HTTPRequest</span>(path: <span class="string">"/home"</span>, headers: [:]) </span><br><span class="line"><span class="keyword">var</span> copy = req</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">    req.headers[<span class="string">"X-RequestId"</span>] = <span class="string">"\(x)"</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Making a copy...</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug语句仅打印一次：当我们第一次更改req时。 在随后的迭代中，将检测到唯一性，并且不会复制任何副本。 结合由编译器完成的优化，写时复制避免了大多数不必要的值类型副本。</p><h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a><strong>概括</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本章中，我们了解了结构（值类型）和类（引用类型）尽管具有相同的功能，但它们在行为上有根本不同。 <strong>值类型变量仅包含值，对每个变量的每个赋值或将其传递给函数都会创建该值的副本</strong>。 另一方面，引<strong>用类型变量包含对实际值的引用。 将其分配给另一个变量或将其传递给函数将创建引用的副本，而不是基础值本身</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经讨论了如何通过<code>let</code>和<code>var</code>来控制可变性，<code>mutant关键字</code>如何工作以及如何使用<code>inout参数</code>。 最后，我们展示了<strong>写入时复制优化</strong>（标准库中的许多类型都使用过）可以工作，以及如何为自己的结构实现该功能。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Advanced Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Advanced Swift </tag>
            
            <tag> Swift 5.0 </tag>
            
            <tag> Structs and Classes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Swift系列(四):  Functions</title>
      <link href="/Advanced%20Swift%E7%B3%BB%E5%88%97(%E5%9B%9B):%20%20Functions/"/>
      <url>/Advanced%20Swift%E7%B3%BB%E5%88%97(%E5%9B%9B):%20%20Functions/</url>
      
        <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a><strong>总览</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在打开本章之前，让我们回顾一下有关功能的要点。如果你已经熟悉一流的功能，请随时跳到下一部分。但是，如果你甚至不确定它们，请通读以下内容。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要了解 <code>Swift中的函数</code> 和 <code>闭包</code> ，你实际上需要理解三件事，大致按此重要性顺序排列：</p><ul><li>1.可以将函数分配给变量，并传入和传出其他函数作为参数，就像 <code>Int</code> 或 <code>String</code> 一样。</li><li>2.函数可以捕获存在于其本地范围之外的变量。</li><li>3.有两种创建功能的功能–使用 <code>关键字</code> 或 <code>{}</code>。 <code>Swift</code>调用后一个闭包表达式。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，刚接触闭包主题的人会以相反的顺序来讲，可能会错过这些要点之一，或者他们将 <code>闭包</code> 和 <code>闭包表达</code> 这两个术语混为一谈，这可能会引起很多混乱。这是三足凳，如果你错过了以上三点之一，当你尝试坐下时会跌倒。</p><h2 id="可以将函数分配给变量，并可以将其他函数作为参数传入和传出"><a href="#可以将函数分配给变量，并可以将其他函数作为参数传入和传出" class="headerlink" title="可以将函数分配给变量，并可以将其他函数作为参数传入和传出"></a><strong><em>可以将函数分配给变量，并可以将其他函数作为参数传入和传出</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与许多现代语言一样，在 <code>Swift</code> 中，功能被称为 <code>“一流的对象”</code> 。 你可以将函数分配给变量，也可以将它们传入和传出其他函数，以供以后调用。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是最重要的了解。 对于函数式编程，“获取”类似于在C语言中的“获取”指针。如果你不太了解这一部分，那么其他所有内容都将成为噪音。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从一个简单地输出整数的函数开始：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInt</span><span class="params">(i: Int)</span></span> &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"You passed \(i)."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要将函数分配给变量 <code>funVar</code> ，我们仅使用函数名称作为值。 请注意，函数名称后没有括号：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> funVar = printInt</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以使用 <code>funVar变量</code> 调用 <code>printInt函数</code> 。 注意使用变量名称后的括号：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funVar(<span class="number">2</span>) <span class="comment">// You passed 2.</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样值得注意的是，我们不能在 <code>funVar</code> 调用中包含参数标签，而 <code>printInt</code> 调用则需要参数标签，就像<code>printInt（i：2）</code> 一样。  <code>Swift</code> 仅允许在函数声明中使用参数标签； 标签未包含在函数的类型中。 这意味着你目前无法将参数标签分配给函数类型的变量，尽管在以后的 <code>Swift版本</code> 中这可能会发生变化。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以编写一个以函数作为参数的函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useFunction</span><span class="params">(function: <span class="params">(Int)</span></span></span> -&gt; () ) &#123; </span><br><span class="line">    function(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">useFunction(function: printInt) <span class="comment">// You passed 3.</span></span><br><span class="line">useFunction(function: funVar) <span class="comment">// You passed 3.</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么能够处理这么大的功能呢？ 因为它使你能够轻松编写 <code>“高阶”函数</code> ，这些函数将函数作为参数并以有用的方式应用它们，如我们在<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%8C):%20Build-in%20Collections/"><strong><code>“内置集合”</code></strong></a> 一章中所见。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数还可以返回其他函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnFunc</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">String</span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">innerFunc</span><span class="params">(i: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"You passed \(i)."</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> innerFunc</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myFunc = returnFunc() myFunc(<span class="number">3</span>) <span class="comment">// You passed 3.</span></span><br></pre></td></tr></table></figure><h2 id="函数可以捕获存在于其局部范围之外的变量"><a href="#函数可以捕获存在于其局部范围之外的变量" class="headerlink" title="函数可以捕获存在于其局部范围之外的变量"></a><strong><em>函数可以捕获存在于其局部范围之外的变量</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当函数引用超出其范围的变量时，这些变量将被捕获并留在它们周围，否则它们将超出范围并被销毁。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了看到这一点，让我们重新访问 <code>returnFunc函数</code> ，但是添加一个每次调用时都会增加的计数器：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counterFunc</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">String</span> &#123; </span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">innerFunc</span><span class="params">(i: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        counter += i <span class="comment">// counter is captured</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Running total: \(counter)"</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerFunc </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，<code>counter</code>（作为 <code>counterFunc</code> 的局部变量）会在 <code>return语句</code> 之后超出范围，并被销毁。 相反，由于它是由 <code>innerFunc</code> 捕获的，因此Swift运行时将使其保持活动状态，直到捕获它的函数被销毁为止。 我们可以多次调用内部函数，并且看到运行总数增加了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = counterFunc() </span><br><span class="line">f(<span class="number">3</span>) <span class="comment">// Running total: 3 </span></span><br><span class="line">f(<span class="number">4</span>) <span class="comment">// Running total: 7</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果再次调用 <code>counterFunc()</code> ，将创建并捕获一个新的 <code>counter变量</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = counterFunc() </span><br><span class="line">g(<span class="number">2</span>) <span class="comment">// Running total: 2 </span></span><br><span class="line">g(<span class="number">2</span>) <span class="comment">// Running total: 4</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这不会影响我们的第一个功能，该功能仍然具有自己捕获的counter版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">2</span>) <span class="comment">// Running total: 9</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将这些函数及其捕获的变量组合起来，就像具有单个方法（函数）和某些成员变量（捕获的变量）的类实例一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编程术语中，<strong>函数和捕获变量的环境的组合称为闭包</strong>。 因此，上面的f和g是闭包的示例，因为它们捕获并使用在其外部声明的非局部变量（计数器）。</p><h2 id="可以使用-语法为闭包表达式声明函数"><a href="#可以使用-语法为闭包表达式声明函数" class="headerlink" title="可以使用{}语法为闭包表达式声明函数"></a><strong>可以使用{}语法为闭包表达式声明函数</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中，你可以通过两种方式定义函数。 一种是使用 <code>func关键字</code> 。 另一种方法是使用 <code>闭包表达式</code> 。 考虑使用以下简单函数将数字加倍：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doubler</span><span class="params">(i: Int)</span></span> -&gt; <span class="type">Int</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">map</span>(doubler) <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是使用闭包表达式语法编写的相同函数。 和以前一样，我们可以将其传递给 <code>map</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doublerAlt = &#123; (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span> <span class="keyword">return</span> i*<span class="number">2</span> &#125; </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">map</span>(doublerAlt) <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将声明为 <code>闭包表达式的函数</code> 视为 <code>函数文字</code> ，就像 <code>1</code> 和 <code>“hello”</code> 是整数和字符串文字一样。 它们也是匿名的-它们没有命名，与func关键字不同。 可以使用它们的唯一方法是在创建它们时将它们分配给变量（就像我们在doubler中所做的那样），或者将它们传递给另一个函数或方法。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用匿名函数的第三种方式：你可以直接在内部调用函数，作为定义该函数的同一表达式的一部分。 这对于定义初始化需要多行的属性很有用。 我们将在下面的惰性属性部分中看到一个示例。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>闭包表达式</code> 声明的 <code>doubler</code> 和之前使用 <strong>func关键字声明的doubler完全等效</strong> ，除了上面提到的参数标签处理方式不同。 与某些语言不同，它们甚至存在于相同的<code>“命名空间”</code>中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么 <code>{}</code> 语法有用呢？ 为什么不每次都使用<code>func</code>？ 好吧，它可以紧凑得多，尤其是在编写快速函数以传递给其他函数（例如map）时。 这是我们的doubler <code>map</code>示例，其格式简短得多：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125; <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这看起来非常不同，因为我们利用了 <code>Swift</code> 的多项功能来制作代码更简洁。 在这里，它们一一对应：</p><ul><li><p>1.如果你要传递的闭包参数不正确，则无需先将其存储在本地变量中。可以认为这就像将数字表达式（例如5 * i）传递给以Int作为参数的函数一样。</p></li><li><p>2.如果编译器可以从上下文中推断出类型，则无需指定它。在我们的示例中，传递给map的函数采用一个Int（根据数组元素的类型推断）并返回一个Int（根据乘法表达式的类型推断）。</p></li><li><p>3.如果closureexpression的主体包含与leexpression相同的值，它将自动返回该表达式的值，你可以不使用该返回值。</p></li><li><p>4.Swift自动为该函数的参数提供缩写名称-第一个为 $0 ，第二个为 $1 ，依此类推。</p></li><li><p>5.如果无法执行该函数的闭包表达式，则可以将表达式移到函数调用括号之外。如果你有多行闭包表达式，那么这种尾随的闭包语法非常有用，因为它更类似于常规函数定义或其他块语句，例如 if expr {}。</p></li><li><p>6.最后，如果功能没有其他说法，则可以关闭在函数名称后的所有括号之间都不要加上括号。</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用这些规则，我们可以将下面的表达式简化为上面所示的形式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span>( &#123; (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span> <span class="keyword">return</span> i * <span class="number">2</span> &#125; ) </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span>( &#123; i <span class="keyword">in</span> <span class="keyword">return</span> i * <span class="number">2</span> &#125; )</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span>( &#123; i <span class="keyword">in</span> i * <span class="number">2</span> &#125; )</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span>( &#123; $<span class="number">0</span> * <span class="number">2</span> &#125; )</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span>() &#123; $<span class="number">0</span> * <span class="number">2</span> &#125; </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span>&#123;$<span class="number">0</span>*<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不熟悉 <code>Swift</code> 的语法以及一般的 <code>函数式编程</code> ，那么这些紧凑的函数声明乍一看似乎令人生畏。但是随着你对语法和函数式编程风格的逐渐熟悉，它们会开始变得更加自然，并且你将欣赏消除混乱的功能，从而可以更清楚地看到代码在做什么。一旦你习惯于阅读这样编写的代码，与使用常规for循环编写的等效代码相比，一目了然地进行解析。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时， <code>Swift</code> 需要帮助来 <code>推断类型</code> 。有时，你可能会出错，并且类型不是你认为应该的。如果你在尝试提供 <code>闭包表达式</code> 时遇到神秘的错误，最好写出完整的表格（上面的第一个版本）并附上类型。在许多情况下，这将有助于弄清问题出在哪里。完成长格式编译后，再次将类型一一取出，直到编译器抱怨为止。如果错误是你的错误，则将在此过程中修复你的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 也会坚持让你有时更露骨。例如，你不能完全忽略输入参数。假设你想要一个随机数数组。一种快速的方法是使用仅生成随机数的函数映射范围。但是，你必须提供一个参数。在这种情况下，你可以使用 <code>_</code> 来指示编译器你确认有一个参数，但是你并不关心它是什么：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>..&lt;<span class="number">3</span>).<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">1</span>..&lt;<span class="number">100</span>) &#125; <span class="comment">// [3, 63, 60]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你需要显式键入变量时，不必在闭包内进行操作 closure表达。 例如，尝试定义不带任何类型的 <code>isEven</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isEven = &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面，将 <code>isEven</code> 的类型推断为 <code>（Int）-&gt; Bool</code>，就像让 <code>i = 1</code> 推断为 <code>Int</code> 一样，因为 <code>Int</code> 是整数文字的默认类型。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是因为标准库中的类型别名 <code>IntegerLiteralType</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ExpressibleByIntegerLiteral</span> </span>&#123; <span class="keyword">associatedtype</span> <span class="type">IntegerLiteralType</span></span><br><span class="line"><span class="comment">/// Create an instance initialized to `value`. init(integerLiteral value: IntegerLiteralType)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// The default type for an otherwise-unconstrained integer literal.</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">IntegerLiteralType</span> = <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要定义自己的类型别名，它将覆盖默认的别名，然后更改此行为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">change this behavior:</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">IntegerLiteralType</span> = <span class="type">UInt32</span> <span class="keyword">let</span> i = <span class="number">1</span> <span class="comment">// i will be of type UInt32.</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这几乎肯定是一个坏主意。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果你需要另一版本的 <code>isEven版本</code> ，则可以在<strong>闭包表达式</strong>中键入参数和返回值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isEvenAlt = &#123; (i: <span class="type">Int8</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> i % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是你也可以从闭包外部提供上下文：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> isEvenAlt2: (<span class="type">Int8</span>) -&gt; <span class="type">Bool</span> = &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125; </span><br><span class="line"><span class="keyword">let</span> isEvenAlt3 = &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125; <span class="keyword">as</span> (<span class="type">Int8</span>) -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于闭包表达式最常用于现有输入或输出类型的某些上下文中，因此通常不需要添加显式类型，但是知道你可以执行此操作很有用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，最好将isEven的通用版本定义为适用于任何整数的计算属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BinaryInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isEven: <span class="type">Bool</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span> % <span class="number">2</span> == <span class="number">0</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，我们可以选择将所有Integer类型的isEven变量定义为自由函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEven</span>&lt;T: BinaryInteger&gt;<span class="params">(<span class="number">_</span> i: T)</span></span> -&gt; <span class="type">Bool</span> &#123; returni%<span class="number">2</span>==<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想将该自由函数分配给变量，那么这也就意味着你必须锁定它正在操作的特定类型。 变量不能包含通用函数-只能是特定的一个：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> int8IsEven: (<span class="type">Int8</span>) -&gt; <span class="type">Bool</span> = isEven</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于命名的最后一点。 请务必记住，用 <code>func</code> 声明的函数可以是闭包，就像用 <code>{}</code> 声明的函数一样。 请记住，<strong>闭包是与任何捕获的变量组合的函数</strong>。 虽然用<strong>{}创建的函数称为闭包表达式</strong>，但人们通常将此语法称为<strong>闭包</strong>。 但是请不要感到困惑，并认为使用闭包表达式语法声明的函数与其他函数不同-没什么不同。 它们既是函数，也可以是闭包。</p><h1 id="Flexibility-through-Functions"><a href="#Flexibility-through-Functions" class="headerlink" title="Flexibility through Functions"></a><strong>Flexibility through Functions</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%8C):%20Build-in%20Collections/"><strong><em><code>“内置集合”</code></em></strong></a>一章中，我们讨论了通过将函数作为参数传递来对行为进行参数化。 让我们来看另一个例子：排序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Swift中对集合进行排序很简单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>] </span><br><span class="line">myArray.sorted() <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共有四种排序方法：<code>非变异变体sorted(by :)</code> 和 <code>变异sor(by :)</code> ，对于默认不以升序对可比较事物进行排序且不带参数的版本，将其乘以2。 对于最常见的情况，你只需要 <code>sorted()</code> 。 而且，如果你想以其他顺序排序，只需提供一个函数即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myArray.sorted(by: &gt;) <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你的元素不符合 <code>Comparable</code> , 但你还可以提供函数像元组一样有一个 <code>&lt;运算符</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberStrings = [(<span class="number">2</span>, <span class="string">"two"</span>), (<span class="number">1</span>, <span class="string">"one"</span>), (<span class="number">3</span>, <span class="string">"three"</span>)] </span><br><span class="line">numberStrings.<span class="built_in">sort</span>(by: &lt;)</span><br><span class="line">numberStrings <span class="comment">// [(1, "one"), (2, "two"), (3, "three")]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者，如果你想按一些任意条件排序，则可以提供更复杂的功能：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> animals = [<span class="string">"elephant"</span>, <span class="string">"zebra"</span>, <span class="string">"dog"</span>] animals.sorted &#123; lhs, rhs <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> l = lhs.reversed()</span><br><span class="line"><span class="keyword">let</span> r = rhs.reversed()</span><br><span class="line"><span class="keyword">return</span> l.lexicographicallyPrecedes(r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["zebra", "dog", "elephant"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是最后一项功能-使用任何比较功能对集合进行排序的能力-使Swift排序如此强大。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将此与<code>Objective-C</code>中的排序方式进行比较。如果要使用<code>Foundation</code>对数组进行排序，则会遇到一长串不同的选项：有些排序方法将选择器，块或函数指针作为比较谓词，或者可以传入<code>NSSortDescriptors</code>数组定义排序标准。所有这些功能都提供了很大的灵活性和功能，但是却以复杂性为代价-无法选择 <strong>“仅根据默认顺序进行常规排序”</strong> 。 <code>Foundation</code>中的某些变体（例如，将块作为比较谓词的方法）与<code>Swift</code>的<code>sorted（by :)</code>方法基本相同；其他版本（例如带有排序描述符数组的版本）则充分利用了<code>Objective-C</code>的动态特性，从而获得了一种非常灵活和强大的（如果是弱类型的）<code>API</code>，该<code>API</code>无法直接移植到<code>Swift</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code>中仍然支持<code>选择器</code>和<code>动态调度</code>，但是<code>Swift标准库</code>倾向于使用基于<code>函数</code>的方法。在本节中，我们将演示如何<strong>使用函数作为参数以及将函数作为数据如何以完全类型安全的方式复制相同的功能</strong>。让我们看一个受苹果文档中<code>“排序描述符编程主题”</code>指南启发的复杂示例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们首先定义一个<code>Person</code>类型。因为我们想展示<code>Objective-C</code>强大的运行时系统是如何工作的，所以我们必须使该对象成为<code>NSObject子类</code>（在纯<code>Swift</code>中，结构可能是更好的选择）。我们还使用<code>@objcMembers</code>对该类进行注释，以使所有成员对<code>Objective-C</code>可见：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span>Members</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first: <span class="type">String</span> </span><br><span class="line">    <span class="keyword">let</span> last: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> yearOfBirth: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(first: <span class="type">String</span>, last: <span class="type">String</span>, yearOfBirth: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.first = first</span><br><span class="line">        <span class="keyword">self</span>.last = last</span><br><span class="line">        <span class="keyword">self</span>.yearOfBirth = yearOfBirth</span><br><span class="line">        <span class="comment">// super.init() implicitly called here</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还定义了一系列具有不同姓名和出生年月的人：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people = [</span><br><span class="line"><span class="type">Person</span>(first: <span class="string">"Emily"</span>, last: <span class="string">"Young"</span>, yearOfBirth: <span class="number">2002</span>), </span><br><span class="line"><span class="type">Person</span>(first: <span class="string">"David"</span>, last: <span class="string">"Gray"</span>, yearOfBirth: <span class="number">1991</span>), </span><br><span class="line"><span class="type">Person</span>(first: <span class="string">"Robert"</span>, last: <span class="string">"Barnes"</span>, yearOfBirth: <span class="number">1985</span>), </span><br><span class="line"><span class="type">Person</span>(first: <span class="string">"Ava"</span>, last: <span class="string">"Barnes"</span>, yearOfBirth: <span class="number">2000</span>), </span><br><span class="line"><span class="type">Person</span>(first: <span class="string">"Joanne"</span>, last: <span class="string">"Miller"</span>, yearOfBirth: <span class="number">1994</span>), </span><br><span class="line"><span class="type">Person</span>(first: <span class="string">"Ava"</span>, last: <span class="string">"Barnes"</span>, yearOfBirth: <span class="number">1998</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要首先按姓氏，然后按名字，最后按出生年份对这个数组进行排序。 订购应遵守用户的语言环境设置。 <code>NSSortDescriptor</code>对象描述了如何对对象进行排序，我们可以使用它们来表示各个排序标准（使用<code>localizedStandardCompare</code>作为符合区域设置的比较器方法）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastDescriptor = <span class="type">NSSortDescriptor</span>(key: #keyPath(<span class="type">Person</span>.last), ascending: <span class="literal">true</span>,</span><br><span class="line">selector: #selector(<span class="type">NSString</span>.localizedStandardCompare(<span class="number">_</span>:)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstDescriptor = <span class="type">NSSortDescriptor</span>(key: #keyPath(<span class="type">Person</span>.first), ascending: <span class="literal">true</span>,</span><br><span class="line">selector: #selector(<span class="type">NSString</span>.localizedStandardCompare(<span class="number">_</span>:)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yearDescriptor = <span class="type">NSSortDescriptor</span>(key: #keyPath(<span class="type">Person</span>.yearOfBirth), ascending: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要对数组进行排序，我们可以在<code>NSArray</code>上使用<code>sortedArray（using :)</code>方法。 这需要一个排序描述符列表。 为了确定两个元素的顺序，该方法首先使用第一个排序描述符并使用该结果。 但是，如果根据第一个描述符，两个元素相等，则使用第二个描述符，依此类推：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> descriptors = [lastDescriptor, firstDescriptor, yearDescriptor]</span><br><span class="line">(people <span class="keyword">as</span> <span class="type">NSArray</span>).sortedArray(using: descriptors)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Ava Barnes (1998), Ava Barnes (2000), Robert Barnes (1985),</span></span><br><span class="line"><span class="comment">David Gray (1991), Joanne Miller (1994), Emily Young (2002)] */</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;排序描述符使用了<code>Objective-C</code>的两个运行时功能：首先，键是一个<code>Objective-C</code>的键路径，它实际上只是一个包含属性名称链表的字符串。不要将这些与<code>Swift 4</code>中引入的<code>Swift</code>的本机（强类型）键路径混淆。我们将在下文中对后者进行更多说明。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Objective-C</code>运行时的第二个功能是<code>键值编码</code>，它可以在运行时查找键的值。选择器参数带有一个选择器（它实际上也只是描述方法名称的字符串）。在运行时，选择器用于查找比较功能，当比较两个对象时，使用该比较功能比较键的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是运行时编程的一种很酷的用法，尤其是当你意识到可以例如在用户单击列标题的情况下在运行时构建排序描述符数组时。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们如何使用<code>Swift</code>的排序功能来复制此功能？复制排序的各个部分很简单-例如，如果你想使用<code>localizedStandardCompare</code>对数组进行排序：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strings = [<span class="string">"Hello"</span>, <span class="string">"hallo"</span>, <span class="string">"Hallo"</span>, <span class="string">"hello"</span>]</span><br><span class="line">strings.<span class="built_in">sort</span> &#123; $<span class="number">0</span>.localizedStandardCompare($<span class="number">1</span>) == .orderedAscending &#125; strings <span class="comment">// ["hallo", "Hallo", "hello", "Hello"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你只想使用一个对象的单个属性进行排序，那也很简单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">people.sorted &#123; $<span class="number">0</span>.yearOfBirth &lt; $<span class="number">1</span>.yearOfBirth &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Robert Barnes (1985), David Gray (1991), Joanne Miller (1994),</span></span><br><span class="line"><span class="comment">Ava Barnes (1998), Ava Barnes (2000), Emily Young (2002)] */</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，当将可选属性与<code>localizedStandardCompare</code>之类的方法结合使用时，这种方法效果不佳–丑陋得很快。 例如，考虑按文件扩展名对文件名数组进行排序（使用<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%89):%20%20Optionals/"><strong><em><code>“可选”</code></em></strong></a>一章中的fileExtension属性）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> files = [<span class="string">"one"</span>, <span class="string">"file.h"</span>, <span class="string">"file.c"</span>, <span class="string">"test.h"</span>] </span><br><span class="line">files.<span class="built_in">sort</span> &#123; l, r <span class="keyword">in</span> r.fileExtension.flatMap &#123;</span><br><span class="line">    l.fileExtension?.localizedStandardCompare($<span class="number">0</span>) &#125; == .orderedAscending </span><br><span class="line">&#125;</span><br><span class="line">files <span class="comment">// ["one", "file.c", "file.h", "test.h"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这很丑。 稍后，我们将使排序时使用可选选项更加容易。 但是，到目前为止，我们甚至都没有尝试过按多个属性进行排序。 要按姓氏，然后按名字排序，我们可以使用标准库的<code>lexicographicallyPrecedes</code>方法。 这需要两个序列，并通过遍历每一对元素直到找到一个不相等的元素来执行电话簿样式的比较。 因此，我们可以构建元素的两个数组并使用<code>lexicographicallyPrecedes</code>进行比较。 此方法还需要一个函数来执行比较，因此我们将对<code>localizedStandardCompare</code>的使用放在函数中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">people.sorted &#123; p0, p1 <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">left</span> = [p0.last, p0.first]</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">right</span> = [p1.last, p1.first]</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span>.lexicographicallyPrecedes(<span class="keyword">right</span>) &#123;</span><br><span class="line">        $<span class="number">0</span>.localizedStandardCompare($<span class="number">1</span>) == .orderedAscending </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Ava Barnes (2000), Ava Barnes (1998), Robert Barnes (1985),</span></span><br><span class="line"><span class="comment">David Gray (1991), Joanne Miller (1994), Emily Young (2002)] */</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，我们几乎以几乎相同的行数复制了原始排序的功能。 但是仍然有很多改进的余地：每次比较的数组构建效率都很低，比较是硬编码的，使用这种方法我们无法真正按照<code>yearOfBirth</code>进行排序。</p><h1 id="Functions-as-Data"><a href="#Functions-as-Data" class="headerlink" title="Functions as Data"></a><strong>Functions as Data</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们退后一步，而不是编写一个我们可以用来排序的更复杂的函数。 上面的排序描述符更加清晰，但是它们使用运行时编程。 我们编写的函数未使用运行时编程，但编写（和读取）起来并不那么容易。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>排序描述符是描述对象顺序的一种方式</strong>。 代替将信息存储为类，我们可以定义一个函数来描述对象的顺序。 最简单的定义是采用两个对象，如果顺序正确，则返回 <code>true</code> 。 这也正是标准库的<code>sort（by :)</code>和<code>sorted（by :)</code>方法作为参数的类型。 让我们定义一个通用类型别名来描述<code>排序描述符</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A sorting predicate that returns `true` if the first</span></span><br><span class="line"><span class="comment">/// value should be ordered before the second. </span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">SortDescriptor</span>&lt;<span class="type">Root</span>&gt; = (<span class="type">Root</span>, <span class="type">Root</span>) -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，我们可以定义一个排序描述符，该描述符按出生年份比较两个<code>Person</code>对象，或者一个按姓氏排序的排序描述符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortByYear: <span class="type">SortDescriptor</span>&lt;<span class="type">Person</span>&gt; = &#123; </span><br><span class="line">    $<span class="number">0</span>.yearOfBirth &lt; $<span class="number">1</span>.yearOfBirth </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sortByLastName: <span class="type">SortDescriptor</span>&lt;<span class="type">Person</span>&gt; = &#123;</span><br><span class="line">    $<span class="number">0</span>.last.localizedStandardCompare($<span class="number">1</span>.last) == .orderedAscending </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无需手动编写排序描述符，我们可以编写一个生成它们的函数。 我们不得不两次写相同的属性是不好的：在<code>sortByLastName</code>中，我们很容易犯了一个错误，并且意外地将 <code>$0.last</code> 与 <code>$1.first</code> 进行了比较。 另外，编写这些排序描述符也很麻烦； 要按名字排序，最简单的方法是复制并粘贴<code>sortByLastName</code>定义并进行修改。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了可以复制和粘贴外，我们还可以使用带有类似于<code>NSSortDescriptor</code>的接口定义函数，而无需进行运行时编程。 此函数将函数键作为第一个参数：给定要排序的数组元素，它返回排序描述符正在处理的属性的值。 然后使用<code>areInIncreasingOrder</code>函数比较两个值。 最后，即使类型别名稍微掩盖了这个事实，返回类型也是一个函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Builds a `SortDescriptor` function from a sorting predicate</span></span><br><span class="line"><span class="comment">/// and a `key` function that, given an element to compare, produces /// the value that should be used by the sorting predicate.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortDescriptor</span>&lt;Root, Value&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">key: @escaping <span class="params">(Root)</span></span></span> -&gt; <span class="type">Value</span>,</span><br><span class="line">by areInIncreasingOrder: @escaping (<span class="type">Value</span>, <span class="type">Value</span>) -&gt; <span class="type">Bool</span>) -&gt; <span class="type">SortDescriptor</span>&lt;<span class="type">Root</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; areInIncreasingOrder(key($<span class="number">0</span>), key($<span class="number">1</span>))  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关键功能描述了如何深入到<code>Root类型</code>的元素并提取与一个特定排序步骤相关的<code>Value类型</code>的值。 它与<code>Swift 4</code>中引入的<code>Swift</code>本机键路径有很多共通之处，这就是我们借用通用参数命名的原因—根和值—来自<code>KeyPath类型</code>。 在本章的后面，我们将讨论如何使用<code>Swift</code>的键路径重写排序描述符。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这允许我们以不同的方式定义 <code>sortByYear</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortByYearAlt: <span class="type">SortDescriptor</span>&lt;<span class="type">Person</span>&gt; = sortDescriptor(key: &#123; $<span class="number">0</span>.yearOfBirth &#125;, by: &lt;)</span><br><span class="line">people.sorted(by: sortByYearAlt)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Robert Barnes (1985), David Gray (1991), Joanne Miller (1994),</span></span><br><span class="line"><span class="comment">Ava Barnes (1998), Ava Barnes (2000), Emily Young (2002)] */</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们甚至可以定义一个适用于所有<code>Comparable类型</code>的重载变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortDescriptor</span>&lt;Root, Value&gt;<span class="params">(key: @escaping <span class="params">(Root)</span></span></span> -&gt; <span class="type">Value</span>) -&gt; <span class="type">SortDescriptor</span>&lt;<span class="type">Root</span>&gt; <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Comparable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &#123; key($<span class="number">0</span>) &lt; key($<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sortByYearAlt2: <span class="type">SortDescriptor</span>&lt;<span class="type">Person</span>&gt; =</span><br><span class="line">sortDescriptor(key: &#123; $<span class="number">0</span>.yearOfBirth &#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的两个<code>sortDescriptor变体</code>都可以使用返回布尔值的函数，因为这是标准库的比较谓词约定。 另一方面，像<code>localizedStandardCompare</code>这样的<code>Foundation API</code>则希望使用三向比较结果值（升序，降序或相等）。 添加对此的支持也很容易：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortDescriptor</span>&lt;Root, Value&gt;<span class="params">( key: @escaping <span class="params">(Root)</span></span></span> -&gt; <span class="type">Value</span>, ascending: <span class="type">Bool</span> = <span class="literal">true</span>,</span><br><span class="line">by comparator: @escaping (<span class="type">Value</span>) -&gt; (<span class="type">Value</span>) -&gt; <span class="type">ComparisonResult</span>)</span><br><span class="line">-&gt; <span class="type">SortDescriptor</span>&lt;<span class="type">Root</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; lhs, rhs <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> order: <span class="type">ComparisonResult</span> = ascending</span><br><span class="line">        ? .orderedAscending</span><br><span class="line">        : .orderedDescending</span><br><span class="line">        <span class="keyword">return</span> comparator(key(lhs))(key(rhs)) == order</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这使我们能够以更短更清楚的方式编写<code>sortByFirstName</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortByFirstName: <span class="type">SortDescriptor</span>&lt;<span class="type">Person</span>&gt; =</span><br><span class="line">sortDescriptor(key: &#123; $<span class="number">0</span>.first &#125;, by: <span class="type">String</span>.localizedStandardCompare)</span><br><span class="line">people.sorted(by: sortByFirstName)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Ava Barnes (2000), Ava Barnes (1998), David Gray (1991),</span></span><br><span class="line"><span class="comment">Emily Young (2002), Joanne Miller (1994), Robert Barnes (1985)] */</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此<code>SortDescriptor</code>与<code>NSSortDescriptor</code>变体一样具有表现力，但类型安全，并且不依赖于运行时编程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前，我们只能使用单个<code>SortDescriptor函数</code>对数组进行排序。 如果你回想起基于<code>NSSortDescriptor</code>的示例，我们使用了<code>NSArray.sortedArray（using :)</code>方法对具有多个比较运算符的数组进行排序。 我们可以轻松地向<code>Array</code>甚至<code>Sequence协议</code>添加类似的方法。 但是，我们必须添加两次：一次用于<code>sort的变异变体</code>，一次用于<code>sort的非变异变体</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们采用了不同的方法，因此我们不必编写更多扩展：我们编写了一个将多个排序描述符合并为一个排序描述符的函数。 它的工作方式类似于<code>sortedArray（using :)</code>方法：首先，它尝试第一个描述符并使用该比较结果。 但是，如果结果相等，它将使用第二个描述符，依此类推，直到描述符用完为止：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span>&lt;Root&gt;</span></span><br><span class="line"><span class="function"><span class="params">(sortDescriptors: [SortDescriptor&lt;Root&gt;])</span></span> -&gt; <span class="type">SortDescriptor</span>&lt;<span class="type">Root</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">return</span> &#123; lhs, rhs <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">for</span> areInIncreasingOrder <span class="keyword">in</span> sortDescriptors &#123;</span><br><span class="line">            <span class="keyword">if</span> areInIncreasingOrder(lhs, rhs) &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">            <span class="keyword">if</span> areInIncreasingOrder(rhs, lhs) &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们终于可以复制初始示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> combined: <span class="type">SortDescriptor</span>&lt;<span class="type">Person</span>&gt; = combine(</span><br><span class="line">sortDescriptors: [sortByLastName, sortByFirstName, sortByYear]</span><br><span class="line">)</span><br><span class="line">people.sorted(by: combined)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Ava Barnes (1998), Ava Barnes (2000), Robert Barnes (1985),</span></span><br><span class="line"><span class="comment">David Gray (1991), Joanne Miller (1994), Emily Young (2002)] */</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们最终获得了与<code>Foundation版本</code>相同的行为和功能，但是我们的解决方案更安全，并且在<code>Swift</code>中更加惯用。由于<code>Swift版本</code>不依赖运行时编程，因此编译器还可以更好地对其进行优化。另外，我们可以将其与结构或<code>非Objective-C</code>对象一起使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于函数的方法的一个缺点是函数是不透明的。我们可以使用<code>NSSortDescriptor</code>并将其打印到控制台，然后获得有关排序描述符的一些信息：<code>键路径，选择器名称和排序顺序</code>。我们基于功能的方法无法做到这一点。如果需要这些信息很重要，我们可以将函数包装在结构或类中，并存储其他调试信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种将<code>函数用作数据的方法</code>（将它们存储在数组中并在运行时构建这些数组）开辟了新的动态行为水平，这是一种像<code>Swift</code>这样的面向静态类型的面向编译时的语言仍然可以复制其中一些内容的方法。诸如<code>Objective-C</code>或<code>Ruby</code>之类的语言的动态行为。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还看到了编写结合其他功能的功能的有用性，这是功能编程的组成部分之一。例如，我们的<code>Combine（sortDescriptors :)</code>函数采用了一组排序描述符，并将它们组合为一个排序描述符。这是一项非常强大的技术，具有许多不同的应用程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，我们甚至可以编写一个自定义运算符来组合两个排序函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;||&gt; : <span class="type">LogicalDisjunctionPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;||&gt;&lt;A&gt;<span class="params">(lhs: @escaping <span class="params">(A,A)</span></span></span> -&gt; <span class="type">Bool</span>, rhs: @escaping (<span class="type">A</span>,<span class="type">A</span>) -&gt; <span class="type">Bool</span>)</span><br><span class="line">-&gt; (<span class="type">A</span>,<span class="type">A</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>&#123; x,yin</span><br><span class="line">        <span class="keyword">if</span> lhs(x, y) &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> lhs(y, x) &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="comment">// Otherwise they're the same, so we check for the second condition. </span></span><br><span class="line">        <span class="keyword">if</span> rhs(x, y) &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在大多数情况下，编写自定义运算符不是一个好主意。 自定义运算符通常比函数难读，因为运算符没有易于解释的名称。 但是，当少量使用它们时，它们可能会非常强大。 上面的运算符允许我们重写组合的排序示例，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> combinedAlt = sortByLastName &lt;||&gt; sortByFirstName &lt;||&gt; sortByYear people.sorted(by: combinedAlt)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Ava Barnes (1998), Ava Barnes (2000), Robert Barnes (1985),</span></span><br><span class="line"><span class="comment">David Gray (1991), Joanne Miller (1994), Emily Young (2002)] */</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这读起来很清楚，也许也比替代方法更简洁地表达了代码的意图，但前提是你（和代码的所有其他阅读者）已经深深理解了操作员的含义。与自定义运算符相比，我们更喜欢<code>Combine（sortDescriptors :)</code>函数。在呼叫站点更清晰，最终使代码更具可读性。除非你编写的是特定于域的高度代码，否则自定义运算符可能会过分杀人。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Foundation版本</code>与我们的版本相比仍然具有一个功能优势：它可以处理可选内容，而无需编写更多代码。例如，如果我们将<code>Person</code>的最后一个属性设为可选字符串，则无需在使用<code>NSSortDescriptor</code>的排序代码中进行任何更改。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于函数的版本需要一些额外的代码。你可能会猜到接下来会发生什么：我们再一次编写一个接受一个函数并返回一个函数的函数。我们可以使用一个常规的比较函数（例如<code>localizedStandardCompare</code>），该函数对两个字符串起作用，然后将其转换为一个对两个字符串进行可选的函数。如果两个值均为零，则它们相等。如果左侧为零，但右侧不是，则它们在上升，反之亦然。最后，如果它们都不为零，我们可以使用<code>compare函数</code>对它们进行比较：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lift</span>&lt;A&gt;<span class="params">(<span class="number">_</span> compare: @escaping <span class="params">(A)</span></span></span> -&gt; (<span class="type">A</span>) -&gt; <span class="type">ComparisonResult</span>) -&gt; (<span class="type">A?</span>) -&gt; (<span class="type">A?</span>) -&gt; <span class="type">ComparisonResult</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; lhsin &#123; rhs <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> (lhs, rhs) &#123;</span><br><span class="line">                <span class="keyword">case</span> (<span class="literal">nil</span>, <span class="literal">nil</span>): <span class="keyword">return</span> .orderedSame </span><br><span class="line">                <span class="keyword">case</span> (<span class="literal">nil</span>, <span class="number">_</span>): <span class="keyword">return</span> .orderedAscending </span><br><span class="line">                <span class="keyword">case</span> (<span class="number">_</span>, <span class="literal">nil</span>): <span class="keyword">return</span> .orderedDescending </span><br><span class="line">                <span class="keyword">case</span> <span class="keyword">let</span> (l?, r?): <span class="keyword">return</span> compare(l)(r)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这使我们可以将常规比较函数<code>“提升”</code>到可选对象的域中，并且可以与我们的<code>sortDescriptor</code>函数一起使用。 如果你从前回想起<code>files数组</code>，则通过<code>fileExtension</code>对其进行排序确实很丑陋，因为我们不得不处理可选参数。 但是，有了我们的新举升功能，它又可以干净了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compare = lift(<span class="type">String</span>.localizedStandardCompare)</span><br><span class="line"><span class="keyword">let</span> result = files.sorted(by: sortDescriptor(key: &#123; $<span class="number">0</span>.fileExtension &#125;,</span><br><span class="line">by: compare))</span><br><span class="line">result <span class="comment">// ["one", "file.c", "file.h", "test.h"]</span></span><br></pre></td></tr></table></figure><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以为返回布尔的函数编写类似版本的<code>lift</code>。 正如我们在<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%89):%20%20Optionals/"><strong><em><code>“可选内容”</code></em></strong></a>一章中看到的那样，标准库不再提供诸如<code>&gt;的比较运算符</code>作为可选内容。 删除它们是因为如果你不小心使用它们可能会导致令人惊讶的结果。 布尔值的<code>lift</code>变量使你可以轻松使用现有的运算符，并在需要功能时使其成为可选函数。</p></blockquote><h1 id="Functions-as-Delegates"><a href="#Functions-as-Delegates" class="headerlink" title="Functions as Delegates"></a><strong>Functions as Delegates</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Delegates</code> 他们无处不在。 这条消息深深打入了<code>Objective-C（和Java）</code>程序员的脑海：<strong>使用协议（接口）进行回调</strong>。 你定义一个<code>协议</code>，你的<code>所有者实现该协议</code>，然后将其注册为你的委托，以便获取回调。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果委托协议仅包含一个方法，则可以将存储委托对象的属性替换为直接存储回调函数的属性。 但是，要记住一些折衷方案。</p><h2 id="Delegates-Cocoa-Style"><a href="#Delegates-Cocoa-Style" class="headerlink" title="Delegates, Cocoa Style"></a><strong><em>Delegates, Cocoa Style</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，以与<code>Cocoa</code>定义其无数个委托协议相同的方式创建一个协议。 来自<code>Objective-C</code>的大多数程序员多次编写这样的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AlertViewDelegate</span>: <span class="title">AnyObject</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buttonTapped</span><span class="params">(atIndex: Int)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>AlertViewDelegate</code>被定义为<code>仅类协议</code>（通过从<code>AnyObject</code>继承），因为我们希望我们的<code>AlertView类</code>保留对委托的弱引用。 这样，我们就不必担心引用周期。 <code>AlertView</code>永远不会强烈保留其委托，因此，即使委托（直接或间接）对警报视图有很强的引用，一切都很好。 如果委托被取消初始化，则委托属性将自动变为nil：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlertView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buttons: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">AlertViewDelegate?</span></span><br><span class="line">    <span class="keyword">init</span>(buttons: [<span class="type">String</span>] = [<span class="string">"OK"</span>, <span class="string">"Cancel"</span>]) &#123; </span><br><span class="line">        <span class="keyword">self</span>.buttons = buttons</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123; </span><br><span class="line">        delegate?.buttonTapped(atIndex: <span class="number">1</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们处理课程时，这种模式非常有效。 例如，假设我们有一个<code>ViewController类</code>，该类初始化警报视图并将其自身设置为委托。 由于该代表被标记为弱者，因此我们无需担心循环引用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">AlertViewDelegate</span> </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> alert: <span class="type">AlertView</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        alert = <span class="type">AlertView</span>(buttons: [<span class="string">"OK"</span>, <span class="string">"Cancel"</span>]) </span><br><span class="line">        alert.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buttonTapped</span><span class="params">(atIndex index: Int)</span></span> &#123; </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Button tapped: \(index)"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常的做法是始终将代表属性标记为 <strong><em><code>weak</code></em></strong>。 这个约定使内存管理的推理变得非常容易，因为实现委托协议的类不必担心创建<code>循环引用</code>。</p><h2 id="使用结构的Delegate"><a href="#使用结构的Delegate" class="headerlink" title="使用结构的Delegate"></a><strong><em>使用结构的Delegate</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时我们可能想要一个由结构体实现的委托协议。 使用<code>AlertViewDelegate</code>的当前定义，这是不可能的，因为它是仅类的协议。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过不将<code>AlertViewDelegate</code>定义为仅<code>类协议</code>来放松其定义。 另外，我们将<code>buttonTapped（atIndex :)</code>方法标记为变异。 这样，当方法被调用时，结构可以自行变异：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AlertViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">buttonTapped</span><span class="params">(atIndex: Int)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还必须更改<code>AlertView</code>，因为委托属性不能再弱了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlertView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buttons: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">var</span> delegate: <span class="type">AlertViewDelegate?</span></span><br><span class="line">    <span class="keyword">init</span>(buttons: [<span class="type">String</span>] = [<span class="string">"OK"</span>, <span class="string">"Cancel"</span>]) &#123; </span><br><span class="line">        <span class="keyword">self</span>.buttons = buttons</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123; </span><br><span class="line">        delegate?.buttonTapped(atIndex: <span class="number">1</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们为委托属性分配一个对象，则将强引用该对象。 特别是在与<code>Delegate</code>合作时， <code>strong reference</code> 意味着我们很有可能在某个时候引入循环引用。 但是，我们现在可以使用结构。 例如，我们可以创建一个记录所有按钮点击的结构：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TapLogger</span>: <span class="title">AlertViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> taps: [<span class="type">Int</span>] = []</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">buttonTapped</span><span class="params">(atIndex index: Int)</span></span> &#123;</span><br><span class="line">        taps.append(index) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;起初，似乎一切正常。 我们可以创建一个警报视图和一个记录器，然后将两者连接起来。如果我们在触发事件后查看<code>logger.taps</code>，则该数组仍为空：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alert = <span class="type">AlertView</span>() </span><br><span class="line"><span class="keyword">var</span> logger = <span class="type">TapLogger</span>() </span><br><span class="line">alert.delegate = logger </span><br><span class="line">alert.fire()</span><br><span class="line">logger.taps <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们分配给 <code>alert.delegate</code> 时，<code>Swift</code>复制了该结构。 因此，这些 <code>taps</code> 不是记录在记录器中，而是记录在<code>alert.delegate</code>中。 更糟糕的是，当我们分配值时，我们失去了价值的类型。 为了获取信息，我们需要使用条件类型转换：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> theLogger = alert.delegate <span class="keyword">as</span>? <span class="type">TapLogger</span> &#123; </span><br><span class="line">    <span class="built_in">print</span>(theLogger.taps)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，这种方法行不通。 使用类时，创建引用循环很容易；使用结构时，原始值不会发生突变。 简而言之：使用结构时，委托协议没有多大意义。</p><h2 id="用函数代替-Delegates"><a href="#用函数代替-Delegates" class="headerlink" title="用函数代替 Delegates"></a><strong><em>用函数代替 Delegates</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果委托协议仅定义了一个方法，我们可以简单地将委托属性替换为直接存储回调函数的属性。 在我们的情况下，这可以是一个可选的 <code>buttonTapped属性</code> ，默认情况下为<code>nil</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlertView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buttons: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">var</span> buttonTapped: ((<span class="number">_</span> buttonIndex: <span class="type">Int</span>) -&gt; ())?</span><br><span class="line">    <span class="keyword">init</span>(buttons: [<span class="type">String</span>] = [<span class="string">"OK"</span>, <span class="string">"Cancel"</span>]) &#123; </span><br><span class="line">        <span class="keyword">self</span>.buttons = buttons</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123; </span><br><span class="line">        buttonTapped?(<span class="number">1</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数类型的<code>（_ buttonIndex：Int）-&gt;（）</code>表示法有点奇怪，因为内部名称 <code>buttonIndex</code> 与代码中的其他地方无关。 上面我们提到，不幸的是，函数类型没有参数标签； 但是，它们可以具有显式的空白参数标签和内部参数名称。 这是经过官方批准的解决方法，可以在函数类型标签中提供参数以用于文档编制，直到Swift支持更好的方法为止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和以前一样，我们可以创建一个<code>logger结构</code>，然后创建一个警报视图实例和一个<code>logger</code>变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TapLogger</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> taps: [<span class="type">Int</span>] = []</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">logTap</span><span class="params">(index: Int)</span></span> &#123; </span><br><span class="line">        taps.append(index)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> alert = <span class="type">AlertView</span>() </span><br><span class="line"><span class="keyword">var</span> logger = <span class="type">TapLogger</span>()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，我们不能简单地将 <code>logTap方法</code> 分配给 <code>buttonTapped属性</code> 。 Swift编译器告诉我们“不允许部分应用<code>&#39;mutating&#39;方法”</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert.buttonTapped = logger.logTap <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的代码中，尚不清楚应在作业中执行什么操作。 记录器是否被复制？ 还是应该buttonTapped改变原始变量（即记录器被捕获）？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使这项工作有效，我们必须将赋值的右边包装在一个闭包中。 这样做的好处是非常清楚地表明，我们现在正在捕获原始的logger变量（而不是值），并且正在对其进行突变：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert.buttonTapped = &#123; logger.logTap(index: $<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个好处是，现在取消了命名的耦合：回调属性称为<code>buttonTapped</code>，而实现该属性的函数称为<code>logTap</code>。 除了方法之外，我们还可以指定一个匿名函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert.buttonTapped = &#123; <span class="built_in">print</span>(<span class="string">"Button \($0) was tapped"</span>) &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将回调与类结合使用时，有一些警告。 让我们回到我们的视图控制器示例。 在其初始值设定项中，视图控制器现在可以将其<code>buttonTapped方法</code>分配给警报视图的回调处理程序，而不必将自己分配为警报视图的委托：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> alert: <span class="type">AlertView</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        alert = <span class="type">AlertView</span>(buttons: [<span class="string">"OK"</span>, <span class="string">"Cancel"</span>]) </span><br><span class="line">        alert.buttonTapped = <span class="keyword">self</span>.buttonTapped(atIndex:)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buttonTapped</span><span class="params">(atIndex index: Int)</span></span> &#123; </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Button tapped: \(index)"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>alert.buttonTapped = self.buttonTapped（atIndex :)</code>行看起来像是一个无辜的任务，但是请注意：我们刚刚创建了一个引用循环！ 对对象的实例方法的每个引用（例如示例中的<code>self.buttonTapped</code>）都隐式捕获对象。 要了解为什么必须这样做，请考虑警报视图的角度：当警报视图调用存储在其<code>buttonTapped属性</code>中的回调函数时，该函数必须以某种方式“知道”它需要调用哪个对象的实例方法，即 仅存储对<code>ViewController.buttonTapped（atIndex :)</code>的引用而不知道实例是不够的。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以将<code>self.buttonTapped（atIndex :)</code>缩短为<code>self.buttonTapped</code>或仅仅为<code>buttonTapped</code>; 所有这三个都指同一个功能。 可以省略参数标签，只要这样做不会造成歧义。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了避免强引用，通常需要将方法调用包装在另一个弱捕获对象的闭包中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert.buttonTapped = &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] index <span class="keyword">in</span> </span><br><span class="line">    <span class="keyword">self</span>?.buttonTapped(atIndex: index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，警报视图就不会强烈引用视图控制器。 如果我们可以保证警报视图的生命周期与视图控制器相关联，那么另一种选择是使用无所有权而不是弱项。 弱，如果警报视图超出视图控制器，则在调用函数时<code>self</code>在闭包内为<code>nil</code>。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你查看了<code>ViewController.buttonTapped</code>表达式的类型，你会注意到它是<code>（ViewController）-&gt;（Int）-&gt;（）</code>。 发生什么事了？在幕后，实例方法被建模为以下函数：<br>给定实例，返回另一个函数，然后对该函数进行操作实例。 <code>someVC.buttonTapped</code>实际上只是编写<code>ViewController.buttonTapped（someVC）</code>的另一种方式-这两个表达式都返回一个<code>（Int）-&gt;（）</code>类型的函数，而该函数是一个已强烈捕获<code>someVC实例</code>的闭包。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如我们所见，<code>协议和回调函数</code>之间存在一定的权衡。协议增加了一些冗长性，但是具有弱委托的纯类协议无需担心引入引用循环。用函数替换委托可以增加很多灵活性，并允许你使用结构和匿名函数。但是，在处理类时，需要注意不要引入引用循环。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样，当你需要多个紧密相关的回调函数时（例如，为表视图提供数据时），将它们按协议分组在一起而不是单独进行回调会很有帮助。另一方面，当使用协议时，单个类型必须实现所有方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要取消注册委托或函数回调，我们可以简单地将其设置为nil。当我们的类型存储委托或回调数组时该怎么办？使用基于类的委托，我们可以简单地从委托列表中删除一个对象。使用回调函数，这并不是那么简单。我们无法添加功能，因此需要添加额外的基础架构以进行注销。</p><h2 id="输入参数和突变方法"><a href="#输入参数和突变方法" class="headerlink" title="输入参数和突变方法"></a><strong><em>输入参数和突变方法</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Swift</code>中<code>inout参数</code>前面使用的<code>“＆”</code>可能会给你印象，特别是如果你具有<code>C</code>或<code>C ++</code>背景的话，<code>inout参数</code>本质上是通过<strong>引用</strong>。 但事实并非如此。 <code>inout</code>是<strong><em>按值传递和复制回传，而不是按引用传递</em></strong>。 引用Swift编程语言：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inout参数具有一个值，该值传递给函数，由函数修改，然后从函数传递回以替换原始值。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了了解可以将哪种表达式作为<code>inout参数传递</code>，我们需要区分左值和右值。 左值描述内存位置。 <code>lvalue</code>是“左值”的缩写，因为左值是可以出现在赋值左侧的表达式。 例如，<code>array [0]</code>是一个左值，因为它描述了数组中第一个元素的存储位置。 右值描述一个值。 2 + 2是一个值，它描述了值4。 你不能在赋值语句的左侧输入2 + 2或4。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于<code>inout参数</code>，你只能传递左值，因为突变右值没有意义。 在常规函数和方法中使用inout参数时，需要明确地传入它们：每个左值都必须以<code>＆</code>开头。 例如，当我们调用增量函数（需要一个<code>inout Int</code>）时，我们可以通过在变量前面加上一个<code>＆符号</code>来传递变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(value: <span class="keyword">inout</span> Int)</span></span> &#123; </span><br><span class="line">    value += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0</span> </span><br><span class="line">increment(value: &amp;i)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果使用<code>let定义变量</code>，则不能将其用作左值。 这是有道理的，因为我们不允许对<code>let变量</code>进行突变； 我们只能使用“可变”左值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> y:<span class="type">Int</span> = <span class="number">0</span> </span><br><span class="line">increment(value: &amp;y) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了变量之外，还有一些其他东西也是左值。 例如，我们还可以传入数组下标（如果使用var定义了数组）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>] </span><br><span class="line">increment(value: &amp;array[<span class="number">0</span>]) </span><br><span class="line">array <span class="comment">// [1, 1, 2]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，这适用于每个下标（包括你自己的自定义下标），只要它们都定义了get和set即可。 同样，我们可以将属性用作左值，但前提是它们必须同时定义get和set：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span> </span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> point = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>) </span><br><span class="line">increment(value: &amp;point.x) </span><br><span class="line">point <span class="comment">// Point(x: 1, y: 0)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果属性是只读的（即，只有get可用），我们不能将其用作<code>inout参数</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> squaredDistance: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*x + y*y </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">increment(value: &amp;point.squaredDistance) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运算符也可以取<code>inout值</code>，但为简单起见，在调用时不需要“与”号； 我们只指定左值。 例如，让我们重新添加后缀增量运算符，该运算符在Swift 3中已删除：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">postfix</span> <span class="function"><span class="keyword">func</span> ++<span class="params">(x: <span class="keyword">inout</span> Int)</span></span> &#123; </span><br><span class="line">    x+=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">point.x++</span><br><span class="line">point <span class="comment">// Point(x: 2, y: 0)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变异算子甚至可以与可选链结合使用。 在这里，我们将增量操作链接到字典下标访问：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dictionary = [<span class="string">"one"</span>: <span class="number">1</span>] </span><br><span class="line">dictionary[<span class="string">"one"</span>]?++ </span><br><span class="line">dictionary[<span class="string">"one"</span>] <span class="comment">// Optional(2)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，如果键查询返回nil，则不会执行++运算符。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译器可以优化<code>inout变量</code>以通过引用传递，而不是复制进出。 但是，文档中明确指出我们不应该依赖此行为。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将在下一章<code>“结构和类”</code>中回到<code>inout</code>，在这里我们将探讨采用<code>inout参数</code>的变异方法和函数之间的相似之处。</p><h2 id="嵌套函数和inout"><a href="#嵌套函数和inout" class="headerlink" title="嵌套函数和inout"></a><strong><em>嵌套函数和inout</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以在嵌套函数内使用<code>inout参数</code>，但是<code>Swift</code>会确保你的用法是安全的。 例如，你可以定义一个嵌套函数（<code>使用func或使用闭包表达式</code>）并安全地更改<code>inout参数</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementTenTimes</span><span class="params">(value: <span class="keyword">inout</span> Int)</span></span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value += <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123; </span><br><span class="line">        inc()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x=<span class="number">0</span> </span><br><span class="line">incrementTenTimes(value: &amp;x) </span><br><span class="line">x <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，不允许你使该<code>inout参数</code>转义（在本章的最后，我们将详细讨论<code>转义函数</code>）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">escapeIncrement</span><span class="params">(value: <span class="keyword">inout</span> Int)</span></span> -&gt; () -&gt; () &#123; </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value += <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Error: nested function cannot capture inout parameter // and escape.</span></span><br><span class="line">    <span class="keyword">return</span> inc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鉴于<code>inout值</code>在函数返回之前被复制回去，因此这是有道理的。 如果我们以后能以某种方式修改它，应该怎么办？ 该值是否应该在某个时候复制回去？ 如果源不存在怎么办？ 让编译器验证这一点对安全至关重要。</p><h2 id="When-amp-Doesn’t-Mean-inout"><a href="#When-amp-Doesn’t-Mean-inout" class="headerlink" title="When &amp; Doesn’t Mean inout"></a><strong><em>When &amp; Doesn’t Mean inout</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到不安全的函数，你应该了解<code>＆</code>的其他含义：<strong>将函数参数转换为不安全的指针</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果函数将<code>UnsafeMutablePointer</code>作为参数，则可以使用<code>＆</code>将变量传递给它，类似于使用<code>inout参数</code>的方式。 但是在这里，你实际上是通过<strong>引用传递的-实际上是通过指针传递的</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是增量，写成<code>采用不安全的可变指针</code>而不是<code>inout</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incref</span><span class="params">(pointer: UnsafeMutablePointer&lt;Int&gt;)</span></span> -&gt; () -&gt; <span class="type">Int</span> &#123; </span><br><span class="line">    <span class="comment">// Store a copy of the pointer in a closure.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        pointer.pointee += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> pointer.pointee </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们将在后面的章节中讨论的那样，Swift数组隐式地衰减到指针，以使C的互操作性变得轻松愉快。 现在，假设你传入一个超出范围的数组，然后再调用结果函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun: () -&gt; <span class="type">Int</span> </span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = [<span class="number">0</span>]</span><br><span class="line">    fun = incref(pointer: &amp;array) </span><br><span class="line">&#125;</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这打开了令人兴奋的未定义行为的世界。 在测试中，以上代码在每次运行时都打印不同的值：有时为0，有时为1，有时为140362397107840 —有时会导致运行时崩溃。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的道义是：知道你要传递的内容。 附加<code>＆</code>时，你可能正在调用安全的 <code>Swift inout语义</code>，或者将可怜的变量转换为不安全指针的残酷世界。 在处理不安全的指针时，请特别注意变量的生命周期。 我们将在“互操作性”一章中对此进行更详细的介绍。</p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a><strong><em>Properties</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有两种不同于常规方法的特殊方法：<code>计算属性和下标</code>。 计算属性看起来像常规属性，但是它<br>不使用任何内存来存储其值。 取而代之的是，每次访问属性时都会动态计算该值。 计算属性实际上只是一种具有异常定义和调用约定的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看看定义属性的各种方法。 我们将从代表GPS轨迹的结构开始。 它将所有记录的点存储在称为record的数组中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CoreLocation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GPSTrack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> record: [(<span class="type">CLLocation</span>, <span class="type">Date</span>)] = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们想让record属性对外部只读，而对内部只读，则可以使用 <code>private（set）</code> 或<code>fileprivate（set）</code>修饰符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GPSTrack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> record: [(<span class="type">CLLocation</span>, <span class="type">Date</span>)] = []</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;要访问<span class="type">GPS</span>轨迹中的所有时间戳，我们创建一个计算属性：</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">GPSTrack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Returns all the timestamps for the GPS track.</span></span><br><span class="line">    <span class="comment">/// - Complexity: O(*n*), where *n* is the number of points recorded. </span></span><br><span class="line">    <span class="keyword">var</span> timestamps: [<span class="type">Date</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> record.<span class="built_in">map</span> &#123; $<span class="number">0.1</span> &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于我们未指定设置器，因此<code>timestamps属性为只读</code>。 结果未缓存； 每次你访问该属性时，它都会计算结果。 《Swift API设计指南》建议你记录每个非 O(1) 的计算属性的复杂性，因为调用者可能会假设访问属性需要花费固定时间。</p><h2 id="Change-Observers"><a href="#Change-Observers" class="headerlink" title="Change Observers"></a><strong><em>Change Observers</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以实现<code>willSet</code>和<code>didSet</code>处理程序，以使属性和变量在每次设置属性时都被调用（即使值不变）。 分别在存储新值之前和之后立即调用它们。 一种有用的情况是使用<code>Interface Builder</code>时：我们可以实现<code>didSet</code>来了解何时连接<code>IBOutlet</code>，然后可以在处理程序中执行其他配置。 例如，如果我们想在标签可用时设置标签的文本颜色，则可以执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SettingsController</span>: <span class="title">UIViewController</span> </span>&#123; </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> label: <span class="type">UILabel?</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            label?.textColor = .black</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;必须在属性的声明位置定义观察者-你不能在扩展名中追溯添加观察者。 因此，它们是该类型设计人员的工具，而不是用户的工具。 <code>willSet和didSet</code>处理程序本质上是<strong>定义一对属性的简写：一个提供存储的私有存储属性，以及一个公共计算属性，其<code>setter</code>在将值存储到存储属性之前和/或之后执行附加工作。</strong> 这与<code>Foundation</code>中的键值观察机制有根本的区别，<strong>Foundation中的键值观察机制通常由对象的使用者用来观察内部变化</strong>，而无论类的设计者是否打算这样做。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，你可以<strong>覆盖子类中的属性以添加观察者</strong>。 这是一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> stopped, movingForward, turningRight, turningLeft </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="type">State</span>.stopped </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObservableRobot</span>: <span class="title">Robot</span> </span>&#123; </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> state: <span class="type">State</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Transitioning from \(state) to \(newValue)"</span>)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> robot = <span class="type">ObservableRobot</span>()</span><br><span class="line">robot.state = .movingForward </span><br><span class="line"><span class="comment">// Transitioning from stopped to movingForward</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这仍然与变更观察者作为类型的内部特征的本质保持一致。 如果不允许，则子类可以通过使用执行其他工作的计算后的<code>setter覆盖存储</code>的属性来达到相同的效果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些功能的实现反映了用法上的差异。 <code>KVO</code>使用<code>Objective-C运行时将观察者动态添加到类的setter中</code>，这在当前版本的<code>Swift</code>中是不可能实现的，尤其是对于<code>值类型</code>。 <code>Swift</code>中的<strong>属性观察是纯粹的编译时功能</strong>。</p><h2 id="惰性存储属性"><a href="#惰性存储属性" class="headerlink" title="惰性存储属性"></a><strong><em>惰性存储属性</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>惰性地初始化值</strong>是一种常见的模式，<code>Swift</code>具有一个特殊的<code>关键字lazy来定义惰性属性</code>。 请注意，必须始终将惰性属性声明为<code>var</code>，因为直到 <strong><em>初始化完成后才可能设置其初始值</em></strong>。 <code>Swift</code>有一个严格的规则，即在实例的初始化完成之前，让常量必须具有一个值。 惰性修饰符是记忆的一种非常特定的形式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，如果我们有一个显示<code>GPSTrack</code>的视图控制器，则可能需要一个轨迹的预览图像。 通过使该属性变得懒惰，我们可以将昂贵的图像生成推迟到第一次访问该属性时：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GPSTrackViewController</span>: <span class="title">UIViewController</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> track: <span class="type">GPSTrack</span> = <span class="type">GPSTrack</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> preview: <span class="type">UIImage</span> = &#123; </span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> track.record &#123;</span><br><span class="line">        <span class="comment">// Do some expensive computation.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(<span class="comment">/* ... */</span>) &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，我们是如何定义<code>lazy属性</code>的：它是一个闭包表达式，它返回要存储的值（在本例中为图像）。 首次访问该属性时，将执行闭包（请注意结尾处的括号），并将其返回值存储在该属性中。 这是懒惰属性的常见模式，该属性需要初始化多个衬垫。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于惰性变量需要存储，因此我们需要在<code>GPSTrackViewController</code>的定义中定义惰性属性。 与计算属性不同，<strong>扩展中无法定义存储属性和惰性属性</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果<code>track</code>属性更改，则预览不会自动失效。 让我们看一个更简单的例子，看看发生了什么。 我们有一个<code>Point结构</code>，并将<code>distanceFromOrigin</code>存储为一个惰性计算属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="built_in">lazy</span> <span class="keyword">var</span> distanceFromOrigin: <span class="type">Double</span></span><br><span class="line">    = (x*x + y*y).squareRoot()</span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) &#123; </span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建点时，我们可以访问<code>distanceFromOrigin属性</code>，它将计算值并将其存储以供重用。 但是，如果我们随后更改<code>x</code>值，则该值不会反映在<code>distanceFromOrigin</code>中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = <span class="type">Point</span>(x: <span class="number">3</span>, y: <span class="number">4</span>) </span><br><span class="line">point.distanceFromOrigin <span class="comment">// 5.0 </span></span><br><span class="line">point.x += <span class="number">10</span> </span><br><span class="line">point.distanceFromOrigin <span class="comment">// 5.0</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请务必注意这一点。 解决该问题的一种方法是在<code>x</code>和<code>y</code>的<code>didSet属性观察器</code>中重新计算<code>distanceFromOrigin</code>，但是<code>distanceFromOrigin</code>不再是真正的懒惰了：它会在x或y每次更改时进行计算。 当然，在此示例中，解决方案很简单：我们应该从一开始就将<code>distanceFromOrigin</code>设置为常规的（非延迟）计算属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>访问惰性属性</code>是一项变异操作，因为该属性的初始值是在首次访问时设置的。 当一个结构包含一个惰性属性时，访问该惰性属性的结构的任何所有者都必须因此将包含该结构的变量声明为<code>var</code>，因为访问该属性意味着有可能对其容器进行突变。 因此，这是不允许的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> immutablePoint = <span class="type">Point</span>(x: <span class="number">3</span>, y: <span class="number">4</span>) </span><br><span class="line">immutablePoint.distanceFromOrigin</span><br><span class="line"><span class="comment">// Error: Cannot use mutating getter on immutable value.</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;强制所有想要访问惰性属性的Point类型用户使用var是一个巨大的不便，这通常会使<strong>惰性属性不适用于结构</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，请注意，<code>lazy关键字不会执行任何线程同步</code>。如果在计算该值之前多个线程同时访问一个惰性属性，则该计算可能会执行一次以上，同时还会产生任何副作用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Swift的开源时代初期，Swift团队提出了一种使用<code>“行为”注释属性</code>的通用机制。 <code>Property</code> 行为从未得到实施，但是这个想法在2019年以所谓的 Property 代表提案的形式返回。如果实现，则可以将当前的原始语言功能（如属性观察器和惰性属性）从编译器移至标准库（或第三方库），从而使编译器的复杂性降低，并允许所有开发人员添加自己的属性实现模式。 <code>Property</code> 代表提案未通过其最初的Swift Evolution审查，但我们可能会在以后的Swift版本中看到此功能或类似功能。</p><h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a><strong>下标</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经在标准库中看到了下标。 例如，我们可以像这样执行字典查找：<code>dictionary [key]</code>。 这些下标在很大程度上是函数和计算属性的混合体，具有自己的特殊语法。 像函数一样，它们也接受参数。 像计算的属性一样，它们可以是只读的（使用get）或读写的（使用get set）。 就像普通函数一样，我们可以通过提供具有不同类型的多个变体（属性无法实现）来重载它们。 例如，数组默认具有两个下标-一个用于访问单个元素，另一个用于获取切片（准确地说，这些是在<code>Collection协议</code>中声明的）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibs = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>] </span><br><span class="line"><span class="keyword">let</span> first = fibs[<span class="number">0</span>] <span class="comment">// 0 </span></span><br><span class="line">fibs[<span class="number">1</span>..&lt;<span class="number">3</span>] <span class="comment">// [1, 1]</span></span><br></pre></td></tr></table></figure><h2 id="自定义下标"><a href="#自定义下标" class="headerlink" title="自定义下标"></a><strong><em>自定义下标</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以为自己的类型添加下标支持，也可以使用新的下标重载来扩展现有类型。 举例来说，让我们定义一个<code>Collection</code>下标，该下标接受一个索引列表并返回这些索引处所有元素的数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="built_in">indices</span> indexList: <span class="type">Index</span>...) -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> result: [<span class="type">Element</span>] = [] </span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> indexList &#123;</span><br><span class="line">            result.append(<span class="keyword">self</span>[index]) </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，我们如何使用显式参数标签将下标与标准库中的下标区分开。 三个点表示<code>indexList</code>是可变参数。 调用方可以传递零个或多个指定类型（此处是集合的索引类型）的逗号分隔值。 在函数内部，参数可以作为数组使用。</p><p>我们可以这样使用新的下标：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="string">"abcdefghijklmnopqrstuvwxyz"</span>)[<span class="built_in">indices</span>: <span class="number">7</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">14</span>] <span class="comment">// ["h", "e", "l", "l", "o"]</span></span><br></pre></td></tr></table></figure><h2 id="高级下标"><a href="#高级下标" class="headerlink" title="高级下标"></a><strong><em>高级下标</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下标不限于单个参数。 我们已经看到了一个带多个参数的下标示例：带键和默认值的字典下标。 如果你有兴趣，请在Swift源代码中查看其实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下标的参数或返回类型也可以是通用的。 考虑类型为[String：Any]的异构字典：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> japan: [<span class="type">String</span>: <span class="type">Any</span>] = [ </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Japan"</span>, </span><br><span class="line">    <span class="string">"capital"</span>: <span class="string">"Tokyo"</span>,</span><br><span class="line">    <span class="string">"population"</span>: <span class="number">126_440_000</span>, </span><br><span class="line">    <span class="string">"coordinates"</span>: [</span><br><span class="line">        <span class="string">"latitude"</span>: <span class="number">35.0</span>,</span><br><span class="line">        <span class="string">"longitude"</span>: <span class="number">139.0</span></span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想在此字典中更改嵌套值，例如 坐标的纬度，你会发现这并不容易：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error: Type 'Any' has no subscript members.</span></span><br><span class="line">japan[<span class="string">"coordinates"</span>]?[<span class="string">"latitude"</span>] = <span class="number">36.0</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，这是可以理解的。 表达式<code>japan [“coordinate”]</code>的类型为 <code>Any?</code> ，因此<br>你可能会在应用嵌套下标之前尝试将其转换为字典：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error: Cannot assign to immutable expression.</span></span><br><span class="line">(japan[<span class="string">"coordinates"</span>] <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Double</span>])?[<span class="string">"latitude"</span>] = <span class="number">36.0</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这不仅变得很难看，而且也行不通。 问题是你无法通过类型转换（表达式）来对变量进行突变<code>Japan [“coordinates”] as? [String：Double]</code> 不再是左值。 你必须先将嵌套字典存储在本地变量中，然后对该变量进行突变，然后将本地变量分配回顶级关键字。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过使用通用下标扩展<code>Dictionary</code>来做得更好，该通用下标将所需的目标类型作为第二个参数并尝试在下标实现中进行强制转换：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>&lt;<span class="type">Result</span>&gt;(key: <span class="type">Key</span>, <span class="keyword">as</span> type: <span class="type">Result</span>.<span class="type">Type</span>) -&gt; <span class="type">Result?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>[key] <span class="keyword">as</span>? <span class="type">Result</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// Delete existing value if caller passed nil.</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> value = newValue <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">self</span>[key] = <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Ignore if types don't match.</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> value2 = value <span class="keyword">as</span>? <span class="type">Value</span> <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>[key] = value2 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于我们不再需要向下转换下标返回的值，因此突变操作将转到顶级字典变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">japan[<span class="string">"coordinates"</span>, <span class="keyword">as</span>: [<span class="type">String</span>: <span class="type">Double</span>].<span class="keyword">self</span>]?[<span class="string">"latitude"</span>] = <span class="number">36.0</span> </span><br><span class="line">japan[<span class="string">"coordinates"</span>] <span class="comment">// Optional(["longitude": 139.0, "latitude": 36.0])</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通用下标使这成为可能，但你会注意到此示例中的最终语法仍然很丑陋。 Swift通常不太适合处理像该字典这样的异构集合。 在大多数情况下，最好为数据定义自己的自定义类型（例如，此处为“国家/地区”结构），并将这些类型与<code>Codable兼容</code>，以将值与数据传输格式进行相互转换。</p><h1 id="Key-Paths"><a href="#Key-Paths" class="headerlink" title="Key Paths"></a><strong>Key Paths</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift 4</code>在语言中增加了<strong>关键路径</strong>的概念。key路径是对属性的未调用引用，类似于未应用的方法引用。关键路径在<code>Swift</code>的类型系统中填补了一个相当大的漏洞；以前，无法以引用方法（例如<code>String.uppercased</code>）的方式引用类型的属性（例如<code>String.count</code>）。尽管使用了相同的名称，但是<code>Swift</code>的键路径与<code>Objective-C</code>和<code>Foundation</code>中使用的键路径有很大不同。稍后我们将有更多话要说。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;键路径表达式以反斜杠开头，例如 <code>\String.count</code>。必须使用<strong>反斜杠来区分键路径和可能存在的同名类型属性</strong>（假设<code>String</code>也具有静态<code>count属性</code>，那么<code>String.count</code>将返回该属性的值）。<code>类型推断</code>也可以在键路径表达式中使用：如果编译器可以从上下文中推断类型名称，则可以省略类型名称，这会导致 <code>\.count</code>。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鉴于键路径和函数类型引用是如此紧密地相关，因此不幸的是，<code>Swift</code>的语法不同。即使这样，Swift团队也表示有兴趣在将来的版本中为函数类型引用采用反斜杠语法。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顾名思义，<strong>键路径描述了从根值开始的贯穿值层次结构的路径</strong>。例如，给定以下“人员”和“地址”类型，<code>\Person.address.street</code>是解析人员街道地址的关键路径：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Address</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> street: <span class="type">String</span> </span><br><span class="line">    <span class="keyword">var</span> city: <span class="type">String</span> </span><br><span class="line">    <span class="keyword">var</span> zipCode: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">Address</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> streetKeyPath = \<span class="type">Person</span>.address.street</span><br><span class="line"><span class="comment">// Swift.WritableKeyPath&lt;Person, Swift.String&gt;</span></span><br><span class="line"><span class="keyword">let</span> nameKeyPath = \<span class="type">Person</span>.name <span class="comment">// Swift.KeyPath&lt;Person, Swift.String&gt;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>key路径可以由存储和计算的属性的任意组合以及可选的链接运算符组成</strong>。 编译器会自动为所有类型生成一个新的<code>[keyPath：]</code>下标。 你可以使用此下标“调用”key路径，即在给定实例上访问其描述的属性。 因此，<code>“Hello”[keyPath: \.count]</code>等效于 <code>“Hello” .count</code> 。 或者，对于我们当前的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simpsonResidence = <span class="type">Address</span>(street: <span class="string">"1094 Evergreen Terrace"</span>, city: <span class="string">"Springfield"</span>, zipCode: <span class="number">97475</span>)</span><br><span class="line"><span class="keyword">var</span> lisa = <span class="type">Person</span>(name: <span class="string">"Lisa Simpson"</span>, address: simpsonResidence) </span><br><span class="line">lisa[keyPath: nameKeyPath] <span class="comment">// Lisa Simpson</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你看一下上面两个键路径变量的类型，你会注意到 <code>nameKeyPath</code> 的类型为 <code>KeyPath &lt;Person，String&gt;</code>（即可以应用于Person并产生String的强类型键路径） ，而streetKeyPath的类型为WritableKeyPath。 因为形成后一个键路径的所有属性都是可变的，所以键路径本身允许基础值的改变：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lisa[keyPath: streetKeyPath] = <span class="string">"742 Evergreen Terrace"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对nameKeyPath进行相同操作会产生错误，因为底层property是不可变的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关键路径不仅可以描述属性，我们也可以使用它们来描述下标。 例如，以下语法可用于提取数组中第二个人值的名称：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bart = <span class="type">Person</span>(name: <span class="string">"Bart Simpson"</span>, address: simpsonResidence) </span><br><span class="line"><span class="keyword">let</span> people = [lisa, bart]</span><br><span class="line">people[keyPath: \.[<span class="number">1</span>].name] <span class="comment">// Bart Simpson</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相同的语法也可以用于在关键路径中包括字典下标。</p><h2 id="关键路径可以用函数建模"><a href="#关键路径可以用函数建模" class="headerlink" title="关键路径可以用函数建模"></a><strong><em>关键路径可以用函数建模</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从基本类型<code>Root</code>映射到<code>Value类型</code>的属性的密钥路径与类型<code>（Root）-&gt; Value</code>的函数非常相似，或者对于可写密钥路径，有一对用于获取和设置值的函数。 相对于此类功能（语法除外）的主要好处是，它们是值。 你可以测试键路径是否相等并将它们用作字典键（它们符合<code>Hashable</code>），并且可以确保键路径是无状态的，这与可能捕获可变状态的函数不同。 正常功能无法实现所有这些功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过将一个key路径附加到另一个key路径，也可以构成key路径。 请注意，类型必须匹配：如果你以从A到B的键路径开头，则附加的键路径必须具有B的根类型，然后生成的键路径将从A映射到附加键路径的值类型， 说C：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KeyPath&lt;Person, String&gt; + KeyPath&lt;String, Int&gt; = KeyPath&lt;Person, Int&gt;</span></span><br><span class="line"><span class="keyword">let</span> nameCountKeyPath = nameKeyPath.appending(path: \.<span class="built_in">count</span>) </span><br><span class="line"><span class="comment">// Swift.KeyPath&lt;Person, Swift.Int&gt;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们重新编写本章前面的排序描述符，以使用键路径代替函数。 我们之前将<code>sortDescriptor</code>定义为采用函数，（根）-&gt;值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">SortDescriptor</span>&lt;<span class="type">Root</span>&gt; = (<span class="type">Root</span>, <span class="type">Root</span>) -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortDescriptor</span>&lt;Root, Value&gt;<span class="params">(key: @escaping <span class="params">(Root)</span></span></span> -&gt; <span class="type">Value</span>)</span><br><span class="line">-&gt; <span class="type">SortDescriptor</span>&lt;<span class="type">Root</span>&gt; <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; key($<span class="number">0</span>) &lt; key($<span class="number">1</span>) &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">let</span> streetSD: <span class="type">SortDescriptor</span>&lt;<span class="type">Person</span>&gt; = sortDescriptor &#123; $<span class="number">0</span>.address.street &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以添加一个变体，用于从键路径构造排序描述符。 我们使用下标以获取值的关键路径：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortDescriptor</span>&lt;Root, Value&gt;<span class="params">(key: KeyPath&lt;Root, Value&gt;)</span></span> -&gt; <span class="type">SortDescriptor</span>&lt;<span class="type">Root</span>&gt; <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; $<span class="number">0</span>[keyPath: key] &lt; $<span class="number">1</span>[keyPath: key] &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">let</span> streetSDKeyPath: <span class="type">SortDescriptor</span>&lt;<span class="type">Person</span>&gt; = sortDescriptor(key: \.address.street)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然有一个采用关键路径的<code>sortDescriptor构造函数</code>很有用，但它并没有为我们提供灵活性功能。 关键路径依赖于可比值。 仅使用关键路径，我们就无法轻松地按不同的谓词进行排序（例如，执行不区分大小写的本地化比较）。</p><h2 id="可写关键路径"><a href="#可写关键路径" class="headerlink" title="可写关键路径"></a><strong><em>可写关键路径</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可写关键路径是特殊的。 你可以使用它来读取或写入值。 因此，它等效于一对函数：一个用于获取属性<code>((Root) -&gt; Value)</code>，另一个用于设置属性 <code>((inout Root，Value) -&gt; Void)</code> 。 可写关键路径比只读关键路径要大得多。 首先，它们以简洁的语法捕获了大量代码。 将<code>streetKeyPath</code>与等效的<code>getter</code>和<code>setter</code>对进行比较：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> streetKeyPath = \<span class="type">Person</span>.address.street</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getStreet: (<span class="type">Person</span>) -&gt; <span class="type">String</span> = &#123; person <span class="keyword">in</span> </span><br><span class="line">    <span class="keyword">return</span> person.address.street</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setStreet: (<span class="keyword">inout</span> <span class="type">Person</span>, <span class="type">String</span>) -&gt; () = &#123; person, newValue <span class="keyword">in</span></span><br><span class="line">    person.address.street = newValue </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setter usage</span></span><br><span class="line">lisa[keyPath: streetKeyPath] = <span class="string">"1234 Evergreen Terrace"</span> </span><br><span class="line">setStreet(&amp;lisa, <span class="string">"1234 Evergreen Terrace"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可写键路径对于数据绑定特别有用，在数据绑定中，你想将两个属性彼此绑定：当属性一更改时，属性二应自动更新，反之亦然。例如，你可以将<code>model.name</code>属性绑定到<code>textField.text</code>。 <code>API</code>的用户需要指定如何读取和写入<code>model.name</code>和<code>textField.text</code>，而关键路径仅用于捕获和写入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还需要一种观察属性变化的方法。为此，我们在<code>Cocoa</code>中使用键值观察机制，这意味着该示例仅适用于类，并且仅适用于<code>Apple平台</code>。 <code>Foundation</code>提供了一种类型安全的<code>KVO API</code>，该<code>API</code>隐藏了<code>Objective-C键路径</code>的字符串类型世界。 <code>NSObject</code>方法<code>observe（_：options：changeHandler :)</code>观察键路径（作为强类型<code>Swift键路径</code>传递），并在属性更改时调用更改处理程序。<strong>不要忘记将你要观察的任何属性标记为<code>@objc动态</code></strong>。否则，KVO将无法正常工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的目标是在两个<code>NSObject之间实现双向绑定</code>，但让我们从单向绑定开始：每当观察到的<code>self</code>属性发生变化时，我们也会更改另一个对象。关键路径使我们可以使代码在所涉及的特定属性上通用—调用者指定了两个对象和两个关键路径，此方法将处理其余的工作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObjectProtocol</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">NSObject</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">observe</span>&lt;A, Other&gt;<span class="params">(<span class="number">_</span> keyPath: KeyPath&lt;<span class="keyword">Self</span>, A&gt;, writeTo other: Other, <span class="number">_</span> otherKeyPath: ReferenceWritableKeyPath&lt;Other, A&gt;)</span></span> -&gt; <span class="type">NSKeyValueObservation</span> <span class="keyword">where</span> <span class="type">A</span>: <span class="type">Equatable</span>, <span class="type">Other</span>: <span class="type">NSObjectProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> observe(keyPath, options: .new) &#123; <span class="number">_</span>, change <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> newValue = change.newValue, other[keyPath: otherKeyPath] != newValue <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// prevent endless feedback loop &#125;</span></span><br><span class="line">            other[keyPath: otherKeyPath] = newValue</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此代码段中有很多要解压的内容。 首先，我们在<code>NSObject</code>的每个子类上定义此方法，然后通过扩展<code>NSObjectProtocol</code>（而不是NSObject）来使用<code>Self</code>。 <code>ReferenceWritableKeyPath</code>就像<code>WritableKeyPath</code>一样，但是它也允许我们编写使用<code>let声明</code>的引用变量（与其他变量一样）。 （我们稍后将对此进行详细说明。）为避免不必要的写入，我们仅在值更改后才写入其他值。 <code>NSKeyValueObservation</code>返回值是调用者可以用来控制观察的生存期的令牌：当释放该对象或调用者调用其<code>invalidate</code>方法时，观察停止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定<code>observe（_：writeTo：__ :)</code>，双向绑定非常简单； 我们在两个对象上都调用<code>observe</code>，并返回两个观察标记：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObjectProtocol</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bind</span>&lt;A, Other&gt;<span class="params">(<span class="number">_</span> keyPath: ReferenceWritableKeyPath&lt;<span class="keyword">Self</span>,A&gt;, to other: Other, <span class="number">_</span> otherKeyPath: ReferenceWritableKeyPath&lt;Other,A&gt;)</span></span> -&gt;  (<span class="type">NSKeyValueObservation</span>, <span class="type">NSKeyValueObservation</span>) <span class="keyword">where</span> <span class="type">A</span>: <span class="type">Equatable</span>, <span class="type">Other</span>: <span class="type">NSObject</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> one = observe(keyPath, writeTo: other, otherKeyPath)</span><br><span class="line">        <span class="keyword">let</span> two = other.observe(otherKeyPath, writeTo: <span class="keyword">self</span>, keyPath) <span class="keyword">return</span> (one,two)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以构造两个不同的对象-Person和TextField，并将name和text属性彼此绑定：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextField</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> text: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">let</span> textField = <span class="type">TextField</span>()</span><br><span class="line"><span class="keyword">let</span> observation = person.bind(\.name, to: textField, \.text) person.name = <span class="string">"John"</span></span><br><span class="line">textField.text <span class="comment">// John</span></span><br><span class="line">textField.text = <span class="string">"Sarah"</span></span><br><span class="line">person.name <span class="comment">// Sarah</span></span><br></pre></td></tr></table></figure><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你来自函数式编程，那么可写的键路径可能会让你想起镜头。 它们紧密相关：从<code>WritableKeypath &lt;Root，Value&gt;</code>，你可以创建<code>Lens &lt;Root，Value&gt;</code>。 镜头在纯函数式语言（例如Haskell或PureScript）中很有用，但在Swift中却没有那么有用，因为Swift内置了可变性。</p></blockquote><h2 id="关键路径层次结构"><a href="#关键路径层次结构" class="headerlink" title="关键路径层次结构"></a><strong><em>关键路径层次结构</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;密钥路径有五种不同的类型，每种都为前一种增加了更多的精度和功能：</p><ul><li>→ <strong>AnyKeyPath</strong> 类似于功能类型<code>（Any）-&gt; Any?</code>。</li><li>→ <strong>PartialKeyPath<Source></strong> 类似于<code>typeoffunction（Source）-&gt; Any?</code>。</li><li>→ <strong>KeyPath&lt;Source，Target&gt;</strong> 与 <code>typeoffunction（Source）-&gt; Target</code>相似。</li><li>→ <strong>WritableKeyPath&lt;Source，Target&gt;</strong> 与一对功能类型类似<code>（Source）-&gt;Target</code>和<code>(Source，Target) -&gt; ()</code>。</li><li>→ <strong>ReferenceWritableKeyPath&lt;Source，Target&gt;</strong> 与类型为 <code>(Source) -&gt;Target</code>和 <code>(Source，Target) -&gt; ()</code> 的一对函数相似。第二个函数可以用<code>Target</code>更新<code>Source</code>值，并且仅在<code>Source</code>是引用类型时才起作用。必须区分<code>WritableKeyPath</code>和<code>\ReferenceWritableKeyPath</code>，因为前者的设置者必须将参数<code>inout传入</code>。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前，此关键路径层次结构被实现为类层次结构。理想情况下，这些将是<code>协议</code>，但是Swift的泛型系统缺少一些使之可行的功能。故意将类层次结构保持关闭状态，以便在将来的发行版中对此进行更改而不会破坏现有代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们之前所看到的，关键路径与函数不同：<strong>它们遵循Hashable</strong>，将来也可能遵循<code>Codable</code>。这就是为什么我们说<code>AnyKeyPath</code>类似于函数<code>（Any）-&gt; Any</code>。虽然我们可以将键路径转换为其相应的功能，但我们并不总是朝着另一个方向发展。</p><h2 id="与Objective-C相比的关键路径"><a href="#与Objective-C相比的关键路径" class="headerlink" title="与Objective-C相比的关键路径"></a><strong><em>与Objective-C相比的关键路径</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Foundation</code>和<code>Objective-C</code>中，关键路径被建模为字符串（我们称这些<code>Foundation</code>关键路径是为了将它们与Swift的关键路径区分开）。由于<code>Foundation键路径是字符串</code>，因此它们没有附加任何类型信息。从某种意义上讲，它们类似于<code>AnyKeyPath</code>。如果基础密钥路径拼写错误，格式不正确，或者类型不匹配，则程序可能会崩溃。 （Swift中的#keyPath指令有助于解决拼写错误；编译器可以检查是否存在具有指定名称的属性。）Swift的<code>KeyPath</code>，<code>WritableKeypath</code>和<code>ReferenceWritableKeyPath</code>在构造上是正确的：它们不能被拼写错误并且它们不会允许输入类型错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当功能可能更好时，许多<code>Cocoa API</code>使用（基础）键路径。这在某种程度上是一个历史产物：<code>匿名函数</code>（或块，正如<code>Objective-C</code>所称的）是一个相对较新的功能，而关键路径的存在时间更长。在将块添加到<code>Objective-C</code>之前，要表示类似于功能<code>{$ 0.address.street}</code>的东西并不容易，只是使用关键路径<code>“address.street”</code>。</p><h2 id="未来发展方向"><a href="#未来发展方向" class="headerlink" title="未来发展方向"></a><strong><em>未来发展方向</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关键路径仍在积极讨论中，未来它们可能会变得更加强大。 一种可能的功能是通过可编码协议进行序列化。 这将使我们能够将关键路径保留在磁盘上，通过网络发送它们，等等。 一旦我们可以访问关键路径的结构，就可以进行自省。 例如，我们可以使用键路径的结构来构造类型正确的数据库查询。 如果类型可以自动提供指向其属性的键路径数组，则可以用作<code>运行时反射API</code>的基础。</p><h1 id="Autoclosures"><a href="#Autoclosures" class="headerlink" title="Autoclosures"></a><strong>Autoclosures</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都熟悉逻辑<code>AND运算符&amp;&amp;</code>如何评估其参数。 它首先评估其左操作数，如果评估结果为<code>false</code>，则立即返回。 仅当左侧操作数的值为<code>true</code>时，才对右侧操作数的值进行评估。 毕竟，如果左操作数的计算结果为false，则整个表达式都无法计算为true。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此行为称为<code>短路</code>。 例如，如果我们要检查条件是否满足数组的第一个元素，则可以编写以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> evens = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">if</span> !evens.isEmpty &amp;&amp; evens[<span class="number">0</span>] &gt; <span class="number">10</span> &#123;</span><br><span class="line"><span class="comment">// Perform some work.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的代码段中，我们依赖于短路：只有在第一个条件成立的情况下才会进行数组查找。 如果没有短路，此代码将在空数组上崩溃。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编写此特定示例的更好方法是使用if let绑定：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> first = evens.first, first &gt; <span class="number">10</span> &#123; </span><br><span class="line">    <span class="comment">// Perform some work.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是短路的另一种形式：仅当第一个条件成功时才评估第二个条件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在几乎所有语言中，<code>&amp;&amp;</code> 和 <code>||</code> 都会短路 语言中内置了运算符。 但是，通常无法定义自己的具有相同行为的运算符或函数。 如果语言支持一流的功能，我们可以通过提供匿名功能而不是值来伪造短路。 例如，假设我们要在Swift中定义一个 <code>and函数</code> ，使其具有与<code>&amp;&amp;运算符</code>相同的行为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">and</span><span class="params">(<span class="number">_</span> l: Bool, <span class="number">_</span> r: <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123; </span><br><span class="line">    <span class="keyword">guard</span> l <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> r()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的函数首先检查l的值，如果l的值为false，则返回false。 仅当l为true时，它才返回闭包r中的值。 但是，使用它比使用<code>&amp;&amp;运算符</code>稍微麻烦一些，因为正确的操作数现在必须是一个函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> and(!evens.isEmpty, &#123; evens[<span class="number">0</span>] &gt; <span class="number">10</span> &#125;) &#123; </span><br><span class="line">    <span class="comment">// Perform some work.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swift具有一个很好的功能，可以使其更漂亮。 我们可以使用<code>@autoclosure属性</code>来告诉编译器它应该在闭包表达式中包装一个特定的参数。 和的定义与上面几乎相同，除了添加的<code>@autoclosure</code>批注：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">and</span><span class="params">(<span class="number">_</span> l: Bool, <span class="number">_</span> r: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123; </span><br><span class="line">    <span class="keyword">guard</span> l <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> r()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，and的用法现在要简单得多，因为我们不需要将第二个参数包装在闭包中。 我们可以像调用常规Bool参数一样调用它，并且编译器透明地将参数包装在闭包表达式中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> and(!evens.isEmpty, evens[<span class="number">0</span>] &gt; <span class="number">10</span>) &#123;</span><br><span class="line">     <span class="comment">// Perform some work.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这使我们能够定义自己的具有短路行为的函数和运算符。 例如，像<code>??</code>这样的运算符 和<code>！？</code> （如“可选”一章中定义的）现在很容易编写。 在标准库中，<code>assert</code>和<code>fatalError</code>之类的函数也使用自动关闭功能，以便仅在真正需要时才评估参数。 通过将断言条件的评估从调用位置推迟到断言函数的主体，可以将这些潜在的昂贵操作完全剥离到不需要它们的优化构建中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编写日志记录功能时，自动关闭也可以派上用场。 例如，下面是你编写自己的日志函数的方法，该函数仅在条件为<code>true</code>时才评估日志消息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(ifFalse condition: Bool, message: @autoclosure <span class="params">()</span></span></span> -&gt; (<span class="type">String</span>),</span><br><span class="line">file: <span class="type">String</span> = #file, function: <span class="type">String</span> = #function, line: <span class="type">Int</span> = #line) &#123;</span><br><span class="line">    <span class="keyword">guard</span> !condition <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Assertion failed: \(message()), \(file):\(function) (line \(line))"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这意味着你可以在作为消息参数传递的表达式中执行昂贵的计算，如果不使用该值，则不会产生评估成本。 日志功能还使用调试标识符<code>＃file</code>，<code>＃function</code>和 <code>#line</code>。 他们是当作为默认参数传递给函数时特别有用，因为它们将在调用站点上<code>接收文件名，函数名和行号的值</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，请谨慎使用自动关闭功能。 他们的行为违反了正常的预期-例如，如果由于表达式包含在自动闭合中而没有执行表达式的副作用。 引用Apple的Swift书：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过度使用自动关闭功能会使你的代码难以理解。 上下文和函数名称应清楚表明评估被推迟。</p></blockquote><h1 id="escaping-批注"><a href="#escaping-批注" class="headerlink" title="@escaping 批注"></a><strong>@escaping 批注</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能已经注意到，编译器要求你在某些闭包表达式中（而不是在其他闭包表达式中）明确声明要访问self。例如，我们需要在网络请求的完成处理程序中使用显式的<code>self</code>，而不必在传递给 <code>map或filter</code> 的闭包中对<code>self</code>进行显式的显示。两者之间的区别在于，闭包是存储供以后使用（如网络请求），还是仅在函数范围内同步使用（如<code>map和filter</code>）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果将闭包存储在某个地方（例如存储在某个属性中）以供以后调用，则称该<code>闭包正在转义</code>。相反，从<strong>不离开函数本地范围的闭包是不可转义的</strong>。使用转义，编译器迫使我们明确地在闭包表达式中使用<code>self</code>，因为无意间强力捕获self是引用周期最常见的原因之一。无法转义的闭包无法创建永久的引用循环，因为在返回定义的函数时，该循环会自动销毁。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，<strong>闭包参数是不转义的</strong>。如果要存储闭包以供以后使用，则需要将闭包参数标记为 <strong><em><code>@escaping</code></em></strong>。编译器将对此进行验证：除非你将闭包参数标记为<code>@escaping</code>，否则它<strong>将不允许你存储闭包</strong>（例如，将其返回给调用者）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在排序描述符示例中，有多个函数参数需要 <strong>@escaping属性</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortDescriptor</span>&lt;Root, Value&gt;<span class="params">( key: @escaping <span class="params">(Root)</span></span></span> -&gt; <span class="type">Value</span>, by areInIncreasingOrder: @escaping (<span class="type">Value</span>, <span class="type">Value</span>) -&gt; <span class="type">Bool</span>) -&gt; <span class="type">SortDescriptor</span>&lt;<span class="type">Root</span>&gt; &#123;</span><br><span class="line">    <span class="type">Overusing</span> autoclosures can make your code hard to understand. <span class="type">The</span> context and function name should make it clear that evaluation <span class="keyword">is</span> being deferred.</span><br><span class="line">    <span class="keyword">return</span> &#123; areInIncreasingOrder(key($<span class="number">0</span>), key($<span class="number">1</span>)) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Swift 3之前，是另一回事：转义是默认设置，你可以选择将结束标记为<code>@noescape</code>。 当前行为更好，因为默认情况下它是安全的：现在需要一个函数参数明确注释以表示参考循环的潜力。 <code>@escaping</code>注释是对开发人员调用该函数的警告。 编译器还可以更好地优化非转义的闭包，使快速路径成为必要时必须明确偏离的规范。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>请注意，默认情况下的非转义规则仅适用于功能参数</strong>，然后<strong>仅适用于紧邻参数位置的功能类型</strong>。 这意味着具<strong>有函数类型的存储属性始终在转义</strong>（这很有意义）。 令人惊讶的是，对于用作参数但包装在其他类型（例如元组或可选）中的函数也是如此。 由于在这种情况下闭包不再是立即参数，因此它会<strong>自动转义</strong>。 因此，你无法编写带有函数参数的函数，其中参数既是可选参数也是非转义参数。 在许多情况下，可以通过为闭包提供默认值来避免使参数成为可选参数。 如果不可能，一种解决方法是使用重载来编写该函数的两个变体-一个带有可选的（转义）函数参数，而另一个带有非可选的，非转义参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(<span class="number">_</span> input: Int, with f: <span class="params">(<span class="params">(Int)</span></span></span></span> -&gt; <span class="type">Int</span>)?) -&gt; <span class="type">Int</span> &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Using optional overload"</span>)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> f = f <span class="keyword">else</span> &#123; <span class="keyword">return</span> input &#125;</span><br><span class="line">    <span class="keyword">return</span> f(input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(<span class="number">_</span> input: Int, with f: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Using non-optional overload"</span>)</span><br><span class="line">    <span class="keyword">return</span> f(input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，用<code>nil参数</code>（或可选类型的变量）调用函数将使用可选变量，而传递文字闭包表达式将调用非转义，非可选重载：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform(<span class="number">10</span>, with: <span class="literal">nil</span>) <span class="comment">// Using optional overload</span></span><br><span class="line">transform(<span class="number">10</span>) &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125; <span class="comment">// Using non-optional overload</span></span><br></pre></td></tr></table></figure><h2 id="withoutActuallyEscaping"><a href="#withoutActuallyEscaping" class="headerlink" title="withoutActuallyEscaping"></a><strong><em>withoutActuallyEscaping</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会遇到这样的情况，你知道闭包无法逃脱，但编译器无法证明它，从而迫使你添加<code>@escaping</code>批注。 为了说明这一点，让我们看一下标准库文档中的示例。 我们在<code>Array</code>上编写了<code>allSatisfy方法</code>的自定义实现，该方法在内部使用数组的惰性视图（不要与上面讨论的惰性属性混淆）。 然后，我们将过滤器应用于惰性视图，并检查是否有任何元素通过过滤器（即，至少有一个元素不满足谓词）。 我们的第一次尝试导致编译错误：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">allSatisfy2</span><span class="params">(<span class="number">_</span> predicate: <span class="params">(Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">// Error: Closure use of non-escaping parameter 'predicate' // may allow it to escape.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.<span class="built_in">lazy</span>.<span class="built_in">filter</span>(&#123; !predicate($<span class="number">0</span>) &#125;).isEmpty</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将在<code>“Collection协议”</code>一章中详细介绍<code>延迟CollectionAPI</code>。 到目前为止，只要知道惰性视图就可以将后续转换（例如传递给filter的闭包）存储在内部属性中，以便以后应用。 这要求传入的任何闭包都必须转义，这是导致错误的原因，因为我们的谓词参数是不转义的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过用<code>@escaping注释参数</code>来解决此问题，但是在这种情况下，我们知道闭包不会逃脱，因为惰性集合视图的生命周期与函数的生命周期绑定在一起。 <code>Swift</code>为这种情况提供了逃生舱口，其形式为<code>noActuallyEscaping</code>函数。 它允许你将非转义的闭包传递给期望转义的函数。 这样可以编译并正常工作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">allSatisfy2</span><span class="params">(<span class="number">_</span> predicate: <span class="params">(Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> withoutActuallyEscaping(predicate) &#123; escapablePredicate <span class="keyword">in</span>  </span><br><span class="line">            <span class="keyword">self</span>.<span class="built_in">lazy</span>.<span class="built_in">filter</span> &#123; !escapablePredicate($<span class="number">0</span>) &#125;.isEmpty</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> areAllEven = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].allSatisfy2 &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125; <span class="comment">// false </span></span><br><span class="line"><span class="keyword">let</span> areAllOneDigit = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].allSatisfy2 &#123; $<span class="number">0</span> &lt; <span class="number">10</span> &#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，懒惰的实现并没有比<code>allSatisfy</code>的标准库的实现效率更高，后者使用简单的for循环，并且不需要<code>ActuallyEscaping</code>就不需要。 懒惰的实现仅用于演示以下情况：我们知道闭包不会逃逸，但编译器无法证明这一点。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，你使用的是不使用“实际转义”功能进入不安全区域。 允许闭包的副本从调用中转义到<code>withoutActuallyEscaping</code>会导致未定义的行为。</p><h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a><strong>概括</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数是<code>Swift</code>中的一流对象。 将函数视为数据可以使我们的代码更灵活。 我们已经看到了如何用简单的函数代替运行时编程。 我们比较了实现委托的不同方法。 我们已经研究了变异函数和inout参数，以及计算属性（实际上是一种特殊的函数）。 最后，我们讨论了<code>@autoclosure</code>和<code>@escaping属性</code>。 在有关 <strong><em><code>泛型和协议</code></em></strong> 的章节中，我们将提出更多在Swift中使用函数的方式，以获得更大的灵活性。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Advanced Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Advanced Swift </tag>
            
            <tag> Swift 5.0 </tag>
            
            <tag> Functions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Swift系列(三):  Optionals</title>
      <link href="/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%89):%20%20Optionals/"/>
      <url>/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%89):%20%20Optionals/</url>
      
        <content type="html"><![CDATA[<h1 id="Sentinel-Values"><a href="#Sentinel-Values" class="headerlink" title="Sentinel Values"></a><strong>Sentinel Values</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编程中一种非常常见的模式是具有可能会或可能不会返回值的操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你到达正在读取的文件末尾时，可能不返回值是预期的结果，如以下C代码片段所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="type">EOF</span>) &#123;</span><br><span class="line">printf(<span class="string">"Read character %c\n"</span>, ch); &#125;</span><br><span class="line">printf(<span class="string">"Reached end-of-file\n"</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>EOF</code> 只是 <code>-1</code> 的 <code>#define</code> 。 只要文件中有更多字符， <code>getchar</code> 返回它们。 但是，如果到达文件末尾，则 <code>getchar</code> 返回 <code>-1</code> 。 或者也许不返回任何值表示 <code>“未找到”</code> ，如下面的 <code>C++</code> 所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iterator = <span class="built_in">std</span>::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), someValue); </span><br><span class="line"><span class="keyword">if</span> (iterator != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vec contains "</span> &lt;&lt; *iterator &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，<code>vec.end()</code> 是容器 <code>“末尾一个”</code> 的迭代器； 这是一个特殊的迭代器，你可以检查容器的末端，但绝对不要用它来访问值-类似于 <code>Swift中</code> 集合的 <code>endIndex</code> 。 函数使用它来指示容器中不存在这样的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者可能由于函数处理过程中出现问题而无法返回该值。 可能最臭名昭著的例子是空指针的例子。 这个看起来不错的 <code>Java代码</code> 很可能会抛出 <code>NullPointerException</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = <span class="type">Integer</span>.getInteger(<span class="string">"123"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;碰巧 <code>Integer.getInteger</code> 不会将字符串解析为整数，而是获取名为 <code>“123”</code> 的系统属性的整数值。 此属性可能不存在，在这种情况下， <code>getInteger</code> 返回 <code>null</code> 。 然后，将 <code>null</code> 拆箱为 <code>int</code> 时， <code>Java</code> 会引发异常。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或在 <code>Objective-C</code> 中使用以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="type">NSString</span> alloc] initWithContentsOfURL:url encoding:<span class="type">NSUTF8StringEncoding</span> error:&amp;error];</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该初始化程序可能返回 nil ，在这种情况下（只有在这种情况下），才应该检查 错误指针 。如果初始化程序返回非 nil ，则不能保证错误指针有效。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以上所有示例中，该函数均返回一个特殊的 “魔术”值 ，以表示该函数尚未返回实际值。这样的魔术值称为 “前哨值” 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这种方法是有问题的。返回的结果看起来和感觉像是真正的价值。 <code>int -1</code> 仍然是有效的整数，但是你永远都不想将其打印出来。 <code>vec.end（）</code>是一个迭代器，但是如果你尝试使用它，结果是不确定的。每个人都喜欢在Java程序引发 <code>NullPointerException</code> 时看到 <code>堆栈转储</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <code>Java</code> 不同，<code>Objective-C</code> 允许将消息发送为 <code>nil</code> 。只要运行时保证从消息到 <code>nil</code> 的返回值始终等于零，即对象返回类型为 <code>nil</code> ，数字类型为0，依此类推，这是 <code>“安全的”</code> 。如果邮件返回一个结构，则会将其所有成员初始化为零。考虑到这一点，请考虑以下片段以查找子字符串：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSString</span> *someString = ...</span><br><span class="line"><span class="keyword">if</span> ([someString rangeOfString:@<span class="string">"Swift"</span>].location != <span class="type">NSNotFound</span>) &#123;</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">"Someone mentioned Swift!"</span>); &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>someString</code> 为 <code>nil</code> （无论是偶然还是有意）， <code>rangeOfString：</code> 消息将返回零的 <code>NSRange</code> 。 因此，其 <code>.location</code> 将为零，并且与 <code>NSNotFound</code> （定义为 <code>NSIntegerMax</code> ）的不等式比较将成功。 因此， <code>if语句</code> 的正文将在不应该执行的情况下执行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>空引用</code> 引起了很多问题，以托尼·霍亚尔（Tony Hoare）（于1965年创建）为荣，称它们为“十亿美元的错误”：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当时，我正在设计第一个全面的类型系统，以面向对象的语言（ALGOL W）进行引用。 我的目标是确保对引用的所有使用都绝对安全，并进行检查由编译器自动执行。 但是我忍不住要插入空引用的诱惑，仅仅是因为它很容易实现。 这导致了无数的错误，漏洞和系统崩溃，在最近四十年中可能造成十亿美元的痛苦和破坏。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前哨值 的另一个问题是它们需要先验知识。 有时，社区中会广泛使用成语，例如 C++<code>结束迭代器</code> 或 <code>Objective-C</code> 中的错误处理约定。 如果不存在此类规则，或者你不了解这些规则，则必须参考文档。 而且，该函数无法表明它不会失败。 如果调用返回一个指针，则该指针可能永远不会为零。 但是，除非阅读文档，否则无法说出任何内容，即使如此，该文档也可能是错误的。</p><h1 id="用枚举替换前哨值"><a href="#用枚举替换前哨值" class="headerlink" title="用枚举替换前哨值"></a><strong>用枚举替换前哨值</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，每个好的程序员都知道魔术数字是不好的。 大多数语言都支持某种枚举类型，这是表示类型的一组离散可能值的更安全方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 使用 <code>“关联值”</code> 的概念进一步枚举。 这些是枚举值，也可以具有与其关联的另一个值。 我们将在 <code>“枚举”</code> 一章中详细介绍枚举。 现在，仅需将 <code>Optional</code> 定义为枚举就足够了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">case</span> some(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检索枚举的关联值的唯一方法是通过模式匹配-例如，在 <code>switch</code> 或 <code>if case let</code> 语句中。 与哨兵值不同，在不显式检查和拆包的情况下，你不能不小心使用嵌入在 <code>Optional</code> 中的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，代替返回哨兵值，而不是返回 <code>find</code> 的 <code>Swift</code> 等效项-称为 <code>firstIndex（of :)</code> -返回一个 <code>Optional &lt;Index&gt;</code> ，其实现与此类似：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">firstIndex</span><span class="params">(of element: Element)</span></span> -&gt; <span class="type">Optional</span>&lt;<span class="type">Index</span>&gt; &#123; </span><br><span class="line">        <span class="keyword">var</span> idx = startIndex</span><br><span class="line">        <span class="keyword">while</span> idx != endIndex &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>[idx] == element &#123; </span><br><span class="line">            <span class="keyword">return</span> .some(idx)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        formIndex(after: &amp;idx) &#125;</span><br><span class="line">        <span class="comment">// Not found, return .none.</span></span><br><span class="line">        <span class="keyword">return</span> .<span class="keyword">none</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为 <code>可选参数</code> 是 <code>Swift</code> 的基础，所以有很多语法支持整理一下： <code>Optional&lt;Index&gt;</code> 可以写成 <code>Index</code> 吗？ 可选参数符合 <code>ExpressibleByNilLiteral</code> ，因此你可以编写 <code>nil</code> 而不是 <code>.none</code> ； 和非可选值（例如idx）会在需要时自动“提升”为可选值，以便你可以编写 <code>return idx</code> 而不是 <code>return .some（idx）</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语法糖可以有效掩饰 <code>Optional类型</code> 的真实性质。 值得记住的是，这没有什么不可思议的。 它只是一个普通的枚举，如果不存在，则可以自己定义。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，用户无法在检查值是否有效之前错误地使用该值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>]</span><br><span class="line"><span class="keyword">let</span> idx = array.firstIndex(of: <span class="string">"four"</span>)</span><br><span class="line"><span class="comment">// Compile-time error: remove(at:) takes an Int, not an Optional&lt;Int&gt;. array.remove(at: idx)</span></span><br><span class="line"><span class="type">Instead</span>, you’re forced to “unwrap” the <span class="keyword">optional</span> <span class="keyword">in</span> order to <span class="keyword">get</span> at the index within, assuming you didn’t <span class="keyword">get</span> <span class="keyword">none</span> back:</span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>] </span><br><span class="line">    <span class="keyword">switch</span> array.index(of: <span class="string">"four"</span>) &#123; </span><br><span class="line">        <span class="keyword">case</span> .some(<span class="keyword">let</span> idx):</span><br><span class="line">            array.remove(at: idx)</span><br><span class="line">        <span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// Do nothing.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个 <code>switch语句</code> 写出了可选方法的枚举语法，包括在某些情况下解压缩关联的值。 这对安全性很有好处，但阅读或书写时却不太愉快。 更简洁的选择是使用？ 模式后缀语法以匹配一些可选值，并且可以使用 <code>nil</code> 文字不匹配任何值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> array.index(of: <span class="string">"four"</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> idx?: <span class="comment">// Equivalent to .some(let idx)</span></span><br><span class="line">        array.remove(at: idx) </span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// Do nothing. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这仍然很笨拙。 让我们看一下其他所有可以使你的可选处理简短明了的方法，具体取决于你的用例。</p><h1 id="Optionals-技术之旅"><a href="#Optionals-技术之旅" class="headerlink" title="Optionals 技术之旅"></a><strong>Optionals 技术之旅</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可选语言还内置了许多额外的支持。 如果你已经写了一段时间的 <code>Swift</code> ，下面的一些示例可能看起来很简单，但是确保你对所有这些概念都非常了解非常重要，因为我们会在整本书中不断地使用它们。</p><h2 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a><strong><em>if let</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <code>if let</code> 的可选绑定距离上面的 <code>switch</code> 语句仅一小步之遥。  <code>if let语句检查可选值</code> 是否为非nil，如果是，则解开可选值。  <code>idx</code> 的类型为 <code>Int（非可选）</code> ，并且 <code>idx</code> 仅在 <code>if let语句</code> 的范围内可用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>] </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> idx = array.index(of: <span class="string">"four"</span>) &#123;</span><br><span class="line">    array.remove(at: idx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以将布尔子句与 <code>if</code> 一起使用。 因此，假设你不想删除该元素（如果它恰巧是数组中的第一个元素）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> idx = array.index(of: <span class="string">"four"</span>), idx != array.startIndex &#123; </span><br><span class="line">        array.remove(at: idx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以在同一条 <strong>if语句中绑定多个值</strong> 。 更重要的是，以后的条目可以依靠以前的条目成功解包。 当你要多次调用返回自身可选值的函数时，这非常有用。 例如，如果你的URL格式错误或数据不是图像，则以下示例中的 <code>URL</code> 和 <code>UIImage初始化</code> 程序均“失败”，即它们可以返回 <code>nil</code> 。 数据初始值设定项可能会引发错误，并且通过使用 <code>try?</code> ，我们也可以将其转换为可选项。 这三个都可以链接在一起，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> urlString = <span class="string">"https://www.objc.io/logo.png"</span> </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: urlString), <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: url), <span class="keyword">let</span> image = <span class="type">UIImage</span>(data: data) &#123;</span><br><span class="line">    <span class="keyword">let</span> view = <span class="type">UIImageView</span>(image: image)</span><br><span class="line">    <span class="type">PlaygroundPage</span>.current.liveView = view </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以在同一 <code>if语句</code> 中 <code>自由混合</code> 和 <code>匹配可选</code> 绑定， <code>布尔子句</code> 和 <code>case let</code> 绑定。</p><h2 id="while-let"><a href="#while-let" class="headerlink" title="while let"></a><strong><em>while let</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <code>if let语句</code> 位于 <code>while let</code> 中非常相似-一个循环，当其条件返回 <code>nil</code> 时终止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准库的 <code>readLine函数</code> 从标准输入返回一个可选字符串。 一旦输入结束，它将返回 <code>nil</code> 。 因此，要实现与 <code>Unix cat命令</code> 非常基本的等效功能，请在 <code>let</code> 中使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> line = <span class="built_in">readLine</span>() &#123; </span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像在 <code>if let语句</code> 中一样，你始终可以将 <code>Boolean子句</code> 添加到可选绑定中。 因此，如果要在 EOF 或空白行上终止此循环，请添加一个子句以检测空字符串。 请注意，一旦条件为假，循环就会终止（你可能会错误地认为布尔条件的作用类似于过滤器）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> line = <span class="built_in">readLine</span>(), !line.isEmpty &#123; </span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们将在 <code>“Collection协议”</code> 一章中看到的那样， <code>seq循环</code> 中的 <code>for x</code> 要求 <code>seq符合Sequence</code> 。 该协议提供了一个 <code>makeIterator方法</code> ，该方法返回一个迭代器，该迭代器又具有下一个方法。  <code>next</code> 返回值，直到序列用尽，然后返回 <code>nil</code> 。 而 <code>let</code> 是理想的选择：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> iterator = array.makeIterator() </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> i = iterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(i, terminator: <span class="string">" "</span>)</span><br><span class="line">&#125; <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，鉴于 <code>for循环</code> 实际上只是 <code>while循环</code> ，因此即使它们具有 <code>where关键字</code> ，它们也支持布尔子句也就不足为奇了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span>  <span class="keyword">where</span> i%<span class="number">2</span>==<span class="number">0</span> &#123; </span><br><span class="line">    <span class="built_in">print</span>(i, terminator: <span class="string">" "</span>) </span><br><span class="line">&#125; <span class="comment">// 0 2 4 6 8</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，上面的 <code>where子句</code> 与 <code>while循环</code> 中的 <code>Boolean子句</code> 不同。 在 <code>while循环</code> 中，一旦值为 <code>false</code> ，迭代就会停止，而在 <code>for循环</code> 中，其作用类似于 <code>filter</code> 。 如果我们使用 <code>while</code> 重写上面的 <code>for循环</code> ，则看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterator2 = (<span class="number">0</span>..&lt;<span class="number">10</span>).makeIterator() </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> i = iterator2.next() &#123;</span><br><span class="line">    <span class="keyword">guard</span> i%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(i) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双嵌套可选"><a href="#双嵌套可选" class="headerlink" title="双嵌套可选"></a><strong><em>双嵌套可选</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是时候指出可选包装的类型本身可以是可选的，这导致嵌套在可选对象内部的可选对象。 要了解为什么这不仅是一种奇怪的情况，还是编译器应自动合并的原因，请假设你有一个数字字符串数组，你希望将其转换为整数。 你可以通过地图运行它们以进行转换：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringNumbers = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"three"</span>]</span><br><span class="line"><span class="keyword">let</span> maybeInts = stringNumbers.<span class="built_in">map</span> &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125; <span class="comment">// [Optional(1), Optional(2), nil]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，你有了一个 <code>Optional&lt;Int&gt;</code> 数组-即Int？ —因为 <code>Int.init（String）</code> 可能失败，因为字符串可能不包含有效的整数。 在这里，最后一个条目将为 <code>nil</code> ，因为“ 3”不是整数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当使用 <code>for遍历</code> 数组时，你应该正确地希望每个元素都是一个可选的整数，因为也许 <code>Ints</code> 包含以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> maybeInt <span class="keyword">in</span> maybeInts &#123; </span><br><span class="line">    <span class="comment">// maybeInt is an Int?</span></span><br><span class="line">    <span class="comment">// Two numbers and a `nil`.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在考虑到 <code>for ... in</code> 的实现是上述 <code>while循环</code> 技术的简写。 从 <code>iterator.next（）</code> 返回的内容将是 <code>Optional&lt;Optional&lt;Int&gt;</code> 或 <code>Int？</code>  —因为 <code>next</code> 将序列中的每个元素都包装在可选元素内。  <code>while</code> 让我们将其解包以检查它是否为 <code>nil</code> ，而当它为非 <code>nil</code> 时，绑定解开的值并运行主体：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterator = maybeInts.makeIterator() </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> maybeInt = iterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(maybeInt, terminator: <span class="string">" "</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Optional(1) Optional(2) nil</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当循环到达最后一个元素-“三”中的nil时， <code>next</code> 返回的是一个非nil值： <code>.some（nil）</code> 。 它将解包此内容，并将其中的内容（零）绑定到也许 <code>Int</code> 。 没有嵌套的可选选项，这将是不可能的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顺便说一句，如果你只想使用 <code>for循环</code> 非零值，则可以使用大小写模式匹配：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> i? <span class="keyword">in</span> maybeInts &#123; </span><br><span class="line">        <span class="comment">// i will be an Int, not an Int? print(i, terminator: " ")</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Or only the nil values:</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="literal">nil</span> <span class="keyword">in</span> maybeInts &#123;</span><br><span class="line">    <span class="comment">// Will run once for each nil. print("No value")</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No value</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这使用 <code>x？</code>  的“模式”，仅匹配 <code>非nil值</code> 。 这是 <code>.some（x）</code> 的简写，因此循环可以这样写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letj=<span class="number">5</span> </span><br><span class="line"><span class="keyword">if</span> case0..&lt;<span class="number">10</span>=j &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(j) within range"</span>) </span><br><span class="line">&#125; <span class="comment">// 5 within range</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将在 <code>“枚举”</code> 一章中深入讨论 <code>模式匹配</code> 。</p><h2 id="if-var-and-while-var"><a href="#if-var-and-while-var" class="headerlink" title="if var and while var"></a><strong><em>if var and while var</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以让 <code>var</code> 与 <code>if</code> ， <code>while和for</code> 一起使用，而不是让。 这使你可以在语句主体内对变量进行突变：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="string">"1"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">var</span> i = <span class="type">Int</span>(number) &#123;</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(i) </span><br><span class="line">&#125; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是请注意，我将是本地副本； 对我的任何更改都不会影响原始可选内容中的值。 可选值是值类型，展开它们会在其中复制值。</p><h2 id="Scoping-of-Unwrapped-Optionals"><a href="#Scoping-of-Unwrapped-Optionals" class="headerlink" title="Scoping of Unwrapped Optionals"></a><strong><em>Scoping of Unwrapped Optionals</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，限制只能访问其已定义的if块中的 <code>Unwrapped变量</code> 。 例如，对数组采用 <code>first属性</code> ，该属性返回第一个元素的可选值，或者在数组为空时返回nil。 这是以下常见代码的便捷缩写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line"><span class="keyword">if</span> !array.isEmpty &#123; </span><br><span class="line">    <span class="built_in">print</span>(array[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Outside the block, the compiler can't guarantee that array[0] is valid.</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最好使用 <code>first属性</code> ，因为你必须解开可选参数才能使用它-你不能无意间忘记：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstElement = array.first &#123; </span><br><span class="line">    <span class="built_in">print</span>(firstElement)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Outside the block, you can't use firstElement.</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解开的值仅在 <code>if let块</code> 内部可用。 很好，但是如果if语句的目的是在不满足某些条件时尽早退出函数，这是不切实际的。 提早退出可以避免烦人的嵌套或稍后在函数中重复检查。 你可能会编写以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doStuff</span><span class="params">(withArray a: [Int])</span></span> &#123; </span><br><span class="line">    <span class="keyword">if</span> a.isEmpty &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Now use a[0] or a.first! safely.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里， <code>if let</code> 绑定将不起作用，因为在 <code>if块</code> 之后，绑定变量将不在范围内。 但是，你仍然可以确保该数组将至少包含一个元素，因此即使语法仍然没有吸引力，强制展开第一个元素也是安全的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在绑定的范围之外使用未包装的可选选项的一种方法是依靠 <code>Swift的延迟初始化</code> 功能。 考虑下面的示例，该示例从 <code>URL和NSString</code> 重新实现 <code>pathExtension属性</code> 的一部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileExtension: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> period: <span class="type">String</span>.<span class="type">Index</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> idx = lastIndex(of: <span class="string">"."</span>) &#123;</span><br><span class="line">            period = idx &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> extensionStart = index(after: period) </span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>[extensionStart...])</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"hello.txt"</span>.fileExtension <span class="comment">// Optional("txt")</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译器检查你的代码，以确认只有两种可能的路径：一种在该路径中函数早返回，而另一种在路径中正确初始化。 周期不能为零（这不是可选的）或未初始化（Swift不允许你使用尚未初始化的变量）。 因此，在if语句之后，可以编写代码，而无需完全担心可选项。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，前两个示例非常丑陋。 确实，我们需要的是某种不让步的方法，而这正是 <code>guard</code> 所允许的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doStuff</span><span class="params">(withArray a: [Int])</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> firstElement = a.first <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// firstElement is unwrapped here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个例子变得更加清晰：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileExtension: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> period = lastIndex(of: <span class="string">"."</span>) <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> extensionStart = index(after: period) </span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>[extensionStart...])</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何内容都可以放在 <code>else子句</code> 中，包括多个语句，就像 <code>if ... else</code> 。 唯一的要求是 <code>else块</code> 必须离开当前范围。 这可能意味着返回，引发错误或调用 <code>fatalError（</code> 或任何其他返回Never的函数）。 如果 <code>guard</code> 处于循环状态，则也可以允许中断或继续。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回类型为 <code>Never的函数</code> 不会向编译器发出永不返回的信号。有两种常见的函数可以执行此操作：中止程序的函数，例如 <code>fatalError</code> ；以及在程序整个生命周期内运行的程序，例如 <code>dispatchMain</code> 。编译器使用此信息进行控制流诊断。例如， <code>guard语句</code> 的 <code>else分支</code> 必须退出当前作用域或调用这些永不返回的函数之一。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从来没有所谓的 <strong><code>uninhabited type</code></strong> 。此类型没有有效值，因此无法构造。从不与 <code>Result</code> 结合使用<br>在一般情况下。例如，如果通用 <code>API</code> 期望值的类型为 <code>Result&lt;A，E&gt;</code>（ 其中A和E是通用参数），则可以传入 <code>Result&lt;...，Never&gt;</code> 以表示此具体 <code>Result实例</code> 永远不会包含失败，因为无法构造这样的值。而且，声明为返回无人居住类型的函数永远不会正常返回。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中，无人居住的类型被实现为没有大小写的枚举：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Never</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除非你为 <code>fatalError</code> 或 <code>preconditionFailure</code> 编写包装，否则通常不需要定义自己的永不返回的函数。 一个有趣的用例是在编写新代码时：假设你正在处理复杂的 <code>switch语句</code> ，逐渐填充所有用例，并且编译器用错误消息轰炸你，指出空用例标签或缺少返回值，而你要做的只是专注于你正在处理的一种情况。 在这种情况下，对 f<code>atalError（）</code> 的一些精心放置的调用可能会产生奇迹，使编译器静音。 考虑编写一个名为 <code>unimplemented（）</code> 的函数，以便更好地传达这些调用的临时性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unimplemented</span><span class="params">()</span></span> -&gt; <span class="type">Never</span> &#123;</span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"This code path is not implemented yet."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>swift</code> 精心区分了不同的 <code>“nothingness”</code> 。 除了 <code>nil</code> 和 <code>Never</code> ，还有 <code>Void</code> ，这是另一种写空元组的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Void</span> = ()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Void</code> 或 <code>（）</code> 最常见的用法是不返回任何内容的函数类型，但它也具有其他应用程序。 例如，考虑一个反应式编程框架，该框架以 <code>Observable&lt;T&gt;类型</code>对事件流进行建模，其中 T 描述了所发射事件的有效负载类型。 文本字段对象可能会提供一个 <code>Observable&lt;String&gt;</code>，它会在用户每次编辑文本时触发一个事件。 类似地，当用户点击按钮时，按钮对象发送事件，但没有其他要发送的有效负载-其事件流的类型应为 <code>Observable&lt;（）&gt;</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如戴维·史密斯（David Smith）所说， <code>Swift</code> 在 <strong>“缺物”（nil）</strong> ， <strong>“无物”（void）</strong> 和 <strong>“不可能的事物”（Never）</strong> 之间进行了仔细的区分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像 <code>if</code> 一样， <code>guard</code> 不仅限于绑定。  <code>Guard</code> 可以采取任何可能在常规 <code>if语句</code> 中找到的条件，因此可以使用它重写空数组示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doStuff2</span><span class="params">(withArray a: [Int])</span></span> &#123; </span><br><span class="line">    <span class="keyword">guard</span> !a.isEmpty <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125; <span class="comment">// Now use a[0] or a.first! safely.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与可选的 <code>binding case</code> 不同，此 <code>guard</code> 不是一个大胜利-实际上，它比原始版本更为冗长。 但是仍然值得考虑在任何提早退出的情况下进行此操作。 对于一个，有时（尽管不是这种情况），布尔条件的求逆可以使事情变得更清楚。 此外，当阅读代码。 它说：<strong>“只有在满足以下条件时，我们才会继续。”</strong> 最后， <code>Swift编译器</code> 将检查你是否确实要退出当前作用域，如果不存在，则会引发编译错误。 因此，即使在 <code>if可行的情况下</code> ，我们也建议你 <strong>使用防护功能</strong> 。</p><h2 id="Optional-Chaining"><a href="#Optional-Chaining" class="headerlink" title="Optional Chaining"></a><strong><em>Optional Chaining</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Objective-C</code> 中，向 <code>nil</code> 发送消息是无操作的。 在 <code>Swift</code> 中，可以通过 <code>“Optional Chaining”</code> 实现相同的效果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delegate?.callback()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是与 <code>Objective-C</code> 不同， <code>Swift编译器</code> 将迫使你确认接收方可能为 <code>nil</code> 。 问号 向读者明确表示该方法可能不会被调用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你通过可选链接调用的方法返回结果时，该结果也将是可选的。 考虑以下代码，以了解为什么一定要这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="type">String?</span> = <span class="string">"Never say never"</span></span><br><span class="line"><span class="comment">// We want upper to be the uppercase string. let upper: String</span></span><br><span class="line"><span class="keyword">if</span> str!=<span class="literal">nil</span> &#123;</span><br><span class="line">    upper = str!.uppercased() </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No reasonable action to take at this point.</span></span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"No idea what to do now..."</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>str</code> 不为 <code>nil</code> ，则 <code>upper</code> 将具有所需的值。 但是，如果 <code>str</code> 为 <code>nil</code> ，则不能将 <code>upper</code> 设置为一个值。 因此，在可选链接的情况下， <code>upper2</code> 必须是可选的，以便考虑 <code>str</code> 可能为零的可能性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> upper2 = str?.uppercased() <span class="comment">// Optional("NEVER SAY NEVER")</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顾名思义，你可以在可选值上链接调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lower = str?.uppercased().lowercased() <span class="comment">// Optional("never say never")</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这看起来可能有点令人惊讶。 我们不是只是说可选链接的结果是可选的吗？ 那为什么不需要一个 <code>？</code> 。 在 <code>uppercased（）</code> 之后？ 这是因为可选链接是 <code>“flattening”</code> 操作。 如果 <code>str？.uppercased（）</code> 返回了可选内容，而你在其上调用了 <code>？.lowercased（）</code> ，那么从逻辑上讲，你将获得可选的可选内容。 但是，你只需要一个常规的可选内容，因此我们编写第二个链接调用而没有问号，以表示已捕获可选内容的事实。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一方面，如果大写的方法本身返回了一个可选的，那么你将需要添加第二个 <code>？</code> 表示你正在链接该可选内容。 例如，让我们使用名为 <code>half的计算属性扩展Int类型</code> 。 此属性返回将整数除以二的结果，但前提是该数字足够大以被除。 当数字小于2时，它返回 <code>nil</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> half: <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span>&lt;-<span class="number">1</span>||<span class="keyword">self</span>&gt;<span class="number">1</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">2</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为调用 <code>half</code> 返回一个可选结果，所以我们需要继续输入 <code>？</code> 反复调用时。 毕竟，在每一步，该函数都可能返回 <code>nil</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>.half?.half?.half <span class="comment">// Optional(2)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，编译器仍然足够聪明，可以为我们简化结果类型。 上面的表达式的类型是 <code>Int？</code>  而不是你可能期望的 <code>Int???</code> 。 后者将为你提供更多信息-即，链的哪一部分发生了故障-但也会使处理结果变得更加麻烦，从而破坏了可选链的便利性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可选链接也适用于下标，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dictOfArrays = [<span class="string">"nine"</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]] </span><br><span class="line">dictOfArrays[<span class="string">"nine"</span>]?[<span class="number">3</span>] <span class="comment">// Optional(3)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，你可以使用可选链接来调用可选功能：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dictOfFunctions: [<span class="type">String</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>] = [ <span class="string">"add"</span>: (+),</span><br><span class="line"><span class="string">"subtract"</span>: (-)</span><br><span class="line">]</span><br><span class="line">dictOfFunctions[<span class="string">"add"</span>]?(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// Optional(2)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在类通常存储回调函数以便在事件发生时通知其所有者的典型回调情况下，这很方便。 考虑一个 <code>TextField类</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextField</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> text = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> didChange: ((<span class="type">String</span>) -&gt; ())?</span><br><span class="line">    <span class="comment">// Event handler called by the framework.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">textDidChange</span><span class="params">(newText: String)</span></span> &#123; </span><br><span class="line">        text = newText</span><br><span class="line">        <span class="comment">// Trigger callback if non-nil. didChange?(text)</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>didChange属性</code> 存储一个 回调函数 ，每次用户编辑文本时，该文本字段都会调用该函数。 由于文本字段的所有者不必注册回调，因此该属性为可选； 其初始值为nil。 当需要调用回调的时候（在上面的 <code>textDidChange</code> 方法中），可选链接使我们能够以非常紧凑的方式进行调用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你甚至可以通过可选链进行分配。 假设你有一个可选变量，并且如果非零，则希望更新其属性之一：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> </span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> optionalLisa: <span class="type">Person?</span> = <span class="type">Person</span>(name: <span class="string">"Lisa Simpson"</span>, age: <span class="number">8</span>) <span class="comment">// Increment age if non-nil.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> optionalLisa != <span class="literal">nil</span> &#123;</span><br><span class="line">    optionalLisa!.age += <span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是相当冗长和丑陋的。 请注意，在这种情况下，你不能使用可选绑定。 由于 <code>Person</code> 是一个结构，因此是一个值类型，因此绑定变量是原始值的本地副本； 改变前者不会改变后者：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">var</span> lisa = optionalLisa &#123;</span><br><span class="line">    <span class="comment">// Mutating lisa doesn't change optionalLisa. </span></span><br><span class="line">    lisa.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>Person</code> 是一个 <code>class</code> ，这将起作用。 我们将在 <code>“结构和类”</code> 一章中进一步讨论 值和引用类型 之间的区别。 无论如何，它仍然太冗长。 相反，你可以分配给链接的可选值，如果它不是nil，分配将通过：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optionalLisa?.age += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此功能一个奇怪的（但合乎逻辑的）边缘情况是它可以直接分配给可选值。 这是完全正确的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int?</span>=<span class="number">5</span> </span><br><span class="line">a?=<span class="number">10</span></span><br><span class="line">a <span class="comment">// Optional(10)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b: <span class="type">Int?</span> = <span class="literal">nil</span> </span><br><span class="line">b?=<span class="number">10</span></span><br><span class="line">b <span class="comment">// nil</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意 <code>a = 10</code> 和 <code>a</code> 之间的细微差别吗 <code>？=10</code> 。前者无条件分配新值，而后者仅在 <code>a</code> 的值在赋值前为<strong>非nil时才执行赋值</strong>。</p><h1 id="nil-Coalescing-Operator"><a href="#nil-Coalescing-Operator" class="headerlink" title="nil-Coalescing Operator"></a><strong>nil-Coalescing Operator</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，你想打开一个可选的包装并将 <code>nil</code> 替换为一些默认值。 这是 <code>nil-coalescing</code> 运算符的工作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringteger = <span class="string">"1"</span></span><br><span class="line"><span class="keyword">let</span> number = <span class="type">Int</span>(stringteger) ?? <span class="number">0</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果字符串可以转换为整数，则数字将是该整数，并且不会被包装。 如果不是，则 <code>Int.init</code> 返回 <code>nil</code> ，将替换默认值0。 所以 <code>lhs ?? rhs</code> 类似于代码 <code>lhs！= nil？ h！：rhs</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你使用另一种语言来学习 <code>Swift</code> ，你可能会认为 <code>nil-coalescing</code> 运算符与三元运算符非常相似 <code>（a？b：c）</code> 。 例如，要从可能为空的数组中获取第一个元素，可以编写以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] !array.isEmpty ? array[<span class="number">0</span>] : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>Swift数组</code> 提供的第一个属性为 <code>nil</code> （如果该数组为空），因此你可以使用 <code>nil-coalescing运算符</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.first ?? <span class="number">0</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这更加清晰明了-意图（抓住数组中的第一个元素）在前面，默认设置在末尾，并带有 <code>??</code> 。 表示 “这是默认值” 。 将其与三元运算符版本进行比较，三元运算符版本首先以检查开始，之后是值，最后是默认值。 而且检查被否定了（替代方法是将默认值放在中间，将实际值放在最后）。 而且，与可选选项一样，我们无法忘记 first是可选的 ，并且在没有检查的情况下意外地使用了它，因为如果你尝试这样做，编译器将会阻止你。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要你发现要检查自己的语句以确保该语句有效，便是一个好兆头，可选选项将是一个更好的解决方案。 假设你要检查的是数组范围内的值，而不是一个空数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="built_in">count</span> &gt; <span class="number">5</span> ? array[<span class="number">5</span>] : <span class="number">0</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与“第一个和最后一个”不同，按索引从数组中取出元素不会返回可选的。 但是很容易 <code>扩展Array</code> 以添加此功能：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(guarded idx: <span class="type">Int</span>) -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> (startIndex..&lt;endIndex).<span class="built_in">contains</span>(idx) <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>[idx] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，你可以编写以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[guarded: <span class="number">5</span>] ?? <span class="number">0</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Coalescing</code> 也可以链接在一起-因此，如果你有多个可能的可选选项，并且要选择第一个非nil值，可以按顺序编写它们：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> j: <span class="type">Int?</span> = <span class="literal">nil</span> letk:<span class="type">Int?</span>=<span class="number">42</span></span><br><span class="line">i ?? j ?? k ?? <span class="number">0</span> <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如果你遇到双重嵌套的可选内容，并且想使用 <code>??</code> ， 运算符，你必须小心区分  <code>b ?? c（链接）</code> 和 <code>（a ?? b）?? c</code> （展开内层然后再展开外层）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1: <span class="type">String?</span>? = <span class="literal">nil</span></span><br><span class="line">(s1 ?? <span class="string">"inner"</span>) ?? <span class="string">"outer"</span> <span class="comment">// inner let s2: String?? = .some(nil)</span></span><br><span class="line">(s2 ?? <span class="string">"inner"</span>) ?? <span class="string">"outer"</span> <span class="comment">// outer</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想到了 <code>??</code>  运算符类似于 <code>“or”语句</code> ，你可以将带有多个子句的 <code>if let</code> 视为 <code>“and”</code> 语句：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> n = i, <span class="keyword">let</span> m = j &#123; &#125;</span><br><span class="line"><span class="comment">// similar to if i != nil &amp;&amp; j != nil</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像 <code>|| 运算符</code> ， <code>?? 操作员</code> 使用短路：当我们写 <code>l ?? r</code> ，仅当左侧为零时才评估运算符的右侧。 之所以可行，是因为运算符的函数声明将 <code>@autoclosure</code> 用作其第二个参数。 我们将在 <code>“功能”</code> 一章中详细讨论 <code>autoclosures</code> 的工作原理。</p><h1 id="在字符串插值中使用Optionals"><a href="#在字符串插值中使用Optionals" class="headerlink" title="在字符串插值中使用Optionals"></a><strong>在字符串插值中使用Optionals</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能已经注意到，当你打印可选值或在字符串插值表达式中使用一个值时，编译器会发出警告：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bodyTemperature: <span class="type">Double?</span> = <span class="number">37.0</span> <span class="keyword">let</span> bloodGlucose: <span class="type">Double?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(bodyTemperature) <span class="comment">// Optional(37.0)</span></span><br><span class="line"><span class="comment">// Warning: Expression implicitly coerced from 'Double?' to Any. </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Blood glucose level: \(bloodGlucose)"</span>) <span class="comment">// Blood glucose level: nil </span></span><br><span class="line"><span class="comment">// Warning: String interpolation produces a debug description</span></span><br><span class="line"><span class="comment">// for an optional value; did you mean to make this explicit?</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这通常很有用，因为 <code>“ Optional（...）”</code> 或 <code>“ nil”</code> 很容易意外地潜入显示给用户的文本中。永远不要在面向用户的字符串中直接使用可选选项，并且<strong>始终先将其解包</strong>。由于所有类型都可以在字符串插值中使用（包括 <code>Optional</code> ），因此编译器无法将其设置为硬错误-警告实际上是它可以做的最好的事情。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，你可能希望在字符串插值中使用可选参数（例如，记录其值以进行调试），在这种情况下，警告可能会变得很烦人。编译器提供了几个修复程序来消除警告：用 <code>as Any添加显式强制转换</code> ，用 <strong><code>!</code></strong> 强制解包该值。 （如果确定不能为nil），则将其包装在String中（描述：），或使用 <code>nil-coalescing运算符</code> 提供默认值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后者通常是一种快速而美观的解决方案，但它有一个缺点：<code>??</code> 两侧的类型都没有 <code>？</code>表达式必须匹配，因此你为 <code>Double</code> 提供的默认值？必须为 <code>Double类型</code> 。由于最终目的是将表达式转换为字符串，因此，如果你可以首先提供字符串作为默认值，那将很方便。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 的 <code>？运算符</code> 不支持这种类型的不匹配-毕竟，如果双方没有相同的基本类型，表达式的类型将是什么？但是添加你自己的运算符很容易，尤其是在字符串插值中使用可选参数的目的。命名为 <code>???</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ???: <span class="type">NilCoalescingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> ???&lt;T&gt;<span class="params">(<span class="keyword">optional</span>: T?, defaultValue: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) -&gt; <span class="type">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">optional</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> value?: </span><br><span class="line">            <span class="keyword">return</span> <span class="type">String</span>(describing: value) </span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>: </span><br><span class="line">            <span class="keyword">return</span> defaultValue()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这需要任何可选的 <code>T</code> 吗？ 左侧是一个字符串，右侧是一个字符串。 如果可选参数为 <code>非nil</code> ，我们将其解包并返回其字符串描述。 否则，我们返回默认值传入的字符串。 @autoclosure 批注确保仅在需要时才评估第二个操作数。 在 <code>“函数”</code> 一章中，我们将对此进行更详细的介绍。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以编写以下内容，并且不会收到任何编译器警告：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Body temperature: \(bodyTemperature ??? "</span>n/a<span class="string">")"</span>) <span class="comment">// Body temperature: 37.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Blood glucose level: \(bloodGlucose ??? "</span>n/a<span class="string">")"</span>)</span><br><span class="line"><span class="comment">// Blood glucose level: n/a</span></span><br></pre></td></tr></table></figure><h2 id="Optional-map"><a href="#Optional-map" class="headerlink" title="Optional map"></a><strong><em>Optional map</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们有一个字符数组，我们想将第一个元素转换为字符串：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> characters: [<span class="type">Character</span>] = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>] </span><br><span class="line"><span class="type">String</span>(characters[<span class="number">0</span>]) <span class="comment">// a</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果字符可能为空，则仅当数组为非空时，才可以使用 <code>if</code> 来创建字符串：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstCharAsString: <span class="type">String?</span> = <span class="literal">nil</span> </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> char = characters.first &#123;</span><br><span class="line">    firstCharAsString = <span class="type">String</span>(char) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，现在，如果数组包含至少一个元素，则 <code>firstCharAsString</code> 将包含该元素作为 <code>String</code> 。 但是，如果不是这样，则 <code>firstCharAsString</code> 将为nil。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式（采取可选方式，然后将其转化为nil）会很普遍，以至于在可选方式上有一种方法可以做到这一点。 它称为 <code>map</code> ，它具有一个表示如何转换可选内容的函数。 这是上面的功能，使用 <code>map</code> 重写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstChar = characters.first.<span class="built_in">map</span> &#123; <span class="type">String</span>($<span class="number">0</span>) &#125; <span class="comment">// Optional("a")</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，此 <code>map</code> 非常类似于数组或其他序列上的 <code>map</code> 。 但是，它不是对一系列值进行运算，而是对一个值进行运算：可能的值 <code>内部可选</code> 。 你可以将可选值视为零个或一个值的集合，而 map 则不对零值进行任何处理或将其转换为零。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是在可选项目上实现 <code>map</code> 的一种方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(transform: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">U?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> value = <span class="keyword">self</span> <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> transform(value) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你已经想要一个可选结果时，可选映射特别好。 假设你想编写另一个 <code>reduce数组变体</code> 。 它不使用初始值，而是使用数组中的第一个元素（在某些语言中，这可能称为 <code>reduce1</code> ，但我们称其为 <strong>reduce并依赖于重载</strong> ）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于数组可能为空，结果需要是可选的-如果没有初始值，还可能是什么？ 你可以这样写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reduce</span><span class="params">(<span class="number">_</span> nextPartialResult: <span class="params">(Element, Element)</span></span></span> -&gt; <span class="type">Element</span>)</span><br><span class="line">    -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="comment">// first will be nil if the array is empty.</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> fst = first <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dropFirst</span>().<span class="built_in">reduce</span>(fst, nextPartialResult) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以像这样使用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">reduce</span>(+) <span class="comment">// Optional(10)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于可选 <code>map</code> 如果可选为 <code>nil</code> 则返回 <code>nil</code> ，因此我们的 <code>reduce变量</code> 可以是使用单个 <code>return语句（无保护）重写</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reduce_alt</span><span class="params">(<span class="number">_</span> nextPartialResult: <span class="params">(Element, Element)</span></span></span> -&gt; <span class="type">Element</span>)</span><br><span class="line">    -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.<span class="built_in">map</span> &#123;</span><br><span class="line">            <span class="built_in">dropFirst</span>().<span class="built_in">reduce</span>($<span class="number">0</span>, nextPartialResult)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional-fiatMap"><a href="#Optional-fiatMap" class="headerlink" title="Optional fiatMap"></a><strong><em>Optional fiatMap</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们在 <a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%8C):%20Build-in%20Collections/"><strong><em><code>“内置集合”</code></em></strong></a> 一章中所看到的那样，通常希望使用一个函数来映射一个集合，该函数可以返回一个集合，但将结果作为单个数组而不是数组来收集。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样，如果你想对可选值执行映射，但是转换函数也具有可选结果，则最终会出现一个双重嵌套的可选项。 例如，当你想将字符串数组的第一个元素作为数字来获取时，请在数组上使用 <code>first</code> 然后映射将其转换为数字：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringNumbers = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"foo"</span>]</span><br><span class="line"><span class="keyword">let</span> x = stringNumbers.first.<span class="built_in">map</span> &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125; <span class="comment">// Optional(Optional(1))</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题在于，由于 <code>map</code> 返回一个可选值（first可能为nil），而 <code>Int(someString)</code> 返回一个可选项（字符串可能不是整数），因此x的类型将为 Int?? 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>flatMap</code> 会将结果展平为单个可选内容。 结果，y的类型将为 <code>Int?</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> y = stringNumbers.first.flatMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125; <span class="comment">// Optional(1)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相反，你可以使用 <code>if let</code> 编写此代码，因为以后绑定的值可以是根据先前的计算：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> a = stringNumbers.first, <span class="keyword">let</span> b = <span class="type">Int</span>(a) &#123; </span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">&#125; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这表明 <code>flatMap</code> 和 <code>if let</code> 非常相似。 在本章的前面，我们看到了一个使用多 <code>if-let语句</code> 的示例。 我们可以改用 <code>map</code> 和 <code>flatMap</code> 重写它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> urlString = <span class="string">"https://www.objc.io/logo.png"</span> </span><br><span class="line"><span class="keyword">let</span> view = <span class="type">URL</span>(string: urlString)</span><br><span class="line">    .flatMap &#123; <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: $<span class="number">0</span>) &#125;</span><br><span class="line">    .flatMap &#123; <span class="type">UIImage</span>(data: $<span class="number">0</span>) &#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="type">UIImageView</span>(image: $<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> view= view &#123; </span><br><span class="line">    <span class="type">PlaygroundPage</span>.current.liveView = view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可选链接也与 <code>flatMap</code> 非常相似： <code>i？.advance（by：1）</code> 本质上等效于 <code>i.flatMap {$ 0.advance（by：1）}</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于我们已经证明了多重 <code>if-let语句</code> 等效于 <code>flatMap</code> ，因此我们可以在另一个方面实现一个：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(transform: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">U?</span>) -&gt; <span class="type">U?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> value = <span class="keyword">self</span>, <span class="keyword">let</span> transformed = transform(value) &#123; </span><br><span class="line">            <span class="keyword">return</span>  transformed</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用compactMap过滤掉nil"><a href="#用compactMap过滤掉nil" class="headerlink" title="用compactMap过滤掉nil"></a><strong><em>用compactMap过滤掉nil</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你有一个序列，并且其中包含可选序列，则可能不需要关心 <code>nil值</code> 。 实际上，你可能只想忽略它们。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设你只想处理字符串数组中的数字。 使用可选的模式匹配，可以轻松地在for循环中完成此操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"foo"</span>] varsum=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> i? <span class="keyword">in</span> numbers.<span class="built_in">map</span>(&#123; <span class="type">Int</span>($<span class="number">0</span>) &#125;) &#123;</span><br><span class="line">    sum+=i </span><br><span class="line">&#125;</span><br><span class="line">sum <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能还想使用 <code>??</code>  将 <code>nils</code> 替换为零：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="built_in">map</span> &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125;.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; $<span class="number">0</span> + ($<span class="number">1</span> ?? <span class="number">0</span>) &#125; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但实际上，你只需要一个可 <strong>过滤nil并解开非nil值的map版本</strong> 。 在序列上输入标准库的 <code>compactMap</code> ，它会执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.compactMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125;.<span class="built_in">reduce</span>(<span class="number">0</span>, +) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要定义我们自己的 <code>compactMap版本</code> ，我们首先映射整个数组，然后我们过滤掉非nil值，最后解开每个元素：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">compactMap</span>&lt;B&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">B?</span>) -&gt; [<span class="type">B</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lazy</span>.<span class="built_in">map</span>(transform).<span class="built_in">filter</span> &#123; $<span class="number">0</span> != <span class="literal">nil</span> &#125;.<span class="built_in">map</span> &#123; $<span class="number">0</span>! &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实现中，我们使用 <code>lazy</code> 将数组的<strong>实际创建推迟到最后一刻</strong>。 这可能是 <code>微优化</code> ，但对于较大的序列可能是值得的。 使用惰性可以节省多个中间阵列的分配。 不过，标准库在其 <code>compactMap</code> 实施中并未执行此操作。 在 <code>“Collection协议”</code> 一章中，我们将详细介绍<strong>惰性序列和集合</strong>。</p><h2 id="Equating-Optionals"><a href="#Equating-Optionals" class="headerlink" title="Equating Optionals"></a><strong><em>Equating Optionals</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，你并不关心某个值是否为nil，而只是是否包含某个值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="string">"^Hello$"</span> <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> regex.first == <span class="string">"^"</span> &#123;</span><br><span class="line"><span class="comment">// Match only the start of the string.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下，值是否为nil无关紧要-如果字符串为空，则第一个字符不能是尖号，因此你不想运行该块。 但是你仍然想要第一个的保护和简单性。 替代方案如果 <code>!regex.isEmpty &amp;&amp; regex [regex.startIndex] == &quot;^&quot;</code> ，那太可怕了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码依靠两件事来工作。 首先， <code>Optional</code> 符合 <code>Equatable</code> ，但仅当 <code>Wrapped类型</code> 也符合 <code>Equatable</code> 时：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span>: <span class="title">Equatable</span> <span class="title">where</span> <span class="title">Wrapped</span>: <span class="title">Equatable</span> </span>&#123; <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Wrapped?, rhs: Wrapped?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (lhs, rhs) &#123;</span><br><span class="line">        <span class="keyword">case</span> (<span class="literal">nil</span>, <span class="literal">nil</span>): </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> (x?, y?): </span><br><span class="line">        <span class="keyword">return</span> x == y <span class="keyword">case</span> (<span class="number">_</span>?, <span class="literal">nil</span>), (<span class="literal">nil</span>, <span class="number">_</span>?): <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较两个可选参数时，有四种可能：它们都为nil，或者它们都具有值，或者一个或另一个为nil。 <code>switch</code> 详尽地测试了所有四种可能性（因此不需要默认子句）。 它定义两个nil彼此相等，nil永不等于non-nil，如果两个非nil值的展开值相等，则两个nil值相等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这只是故事的一半。 注意，我们不必编写以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> regex.first == <span class="type">Optional</span>(<span class="string">"^"</span>) &#123; <span class="comment">// or: == .some("^") </span></span><br><span class="line">    <span class="comment">// Match only the start of the string.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是因为每当你有一个非可选值时， <code>Swift</code> 总是愿意将其提升为可选值，以使类型匹配。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种隐式转换对于编写清晰，紧凑的代码非常有用。 假设没有这样的转换，但是为了使调用者感觉更好，你需要一个 ==版本 ，该版本在可选类型和非可选类型之间都起作用。 你必须编写三个单独的版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Both optional.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> == &lt;T: Equatable&gt;<span class="params">(lhs: T?, rhs: T?)</span></span> -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="comment">// lhs non-optional.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> == &lt;T: Equatable&gt;<span class="params">(lhs: T, rhs: T?)</span></span> -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="comment">// rhs non-optional.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> == &lt;T: Equatable&gt;<span class="params">(lhs: T?, rhs: T)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，相反，只有第一个版本是必需的，并且编译器将在必要时转换为可选参数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，我们在整本书中都一直依赖此功能。例如，当我们实现可选映射时，我们转换了内部值并返回了它。但是 map 的返回值是可选的。编译器自动为我们转换了值-我们不必编写 <code>return Optional(transform(value))</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 代码始终依赖于此<strong>隐式转换</strong>。例如，按键查找字典下标将返回可选键（键可能不存在）。但这在分配时也需要一个可选的选项-下标必须同时采用和接受相同的类型。没有隐式转换，你将不得不编写<br> <code>myDict[&quot;someKey&quot;] = Optional(someValue)</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顺便说一句，如果你想知道在分配nil值时使用基于键的下标分配的字典会发生什么情况，那么答案就是要删除键。这可能很有用，但也意味着你在处理带有可选值类型的字典时需要格外小心。考虑一下这个字典：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dictWithNils: [<span class="type">String</span>: <span class="type">Int?</span>] = [ <span class="string">"one"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"two"</span>: <span class="number">2</span>,</span><br><span class="line"><span class="string">"none"</span>: <span class="literal">nil</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字典有三个键，其中一个键的值为nil。 假设我们也想将“ two”键的值设置为nil。 这不会这样做：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dictWithNils[<span class="string">"two"</span>] = <span class="literal">nil</span></span><br><span class="line">dictWithNils <span class="comment">// ["one": Optional(1), "none": nil]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相反，它将删除“two”键。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要更改key的值，你必须编写以下内容之一（它们都可以工作，因此，请选择你认为较清晰的那个）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dictWithNils[<span class="string">"two"</span>] = <span class="type">Optional</span>(<span class="literal">nil</span>)</span><br><span class="line">dictWithNils[<span class="string">"two"</span>] = .some(<span class="literal">nil</span>)</span><br><span class="line">dictWithNils[<span class="string">"two"</span>]? = <span class="literal">nil</span></span><br><span class="line">dictWithNils <span class="comment">// ["one": Optional(1), "two": nil, "none": nil]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，上面的第三个版本与其他两个版本略有不同。 之所以有效，是因为字典中已经有“ two”键，因此，如果成功提取它，它将使用可选链接来设置其值。 现在，尝试使用不存在的 key ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dictWithNils[<span class="string">"three"</span>]? = <span class="literal">nil</span> </span><br><span class="line">dictWithNils.index(forKey: <span class="string">"three"</span>) <span class="comment">// nil</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你会看到什么都不会被更新/插入。</p><h1 id="Comparing-Optionals"><a href="#Comparing-Optionals" class="headerlink" title="Comparing Optionals"></a><strong>Comparing Optionals</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <code>==</code> 相似，对于可选项，曾经有 <code>&lt;</code> ， <code>&gt;</code> ， <code>&lt;=</code> 和 <code>&gt;=</code> 的实现。 对于 <code>Swift 3.0</code> ，将这些比较运算符作为可选项删除了，因为它们很容易产生意外的结果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>nil&lt;.some(_)</code> 将返回true。 结合高阶函数或可选链接，这可能非常令人惊讶。 考虑以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temps = [<span class="string">"-459.67"</span>, <span class="string">"98.6"</span>, <span class="string">"0"</span>, <span class="string">"warm"</span>]</span><br><span class="line"><span class="keyword">let</span> belowFreezing = temps.<span class="built_in">filter</span> &#123; <span class="type">Double</span>($<span class="number">0</span>) &lt; <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>Double(&quot;warm&quot;)</code> 将返回nil并且nil小于0，因此它将包含在下面的冻结温度中。 这确实是出乎意料的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你需要可选项之间的不等式关系，则现在必须首先解开值，从而明确说明应如何处理nil值。 我们将在 <code>“函数”</code> 一章中显示一个示例，其中定义了一个通用函数，该函数将常规比较函数“提升”到可选域中。</p><h1 id="何时强制展开"><a href="#何时强制展开" class="headerlink" title="何时强制展开"></a><strong>何时强制展开</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了所有这些用于清晰地展开可选内容的技术，何时应该使用 <code>！</code> ，强制展开运算符 <code>？</code> 对此在互联网上散布着很多意见，包括 <code>“从不”</code> ， <code>“每当使代码更清晰时”</code> 和 <code>“何时无法避免”</code> 。 我们提出以下规则，其中涵盖了大多数规则：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用 ！ 当你确定某个值不会为零时，就希望你的程序崩溃。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，从上面开始执行 <code>compactMap</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">compactMap</span>&lt;B&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">B?</span>) -&gt; [<span class="type">B</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lazy</span>.<span class="built_in">map</span>(transform).<span class="built_in">filter</span> &#123; $<span class="number">0</span> != <span class="literal">nil</span> &#125;.<span class="built_in">map</span> &#123; $<span class="number">0</span>! &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，这 <code>$0</code> 是不可能的！ 内部映射永远不会达到零，因为在上一步中所有nil元素都被过滤掉了。 通过遍历数组并将非nil值添加到数组中，可以肯定地编写此函数来消除强制展开运算符。 但是 <code>filter/map</code> 版本更干净，也许更清晰，所以<code>！</code> 是有道理的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，这些情况很少见。 如果你完全掌握了本章介绍的所有展开技术，那么比强制展开有更好的方法。 每当你发现自己想要达到<code>！</code>时，就应该退后一步，想知道是否真的没有其他选择。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为另一个示例，请考虑以下代码，该代码以匹配特定条件的值获取字典中的所有键：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ages = [</span><br><span class="line"><span class="string">"Tim"</span>: <span class="number">53</span>,<span class="string">"Angela"</span>:<span class="number">54</span>,<span class="string">"Craig"</span>:<span class="number">44</span>, <span class="string">"Jony"</span>: <span class="number">47</span>, <span class="string">"Chris"</span>: <span class="number">37</span>, <span class="string">"Michael"</span>: <span class="number">34</span>,</span><br><span class="line">] </span><br><span class="line">ages.keys</span><br><span class="line">.<span class="built_in">filter</span> &#123; name <span class="keyword">in</span> ages[name]! &lt; <span class="number">50</span> &#125;</span><br><span class="line">.sorted()</span><br><span class="line"><span class="comment">// ["Chris", "Craig", "Jony", "Michael"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再次，<code>！</code>是非常安全的-由于所有键都来自字典，因此不可能从字典中丢失键。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，你也可以重写该语句，以完全不需要进行强制拆包。 利用字典将自身表示为键值序列的事实<br>对，你可以过滤此序列，然后在 <code>map</code> 中运行以删除值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ages.<span class="built_in">filter</span> &#123; (<span class="number">_</span>, age) <span class="keyword">in</span> age &lt; <span class="number">50</span> &#125; </span><br><span class="line">.<span class="built_in">map</span> &#123; (name, <span class="number">_</span>) <span class="keyword">in</span> name &#125; </span><br><span class="line">.sorted()</span><br><span class="line"><span class="comment">// ["Chris", "Craig", "Jony", "Michael"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该版本甚至可以带来性能上的好处，因为它避免了不必要的键查找。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，有时候生活会给你一个可选的选择，并且你肯定会知道它不是零。 可以肯定的是，你宁愿让程序崩溃而不是继续，因为遇到nil值意味着你的逻辑中存在一个非常讨厌的错误。 在这种情况下比继续进行陷阱更好，所以<code>！</code> 在一个方便的角色中充当组合的拆包或错误运算符。 与仅使用nil链接或合并运算符在地毯下扫除理论上不可能的情况相比，此方法通常是更好的方法。</p><h1 id="改进强制展开错误消息"><a href="#改进强制展开错误消息" class="headerlink" title="改进强制展开错误消息"></a><strong>改进强制展开错误消息</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，即使你强制展开可选值，你也可以使用除<code>！</code>以外的其他选项。 当程序出错时，你在输出日志中获得的原因说明不多。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会发表评论，说明为何有理由进行强制解包。 那么，为什么不将该注释也用作错误消息呢？  <code>!!</code> 当应用程序退出时，它将解包与提供更具描述性的错误消息结合在一起记录：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> !!</span><br><span class="line">    <span class="function"><span class="keyword">func</span> !! &lt;T&gt;<span class="params">(wrapped: T?, failureText: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) -&gt; <span class="type">T</span> &#123; <span class="keyword">if</span> <span class="keyword">let</span> x=wrapped &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fatalError</span>(failureText())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，你可以编写更具描述性的错误消息，包括你希望能够解开的值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"foo"</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="type">Int</span>(s) !! <span class="string">"Expecting integer, got \"\(s)\""</span></span><br></pre></td></tr></table></figure><h1 id="声明调试版本"><a href="#声明调试版本" class="headerlink" title="声明调试版本"></a><strong>声明调试版本</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管如此，即使在发布版本上崩溃也仍然是一个大胆的举措。 通常，你可能更喜欢在调试和测试构建期间声明，但是在生产环境中，你将替换为有效的默认值-可能为nil或空数组。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入 <code>interrobang</code> 运算符 <code>!?</code>。 我们定义了此运算符，以便在失败的展开操作时断言，并在断言在释放模式下未触发时替换默认值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> !?</span><br><span class="line"><span class="function"><span class="keyword">func</span> !?&lt;T: ExpressibleByIntegerLiteral&gt;</span></span><br><span class="line"><span class="function"><span class="params">(wrapped: T?, failureText: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) -&gt; <span class="type">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(wrapped != <span class="literal">nil</span>, failureText()) <span class="keyword">return</span> wrapped ?? <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，以下内容将在调试时声明，但在发行版中显示0：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lets=<span class="string">"20"</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="type">Int</span>(s) !? <span class="string">"Expecting integer, got \"\(s)\""</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他字面可转换协议的重载可以广泛覆盖可以默认：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> !?&lt;T: ExpressibleByArrayLiteral&gt;</span></span><br><span class="line"><span class="function"><span class="params">(wrapped: T?, failureText: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) -&gt; <span class="type">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(wrapped != <span class="literal">nil</span>, failureText()) <span class="keyword">return</span> wrapped ?? []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> !?&lt;T: ExpressibleByStringLiteral&gt;</span></span><br><span class="line"><span class="function"><span class="params">(wrapped: T?, failureText: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) -&gt; <span class="type">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(wrapped != <span class="literal">nil</span>, failureText())</span><br><span class="line">    <span class="keyword">return</span> wrapped ?? <span class="string">""</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于要提供其他显式默认值的情况，或者对于非标准类型，可以定义一个带有一对的版本-默认值和错误文本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> !?&lt;T&gt;<span class="params">(wrapped: T?,</span></span></span><br><span class="line"><span class="function"><span class="params">nilDefault: @autoclosure <span class="params">()</span></span></span> -&gt; (value: <span class="type">T</span>, text: <span class="type">String</span>)) -&gt; <span class="type">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(wrapped != <span class="literal">nil</span>, nilDefault().text) <span class="keyword">return</span> wrapped ?? nilDefault().value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asserts in debug, returns 5 in release.</span></span><br><span class="line"><span class="type">Int</span>(s) !? (<span class="number">5</span>, <span class="string">"Expected integer"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于可选的链接方法调用返回 <code>Void</code> 的方法 <code>return Void ?</code> ，因此你也可以编写非通用版本来检测可选链何时变为 <code>nil</code> ，从而导致无操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> !?<span class="params">(wrapped: <span class="params">()</span></span></span>?, failureText: <span class="meta">@autoclosure</span> () -&gt; <span class="type">String</span>) &#123; </span><br><span class="line">    <span class="built_in">assert</span>(wrapped != <span class="literal">nil</span>, failureText())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> output: <span class="type">String?</span> = <span class="literal">nil</span></span><br><span class="line">output?.write(<span class="string">"something"</span>) !? <span class="string">"Wasn't expecting chained nil here"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有三种方法可以停止执行。 第一个选项 <code>fatalError</code> 接收消息并无条件停止执行。 第二个选项 <code>assert</code> ，检查条件和消息，如果条件评估为 <code>false</code> ，则停止执行。 在发行版本中，断言被删除-不检查条件（并且永远不会停止执行）。 第三个选项是前置条件，它具有与 <code>assert</code> 相同的接口，但是不会从发行版本中删除，因此，如果条件评估为 <code>false</code> ，则会停止执行。</p><h1 id="隐式展开的-Optionals"><a href="#隐式展开的-Optionals" class="headerlink" title="隐式展开的 Optionals"></a><strong>隐式展开的 Optionals</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没错：<strong>隐式解包</strong>的可选对象—带有感叹号的类型，例如 <code>UIView！</code> -仍然是可选的，尽管在你使用它们时会自动将其自动展开。既然我们知道强制拆包将使你的应用程序永远无效，那么为什么你会使用它们呢？好吧，确实有两个原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因1：暂时是因为你正在调用未经审计的可空性的<code>Objective-C</code>代码，或者是正在调用没有<code>Swift</code>特定注释的<code>C库</code>。</p><p>v甚至存在隐式展开的可选参数的唯一原因是使与<code>Objective-C</code>和<code>C</code>的互操作性更容易。当然，在第一天开始针对现有的<code>Objective-C</code>代码库编写<code>Swift</code>时，任何返回引用的<code>Objective-C</code>方法都将转换为隐式解包的可选方法。由于在<code>Objective-C</code>的整个生命周期中，都没有办法表明引用是可为空的，因此除了假定任何返回引用的调用都可能返回<code>nil</code>引用之外，别无选择。但是实际上很少有<code>Objective-C API</code>返回<code>null</code>引用，因此自动将它们公开为可选参数会非常令人讨厌。由于每个人都习惯于处理<code>Objective-C对象</code>的<code>“可能为空”</code>的世界，因此隐式展开的可选对象是一个合理的折衷方案。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，你会在未经审核的桥接<code>Objective-C</code>代码中看到它们。但是，你永远都不会看到纯粹的本机<code>Swift API</code>返回<strong>隐式可选</strong>（或将其传递给回调）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因2：因为在定义的时间段内，值非常短地为<code>nil</code>，然后再也不会为<code>nil</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最常见的情况是两阶段初始化。在你的类准备就绪时，隐式包装的可选变量都将具有值。这就是 <code>Xcode / Interface Builder</code> 在视图控制器生命周期中使用它们的原因：在<code>Cocoa</code>和<code>Cocoa Touch</code>中，视图控制器延迟地创建其视图，因此存在一个时间窗口-在初始化视图控制器之后但在加载视图之前—当视图对象尚未创建时，其出口引用。</p><h1 id="隐含的选择性行为"><a href="#隐含的选择性行为" class="headerlink" title="隐含的选择性行为"></a><strong>隐含的选择性行为</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管 <strong>隐式解包</strong> 的可选变量通常表现为非可选值，但你仍然可以使用大多数拆包技术像可选变量一样安全地处理它们— <code>chaining</code>，<code>nil-coalescing</code>，<code>映射</code>，或将它们与nil进行比较都可以相同：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s: <span class="type">String!</span> = <span class="string">"Hello"</span> </span><br><span class="line">s?.isEmpty <span class="comment">// Optional(false) </span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> s = s &#123; <span class="built_in">print</span>(s) &#125; <span class="comment">// Hello </span></span><br><span class="line">s=<span class="literal">nil</span></span><br><span class="line">s ?? <span class="string">"Goodbye"</span> <span class="comment">// Goodbye</span></span><br></pre></td></tr></table></figure><h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a><strong>概括</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em>Optional</em></strong> 被吹捧为<code>Swift</code>编写更安全代码的最大功能之一，我们当然同意。但是，如果你考虑一下，真正的突破不是可选的，而是非可选的。几乎每种主流语言都有 <code>“null”</code> 或 <code>“nil”</code> 的概念；他们大多数人所没有的就是能够将值声明为<code>“永不零”</code>。或者，或者，某些类型（如<code>Objective-C</code>或<code>Java</code>中的非类类型）是<code>“总是非零”</code>，这迫使开发人员想出魔术值来表示缺少值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其输入和输出经过精心设计并考虑到可选元素的<code>API</code>更具表现力，更易于使用；由于类型包含更多信息，因此无需参考文档。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在本章中展示的所有解包技术都是<code>Swift</code>试图使桥接可选值和非可选值的两个世界尽可能轻松地进行的尝试。你应该使用哪种方法通常取决于个人喜好。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Advanced Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Advanced Swift </tag>
            
            <tag> Swift 5.0 </tag>
            
            <tag> Optionals </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Swift系列(二): Build-in Collections</title>
      <link href="/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%8C):%20Build-in%20Collections/"/>
      <url>/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%8C):%20Build-in%20Collections/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在任何编程语言中，元素的 <code>集合</code> 都是最重要的数据类型之一。 对各种容器的良好语言支持对程序员的工作效率和幸福感有很大影响。  <code>Swift</code> 特别强调序列和集合-标准库的大部分内容都专门针对该主题，因此我们有时会觉得它处理的很少。 生成的模型比你可能习惯于其他语言的模型具有更高的 <code>可扩展性</code> ，但是它也相当复杂。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本章中，我们将介绍 <code>Swift</code> 附带的主要 <code>集合类型</code> ，重点是如何有效地和惯用地使用它们。 在本书后面的 <code>“集合协议”</code> 一章中，我们将爬上 <code>抽象阶梯</code> ，并了解 <code>标准库</code> 中的 <code>集合协议</code> 如何工作。</p><h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a><strong>Arrays</strong></h1><h2 id="Arrays-and-Mutability"><a href="#Arrays-and-Mutability" class="headerlink" title="Arrays and Mutability"></a><strong><em>Arrays and Mutability</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>数组</code> 是 <code>Swift</code> 中最常见的 <code>集合</code> 。  <code>数组</code> 是所有具有 <strong><code>相同类型的元素的有序容器</code></strong> ，它提供对每个元素的随机访问。 例如，要创建一个数字数组，我们可以编写以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The Fibonacci numbers</span></span><br><span class="line"><span class="keyword">let</span> fibs = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果尝试修改上面定义的数组（例如，使用 <code>append（_ :)</code> ），则会出现编译错误。 这是因为使用 <code>let</code> 将数组定义为常量。 在很多情况下，这是正确的做法。 它可以防止我们意外更改数组。 如果我们希望数组为变量，则必须使用 <code>var</code> 进行定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutableFibs = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以轻松地附加单个元素或元素序列：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutableFibs.append(<span class="number">8</span>) </span><br><span class="line">mutableFibs.append(contentsOf: [<span class="number">13</span>, <span class="number">21</span>]) </span><br><span class="line">mutableFibs <span class="comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;区分 <code>var</code> 和 <code>let</code> 有很多好处。 用 <code>let</code> 定义的常数是 <code>不可变的</code> ，因此更容易推论。 什么时候<br>你读了一个类似 <code>let fibs= ...</code>的声明，你知道 <code>fibs</code> 的值将永远不会改变-不变性由编译器强制执行。 这在阅读时有很大帮助<br>通过代码。 但是，请注意，这仅适用于具有 <strong>值语义</strong> 的类型。 包含对类实例的引用的 <code>let变量</code> 可确保该引用永远不会改变，即，你不能将其他对象分配给该变量。 但是，参考指向的对象可以更改。 我们将在 <a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%94):%20Structs%20and%20Classes/"><strong><em><code>“结构和类”</code></em></strong></a> 一章中详细介绍这些差异。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <code>标准库</code> 中的所有集合类型一样， <code>数组</code> 也具有 <strong>值语义</strong> 。 将现有数组分配给另一个变量时，将复制数组内容。 例如，在以下代码片段中， <code>x</code> 从未修改：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line"><span class="keyword">var</span> y=x </span><br><span class="line">y.append(<span class="number">4</span>)</span><br><span class="line">y <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line">x <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语句 <code>var y = x</code> 复制了 <code>x</code> ，因此将 <code>4</code> 附加到 <code>y</code> 不会更改 <code>x-x</code> 的值仍为[1、2、3]。 当你将数组传递给函数时，也会发生同样的事情。 该函数接收数组的本地副本，并且所做的任何更改都不会影响调用者。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将此与 <code>Foundation</code> 中 <code>NSArray</code> 采取的可变性方法进行比较。  <code>NSArray</code> 没有变异方法-要变异数组，你需要一个 <code>NSMutableArray</code> 。 但是，仅仅因为你拥有一个不变的 <code>NSArray引用</code> 并不意味着该数组无法在你的下方进行改变：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">NSMutableArray</span>(array: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) </span><br><span class="line"><span class="comment">// I don't want to be able to mutate b. </span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">NSArray</span> = a</span><br><span class="line"><span class="comment">// But it can still be mutated — via a. </span></span><br><span class="line">a.insert(<span class="number">4</span>, at: <span class="number">3</span>)</span><br><span class="line">b <span class="comment">// ( 1, 2, 3, 4 )</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正确的写法是在分配后手动创建一个副本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">NSMutableArray</span>(array: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) </span><br><span class="line"><span class="comment">// I don't want to be able to mutate d. </span></span><br><span class="line"><span class="keyword">let</span> d = <span class="built_in">c</span>.copy() <span class="keyword">as</span>! <span class="type">NSArray</span></span><br><span class="line"><span class="built_in">c</span>.insert(<span class="number">4</span>, at: <span class="number">3</span>) </span><br><span class="line">d <span class="comment">// ( 1, 2, 3 )</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的示例中，很明显，我们需要进行复制-毕竟是可变的。 但是，当在 <code>方法和函数</code> 之间传递数组时，这并不总是那么容易看到。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中，只有一种数组类型，而 <code>可变性</code> 是通过使用 <code>var</code> 而不是 <code>let声明</code> 来控制的。 但是没有引用共享-当你使用 <code>let声明</code> 第二个数组时，可以确保它永远不会改变。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;制作如此多的副本可能会造成性能问题，但是实际上， <code>Swift标准库</code> 中的所有集合类型都是使用称为 <code>写时复制的技术</code> 实现的，<strong>该技术可确保仅在必要时才复制数据</strong>。 因此，在我们的示例中，<strong>x和y共享内部存储</strong>，直到调用点 <strong><code>y.append</code></strong> 。 在“结构和类”一章中，我们将更深入地研究 <strong>值语义</strong> ，包括如何为自己的类型实现<strong>写时复制</strong>：</p><h2 id="Array-Indexing"><a href="#Array-Indexing" class="headerlink" title="Array Indexing"></a><strong><em>Array Indexing</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift Array</code> 可提供你期望的所有常规操作，例如 <code>isEmpty</code> 和 <code>count</code> 。 数组还允许通过下标直接访问特定索引处的元素，例如 <code>fibs[3]</code> 。 请记住，在通过下标获取元素之前，需要确保索引在范围之内。 提取索引3的元素，最好确保数组中至少包含四个元素。 否则，你的程序将崩溃，<br>即因致命错误而中止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 有很多使用数组的方式，而无需你计算索引：</p><ul><li>→是否希望遍历整个数组？ 用于数组中的x</li><li>→是否想对数组的第一个元素进行总体评估？ 对于array.dropFirst（）中的x</li><li>→是否想对所有最后五个要素进行评估？ 对于array.dropLast（5）中的x</li><li>→想要对数组中的所有元素进行编号？ 用于array.enumerated（）中的（num，element）</li><li>→是否想找到特定元素的位置？<br>如果让idx =array.􏰀rstIndex{someMatchingLogic（$ 0）}</li><li>→想要在数组中转换所有元素？ array.map {someTransformation（$ 0）}</li><li>→是否只想获取与特定标准匹配的元素？ array.􏰀lter{someCriteria（$ 0）}</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 希望阻止你进行 索引数学运算 的另一个迹象是，从 <code>Swift 3</code> 的语言中删除了传统的C风格的 <code>for循环</code> 。手动摆弄索引会产生很多漏洞，因此通常最好避免使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是有时你必须使用索引。 对于数组索引，期望的是，当你这样做时，你会非常仔细地考虑过索引计算背后的逻辑。 因此必须解开下标操作的值可能是过大的<br>—这意味着你不信任你的代码。 但是你确实有可能信任代码，所以你可能会求助于对结果进行强制包装，因为你知道索引必须有效。 这是（a）令人讨厌的，并且（b）是要养成的不良习惯。 当强制展开成为常规操作时，最终你将滑倒并强制展开你不想要的东西。 因此，为避免这种习惯成为常规，数组不给你选择的余地。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管可以说对下标操作进行响应以控制崩溃的下标操作可以称为不安全，但这只是安全性的一个方面。 就内存安全而言，下标是绝对安全的-标准库集合始终执行边界检查，以防止越界索引进行未经授权的内存访问。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他操作的行为有所不同。 第一个和最后一个属性返回一个可选值，如果数组为空，则为 <code>nil</code> 。  <code>first</code> 等于 <code>isEmpty</code> 吗？ 无：<code>self[0]</code>。 同样，如果你在空数组上调用 <code>removeLast</code> 方法，则会捕获该方法，而如果数组不为空，则 <code>popLast</code> 将仅删除并返回最后一个元素，否则它将不执行任何操作并返回 <code>nil</code> 。 你要使用哪一个取决于你的用例。 当你将数组作为堆栈使用时，你可能总是希望结合使用检查空和删除最后一个条目。 另一方面，如果你已经知道数组是否为空，那么处理可选对象就很麻烦了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本章的后面，当我们谈论字典时，我们将再次遇到这些折衷。 此外，有一整章专门介绍可选内容。</p><h2 id="转换数组"><a href="#转换数组" class="headerlink" title="转换数组"></a><strong><em>转换数组</em></strong></h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a><strong><em>map</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常需要对数组中的每个值执行转换。 每个程序员都写过类似的代码数百次：创建一个新的数组，遍历现有数组中的所有元素，对一个元素执行操作，并将该操作的结果附加到新数组中。 例如，以下代码对整数数组求平方：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> squared: [<span class="type">Int</span>] = [] </span><br><span class="line"><span class="keyword">for</span> fib <span class="keyword">in</span> fibs &#123;</span><br><span class="line">    squared.append(fib * fib) </span><br><span class="line">&#125;</span><br><span class="line">squared <span class="comment">// [0, 1, 1, 4, 9, 25]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 数组具有 <code>map方法</code> ，该方法从函数世界中采用编程。 使用 <strong><em>map</em></strong> 的操作完全相同：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squares = fibs.<span class="built_in">map</span>&#123; fib <span class="keyword">in</span> fib*fib &#125;</span><br><span class="line">squares <span class="comment">// [0, 1, 1, 4, 9, 25]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此版本具有三个主要优点。当然要短一些。错误的余地也更少了。但更重要的是，它更清楚：所有杂物都已消除。一旦习惯了无所不在地查看和使用 map ，它就可以作为信号-你看到 map 后，便会立即知道发生了什么：<strong>一个函数将应用于每个元素，并返回经过转换的元素的新数组</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不再需要使用 <code>var</code> 来声明平方，因为我们不再对它进行变异-它会从完整形成的 map 中提供，因此我们可以在适当的情况下使用 <code>let声明平方</code> 。并且由于可以从传递给 <code>map</code> 的函数中推断内容的类型，因此不再需要明确键入 <code>squares</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>map方法</code> 并不难编写-只是将for循环的样板部分包装为通用函数的问题。这是一种可能的实现方式（尽管在Swift中，它实际上是 <code>Sequence协议</code> 的扩展，我们将在Collection Protocols一章中介绍）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">T</span>] = [] </span><br><span class="line">    result.reserveCapacity(<span class="built_in">count</span>) </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span>&#123;</span><br><span class="line">        result.append(transform(x)) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Element</code> 是数组包含的任何类型的 <code>通用占位符</code> ，而 <code>T</code> 是表示元素转换结果的 <code>新占位符</code> 。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>map</code> 功能本身并不关心 <code>元素</code> 和 <code>T</code> 是什么。 他们可以是任何东西。 转换元素的具体 <code>类型T</code> 由 <code>调用者传递给映射的转换函数的返回类型定义</code> 。 有关通用参数的详细信息，请参见 <code>“通用”</code> 一章。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确实，此方法的签名应为<code>func map &lt;T&gt;（__ transform：（Element）throws-&gt; T）rethrows-&gt; [T]</code>，表示映射将转换功能可能抛出的任何错误转发给调用者。 我们将在 <code>“错误”</code> 一章中对此进行详细介绍，但是在这里，为简单起见，我们省略了错误处理注释。 如果需要，你可以在 <code>GitHub</code> 的 <code>Swift</code> 存储库中检出 <code>Sequence.map</code> 的源代码。</p></blockquote><h3 id="用函数参数化行为"><a href="#用函数参数化行为" class="headerlink" title="用函数参数化行为"></a><strong><em>用函数参数化行为</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使你已经熟悉 <code>map</code> ，也请花点时间考虑一下 <code>map</code> 的实现。 是什么使它如此通用却如此有用？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>map</code> 设法将 样板 与每次调用的功能区分开来，即每次调用之间都没有变化，即逻辑上如何精确转换每个元素。 它通过调用者提供的参数来完成此操作： <code>转换函数</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在整个标准库中都可以找到这种 参数化行为模式 。 例如，在 <code>Array</code> （以及其他种类的集合）上有十几个单独的方法，它们带有一个函数来自定义其行为：</p><ul><li>→ <strong><code>map</code></strong> and <strong><code>flatMap</code></strong> - 转换元素</li><li>→ <strong><code>filter</code></strong> - 仅包含某些元素</li><li>→ <strong><code>allSatisfy</code></strong> — 满足条件的测试要素</li><li>→ <strong><code>reduce</code></strong> — 将元素折叠为合计值</li><li>→ <strong><code>forEach</code></strong> —访问</li><li>→ <strong><code>sort（by :)</code></strong>， <strong><code>sorted（by :</code></strong>) ， <strong><code>lexicographicallyPrecedes（_：by :)</code></strong> 和 <strong><code>partition（by :)</code></strong> —重新排列元素</li><li>→ <strong><code>firstIndex（where :)</code></strong>，<strong><code>lastIndex（where :)</code></strong>，<strong><code>first（where :)</code></strong>，<strong><code>last（where :)</code></strong>和 <strong><code>contains（where :)</code></strong>  — 元素是否存在？</li><li>→ <strong><code>min（by :)</code></strong> 和 <strong><code>max（by :)</code></strong> -查找最小的 <strong><code>mumormaximumo</code></strong> 元素</li><li>→ <strong><code>elementsEqual（_：by :)</code></strong> 和 <strong><code>starts（with：by :)</code></strong>  — 比较元素到另一个元素<br>数组</li><li>→ <strong><code>split（whereSeparator :)</code></strong> - 将元素分解为多个数组</li><li>→ <strong><code>prefix（while :)</code></strong>- 只要条件成立，就从头开始采集元素</li><li>→ <strong><code>drop（while :)</code></strong> -在条件变为真之前丢弃元素，然后返回其余元素（类似于 <code>prefix</code> ，但这返回相反的值）</li><li>→ <strong><code>removeAll（where :)</code></strong> - 删除符合条件的要素</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有这些功能的目标是消除代码中不感兴趣的部分的混乱情况，例如创建新数组和对源数据进行 for循环 。取而代之的是，用一个描述正在做什么的单词来代替混乱。这将重要的代码（程序员想要表达的逻辑）带到了最前沿。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中一些功能具有默认行为。  sort 会在元素具有可比性时按升序排序（除非另行指定），并且只要元素是等价的， contains 就可以接受一个值进行检查。这些默认值有助于使代码更具可读性。升序排序是很自然的，因此 <code>array.sort（）</code> 的含义很直观，而 <code>array.firstIndex（of：“ foo”）</code> 比 <code>array.firstIndex{$ 0 ==“ foo”}</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在每种情况下，这些只是常见情况的简写。元素不必具有可比性或相等性，也不必比较整个元素-你可以按年龄对一组人进行排序<code>（people.sort {$ 0.age &lt;$ 1.age}）</code>或检查是否该数组包含未成年人<code>（people.contains {$ 0.age &lt;18}）</code>。你还可以比较元素的某种变换。例如，公认的低效率不区分大小写和语言环境的排序可以通过 <code>people.sort {$ 0.name.uppercased（）&lt;$ 1.name.uppercased（）</code>} 执行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有其他用途相似的功能，它们也需要指定其行为的功能，但这些功能不在标准库中。你可以轻松地自己定义它们（并且可以尝试）：</p><ul><li>→ <strong><code>accumulate</code></strong> - 将组合元素合并到一个运行值数组中（减少，但返回每个临时组合的数组）</li><li>→ <strong><code>count（where :)</code></strong> - 计算要匹配的元素数（这应该是Swift 5.0标准库的一部分，但是由于与count属性的名称冲突而延迟；不过可能会在后续发行版中重新引入）</li><li>→ <strong><code>indexs（where :)</code></strong> - 返回与条件匹配的条件（类似于 <code>firstIndex（where :)</code>，但它并不止于第一个）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果发现自己遍历一个数组以在代码中多次执行相同或相似的任务，请考虑为 <code>Array</code> 编写一个简短的扩展。例如，以下代码将数组拆分为相邻的相等元素的组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array: [<span class="type">Int</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> result: [[<span class="type">Int</span>]] = array.isEmpty ? [] : [[array[<span class="number">0</span>]]]</span><br><span class="line"><span class="keyword">for</span> (previous, current) <span class="keyword">in</span> <span class="built_in">zip</span>(array, array.<span class="built_in">dropFirst</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> previous == current &#123; </span><br><span class="line">        result[result.endIndex-<span class="number">1</span>].append(current)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        result.append([current])</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">result <span class="comment">// [[1], [2, 2, 2], [3], [4, 4]]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过根据应用程序之间不同的逻辑（决定在何处拆分数组）提取成对在相邻元素对中成对循环遍历数组的代码来形式化此算法。 我们使用函数参数来允许调用者自定义后者：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(<span class="keyword">where</span> condition: <span class="params">(Element, Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [[<span class="type">Element</span>]] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [[<span class="type">Element</span>]] = array.isEmpty ? [] : [[<span class="keyword">self</span>[<span class="number">0</span>]]] </span><br><span class="line">    <span class="keyword">for</span> (previous, current) <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="keyword">self</span>, <span class="keyword">self</span>.<span class="built_in">dropFirst</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> condition(previous, current) &#123;</span><br><span class="line">            result.append([current]) &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result[result.endIndex-<span class="number">1</span>].append(current) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这使我们可以将 <code>for循环</code> 替换为以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parts = array.<span class="built_in">split</span> &#123; $<span class="number">0</span> != $<span class="number">1</span> &#125;</span><br><span class="line">parts <span class="comment">// [[1], [2, 2, 2], [3], [4, 4]]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者，在这种特殊情况下，我们甚至可以写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parts2 = array.<span class="built_in">split</span>(<span class="keyword">where</span>: !=)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这具有我们为 <code>map</code> 描述的所有相同优势。 使用 <code>split（where :)</code> 的示例比使用 <code>for循环</code> 的示例更具可读性； 即使 <code>for循环</code> 很简单，你仍然必须在脑子里遍历循环，这是一个小的精神负担。 使用 <code>split（where :)</code> 引入错误的机会更少（例如，意外忘记了数组为空的情况），它允许你使用 <code>let</code> 而不是 <code>var声明</code> 结果变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本书的后面，我们将详细介绍扩展集合和使用功能。</p><h3 id="Mutation-and-Stateful-Closures"><a href="#Mutation-and-Stateful-Closures" class="headerlink" title="Mutation and Stateful Closures"></a><strong><em>Mutation and Stateful Closures</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历数组时，可以使用 <code>map</code> 产生副作用（例如，将元素插入到一些查找表中）。 我们不建议你这样做。 看一下以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="built_in">map</span> &#123; </span><br><span class="line">    item <span class="keyword">in</span> table.insert(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这在看起来像数组转换的构造中隐藏了副作用（查找表的 <code>mutation</code> ）。 如果你看到以上类似的内容，那么很明显<br>使用普通的 <code>for循环</code> 而不是诸如 <code>map之类</code> 的函数的情况。 在这种情况下， <code>forEach方法</code> 也比 <code>map</code> 更合适，但是它有其自身的问题，因此我们稍后再讨论 <code>forEach</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行副作用不同于故意赋予封闭局部状态，这是一种特别有用的技术。 除了有用之外， <code>闭包</code> （可以捕获超出范围范围内的变量并对其进行改变的函数）的强大功能也是与 <code>高阶函数</code> 结合使用时的强大工具。 例如，可以使用 <code>map</code> 和 <code>有状态</code> 的 <code>闭包</code> 来实现上述累加函数，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">accumulate</span>&lt;Result&gt;<span class="params">(<span class="number">_</span> initialResult: Result,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> nextPartialResult: <span class="params">(Result, Element)</span></span></span> -&gt; <span class="type">Result</span>) -&gt; [<span class="type">Result</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> running = initialResult <span class="keyword">return</span> <span class="built_in">map</span> &#123; next <span class="keyword">in</span></span><br><span class="line">            running = nextPartialResult(running, next)</span><br><span class="line">            <span class="keyword">return</span> running </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这将创建一个临时变量来存储运行值，然后在计算过程中使用 <code>map</code> 创建一个运行值数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].accumulate(<span class="number">0</span>, +) <span class="comment">// [1, 3, 6, 10]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，此代码假定 <code>map</code> 在整个序列上按顺序执行其转换。 就我们上面的 <code>map</code> 而言，确实如此。 但是有些实现可能会无序地转换序列，例如，同时执行元素转换的实现。 <code>map</code> 的官方标准库版本没有指定是否按顺序转换序列，尽管看起来可以这么做。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong><em>filter</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个非常常见的操作是获取一个数组并创建一个仅包含符合特定条件的元素的新数组。 过滤器方法捕获在数组上循环并选择与给定谓词匹配的元素的模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">nums.<span class="built_in">filter</span> &#123; num <span class="keyword">in</span> num % <span class="number">2</span> == <span class="number">0</span> &#125; <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以将 <code>Swift</code> 的速记符号用于闭包表达式的参数，以使其更短。 不用命名 <code>num参数</code> ，我们可以这样编写上面的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums.<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125; <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于非常短的 <code>闭包</code> ，这可能更具可读性。 如果 <code>闭包</code> 更为复杂，则像我们之前所做的那样，显式命名几乎总是一个更好的主意。 这实际上是个人喜好问题，一目了然地选择更易读的选项。 一个好的经验法则是：如果闭包整齐地适合一行，则速记参数名称是一个很好的选择。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过组合 <code>map</code> 和 <code>filter</code> ，我们可以在数组上编写很多操作，而不必引入单个中间变量。 结果代码将变得更短，更易于阅读。 例如，要查找所有小于100的偶数平方，我们可以映射范围 <code>1..&lt;10</code> 以便平方其成员，然后可以滤除所有奇数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>..&lt;<span class="number">10</span>).<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;.<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125; <span class="comment">// [4, 16, 36, 64]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>filter</code> 的实现类似于 <code>map</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(<span class="number">_</span> isIncluded: <span class="params">(Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> result: [<span class="type">Element</span>] = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span> <span class="keyword">where</span> isIncluded(x) &#123;</span><br><span class="line">            result.append(x) </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个快速的性能提示：如果你发现自己写了如下内容，那就停下来！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bigArray.<span class="built_in">filter</span> &#123; someCondition &#125;.<span class="built_in">count</span> &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>filter</code> 将创建一个全新的数组并处理该数组中的每个元素。 但这是不必要的。 这段代码只需要检查一个元素是否匹配，在这种情况下， <code>contains（where :)</code> 就可以完成工作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bigArray.<span class="built_in">contains</span> &#123; someCondition &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这要快得多，有两个原因：它不会为过滤的元素创建一个全新的数组，只是为了对它们进行计数，并且它会在找到第一个匹配项后立即退出。 通常，仅在需要所有结果时才使用 <code>filter</code> 。</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><strong><em>reduce</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>map</code> 和 <code>filter</code> 都采用一个数组，并产生一个新的修改后的数组。 但是，有时你可能希望将所有元素组合为一个新值。 例如，总结所有元素，我们可以编写以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibs = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> fibs &#123;</span><br><span class="line">    total = total + num </span><br><span class="line">&#125;</span><br><span class="line">total <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>reduce方法</code> 采用这种模式，并抽象出两个部分：初始值（在这种情况下为零），以及组合中间值（总计）和元素（num）的函数。 使用 <code>reduce</code> ，我们可以编写如下相同的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = fibs.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; total, num <span class="keyword">in</span> </span><br><span class="line">    total + num </span><br><span class="line">&#125; <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运算符也是函数，因此我们也可以编写相同的示例，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fibs.<span class="built_in">reduce</span>(<span class="number">0</span>, +) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>reduce</code> 的输出类型不必与元素类型相同。 例如，如果要将整数列表转换为字符串，每个数字后跟一个逗号和一个空格，则可以执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fibs.<span class="built_in">reduce</span>(<span class="string">""</span>) &#123; str, num <span class="keyword">in</span> </span><br><span class="line">    str + <span class="string">"\(num), "</span> </span><br><span class="line">&#125; <span class="comment">// 0, 1, 1, 2, 3, 5,</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是 <code>reduce</code> 的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;Result&gt;<span class="params">(<span class="number">_</span> initialResult: Result,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">_</span> nextPartialResult: <span class="params">(Result, Element)</span></span></span> -&gt; <span class="type">Result</span>) -&gt; <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = initialResult </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        result = nextPartialResult(result, x) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个性能提示： <code>reduce</code> 非常灵活，通常会看到它用于构建阵列和执行其他操作。 例如，你可以仅使用 <code>reduce</code> 来实现 <code>map</code> 和 <code>filter</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map2</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduce</span>([]) &#123;</span><br><span class="line">        $<span class="number">0</span> + [transform($<span class="number">1</span>)]</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter2</span><span class="params">(<span class="number">_</span> isIncluded: <span class="params">(Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Element</span>] &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduce</span>([]) &#123;</span><br><span class="line">        isIncluded($<span class="number">1</span>) ? $<span class="number">0</span> + [$<span class="number">1</span>] : $<span class="number">0</span> &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这很漂亮，它的好处是不需要那些讨厌的命令循环。 但是 <code>Swift</code> 不是 <code>Haskell</code> ， <code>Swift数组</code> 也不是列表。 这里发生的事情是，每次执行合并功能时，都会通过将转换后的元素或包含的元素附加到前一个元素来创建一个全新的数组。 这意味着这两个实现都是 <code>O（n2）</code> ，而不是 <code>O（n）</code> -随着数组长度的增加，这些函数所花费的时间成倍增加。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有另一个 <code>reduce</code> 的版本，它的类型不同。 更具体地说，用于组合中间结果和元素的函数将 <code>Result</code> 作为 <code>inout</code> 参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;Result&gt;<span class="params">(into initialResult: Result, <span class="number">_</span> updateAccumulatingResult:</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">(<span class="number">_</span> partialResult: <span class="keyword">inout</span> Result, Element)</span></span></span> <span class="keyword">throws</span> -&gt; () ) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将在 <code>“结构和类”</code> 一章中详细讨论 <code>inout参数</code> ，但是现在，将 <code>inout Result参数</code> 视为可变参数：我们可以在函数中对其进行修改。 这使我们能够以更有效的方式编写过滤器：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter3</span><span class="params">(<span class="number">_</span> isIncluded: <span class="params">(Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduce</span>(into: []) &#123; result, element <span class="keyword">in</span> </span><br><span class="line">            <span class="keyword">if</span> isIncluded(element) &#123;</span><br><span class="line">                result.append(element) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>inout</code> 时， 编译器 不必每次都创建一个新数组，因此 <code>filter</code> 的这个版本也是 <code>O(n)</code>。 当编译器内联调用 <code>reduce(into: _ :)</code> 时，生成的代码通常与使用 <code>for循环</code> 时相同。</p><h3 id="A-Flattening-map"><a href="#A-Flattening-map" class="headerlink" title="A Flattening map"></a><strong><em>A Flattening map</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，你想映射一个数组，其中转换函数将返回另一个数组而不是单个元素。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，假设我们有一个函数 <code>extractLinks</code> ，该函数接受 <code>Markdown文件</code> 并返回一个数组，其中包含文件中所有链接的 <code>URL</code> 。 函数签名如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractLinks</span><span class="params">(markdownFile: String)</span></span> -&gt; [<span class="type">URL</span>]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们有一堆 <code>Markdown文件</code> ，并且想要将所有文件中的链接提取到单个数组中，我们可以尝试编写诸如 <code>markdownFiles.map(extractLinks)</code> 之类的东西。 但这会返回包含 <code>URL</code> 的 <code>array of arrays</code> ：每个文件一个 <code>array of arrays</code> 。 现在，你可以执行映射，取回一个数组，然后调用 <code>join</code> 将结果展平为单个数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> markdownFiles: [<span class="type">String</span>] = <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> nestedLinks = markdownFiles.<span class="built_in">map</span>(extractLinks) </span><br><span class="line"><span class="keyword">let</span> links = nestedLinks.joined()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>flatMap方法</code> 将映射和展平这两个操作组合到一个步骤中。 因此 <code>markdownFiles.flatMap(extractLinks)</code> 将 <code>Markdown文件</code> 数组中的所有 <code>URL</code> 作为单个数组返回。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Map\flatMap</code> 的签名几乎与map相同，不同之处在于其转换函数返回一个数组。 该实现使用 <code>append（contentsOf :)</code> 而不是<code>append（_ :)</code>来展平结果数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> -&gt; [<span class="type">T</span>]) -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> result: [<span class="type">T</span>] = [] </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span>&#123;</span><br><span class="line">            result.append(contentsOf: transform(x)) </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>flatMap</code> 的另一个很好的用例是组合来自不同数组的元素。 要获取两个数组中所有可能的元素对，请在一个数组上使用 <code>flatMap</code> ，然后在内部转换函数中在另一个数组上进行映射：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">"♠"</span>, <span class="string">"♥"</span>, <span class="string">"♣"</span>, <span class="string">"♦"</span>]</span><br><span class="line"><span class="keyword">let</span> ranks = [<span class="string">"J"</span>, <span class="string">"Q"</span>, <span class="string">"K"</span>, <span class="string">"A"</span>]</span><br><span class="line"><span class="keyword">let</span> result = suits.flatMap &#123; suit <span class="keyword">in</span></span><br><span class="line">        ranks.<span class="built_in">map</span> &#123; rank <span class="keyword">in</span> (suit, rank)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[("♠", "J"), ("♠", "Q"), ("♠", "K"), ("♠", "A"), ("♥", "J"), ("♥",</span></span><br><span class="line"><span class="comment">"Q"), ("♥", "K"), ("♥", "A"), ("♣", "J"), ("♣", "Q"), ("♣", "K"),</span></span><br><span class="line"><span class="comment">("♣", "A"), ("♦", "J"), ("♦", "Q"), ("♦", "K"), ("♦", "A")]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="使用-forEach-进行迭代"><a href="#使用-forEach-进行迭代" class="headerlink" title="使用 forEach 进行迭代"></a><strong><em>使用 forEach 进行迭代</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要讨论的最后一个操作是 <code>forEach</code> 。 它几乎像 <code>for循环</code> 一样工作：传入的函数对序列中的每个元素执行一次。 与 <code>map</code> 不同， <code>forEach</code> 不会返回任何内容-它专门用于产生副作用。 首先，以机械方式将循环替换为 <code>forEach</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#123; </span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach &#123; element <span class="keyword">in</span> </span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这不是一个大的胜利，但是如果你要执行的操作是对集合中每个元素的单个函数调用，则可能会很方便。 将函数名传递给 <code>forEach</code> 而不是 <code>传递闭包表达式</code> 可以导致代码更清晰，更简洁。 例如，如果你要在 <code>iOS</code> 上编写视图控制器，并想向主视图添加一个子视图数组，则可以只使用 <code>theViews.forEach（view.addSubview）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是， <code>for循环</code> 和 <code>forEach</code> 之间有一些细微的差异。 例如，如果 <code>for循环</code> 中包含 <code>return语句</code> ，则使用 <code>forEach重写</code> 它可以显着改变代码的行为。 考虑以下示例，该示例是使用带 <code>where条件</code> 的 <code>for循环</code> 编写的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">firstIndex</span><span class="params">(of element: Element)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="keyword">self</span>.<span class="built_in">indices</span> <span class="keyword">where</span> <span class="keyword">self</span>[idx] == element &#123; </span><br><span class="line">            <span class="keyword">return</span> idx</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们无法直接在 <code>forEach</code> 构造中复制 <code>where子句</code> ，因此我们可能会（错误地）使用 <code>flter重写</code> 此子句：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">firstIndex_foreach</span><span class="params">(of element: Element)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="built_in">indices</span>.<span class="built_in">filter</span> &#123; idx <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>[idx] == element &#125;.forEach &#123; idx <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> idx</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>forEach闭包</code> 内部的返回值不会从外部函数中返回； 它仅从闭包本身返回。 在这种情况下，我们可能已经找到了该错误，因为编译器会生成一条警告，指出未使用 return语句 的参数，但是你不应依赖它来发现所有此类问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，请考虑以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>..&lt;<span class="number">10</span>).forEach &#123; number <span class="keyword">in</span> </span><br><span class="line">    <span class="built_in">print</span>(number) </span><br><span class="line">    <span class="keyword">if</span> number&gt;<span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在还不能立即打印出输入范围内的所有数字。  <code>return</code> 语句不会中断循环； 而是从 <code>闭包</code> 中返回，从而开始 <code>forEachs</code> 实现中循环的新迭代。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在某些情况下，例如上面的 <code>addSubview</code> 示例， <code>forEach</code> 可能比 <code>for循环</code> 更好。 但是，由于返回的行为不明显，因此建议不要将 <code>forEach</code> 的大多数其他用法用于其他用途。 只需使用常规的 <code>for循环</code> 即可。</p><h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a><strong><em>数组切片</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了通过下标访问数组的单个元素（例如fibs[0]）之外，我们还可以通过下标检索一系列元素。 例如，要获取除数组的第一个元素以外的所有元素，我们可以执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> slice = fibs[<span class="number">1</span>...]</span><br><span class="line">slice <span class="comment">// [1, 1, 2, 3, 5]</span></span><br><span class="line">type(of: slice) <span class="comment">// ArraySlice&lt;Int&gt;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从第二个元素开始，这使我们获得了数组的一部分。 结果的类型是 <code>ArraySlice</code> ，而不是 <code>Array</code> 。  <code>ArraySlice</code> 是阵列视图。 它由原始数组支持，但仅提供切片视图。 因此，创建切片不会占据太多资源-不会复制数组元素。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/asbc-stp1.png" alt="ArraySlice"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ArraySlice类型</code> 具有与 <code>Array</code> 定义的方法相同的方法（因为两者都遵循相同的协议，最重要的是 <code>Collection</code> ），因此你可以像使用数组一样使用切片。 如果确实需要将切片转换为数组，则可以从切片中构造一个新数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArray = <span class="type">Array</span>(slice) </span><br><span class="line">type(of: newArray) <span class="comment">// Array&lt;Int&gt;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请务必记住，切片使用的索引与其基集合使用的索引相同，以引用特定的元素。 因此，切片索引不一定从零开始。 例如，我们上面创建的 <code>fibs[1 ...]</code> <code>slice</code> 的第一个元素在索引1处，错误地访问 <code>slice [0]</code> 将使我们的程序崩溃，并超出范围。 如果你使用索引，即使你要处理的是索引，我们也建议你始终以 <code>startIndex</code> 和 <code>endIndex属性</code> 为基础进行计算<br>普通数组，其中 <code>0</code> 和 <code>count-1</code> 也可以解决问题。 这种隐含的假设以后很容易打破，这太容易了。</p></br><h1 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a><strong>Dictionaries</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个关键数据结构是 <strong>字典</strong> 。 <strong>词典包含具有相应值的唯一键</strong>。 通过其键检索值平均需要花费固定时间，而在数组中搜索特定元素则随数组大小线性增长。 与数组不同，<strong>字典没有顺序</strong>。 在 <code>for循环</code> 中枚举 <code>键/值对</code> 的顺序是不确定的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以下示例中，我们将字典用作智能手机应用程序中虚构设置屏幕的模型数据。 屏幕由一系列设置组成，每个单独的设置都有一个名称（我们字典中的键）和一个值。 值可以是几种数据类型之一，例如文本，数字或布尔值。 我们使用带有关联值的枚举对此建模：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Setting</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> text(<span class="type">String</span>) </span><br><span class="line">    <span class="keyword">case</span> int(<span class="type">Int</span>) </span><br><span class="line">    <span class="keyword">case</span> bool(<span class="type">Bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> defaultSettings: [<span class="type">String</span>:<span class="type">Setting</span>] = [ </span><br><span class="line">    <span class="string">"Airplane Mode"</span>: .bool(<span class="literal">false</span>), </span><br><span class="line">    <span class="string">"Name"</span>: .text(<span class="string">"My iPhone"</span>),</span><br><span class="line">]</span><br><span class="line">defaultSettings[<span class="string">"Name"</span>] <span class="comment">// Optional(Setting.text("My iPhone"))</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们使用下标来获取设置的值。 字典查找始终返回一个可选值-当 <strong>指定的键不存在时，它返回 nil</strong> 。 将此与数组进行比较，这些<strong>数组通过使程序崩溃来响应越界访问</strong>。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字典还具有一个下标，该下标带有一个索引（与通常的下标带有一个键相反），这是它们与 <code>Collection协议</code> 一致的一部分。 与数组下标一样，使用无效索引调用该下标时会捕获陷阱。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种差异的基本原理是数组索引和字典键的用法非常不同。 我们已经看到，实际上很少需要直接使用数组索引的情况。 而且，如果这样做，通常会以某种方式直接从数组派生数组索引（例如，从 <code>0 ..&lt;array.count</code> 之类的范围）； 因此，使用<strong>无效索引是程序员错误</strong>。 另一方面，字典键通常来自某些来源，而不是要订阅的字典。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与数组不同，<strong>字典也是稀疏</strong> 的。 <strong><em>键“名称”下的值的存在不会告诉你键“地址”是否也存在</em></strong>。</p><h2 id="Mutating-Dictionaries"><a href="#Mutating-Dictionaries" class="headerlink" title="Mutating Dictionaries"></a><strong><em>Mutating Dictionaries</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像数组一样，使用 <code>let定义的字典是不可变的</code> ：<strong>不能 添加，删除或更改任何条目</strong> 。 就像数组一样，我们可以使用 <code>var定义可变的变体</code> 。 要从字典中删除值，我们可以使用下标将其设置为 nil 或 <code>调用removeValue（forKey :)</code>。 后者还会返回已删除的值，如果键不存在，则返回 <code>nil</code> 。 如果我们要使用不可变的字典并对其进行更改，则必须制作一个副本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userSettings = defaultSettings </span><br><span class="line">userSettings[<span class="string">"Name"</span>] = .text(<span class="string">"Jared's iPhone"</span>) </span><br><span class="line">userSettings[<span class="string">"Do Not Disturb"</span>] = .bool(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请再次注意， <code>defaultSettings</code> 的<strong>值没有改变</strong>。 与删除键一样，通过下标更新的替代方法是 <code>updateValue（_：forKey :)</code> 方法，该方法返回先前的值（如果有）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldName = userSettings</span><br><span class="line">.updateValue(.text(<span class="string">"Jane's iPhone"</span>), forKey: <span class="string">"Name"</span>)</span><br><span class="line">userSettings[<span class="string">"Name"</span>] </span><br><span class="line"><span class="comment">// Optional(Setting.text("Jane\'s iPhone")) </span></span><br><span class="line">oldName</span><br><span class="line"> <span class="comment">// Optional(Setting.text("Jared\'s iPhone"))</span></span><br></pre></td></tr></table></figure><h2 id="Useful-Dictionary-Methods"><a href="#Useful-Dictionary-Methods" class="headerlink" title="Useful Dictionary Methods"></a><strong><em>Useful Dictionary Methods</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们想将默认设置字典与用户已更改的任何自定义设置结合起来怎么办？ 自定义设置应覆盖默认设置，但生成的字典仍应包括尚未自定义的所有键的默认值。 本质上，我们<strong><em>要合并两个字典，其中要合并的字典会覆盖重复的键</em></strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字典有一个 <strong><code>merge（_：uniquingKeysWith :)方法</code></strong> ，该方法将要合并的键值对和一个指定如何将两个值与同一键组合的函数。 我们可以使用它来将一个字典合并为另一个字典，如以下示例所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> settings = defaultSettings</span><br><span class="line"><span class="keyword">let</span> overriddenSettings: [<span class="type">String</span>:<span class="type">Setting</span>] = [<span class="string">"Name"</span>: .text(<span class="string">"Jane's iPhone"</span>)] </span><br><span class="line">settings.merge(overriddenSettings, uniquingKeysWith: &#123; $<span class="number">1</span> &#125;)</span><br><span class="line">settings</span><br><span class="line"><span class="comment">// ["Name": Setting.text("Jane\'s iPhone"), "Airplane Mode": Setting.bool(false)]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的示例中，我们使用 <code>{$1}</code> 作为组合两个值的策略。 换句话说，如果键同时存在于设置和 <code>overriddenSettings</code> 中，则使用 <code>overriddenSettings</code> 中的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以从<code>（Key，Value）</code>对序列中构造一个新字典。 如果我们保证键是唯一的，则可以使用 <code>Dictionary（uniqueKeysWithValues :)</code>。 但是，如果我们有一个键可以多次存在的序列，则需要像上面一样提供一个函数来组合相同键的两个值。 例如，要计算元素在序列中出现的频率，我们可以映射每个元素，将其与1组合，然后从所得的元素频率对中创建字典。 如果我们遇到同一键的两个值（换句话说，如果我们多次看到相同的元素），则只需使用 <code>+</code> 将 <code>frequencies</code> 相加：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Hashable</span> </span>&#123; <span class="keyword">var</span> frequencies: [<span class="type">Element</span>:<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> frequencyPairs = <span class="keyword">self</span>.<span class="built_in">map</span> &#123; ($<span class="number">0</span>, <span class="number">1</span>) &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Dictionary</span>(frequencyPairs, uniquingKeysWith: +) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> frequencies = <span class="string">"hello"</span>.frequencies <span class="comment">// ["h": 1, "e": 1, "l": 2, "o": 1] frequencies.filter &#123; $0.value &gt; 1 &#125; // ["l": 2]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个有用的方法是在字典的值上映射。 因为 <code>Dictionary</code> 是一个 <code>Sequence</code> ，所以它已经具有一个产生数组的 <code>map方法</code> 。 但是，有时我们希望保持 <code>字典结构</code> 完整，只变换其值。 <code>mapValues方法</code> 执行此操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> settingsAsStrings = settings.mapValues &#123; setting -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="keyword">switch</span> setting &#123;</span><br><span class="line">    <span class="keyword">case</span> .text(<span class="keyword">let</span> text): <span class="keyword">return</span> text</span><br><span class="line">    <span class="keyword">case</span> .int(<span class="keyword">let</span> number): <span class="keyword">return</span> <span class="type">String</span>(number) </span><br><span class="line">    <span class="keyword">case</span> .bool(<span class="keyword">let</span> value): <span class="keyword">return</span> <span class="type">String</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">settingsAsStrings <span class="comment">// ["Name": "Jane\'s iPhone", "Airplane Mode": "false"]</span></span><br></pre></td></tr></table></figure><h2 id="Hashable-Requirement"><a href="#Hashable-Requirement" class="headerlink" title="Hashable Requirement"></a><strong><em>Hashable Requirement</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>字典是哈希表</strong>。字典根据密钥的 <code>hashValue</code> 在其<strong>基础存储阵列中为其分配位置</strong>。这就是为什么 <code>Dictionary</code> 要求其 <code>Key类型符合Hashable协议</code> 的原因。标准库中的所有基本数据类型（包括字符串，整数，浮点数和布尔值）都已经具备。此外，如果其他<strong>许多类型的元素是可哈希的，则它们会自动变为可哈希的，例如数组，集合和可选对象</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了保持性能，<strong>哈希表要求存储在其中的类型提供良好的哈希函数，不会产生太多冲突</strong>。编写出色的哈希函数以将其输入均匀地分布在整个整数范围内并不容易。幸运的是，我们几乎不需要自己做。在许多情况下，编译器都可以生成<code>Hashable一致性</code>，即使这不适用于特定类型，标准库也带有自定义类型可以插入的内置哈希函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于<strong>结构和枚举</strong>，只要它们本身由可<code>哈希类型</code>组成，<code>Swift</code>可以自动为我们合成<code>可哈希一致性</code>。如果一个结构的所有存储属性都是可哈希的，则该结构本身可以符合 <code>Hashable</code> ，而无需我们编写手动实现。类似地，仅包含可哈希散列的关联值的枚举可以遵循（没有关联值的枚举甚至符合Hashable，而无需明确声明该符合性）。这不仅可以节省初始实施工作，而且还可以在添加或删除属性时自动使实施保持最新。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你无法利用自动的 <code>Hashable综合功能</code> （因为你正在编写一个类，或者你的自定义结构具有一个或多个出于散列目的而应被忽略的存储属性），则首先需要将 <code>Equatable类型</code> 设置为 <code>Equatable</code> 。然后，你可以实现 <code>Hashable协议的hash（into :)</code> 要求（不建议使用旧的pre-Swift 4.2以前的实现hashValue属性的方法）。此方法接收一个 <code>哈希器</code> ，该哈希器包装通用 <code>哈希函数</code> 并在客户端将数据馈入哈希函数时捕获哈希函数的状态。哈希器具有一个 <code>combination方法</code> ，该方法接受任何可哈希值。你应该通过以下方式将所有类型的基本组件送入哈希器<br>让他们一一结合。基本组成部分是构成该类型实体的属性-你通常需要排除可以延迟重新创建的瞬态属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应使用相同的基本组件进行相等性检查，因为以下重要不变式必须成立：<strong>两个相等的实例（由==实现定义）必须具有相同的哈希值</strong>。反之则不成立：两个具有相同哈希值的实例不一定会相等地进行比较。考虑到只有有限数量的不同哈希值，而许多可哈希类型（如字符串）实际上具有无限基数，这是有道理的。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准库的通用哈希函数使用随机种子作为其输入之一。 换句话说，在每个程序执行时，字符串“abc”的哈希值将有所不同。 随机种子植入是一种安全措施，可防止有针对性的无序哈希拒绝服务攻击。 自字典并按其在哈希表中存储的顺序设置其元素的迭代，并且由于此顺序由哈希值确定，因此这意味着同一代码在每次启动时都会产生不同的迭代顺序。 如果你需要确定性的哈希值（例如用于测试），则可以通过设置环境变量 <code>SWIFT_DETERMINISTIC_HASHING = 1</code> 来禁用随机种子设置，但在生产环境中请勿这样做。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，在<strong>使用没有值语义的类型时要格外小心（例如可变对象）作为字典键</strong>。 如果你在将对象用作字典键后以某种方式对其进行了更改（即更改其哈希值和/或相等性），则你将无法在字典中再次找到该对象。 现在，词典将对象存储在错误的插槽中，从而有效地破坏了其内部存储。 值类型不是问题，因为字典中的键不会共享副本的存储空间，因此无法从外部进行改变。</p></br><h1 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a><strong>Sets</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准库中的第三个主要集合类型是 <code>Set</code> 。 <strong>集合是元素的无序集合，每个元素仅出现一次</strong>。 本质上，<strong><em>你可以将集合视为仅存储键而没有值的字典</em></strong>。 与字典一样，<code>集合是通过哈希表实现的</code>，并且具有相似的性能特征和要求。 测试集合中的成员资格值是一项恒定时间操作，并且集合元素必须是可哈希的，就像字典键一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你需要有效地测试成员资格（对数组进行<code>O（n）</code>操作）并且元素的顺序并不重要，或者需要确保集合不包含重复项时，请使用集合而不是数组。 <code>Set</code> 符合 <code>ExpressibleByArrayLiteral协议</code>，这意味着我们可以使用以下数组文字对其进行初始化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> naturals: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>] </span><br><span class="line">naturals <span class="comment">// [2, 3, 1] </span></span><br><span class="line">naturals.<span class="built_in">contains</span>(<span class="number">3</span>) <span class="comment">// true </span></span><br><span class="line">naturals.<span class="built_in">contains</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，数字2在集合中仅出现一次； 副本甚至都不会被插入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像所有集合一样，集合支持我们已经看到的常见操作：你可以遍历 <code>for循环</code> 中的元素，映射或过滤它们，并执行其他所有操作。</p><h2 id="设置代数"><a href="#设置代数" class="headerlink" title="设置代数"></a><strong><em>设置代数</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顾名思义， <code>Set</code> 与 <code>集合</code> 的数学概念密切相关。 它支持你在数学课中学习的所有常见设置操作。 例如，我们可以从另一组减去一组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iPods: <span class="type">Set</span> = [<span class="string">"iPod touch"</span>, <span class="string">"iPod nano"</span>, <span class="string">"iPod mini"</span>, <span class="string">"iPod shuffle"</span>, <span class="string">"iPod classic"</span>]</span><br><span class="line"><span class="keyword">let</span> discontinuedIPods: <span class="type">Set</span> = [<span class="string">"iPod mini"</span>, <span class="string">"iPod classic"</span>, <span class="string">"iPod nano"</span>, <span class="string">"iPod shuffle"</span>]</span><br><span class="line"><span class="keyword">let</span> currentIPods = iPods.subtracting(discontinuedIPods) <span class="comment">// ["iPod touch"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以形成两个集合的交集，即找到两个集合中的所有元素：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> touchscreen: <span class="type">Set</span> = [<span class="string">"iPhone"</span>, <span class="string">"iPad"</span>, <span class="string">"iPod touch"</span>, <span class="string">"iPod nano"</span>] <span class="keyword">let</span> iPodsWithTouch = iPods.intersection(touchscreen)</span><br><span class="line"><span class="comment">// ["iPod touch", "iPod nano"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者，我们可以形成两个集合的并集，即将它们合并为一个集合（当然，删除重复项）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> discontinued: <span class="type">Set</span> = [<span class="string">"iBook"</span>, <span class="string">"PowerBook"</span>, <span class="string">"Power Mac"</span>]</span><br><span class="line">discontinued.formUnion(discontinuedIPods)</span><br><span class="line">discontinued</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">["iPod shuffle", "Power Mac", "iBook", "iPod classic", "PowerBook",</span></span><br><span class="line"><span class="comment">"iPod mini", "iPod nano"] */</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们使用了变异变体 <code>formUnion</code> 来变异原始集合（结果，原始集合必须用var声明）。 几乎所有设置操作都具有 <code>非变异形式</code> 和 <code>变异形式</code> ，后者具有形式前缀。 要进行更多设置操作，请查看 <code>SetAlgebra协议</code> 。</p><h2 id="索引集和字符集"><a href="#索引集和字符集" class="headerlink" title="索引集和字符集"></a><strong><em>索引集和字符集</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Set</code> 和 <code>OptionSet</code> 是标准库中唯一符合 <code>SetAlgebra的类型</code> ，但是 <code>Foundation</code> 中两个有趣的类型也采用了此协议： <code>IndexSet</code> 和 <code>CharacterSet</code> 。这两件事都可以追溯到很久以前的 <code>Swift</code> 时代。现在，这些和其他 <code>Objective-C类</code> 作为功能齐全的值类型被桥接到 <code>Swift</code> 中的方式（在此过程中采用通用的标准库协议）是很棒的，因为它们会使 <code>Swift开发人员</code> 立即感到熟悉。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>IndexSet</code> 代表一组正整数值。当然，你可以使用 <code>Set&lt;Int&gt;</code> 来完成此任务，但是 <code>IndexSet</code> 的存储效率更高，因为它内部使用了一系列范围。假设你有一个包含1,000个元素的表视图，并且想使用一个集合来管理用户选择的行的索引。<code>Set&lt;Int&gt;</code> 最多需要存储1,000个元素，具体取决于选择的行数。另一方面， <code>IndexSet</code> 存储连续的范围 ，因此表中前500行的选择仅需要存储两个整数（选择的上下限）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，作为 <code>IndexSet的用户</code> ，你不必担心内部结构，因为它完全隐藏在熟悉的 <code>SetAlgebra</code> 和 <code>Collection接口</code> 后面。 （除非你想直接在范围上工作，也就是说， <code>IndexSet</code> 通过其本身是一个集合的 <code>rangeView属性</code> 向它们公开一个视图。）例如，你可以向索引集添加一些范围，然后映射到索引好像它们是个人成员一样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">indices</span> = <span class="type">IndexSet</span>()</span><br><span class="line"><span class="built_in">indices</span>.insert(integersIn: <span class="number">1</span>..&lt;<span class="number">5</span>)</span><br><span class="line"><span class="built_in">indices</span>.insert(integersIn: <span class="number">11</span>..&lt;<span class="number">15</span>)</span><br><span class="line"><span class="keyword">let</span> evenIndices = <span class="built_in">indices</span>.<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125; <span class="comment">// [2, 4, 12, 14]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CharacterSet</code> 是存储一组 <code>Unicode代码点</code> 的等效方法。 通常用于检查特定字符串是否仅包含来自特定字符子集的字符，例如字母数字或十进制数字。 但是，与 <code>IndexSet</code> 不同， <code>CharacterSet</code> 不是集合。 从 <code>Objective-C</code> 导入的 <code>CharacterSet</code> 名称在 <code>Swift</code> 中是不幸的，因为 <code>CharacterSet</code> 与 <code>Swift</code> 的 <code>Character类型</code> 不兼容。 更好的名称是 <code>UnicodeScalarSet</code> 。 我们将在 <code>“字符串”</code> 一章中进一步讨论 <code>CharacterSet</code> 。</p><h2 id="在闭包内部使用Set"><a href="#在闭包内部使用Set" class="headerlink" title="在闭包内部使用Set"></a><strong>在闭包内部使用Set</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>字典和集合</code> 可以是在函数内部使用的非常方便的数据结构，即使你没有将它们暴露给调用者也是如此。 例如，如果要在 <code>Sequence</code> 上编写扩展名以检索序列中的所有唯一元素，则可以轻松地将元素放入集合中并返回其内容。 但是，这将不稳定：由于集合没有定义的顺序，因此输入元素可能会在结果中重新排序。 为了解决这个问题，我们可以编写一个扩展，通过使用内部Set进行记录来维护顺序：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Hashable</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unique</span><span class="params">()</span></span> -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> seen: <span class="type">Set</span>&lt;<span class="type">Element</span>&gt; = [] </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">filter</span> &#123; element <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> seen.<span class="built_in">contains</span>(element) &#123; </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                seen.insert(element) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>].unique() <span class="comment">// [1, 2, 3, 12, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的方法使我们能够找到序列中的所有唯一元素，同时仍然保持原始顺序（约束条件是元素必须是可哈希的）。 在闭包内部，我们传递给 <code>filter</code> ，我们引用在闭包外部定义的变量，从而在闭包的多次迭代中保持状态。 在 <code>“函数”</code> 一章中，我们将更详细地介绍这种技术。</p></br><h1 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a><strong>Ranges</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Ranges是值的间隔</strong>，由其上下限定义。 你可以使用以下两个范围运算符来创建范围：<code>..&lt;</code> 用于不包含上限的半开范围，而 <code>...</code> 用于包含两个范围的封闭范围：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 to 9, 10 is not included.</span></span><br><span class="line"><span class="keyword">let</span> singleDigitNumbers = <span class="number">0</span>..&lt;<span class="number">10</span> <span class="type">Array</span>(singleDigitNumbers) <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] // "z" is included.</span></span><br><span class="line"><span class="keyword">let</span> lowercaseLetters = <span class="type">Character</span>(<span class="string">"a"</span>)...<span class="type">Character</span>(<span class="string">"z"</span>)</span><br><span class="line"><span class="type">There</span> are also <span class="keyword">prefix</span> and <span class="keyword">postfix</span> variants of these operators, which are used to express one-sided ranges:</span><br><span class="line"><span class="keyword">let</span> fromZero = <span class="number">0</span>...</span><br><span class="line"><span class="keyword">let</span> upToZ = ..&lt;<span class="type">Character</span>(<span class="string">"z"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有五种不同的具体类型代表范围，每种类型捕获对值的不同约束。 两种最基本的类型是 <code>Range</code> （使用 ..&lt;创建的半开范围 ）和 <code>ClosedRange</code> （使用…创建的）。 两者都有一个通用的 <code>Bound参数</code> ：<strong>唯一的要求是Bound必须是Comparable</strong>。 例如，上面的 <code>lowercaseLetter</code> s表达式的类型为<code>ClosedRange&lt;Character&gt;</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;范围上最基本的操作是测试它是否包含某些元素：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singleDigitNumbers.<span class="built_in">contains</span>(<span class="number">9</span>) <span class="comment">// true lowercaseLetters.overlaps("c"..&lt;"f") // true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;半开和封闭范围有单独的类型，因为两者都有一个位置：</p><ul><li>→ <code>Onlyahalf-openrange</code> 可以表示一个空间隔（当降低时，<br>上限相等，如5 .. &lt;5）。</li><li>→ 只能在一个封闭范围内包含其元素类型的最大值（例如0 …Int.max）。 半开范围总是要求至少一个可表示的值大于该范围内的最大值。</li></ul><h2 id="Countable-Ranges"><a href="#Countable-Ranges" class="headerlink" title="Countable Ranges"></a><strong><em>Countable Ranges</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;范围似乎很自然地适合作为序列或集合。 实际上，你可以遍历整数范围或将其视为集合：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(i)"</span>, terminator: <span class="string">" "</span>)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9 singleDigitNumbers.last // Optional(9)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是并非所有范围都可以这种方式使用。 例如，编译器不会让我们迭代一系列字符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error: Type 'Character' does not conform to protocol 'Strideable'.</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> lowercaseLetters &#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（对字符进行迭代的原因并不像看起来与 <code>Unicode</code> 一样简单。在 <code>“字符串”</code> 一章中将详细讨论此问题。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里发生了什么？ 范围仅在其元素类型符合 <code>Strideable</code> 时（即你可以通过添加偏移量从一个元素跳转到另一元素）且步幅步骤本身是整数，才有条件地符合 <code>collection协议</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Range</span>: <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Bound</span>: <span class="title">Strideable</span>, <span class="title">Bound</span>.<span class="title">Stride</span>: <span class="title">SignedInteger</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Range</span>: <span class="title">Collection</span>, <span class="title">BidirectionalCollection</span>,<span class="title">RandomAccessCollection</span></span></span><br><span class="line"><span class="class"><span class="title">where</span> <span class="title">Bound</span>: <span class="title">Strideable</span>, <span class="title">Bound</span>.<span class="title">Stride</span>: <span class="title">SignedInteger</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（我们将在 <code>“collection协议”</code> 一章中深入介绍 <code>“Sequence”</code> <code>，“collection”</code> ， <code>“双向collection”</code> 和 <code>“随机访问collection”协议</code> 。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换句话说，范围必须是可计数的，以便对其进行迭代。可计数范围（即与约束匹配）的有效边界包括整数和指针类型，但<strong>不包括浮点类型，因为该类型的跨度受到整数约束</strong>。如果需要迭代连续的浮点值，则可以使用 <code>stride（from：to：by）</code> 和 <code>stride（from：through：by）</code> 函数创建这样的序列。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Swift 4.1和4.2中引入条件协议一致性之前，标准库包括名为 <code>CountableRange</code> 和 <code>CountableClosedRange</code> 的具体类型，用于区分 <code>可计数范围</code> 和 <code>不可计数范围</code> 。这些名称仍作为类型别名存在，以实现向后兼容。你还可以将它们用作一系列范围加约束的简写，如标准库中的注释所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: this is not for compatibility only; it is considered useful</span></span><br><span class="line"><span class="comment">// shorthand.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">CountableRange</span>&lt;<span class="type">Bound</span>: <span class="type">Strideable</span>&gt; = <span class="type">Range</span>&lt;<span class="type">Bound</span>&gt;</span><br><span class="line"><span class="keyword">where</span> <span class="type">Bound</span>.<span class="type">Stride</span> : <span class="type">SignedInteger</span></span><br></pre></td></tr></table></figure><h2 id="Partial-Ranges"><a href="#Partial-Ranges" class="headerlink" title="Partial Ranges"></a><strong><em>Partial Ranges</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用 <code>...</code> 或 <code>..&lt;</code> 作为前缀或后缀运算符来构造部分范围。 这些范围之所以称为局部范围，是因为它们缺少边界之一。 例如， <code>0 ...</code> 描述了一个从零开始且没有上限的范围。 共有三种：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fromA: <span class="type">PartialRangeFrom</span>&lt;<span class="type">Character</span>&gt; = <span class="type">Character</span>(<span class="string">"a"</span>)...</span><br><span class="line"><span class="keyword">let</span> throughZ: <span class="type">PartialRangeThrough</span>&lt;<span class="type">Character</span>&gt; = ...<span class="type">Character</span>(<span class="string">"z"</span>) <span class="keyword">let</span> upto10: <span class="type">PartialRangeUpTo</span>&lt;<span class="type">Int</span>&gt; = ..&lt;<span class="number">10</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <code>CountableRange</code> 是具有可跨越元素类型的范围的类型别名一样 <code>CountablePartialRangeFrom</code> 是 <code>PartialRangeFrom</code> 的类型别名，但约束更严格。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们迭代可计数的 <code>PartialRangeFrom</code> 时，迭代从 <code>lowerBound</code> 开始并重复调用 <code>advanced（by：1）</code> 。 如果在 <code>for循环</code> 中使用此范围，则必须小心添加中断条件，以免最终陷入无限循环（否则计数器溢出时会崩溃）。 无论 <code>PartialRangeThrough</code> 和 <code>PartialRangeUpTo</code> 如何迭代，无论它们的元素类型是否可跨越，都因为它们没有下限而无法迭代。</p><h2 id="Range-Expressions"><a href="#Range-Expressions" class="headerlink" title="Range Expressions"></a><strong><em>Range Expressions</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有五个范围类型均符合 <code>RangeExpression协议</code> 。 该协议本身很小，足以在本书中印刷。 它允许你询问元素是否包含在范围内，并给出一个集合，它可以为你计算完全指定的范围：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">RangeExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Bound</span>: <span class="type">Comparable</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="number">_</span> element: Bound)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">relative</span>&lt;C&gt;<span class="params">(to collection: C)</span></span> -&gt; <span class="type">Range</span>&lt;<span class="type">Bound</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="type">C</span>: <span class="type">Collection</span>, <span class="type">Self</span>.<span class="type">Bound</span> == <span class="type">C</span>.<span class="type">Index</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于缺少下界的部分范围， <code>relative（to :)</code> 方法将集合的 <code>startIndex</code> 添加为下界。 对于缺少上限的部分范围，该方法将使用集合的 <code>endIndex</code> 。 部分范围使切片集合的语法非常紧凑：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] </span><br><span class="line">arr[<span class="number">2</span>...] <span class="comment">// [3, 4] </span></span><br><span class="line">arr[..&lt;<span class="number">1</span>] <span class="comment">// [1]</span></span><br><span class="line">arr[<span class="number">1</span>...<span class="number">2</span>] <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之所以可行，是因为 <code>Collection协议</code> 中的相应下标声明采用 <code>RangeExpression</code> 而不是五个具体范围类型之一。 你甚至可以忽略两个边界，以获取整个集合的一部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[...] <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">type(of: arr[...]) <span class="comment">// ArraySlice&lt;Int&gt;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（这是标准库中的一种特殊情况。这种无界范围尚不是有效的 <code>RangeExpression</code> ，但最终应成为一个范围。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果可能，请尝试复制标准库的方法，并使你自己的函数采用 <code>RangeExpressio</code> n而不是具体的范围类型。 并非总是可能的，因为除非你处于集合的上下文中，否则该协议不会使你能够访问范围的边界，但是如果是这样，则可以为 <code>API</code> 的使用者提供更大的自由来传递任何形式的 他们喜欢的范围表达。</p></br><h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a><strong>概括</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本章中，我们看到了许多不同的集合：<code>数组</code>，<code>字典</code>，<code>集合</code>，<code>索引集</code>和<code>范围</code>。 我们还研究了每个集合所具有的许多方法。 我们了解了 <code>Swift</code> 的内置集合如何使你可以通过 <code>let和var</code> 控制 <code>可变性</code> ，还了解了如何理解所有不同的 <code>Range类型</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将在 <code>“Collection协议”</code> 中重新访问本章的主题，在此我们将深入讨论 <code>Swift</code> 的 <code>Collection所基于的协议</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Advanced Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Advanced Swift </tag>
            
            <tag> Swift 5.0 </tag>
            
            <tag> Build-in Collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Swift系列(一): Swift 简介</title>
      <link href="/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%80):%20Swift%20%E7%AE%80%E4%BB%8B/"/>
      <url>/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%80):%20Swift%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Advanced Swift</code> 是一本书的大胆标题，所以也许我们应该从它的意思开始。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们开始编写本书的第一版时， <code>Swift</code> 才刚满一岁。我们是在2.0版Beta发布之前这样做的-尽管只是暂时的，因为我们怀疑该语言在进入第二年后会继续发展。很少有语言（也许没有其他语言）被如此众多的开发人员如此迅速地采用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这给人们留下了未解之谜。你如何编写“惯用”  <code>Swift</code> ？有正确的方法来做某些事情吗？标准库提供了一些线索，但是即使随着时间的推移，它也发生了变化，删除了一些约定并采用了其他约定。自从将近五年前 <code>Swift</code> 推出以来， <code>Swift</code> 取得了长足的发展，并且变得更加清晰。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于来自另一种语言的人， Swift 可以使他们喜欢他们所选择的语言。低级位扭曲看起来可能与C非常相似（并且可以与C一样性能），但是没有许多未定义的行为陷阱。  <code>Rubyists</code> 熟悉 <code>map</code> 或 <code>lter</code> 的轻量级 <code>尾随闭包语法</code> 。  <code>Swift泛型</code> 类似于 <code>C++模板</code> ，但是具有类型约束，以确保泛型函数在定义时（而不是在使用时）是正确的。高阶函数的灵活性和运算符重载意味着你​​可以编写与 <code>Haskell</code> 或 <code>F＃</code> 风格相似的代码。  <code>@objc</code> 和 <code>dynamic</code> 关键字允许你以与 <code>Objective-C</code> 相同的方式使用选择器和运行时动态性。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到这些相似之处，很容易采用其他语言的习惯用法。恰当的例子： <code>Objective-C</code> 示例项目几乎可以机械地移植到 <code>Swift</code> 。  <code>Java</code> 或 <code>C＃设计模式</code> 以及大多数功能编程模式也是如此。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是随之而来的是沮丧。为什么我们不能将 协议扩展 与相关类型（如Java中的接口）一起使用？为什么数组不像我们期望的那样协变？为什么我们不能写 <code>“ functor”</code> ？有时答案是因为有关  <code>Swift</code> 的部分尚未实现。但是更常见的是，这是因为有一种类似 <code>Swift</code> 的方式来完成你想做的事情，或者是因为你认为 <code>Swift</code> 功能实际上与其他语言中的等效功能实际上并不完全一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 是一种复杂的语言-大多数编程语言都是。但这很好地掩盖了这种复杂性。你可以在 <code>Swift</code> 中启动并运行开发应用程序，而无需了解 <code>泛型</code> 或 <code>重载</code> 或 <code>静态</code> 和 <code>动态调度</code> 之间的区别。你当然可以使用 <code>Swift</code> ，而无需调用 <code>C库</code> 或编写自己的集合类型，但是过了一会儿，我们认为你有必要了解<br>这些事情-是提高代码的性能，还是使其更优雅或更富表现力，或者仅仅是为了完成某些事情。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本书旨在进一步了解这些功能。我们打算回答许多“我该怎么做？”或“为什么Swift会那样表现？”我们在各种论坛上反复提出的问题。希望，一旦你阅读了我们的书，你将从了解语言的基础到了解许多高级功能以及对 <code>Swift</code> 的工作原理有更好的了解。熟悉所提供的材料可能是必要的，即使不够用，也要称自己为 <code>高级Swift程序员</code> 。</p></br><h1 id="这本书是给谁的？"><a href="#这本书是给谁的？" class="headerlink" title="这本书是给谁的？"></a><strong>这本书是给谁的？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本书面向有经验的（尽管不一定是专家） 程序员 ，例如现有的 <code>Apple平台开发人员</code> 。这也适用于那些来自其他语言（例如 <code>Java</code> 或 <code>C++</code> ）的人，他们希望将自己对 <code>Swift</code> 的知识提高到与“入门”语言相同的水平。此外，它适合刚开始使用 <code>Swift</code> 并熟悉基础知识并希望将其提升到新水平的新程序员。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这本书并不是要介绍 <code>Swift</code> 。假定你熟悉该语言的语法和结构。如果你希望对 <code>Swift</code> 的基础知识有一个很好的紧凑介绍，最好的资料是 <code>Apple Swift官方</code> 书（可在iBooks或Apple的网站上找到）。如果你已经是一名自信的程序员，则可以尝试同时阅读我们的书和Apple Swift书。<br>这也不是有关为macOS或iOS设备编程的书。当然，由于 <code>Swift</code> 在Apple平台上的开发用途很多，因此我们尝试提供一些实际使用的示例，但我们希望这本书对非Apple平台的程序员也有用。本书中的绝大多数示例在其他操作系统上应保持不变。那些根本不与Apple平台相关联的（因为它们使用iOS框架或依赖于Objective-C运行时），或者只需要很小的更改。从个人经验可以说， <code>Swift</code> 是编写运行在 <code>Linux</code> 上的服务器应用程序的绝佳语言，过去几年来，生态系统和社区不断发展，使之成为可行的选择。</p></br><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a><strong>主题</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本书的组织方式使每一章都涵盖一个特定的概念。关于一些基本的基本概念（例如，可选参数和字符串），有深入的章节，同时还深入探讨了诸如C互操作性之类的主题。但是在整本书中，希望有一些关于Swift的主题出现：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><em><code>Swift</code> 桥接了多个抽象级别。</em></strong>  <code>Swift</code> 是一种高级语言，它允许你使用 <code>map</code> 和 <code>reduce</code> 来编写与 <code>Ruby</code> 和 <code>Python</code> 类似的代码，并轻松编写自己的高阶函数。  <code>Swift</code> 还允许你编写快速代码，这些代码可以直接编译为本机二进制文件，其性能类似于用 <code>C语言</code> 编写的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们兴奋的是，我们最欣赏的 <code>Swift</code> 方面是，你能够同时做这两项事情。将闭包表达式映射到数组上将编译为与循环访问连续内存块相同的汇编代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，要充分利用此功能，你需要了解一些事情。例如，对 <code>结构</code> 和 <code>类</code> 的差异有所了解，或者对 <code>动态</code> 和 <code>静态方法</code> 分配之间的区别有所了解，将使你受益（稍后我们将更深入地讨论诸如此类的主题）。而且，如果你需要降到较低的抽象层次并直接操作指针， <code>Swift</code> 也可以使你做到这一点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 是一种 <code>多范式语言</code> 。你可以使用它来使用不可变值编写面向对象的代码或纯函数代码，也可以使用指针算法编写类似 <code>C</code> 的 <code>命令式代码</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这既是福也是祸。太好了，因为你有很多可用的工具，而且你不必被迫以一种方式编写代码。但这也使你面临用 <code>Swift</code> 编写 <code>Java</code> 或 <code>C</code> 或 <code>Objective-C</code> 的风险。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 仍然可以使用 <code>Objective-C</code> 的大多数功能，包括 <code>消息发送</code> ， <code>运行时类型识别</code> 和 <code>键值观察</code> 。但是 <code>Swift</code> 引入了许多在 <code>Objective-C</code> 中不可用的功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;著名的编程语言专家 <code>Erik Meijer</code> 在2015年10月发布了以下推文：</p><blockquote><p>在这一点上，<code>@SwiftLang</code> 可能是比 <code>Haskell</code> 更好，更有价值的学习 <code>函数式编程</code> 的工具。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 通过使用 <code>泛型</code> ， <code>协议</code> ， <code>值类型</code> 和 <code>闭包</code> ，很好地介绍了一种更具功能性的编程风格。 甚至可以使用它来编写将 <code>函数组合</code> 在一起的 <code>运算符</code> 。 也就是说， <code>Swift社区</code> 中的大多数人似乎更喜欢命令式风格，同时融入了源于 <code>函数式编程</code> 的模式。  <code>Swift</code> 的 <code>值类型</code> <code>可变性</code> 概念及其 <code>错误处理模型</code> 是友好的命令式语法背后的语言“隐藏”功能概念的示例。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 非常灵活。 在《关于Lisp的书》的简介中，Paul Graham写道：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经验丰富的 <code>Lisp程序员</code> 对程序进行了不同的划分。 除自上而下的设计外，它们还遵循可称为自下而上的设计的原则-更改语言以适应问题。 在 <code>Lisp</code> 中，你不仅要按照语言编写程序，还要按照程序编写语言。 在编写程序时，你可能会想“我希望Lisp拥有这样的运算符。” 所以你去写吧。 之后，你意识到使用 <code>new运算符</code> 将简化程序另一部分的设计，依此类推。 语言和程序一起发展。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 与 <code>Lisp</code> 有很大的不同。但是，我们仍然感觉到 <code>Swift</code> 也具有鼓励“自下而上”编程的特征-简化编写非常通用的 可重用构建基块 ，然后将其组合成更大的功能，然后将其用于解决实际问题的特性。  <code>Swift</code> 特别擅长使这些构建基块看起来像原始语言，就像语言的一部分一样。这方面的一个很好的证明是，你可能认为许多基本功能（例如可选功能或基本运算符）的功能实际上是在库中定义的- <code>Swift标准库</code> -而不是直接在语言中定义。 尾随闭包 使你可以使用内置的功能扩展语言。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 代码可以紧凑而简洁，同时仍然清晰。  <code>Swift</code> 使自己适合相对简洁的代码。这里有一个潜在的目标，那就是不能节省打字。这个想法是为了更快地解决问题，并通过删除很多<br>在其他语言中，你经常看到的“典范”样板模糊而不是澄清了代码的含义。<br>例如， <code>类型推论</code> 消除了从上下文显而易见的类型声明的混乱情况。没有什么价值的分号和括号都消失了。 <code>泛型</code> 和 <code>协议扩展</code> 鼓励你通过将常见操作打包到 <code>可重用函数</code> 中来避免重复。目的是一眼就能看懂代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，这可能会令人反感。如果你从未使用过 <code>map</code> ， <code>maplter</code> 和 <code>reduce</code> 之类的 <code>函数</code> ，那么它们可能比简单的 <code>for循环难读</code> 。但是我们希望这是一条短暂的学习曲线，而回报是代码，它可以带来更多<br>乍看之下“显然是正确的”。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 会尝试尽可能实际地保持安全，直到你告知并非如此为止。这与 <code>C</code> 和 <code>C++</code> （你可能会因忘记做某事而很不安全）或 <code>Haskell</code> 或 <code>Java</code> （无论你是否喜欢它有时都是安全的）这样的语言不同。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>C＃</code> 的主要设计师之一埃里克·利珀特（Eric Lippert）讲述了他对 <code>C＃</code> 的十个遗憾，包括以下课程：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，你需要实现仅适用于正在 <code>构建基础架构</code> 的专家的功能； 这些功能应清楚地标记为危险-不会与其他语言的功能相似。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;埃里克（Eric）特别是指 <code>C＃</code> 的 <code>finalizers</code> ，类似于 <code>C++</code> 的 <code>析构函数</code> 。 但是与 <code>析构函数</code> 不同的是，它们在 <code>垃圾收集器</code> 的要求下（并在 <code>垃圾收集器</code> 的线程上）在不确定的时间运行（也许永远不会）。 但是，被 <code>引用计数的Swift</code> 确实可以确定地 <code>执行类的deinit</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 以其他方式体现了这一观点。 默认情况下， <strong>避免未定义和不安全的行为</strong> 。 例如，变量必须在初始化之前才能使用，并且在 <code>数组上</code> 使用 <code>越界下标</code> 将被捕获，而不是继续使用可能的垃圾值。<br>当你确实需要它们时，可以使用许多“不安全”选项（例如 <code>unsafeBitCast函数</code> 或 <code>UnsafeMutablePointer类型</code> ）。 但是强大的力量带来了巨大的不确定行为。 例如，你可以编写以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> someArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> uhOh = someArray.withUnsafeBufferPointer &#123; ptr <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> ptr &#125;</span><br><span class="line"><span class="comment">// Later...</span></span><br><span class="line"><span class="built_in">print</span>(uhOh[<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它会编译，但是谁知道它会做什么。  <code>ptr变量</code> 仅在 <code>闭包表达式</code> 中有效，并且将其返回给调用者是非法的。但是，没有什么阻止你让它逃脱到野外。但是，你不能说没有人警告过你。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 是一种自以为是的语言。作为作者，我们对编写 <code>Swift</code> 的“正确”方法有强烈的意见。你会在本书中看到许多这样的内容，有时甚至表示它们是事实。但它们只是我们的意见-随时可以不同意！ <code>Swift</code> 还是年轻的<br>语言，许多事情还没有解决。无论你正在阅读什么，最重要的事情就是亲自尝试一下，检查它们的行为，并决定你对它们的感觉。认真思考，并注意过时的信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 继续发展。年度语法大变动的时期已经过去，但是该语言的重要领域仍未完成（ <code>字符串API</code> ， <code>泛型系统</code> ）， <code>不断变化（反射）</code> 或 <code>尚未解决（并发）</code> 。</p></br><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h1><blockquote><p>‘When I use a word,’ Humpty Dumpty said, in rather a scornful tone, ‘it means just what I choose it to mean — neither more nor less.’<br>— Through the Looking Glass, by Lewis Carroll</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序员经常抛出艺术术语。为 <code>避免混淆</code> ，以下是我们在本书中使用的一些术语定义。在可能的情况下，我们尝试遵守与官方文档相同的用法，有时甚至坚持 <code>Swift社区</code> 广泛采用的定义。这些定义中的许多定义将在后面的章节中更详细地介绍，因此请放心，如果不是所有事情都立即生效的话。如果你已经熟悉所有这些术语，那么最好还是先略过一遍，以确保你所接受的含义与我们的含义相同。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中，我们区分 <code>值</code> ， <code>变量</code> ， <code>引用</code> 和 <code>常量</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>值</code> 是永远不变的，永远不变。例如，1，true和[1,2,3]均为值。这些是文字的示例，但是值也可以在运行时生成。将数字5平方时得到的数字是一个值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用 <code>var x = [1,2]</code> 为名称分配值时，我们将创建一个名为x的变量，其中包含值[1,2]。通过更改 <code>x</code> 通过执行 <code>x.append（3）</code> ，我们没有更改原始值。相反，我们将 <code>x</code> 所保存的值替换为新值[1,2,3]-至少在逻辑上，如果不在实际实现中（这实际上可能只是在一些现有内存的后面添加新条目）。我们称此为 <code>变量变量</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以用 <code>let</code> 而不是 <code>var声明常量变量（简称常量）</code> 。一旦为常数分配了值，就永远不能为其分配新值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们也不需要立即为 <code>变量赋值</code> 。我们可以先声明变量 <code>（让x：Int ）</code>，然后再给它赋一个值 <code>（x = 1）</code> 。  <code>Swift</code> 强调 <code>安全性</code> ，将在读取变量值之前检查所有可能的代码路径是否导致为变量分配了值。没有一个变量具有尚未定义的值的概念。当然，如果变量用 <code>let声明</code> ，则只能赋给一次。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>结构</code> 和 <code>枚举</code> 是 值类型 。当将一个结构变量分配给另一个时，两个变量将包含相同的值。你可以认为内容是被复制的，但是更准确地说，一个变量已更改为包含与另一个变量相同的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>引用</code> 是一种特殊的值：它是一个 <code>“指向”内存</code> 中其他位置的值。因为两个引用可以引用相同的位置，所以这会导致存储在该位置的值立即被程序的两个不同部分 <code>突变的可能性</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>类</code> 是 <code>引用类型</code> 。你不能直接在 <code>变量</code> 中 <code>保存类的实例</code> （有时可能将其称为 <code>对象</code> ，这个术语充满了麻烦！）。相反，你必须在变量中保存对它的引用，然后通过该 <code>引用</code> 对其进行访问。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>引用类型</code> 具有标识-你可以使用 <code>===</code> 检查两个变量是否引用了 <code>完全相同的对象</code> 。你也可以检查它们是否相等，假设为相关类型实现了 <code>==</code> 。具有不同身份的两个 <code>对象仍然可以相等</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>值类型</code> 没有身份。你无法检查 <code>特定变量</code> 是否与另一个 <code>变量</code> 具有“相同”的数字2。你只能检查它们是否都包含值2。 <code>===</code> 确实是在问：“这两个变量是否都具有与它们的值相同的引用？”在编程语言文献中， <code>==</code> 有时称为 <code>结构相等</code> ，而 <code>===</code> 有时又称为 <code>指针相等</code> 或 <code>引用相等</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中， <code>类引用</code> 并不是唯一的一种引用。例如，还存在通过 <code>UnsafeMutablePointer函数</code> 等 <code>访问的指针</code> 。但是 <code>类</code> 是最简单的 <code>引用类型</code> ，部分原因是它们的类引用性质被语法糖部分地隐藏了，这意味着你不需要像使用其他语言的 <code>指针</code> 那样进行任何显式的 <code>“解引用”</code> 。 （我们将在“互操作性”一章中详细介绍其他类型的参考。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用 <code>let声明</code> 保存引用的变量，即引用是 <code>常量</code> 。这意味着该变量 <code>永远不能更改为引用其他内容</code> 。但是-这很重要-并不意味着 <code>它所指的对象不能更改</code> 。因此，在将 <code>变量称为常量</code> 时，请小心-它 <code>仅指向常量</code> 。这并不意味着它指向的是  <code>恒定的</code> 。 （注意：如果最后几句话听起来像是双重说话，请不要担心，因为我们将在“结构和类”一章中再次介绍该内容。）不幸的是，这意味着当用 <code>let查看变量</code> 的声明时，你不能一眼就知道声明的内容是否完全不变。相反，你必须知道它是 <code>值类型</code> 还是 <code>引用类型</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>复制值类型</code> 时，通常会执行 <code>深度复制</code> ，即，它包含的所有值也会 <code>递归复制</code> 。此副本可以急于发生（每当引入新变量时），也可能懒惰（每当变量被突变时）。执行 <code>深拷贝的类型</code> 被称为具有 <code>值语义</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们遇到了另一个麻烦。如果 <code>结构</code> 包含 <code>引用类型</code> ，则将 <code>结构</code> 分配给新变量后， 不会自动复制引用的对象 。相反，仅 <code>引用本身会被复制</code> 。这些被称为 <code>浅拷贝</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如， <code>Foundation</code> 中的 <code>Data结构</code> 是 <code>存储实际字节</code> 的类的 <code>包装</code> 。但是，只要 <code>Data结构</code> 发生突变， <code>Data结构</code> 的作者就会采取额外的步骤来执行 <code>类实例</code> 的 <code>深层副本</code> 。他们使用称为 <code>写时复制</code> 的技术有效地做到了这一点，我们将在<a href="https://www.xuebaonline.com/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%BA%94):%20Structs%20and%20Classes/"><strong><em><code>“结构和类”</code></em></strong></a> 一章中对此进行说明。目前，重要的是要知道这种 <code>行为不是免费的</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>标准库</code> 中的 <code>集合</code> 还包装了 <code>引用类型</code> ，并使用 <code>写时复制</code> 有效地提供了 <code>值语义</code> 。但是，如果集合中的元素是引用（例如，包含对象的数组），则不会复制对象。相反，仅引用被复制。这意味着Swift数组仅在其元素也具有值语义的情况下才具有值语义。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有些类是完全不可变的-也就是说，它们在创建后不提供更改其内部状态的方法。这意味着，即使它们是类，它们也具有值语义（因为即使它们是共享的，它们也永远不会改变）。但是要小心-只能保证最终类不会被添加了可变状态。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中， <code>函数</code> 也是值。你可以将 <code>函数</code> 分配给 <code>变量</code> ，具有 <code>函数数组</code> ，然后调用保留在变量中的函数。将其他函数作为 <code>参数的函数</code> （例如map，其使用对变换序列中每个元素的函数进行转换）或返回函数称为 <code>高阶函数</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不必在顶层声明函数-你可以在另一个函数内或在 do 或其他范围内声明一个函数。在 外部作用域中 定义但从中传递出去的函数（例如，作为函数的返回值）可以“捕获”局部变量，在这种情况下，当局部作用域结束时，这些局部变量不会被破坏，并且该函数可以通过他们保持状态。此行为称为 <code>closures</code> 变量 ，执行此操作的函数称为 <code>closures</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用 <code>func关键字</code> 或使用称为 <code>闭包表达式</code> 的速记 <code>{}语法</code> 来声明函数。有时将其简化为 <code>“闭包”</code> ，但不要让你给人以为只有闭包表达式才可以是 <code>闭包</code> 。使用 <code>func关键字</code> 声明的函数在作为 <code>closures</code> 外部变量时也属于 <code>闭包</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Functions</code> 通过引用保留。这意味着将已捕获状态的函数分配给另一个变量不会复制该状态。它共享它，类似于 <code>对象引用</code> 。更重要的是，当两个闭包关闭同一个局部变量时，它们都共享该变量，因此它们共享状态。这可能非常令人惊讶，我们将在“功能”一章中对此进行更多讨论。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>类</code> 或 <code>协议</code> 内部定义的函数是方法，它们具有隐式的 <code>self参数</code> 。有时我们称函数为 <code>非方法自由函数</code> 。这是为了将它们与方法区分开。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <code>Swift</code> 中的标准函数名称不仅包括函数的基本名称（括号前的部分），还包括参数标签。例如，将集合索引移动许多步的方法的全名是 <code>index（_：offsetBy :)</code> ，指示此函数接受两个参数（由两个冒号表示），其中第一个没有标签（由下划线表示）。如果从上下文可以清楚地知道我们指的是什么功能，我们通常会省略书中的标签；编译器允许你执行相同操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>自由函数</code> 和在结构上调用的方法是 <code>静态分派的</code> 。这意味着将在编译时知道要调用的函数。这也意味着编译器可能能够 内联该函数 ，即根本不调用该函数，而是将其替换为该函数将执行的代码。 优化器 还可以 丢弃或简化 在编译时无法实际运行的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>类</code> 或 <code>协议</code> 上的方法可能会 <code>动态调度</code> 。这意味着编译器不一定在编译时就知道哪个函数将运行。通过使用 <code>vtables（类似于Java和C ++动态分配的工作方式）</code> 或在某些 <code>@objc类</code>和 <code>协议</code> 的情况下，通过使用 <code>选择器</code> 和 <code>objc_msgSend</code> 来完成此动态行为。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>子类型化</code> 和 <code>方法重写</code> 是获得 <code>多态行为</code> 的一种方法，<br>即根据所涉及的类型而变化的行为。第二种方法是 <code>函数重载</code> ，其中针对不同类型多次写入函数。 （重要的是不要混淆重写和重载，因为它们的行为截然不同。）第三种方式是通过 <code>泛型</code> ， <code>泛型</code> 是将 函数或方法编写一次 ，以采用任何提供某些函数或方法的类型，但是这些函数的实现可以变化。与方法重写不同， <code>函数重载</code> 和 <code>泛型</code> 的结果在编译时是 <code>静态已知</code> 的。我们将在“泛型”一章中对此进行详细介绍。</p></br><h1 id="Swift风格指南"><a href="#Swift风格指南" class="headerlink" title="Swift风格指南"></a><strong>Swift风格指南</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编写本书以及为我们自己的项目编写 <code>Swift代码</code> 时，我们尝试遵循以下规则：</p><ul><li>→ 进行命名，在使用时进行清晰性是最重要的考虑因素。由于API的使用次数超过了声明的次数，因此，应针对API的名称进行优化，以确保它们在调用站点上的正常运行。熟悉《 Swift API设计指南》，并尝试在你自己的代码中遵守它们。</li><li>→Clarityisoft的简洁性可以帮助其实现，但简洁性不应成为其本身。</li><li>→始终向功能添加文档注释，尤其是通用名称。</li><li>→类型以UpperCaseLetters开头。函数，变量和枚举以lowerCaseLetters开头。</li><li>→使用类型推断。显式但显而易见的类型会影响可读性。</li><li>→不要在模棱两可的情况下使用类型推断，或者在定义合同时（<br>例如，这就是为什么func具有显式的返回类型）。</li><li>→默认值构造为实际上不包含类或功能的引用<br>语义。</li><li>→除非你已明确设计了MTBE可继承性，否则将其标记为“类”。如果要在内部使用继承，但不允许外部客户继承，则将类标记为public，但不要打开。</li><li>→使用尾随密封句法，除非紧接在另一开口括号之后。</li><li>→尽早使用保镖退出功能。</li><li>→Eschewforce展开并隐式展开可选的选项。有时<br>有用，但是经常需要它们通常是一个标志，这是错误的。</li><li>→不要自己重复。如果发现多次编写相同的代码片段，请将其提取到一个函数中。考虑将该功能作为协议扩展。</li><li>→收藏夹和过滤器。但是不要强制使用：在有意义时使用循环。高阶函数的目的是使代码更具可读性。当更简单的for循环更加清晰时，混淆地使用reduce会破坏此目的。</li><li>→Favorimmutable变量：默认为除非你知道你需要的突变。但是，在使代码更清晰或更高效时，请使用突变。再说一次，不要强迫：结构上的变异方法通常比返回全新的结构更惯用和有效。</li><li><ul><li>→Swift泛型（尤其是与协议约束组合）倾向于导致很长的函数签名。不幸的是，我们尚未找到将长函数声明分成多行的好方法。我们将尝试在示例代码中保持一致。</li></ul></li><li>→离开自己。当你不进行编辑时。附件表示中存在自我。是一个明确的信号，表明自我正在被封闭所捕获。</li><li>→代替编写自由功能，写扩展名类型或协议（如果可以）。这有助于提高可读性和可发现性。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于本书中的代码示例的最后一点：为了节省空间并专注于要点，我们通常会省略使代码编译所需的 <code>import</code> 语句。如果你亲自尝试该代码，并且编译器告诉你它无法识别特定符号，请尝试添加 <code>import Foundation</code> 或 <code>import UIKit</code> 语句。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Advanced Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Advanced Swift </tag>
            
            <tag> Swift 5.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 Combine Publishers和Subscribers通过URLSession下载文件？</title>
      <link href="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Combine%20Publishers%E5%92%8CSubscribers%E9%80%9A%E8%BF%87URLSession%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%9F/"/>
      <url>/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Combine%20Publishers%E5%92%8CSubscribers%E9%80%9A%E8%BF%87URLSession%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>URLSessionDownloadTask</code> 和 <code>Swift</code> 中的 <code>Combine框架</code> 将远程图像异步加载到 <code>UIImageView</code> 中。</p></br><h1 id="一个简单的图像下载器"><a href="#一个简单的图像下载器" class="headerlink" title="一个简单的图像下载器"></a><strong>一个简单的图像下载器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 <code>URL下载资源</code> 似乎是一项艰巨的任务，但这真的那么容易吗？ 这要看情况。 如果必须 <a href="http://www.xuebaonline.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Codable%20protocol%E5%9C%A8Swift%E4%B8%AD%E8%A7%A3%E6%9E%90JSON%EF%BC%9F/"><strong><em><code>下载和解析</code></em></strong></a> 只有几个KB的 <code>JSON文件</code> ，则可以采用经典方式，也可以对 <a href="http://www.xuebaonline.com/Swift%20URLSession%20&&%20Combine%20framework/"><strong><em><code>Combine框架中的URLSession对象</code></em></strong></a> 使用新的 <code>dataTaskPublisher</code> 方法。</p><a id="more"></a><h2 id="不良做法⚠️"><a href="#不良做法⚠️" class="headerlink" title="不良做法⚠️"></a><strong>不良做法⚠️</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用一些快速且肮脏的方法从互联网上获取一些较小的数据。 这些方法的问题在于你必须处理大量线程和队列。 幸运的是，使用 <a href="http://www.xuebaonline.com/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Swift%E4%B8%AD%E7%9A%84Grand%20Central%20Dispatch/"><strong><em><code>Dispatch框架</code></em></strong></a> 有很多帮助，因此你可以将阻止功能转换为非阻止功能。 🚧</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos/1"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="comment">// Synchronous download using Data &amp; String</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// get the content as String synchronously</span></span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">try</span> <span class="type">String</span>(contentsOf: url)</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the content of the url as Data synchronously</span></span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Turning sync to async</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//this is happening on a background thread</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> content = <span class="keyword">try</span> <span class="type">String</span>(contentsOf: url)</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="comment">//this is happening on the main thread</span></span><br><span class="line">            <span class="built_in">print</span>(content)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Apple</code> 在其 <a href="https://developer.apple.com/documentation/foundation/nsdata/1547245-datawithcontentsofurl" target="_blank" rel="noopener"><strong><em><code>官方数据文档</code></em></strong></a> 中做了一个重要说明，即你不应该使用这些方法来下载 <code>非文件URL</code> ，但是仍然有人在教导/使用这些不良做法，但是为什么呢？ 😥</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em><code>Don&#39;t use this synchronous method to request network-based URLs.</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的建议是：始终使用 <a href="https://developer.apple.com/documentation/foundation/urlsession" target="_blank" rel="noopener"><strong><em><code>URLSession</code></em></strong></a> 来执行与网络相关的数据传输。 创建数据任务很简单，默认情况下是异步操作，回调在后台线程上运行，因此默认情况下不会阻塞任何内容。 现代网络 <code>API</code> 在 <code>iOS</code> 上确实不错，在99％的情况下，你不再需要 <a href="https://github.com/alamofire/alamofire" target="_blank" rel="noopener"><strong><em><code>Alamofire</code></em></strong></a> 来完成这些任务。 对依赖说不！ 🚫</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The best approach without using Combine</span></span><br><span class="line"><span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// do your stuff here...</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="comment">// do something on the main queue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你需要使用其他 <code>HTTP方法</code> （而不是 <code>GET</code> ），发送特殊的标头（凭证，接受策略等）或在正文中提供额外的数据，则还需要提及，首先需要构造一个 <code>URLRequest对象</code> 。 你只能使用 <code>URLSession API</code> 发送这些自定义请求。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Apple平台</code> 上 ，你将不再被允许使用不安全的 <code>HTTP协议</code> 。 如果要访问不带安全层 <code>（HTTPS）的URL</code> ，则必须禁用 <a href="https://developer.apple.com/security/" target="_blank" rel="noopener"><strong><em><code>应用程序传输安全性</code></em></strong></a> 。</p></blockquote><h2 id="数据任务的问题"><a href="#数据任务的问题" class="headerlink" title="数据任务的问题"></a><strong><em>数据任务的问题</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大文件（例如图像）呢？ 让我向你展示一些教程，然后再进行深入研究：</p><ul><li><a href="https://stackoverflow.com/questions/47030822/uiimageview-load-uiimage-from-remote-url" target="_blank" rel="noopener"><strong><em><code>UIImageView, Load UIImage from remote URL</code></em></strong></a></li><li><a href="https://stackoverflow.com/questions/9786018/loading-an-image-into-uiimage-asynchronously" target="_blank" rel="noopener"><strong><em><code>Loading an image into UIImage asynchronously</code></em></strong></a></li><li><a href="https://www.hackingwithswift.com/example-code/uikit/how-to-load-a-remote-image-url-into-uiimageview" target="_blank" rel="noopener"><strong><em><code>How to load a remote image URL into UIImageView</code></em></strong></a></li><li><a href="https://iosdevcenters.blogspot.com/2018/06/how-to-downloading-image-from-server.html" target="_blank" rel="noopener"><strong><em><code>How To Downloading Image from server URL on Swift 4?</code></em></strong></a></li><li><a href="https://stackoverflow.com/questions/46199203/downloading-uiimage-via-alamofireimage" target="_blank" rel="noopener"><strong><em><code>Downloading UIImage via AlamofireImage?</code></em></strong></a></li><li><a href="https://medium.com/swlh/loading-images-from-url-in-swift-2bf8b9db266" target="_blank" rel="noopener"><strong><em><code>Loading images from URL in Swift</code></em></strong></a></li><li><a href="https://www.tutorialspoint.com/how-do-i-load-an-image-by-url-on-ios-device-using-swift" target="_blank" rel="noopener"><strong><em><code>How do I load an image by URL on iOS device using Swift?</code></em></strong></a></li><li><a href="http://swiftdeveloperblog.com/code-examples/uiimageview-and-uiimage-load-image-from-remote-url/" target="_blank" rel="noopener"><strong><em><code>UIImageView and UIImage. Load Image From Remote URL.</code></em></strong></a></li><li><a href="https://www.youtube.com/watch?v=DnZvlanmpNE" target="_blank" rel="noopener"><strong><em><code>Asynchronously Loading Images in SwiftUI</code></em></strong></a></li><li><a href="https://onmyway133.github.io/blog/How-to-load-remote-image-in-SwiftUI/" target="_blank" rel="noopener"><strong><em><code>How to load remote image in SwiftUI</code></em></strong></a></li><li><a href="http://www.xuebaonline.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Combine%20Publishers%E5%92%8CSubscribers%E9%80%9A%E8%BF%87URLSession%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%9F/"><strong><em><code>Loading/Downloading image from URL on Swift</code></em></strong></a></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大文件（例如图像）呢？ 让我向你展示一些教程，然后再进行深入研究：<br>出于所有应有的尊重，我认为以上所有这些链接实际上都是加载远程映像的不良示例。 当然，他们可以完成工作，而且实施起来也很容易，但是也许我们应该涵盖整个故事……🤐</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于与远程服务器的小型交互，可以使用U <code>RLSessionDataTask类</code> 将响应数据接收到内存中（与使用 <code>URLSessionDownloadTask类</code> 不同，后者将数据直接存储到文件系统中）。 数据任务非常适合调用 <code>Web服务端点</code> 之类的用途。</p></blockquote><h2 id="URLSessionDataTask和URLSessionDownloadTask有什么区别？"><a href="#URLSessionDataTask和URLSessionDownloadTask有什么区别？" class="headerlink" title="URLSessionDataTask和URLSessionDownloadTask有什么区别？"></a><strong><em>URLSessionDataTask和URLSessionDownloadTask有什么区别？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们仔细阅读文档，很明显， <strong>数据任务</strong> 不是下载大型资源的合适人选。 该类旨在仅请求较小的对象，因为基础数据将被加载到内存中。 另一方面，下载任务将响应的内容保存在磁盘上（而不是内存），并且你将收到本地文件URL，而不是数据对象。 事实证明，从数据任务转移到下载任务将对你的内存消耗产生巨大影响。 我有一些数字。 📈</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我使用这两种方法下载了以下<a href="https://images.unsplash.com/photo-1554773228-1f38662139db" target="_blank" rel="noopener"><strong><em><code>图像文件（6000x4000px×13.1MB</code></em></strong></a>）。 我做了一个基于Swift 5.1项目的全新情节提要。 基本的RAM使用量约为52MB，当我使用 <code>URLSessionDataTask类</code> 获取图像时，内存使用量跃升至82MB。 将数据任务转换为下载任务仅使基本内存大小增加了约4MB（总计约56MB），这是一项重大改进。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://images.unsplash.com/photo-1554773228-1f38662139db"</span>)!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// data task</span></span><br><span class="line"><span class="type">URLSession</span>.shared.dataTask(with: url) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">self</span>?.imageView.image = <span class="type">UIImage</span>(data: data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// download task</span></span><br><span class="line"><span class="type">URLSession</span>.shared.downloadTask(with: url) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] url, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span></span><br><span class="line">        <span class="keyword">let</span> cache = <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: .cachesDirectory, <span class="keyword">in</span>: .userDomainMask).first,</span><br><span class="line">        <span class="keyword">let</span> url = url</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> file = cache.appendingPathComponent(<span class="string">"\(UUID().uuidString).jpg"</span>)</span><br><span class="line">        <span class="keyword">try</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.moveItem(atPath: url.path,</span><br><span class="line">                                         toPath: file.path)</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">self</span>?.imageView.image = <span class="type">UIImage</span>(contentsOfFile: file.path)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我使用 <code>UIImageView</code> 渲染图像时，数据任务的内存占用量约为118MB（总计：〜170MB），下载任务的内存占用约为93MB（总计：〜145MB）。 快速摘要：</p><ul><li>数据任务：〜30MB</li><li>带有渲染的数据任务：〜118MB</li><li>下载任务：〜4MB</li><li>带有渲染的下载任务：〜93MB</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;希望你明白我的意思。 请不要忘记， <code>Foundation网络层</code> 附带了四种类型的会话任务。 你应该始终使用适合工作的合适的工具。 我们可以说 <a href="https://stackoverflow.com/questions/20604910/what-is-difference-between-nsurlsessiondatatask-vs-nsurlsessiondownloadtask" target="_blank" rel="noopener"><strong><em><code>URLSessionDataTask与URLSessionDownloadTask之间的区别</code></em></strong></a> 是：大量内存（在这种情况下，大约25MB的RAM）。</p><blockquote><p><strong><em><code>提示：</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener"><strong><em><code>Kingfisher</code></em></strong></a> 或 <a href="https://github.com/SDWebImage/SDWebImage" target="_blank" rel="noopener"><strong><em><code>SDWebImage</code></em></strong></a> 下载和处理远程图像。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会说这是一个边缘情况，因为大多数图像（甚至是高清图像）最大都只有几百千字节。 不过，我的主要收获是我们可以做得更好，如果可能的话，我们应该始终这样做。 🤓</p></br><h1 id="使用-Combine-下载图像"><a href="#使用-Combine-下载图像" class="headerlink" title="使用 Combine 下载图像"></a><strong>使用 Combine 下载图像</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>WWDC19</code> 上，Apple宣布了 <code>Combine框架</code> ，该框架为我们带来了一些 <code>Foundation对象</code> 的一些新扩展。 现代需要现代API，对吗？ 如果你已经熟悉了很好的新SDK，但是如果你不知道这种声明式功能响应性疯狂到底是什么，那么你应该阅读我有关 <a href="http://www.xuebaonline.com/Swift%20URLSession%20&&%20Combine%20framework/"><strong><em><code>Combine框架</code></em></strong></a> 的综合教程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Combine</code> 的第一个版本附带了一个不错的 <code>dataSessionPublisher扩展</code> 方法，用于 <code>URLSession类</code> 。 等一下，其他人呢？ 没有下载任务发布者？ 我们现在应该做什么？ 🤔</p><h2 id="如何编写自定义-Publisher？"><a href="#如何编写自定义-Publisher？" class="headerlink" title="如何编写自定义 Publisher？"></a><strong><em>如何编写自定义 Publisher？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://twitter.com/twannl" target="_blank" rel="noopener"><strong><em><code>SwiftLee</code></em></strong></a> 有一个很好的关于 <a href="https://www.avanderlee.com/swift/custom-combine-publisher/" target="_blank" rel="noopener"><strong><em><code>Combine的教程</code></em></strong></a> ，可以帮助你处理UIControl事件。  <a href="https://twitter.com/donnywals" target="_blank" rel="noopener"><strong><em><code>Donny Wals</code></em></strong></a> 的另一本很棒的读物（甚至比第一本更好）是关于 <a href="https://www.donnywals.com/understanding-combines-publishers-and-subscribers/" target="_blank" rel="noopener"><strong><em><code>理解发布者和订阅者</code></em></strong></a> 的。 这是一篇写得很好的文章，你绝对应该检查一下，我强烈建议你阅读。 🤘🏻</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们开始创建自己的 <code>DownloadTaskPublisher</code> 。 如果在 <code>Xcode</code> 中命令+单击 <code>dataTaskPublisher</code> 方法，则可以看到相应的界面。 右下方还有一个 <code>DataTaskPublisher</code> 结构。 基于该模板，我们可以创建自己的扩展程序。 同一数据任务方法有两种变体，我们将复制此行为。 我们需要的另一件事是 <code>DownloadTaskPublisher</code> 结构，我将首先向你展示Swift代码，然后我们将讨论实现细节。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">downloadTaskPublisher</span><span class="params">(<span class="keyword">for</span> url: URL)</span></span> -&gt; <span class="type">URLSession</span>.<span class="type">DownloadTaskPublisher</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskPublisher(<span class="keyword">for</span>: .<span class="keyword">init</span>(url: url))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">downloadTaskPublisher</span><span class="params">(<span class="keyword">for</span> request: URLRequest)</span></span> -&gt; <span class="type">URLSession</span>.<span class="type">DownloadTaskPublisher</span> &#123;</span><br><span class="line">        .<span class="keyword">init</span>(request: request, session: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">DownloadTaskPublisher</span>: <span class="title">Publisher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Output</span> = (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>)</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Failure</span> = <span class="type">URLError</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">let</span> request: <span class="type">URLRequest</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">let</span> session: <span class="type">URLSession</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">init</span>(request: <span class="type">URLRequest</span>, session: <span class="type">URLSession</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.request = request</span><br><span class="line">            <span class="keyword">self</span>.session = session</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">receive</span>&lt;S&gt;<span class="params">(subscriber: S)</span></span> <span class="keyword">where</span> <span class="type">S</span>: <span class="type">Subscriber</span>,</span><br><span class="line">            <span class="type">DownloadTaskPublisher</span>.<span class="type">Failure</span> == <span class="type">S</span>.<span class="type">Failure</span>,</span><br><span class="line">            <span class="type">DownloadTaskPublisher</span>.<span class="type">Output</span> == <span class="type">S</span>.<span class="type">Input</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> subscription = <span class="type">DownloadTaskSubscription</span>(subscriber: subscriber, session: <span class="keyword">self</span>.session, request: <span class="keyword">self</span>.request)</span><br><span class="line">            subscriber.receive(subscription: subscription)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Publisher</code> 可以将输出或失败消息发送给附加的订阅者。 你必须为每种类型创建一个新的类型别名，因为它们都是协议级别上定义的通用约束。 接下来，我们将存储会话和请求对象供以后使用。 协议一致性的最后一部分是你必须实现 <code>receive &lt;S&gt;（subscriber：S）</code> 通用方法。 此方法负责通过订阅对象附加新的订阅者。 嗯…什么？ 🤨</p><blockquote><p><strong><em><code>提示：</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Combine</code> 中的 <code>publisher/subscriber</code> 关系在第三个对象（订阅）中得到巩固。 创建订阅者并订阅发布者时，发布者将创建订阅对象，并将订阅的引用传递给订阅者。 然后，订阅者将向订阅请求多个值，以开始接收这些值。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>publisher</code> 和 <code>subscriber</code> 通过 <code>Subscription</code> 连接。  <code>subscriber</code> 仅创建 <code>Subscription</code> 并将其传递给 <code>subscriber</code> 。  <code>Subscription</code> 包含将为 <code>subscriber</code> 获取新数据的逻辑。 订阅服务器接收订阅，值和完成（成功或失败）。</p><ul><li><strong>订阅者</strong> 订阅 <strong>发布者</strong></li><li><strong>发布者</strong> 创建一个 <strong>订阅</strong></li><li><strong>发布者</strong> 将此 <strong>订阅</strong> 提供给 <strong>订阅者</strong></li><li><strong>订阅者</strong> 要求 <strong>订阅</strong> 提供一些值</li><li><strong>订阅</strong> 尝试收集值（成功或失败）</li><li><strong>订阅</strong> 根据需求策略将值发送给 <strong>订阅者</strong></li><li>如果发生错误，订阅会将失败完成发送给 <strong>订阅者</strong></li><li>如果没有更多可用值， <strong>订阅</strong> 将发送完成</li></ul><h2 id="如何编写自定义-Subscription？"><a href="#如何编写自定义-Subscription？" class="headerlink" title="如何编写自定义 Subscription？"></a><strong><em>如何编写自定义 Subscription？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，是时候为我们的小型基于 <code>Combine</code> 的下载器创建订阅了，我认为，如果我们将最后的代码片段放在一起，你将理解这三个对象之间的关系。 🧩</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadTaskSubscription</span>&lt;<span class="title">SubscriberType</span>: <span class="title">Subscriber</span>&gt;: <span class="title">Subscription</span> <span class="title">where</span></span></span><br><span class="line"><span class="class">        <span class="title">SubscriberType</span>.<span class="title">Input</span> == (<span class="title">url</span>: <span class="title">URL</span>, <span class="title">response</span>: <span class="title">URLResponse</span>),</span></span><br><span class="line"><span class="class">        <span class="title">SubscriberType</span>.<span class="title">Failure</span> == <span class="title">URLError</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> subscriber: <span class="type">SubscriberType?</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> session: <span class="type">URLSession!</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> request: <span class="type">URLRequest!</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> task: <span class="type">URLSessionDownloadTask!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span>(subscriber: <span class="type">SubscriberType</span>, session: <span class="type">URLSession</span>, request: <span class="type">URLRequest</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.subscriber = subscriber</span><br><span class="line">            <span class="keyword">self</span>.session = session</span><br><span class="line">            <span class="keyword">self</span>.request = request</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(<span class="number">_</span> demand: Subscribers.Demand)</span></span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> demand &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.task = <span class="keyword">self</span>.session.downloadTask(with: request) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] url, response, error <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> error = error <span class="keyword">as</span>? <span class="type">URLError</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>?.subscriber?.receive(completion: .failure(error))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>?.subscriber?.receive(completion: .failure(<span class="type">URLError</span>(.badServerResponse)))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> url = url <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>?.subscriber?.receive(completion: .failure(<span class="type">URLError</span>(.badURL)))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> cacheDir = <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: .cachesDirectory, <span class="keyword">in</span>: .userDomainMask).first!</span><br><span class="line">                    <span class="keyword">let</span> fileUrl = cacheDir.appendingPathComponent((<span class="type">UUID</span>().uuidString))</span><br><span class="line">                    <span class="keyword">try</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.moveItem(atPath: url.path, toPath: fileUrl.path)</span><br><span class="line">                    <span class="number">_</span> = <span class="keyword">self</span>?.subscriber?.receive((url: fileUrl, response: response))</span><br><span class="line">                    <span class="keyword">self</span>?.subscriber?.receive(completion: .finished)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>?.subscriber?.receive(completion: .failure(<span class="type">URLError</span>(.cannotCreateFile)))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.task.resume()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.task.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;订户具有输入和失败类型。订阅者只能订阅具有相同类型的发布者。发布者的输出和失败类型必须与订阅输入和失败类型相同。这次我们不能使用 <code>associatedType</code> ，但是我们必须使用where子句创建一个对这些要求有约束的通用值。其背后的原因是我们不知道哪种订阅者将订阅此订阅。可以是A类或B类，谁知道…🤷️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们必须在 <code>init方法</code> 中传递一些属性，将它们存储为实例变量（请谨慎使用类，如果适用，则应使用weak）。最后，我们通过遵守需求政策来实施价值请求方法。需求只是一个数字。它告诉我们最多可以发送回给订户多少个值。在我们的例子中，我们将拥有最大1的值，因此，如果需求大于零，那么我们就走了。你可以通过在订阅者上调用各种接收方法来向订阅者发送消息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你必须手动发送带有 <code>.finished</code> 或 <code>.failure（T）</code>值的完成事件。同样，我们必须在完成块返回之前移动下载的临时文件，否则我们将完全丢失它。这次，我将简单地将文件移动到应用程序缓存目录。免费取消是结束电池耗尽操作的好方法。你只需要实现一个自定义的 <code>cancel（）</code>方法。在我们的例子中，我们可以在底层 <code>URLSessionDownloadTask</code> 上调用相同的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而已。我们已经准备好自定义发布者和订阅。想尝试一下吗？</p><h2 id="如何创建自定义-Subscriber-？"><a href="#如何创建自定义-Subscriber-？" class="headerlink" title="如何创建自定义 Subscriber ？"></a><strong><em>如何创建自定义 Subscriber ？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有4种订阅。 你可以使用 <code>.sink</code> 或 <code>.assign</code> 方法进行新的订阅，还有一个名为 <code>Subject</code> 的东西，可以为发布者事件进行订阅，或者可以构建自己的 <code>Subscriber对象</code> 。 如果选择此路径，则可以使用 <code>.subscribe方法</code> 来关联发布者和订阅者。 你还可以订阅主题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadTaskSubscriber</span>: <span class="title">Subscriber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Input</span> = (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>)</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Failure</span> = <span class="type">URLError</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> subscription: <span class="type">Subscription?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(subscription: Subscription)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.subscription = subscription</span><br><span class="line">        <span class="keyword">self</span>.subscription?.request(.unlimited)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(<span class="number">_</span> input: Input)</span></span> -&gt; <span class="type">Subscribers</span>.<span class="type">Demand</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Subscriber value \(input.url)"</span>)</span><br><span class="line">        <span class="keyword">return</span> .unlimited</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(completion: Subscribers.Completion&lt;Failure&gt;)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Subscriber completion \(completion)"</span>)</span><br><span class="line">        <span class="keyword">self</span>.subscription?.cancel()</span><br><span class="line">        <span class="keyword">self</span>.subscription = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的 <code>subscriber</code> 将只打印输出值。 我们必须非常小心地进行内存管理。 收到的订阅将存储为强属性，但是当发布者发送完成事件时，我们应取消订阅并删除引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当值到达时，我们必须返回需求。 在我们的情况下，这并不重要，因为我们只有1个传入值，但是如果你想限制发布者，则可以使用例如 <code>.max（1）</code> 作为需求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是使用 <code>Swift 5.1</code> 编写的所有 <code>Combine订阅者</code> 类型的快速示例代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://images.unsplash.com/photo-1554773228-1f38662139db"</span>)!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> defaultValue: (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>) = &#123;</span><br><span class="line">        <span class="keyword">let</span> fallbackUrl = <span class="type">URL</span>(fileURLWithPath: <span class="string">"fallback-image-path"</span>)</span><br><span class="line">        <span class="keyword">let</span> fallbackResponse = <span class="type">URLResponse</span>(url: fallbackUrl, mimeType: <span class="string">"foo"</span>, expectedContentLength: <span class="number">1</span>, textEncodingName: <span class="string">"bar"</span>)</span><br><span class="line">        <span class="keyword">return</span> (url: fallbackUrl, response: fallbackResponse)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> value: (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>) = <span class="type">ViewController</span>.defaultValue</span><br><span class="line">    <span class="keyword">let</span> subject = <span class="type">PassthroughSubject</span>&lt;(url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>), <span class="type">URLError</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> subscriber = <span class="type">DownloadTaskSubscriber</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sinkOperation: <span class="type">AnyCancellable?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> assignOperation: <span class="type">AnyCancellable?</span></span><br><span class="line">    <span class="keyword">var</span> assignSinkOperation: <span class="type">AnyCancellable?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> subjectOperation: <span class="type">AnyCancellable?</span></span><br><span class="line">    <span class="keyword">var</span> subjectSinkOperation: <span class="type">AnyCancellable?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.sinkExample()</span><br><span class="line">        <span class="keyword">self</span>.assignExample()</span><br><span class="line">        <span class="keyword">self</span>.subjectExample()</span><br><span class="line">        <span class="keyword">self</span>.subscriberExample()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sinkExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.sinkOperation = <span class="type">URLSession</span>.shared</span><br><span class="line">            .downloadTaskPublisher(<span class="keyword">for</span>: <span class="type">ViewController</span>.url)</span><br><span class="line">            .sink(receiveCompletion: &#123; completion <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Sink completion: \(completion)"</span>)</span><br><span class="line">            &#125;) &#123; value <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Sink value: \(value.url)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">assignExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.assignSinkOperation = <span class="keyword">self</span>.$value.sink &#123; value <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Assign value: \(value.url)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.assignOperation = <span class="type">URLSession</span>.shared</span><br><span class="line">            .downloadTaskPublisher(<span class="keyword">for</span>: <span class="type">ViewController</span>.url)</span><br><span class="line">            .replaceError(with: <span class="type">ViewController</span>.defaultValue)</span><br><span class="line">            .assign(to: \.value, on: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subjectExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.subjectSinkOperation = <span class="keyword">self</span>.subject.sink(receiveCompletion: &#123; completion <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Subject completion: \(completion)"</span>)</span><br><span class="line">        &#125;) &#123; value <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Subject value: \(value.url)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.subjectOperation = <span class="type">URLSession</span>.shared</span><br><span class="line">            .downloadTaskPublisher(<span class="keyword">for</span>: <span class="type">ViewController</span>.url)</span><br><span class="line">            .subscribe(<span class="keyword">self</span>.subject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subscriberExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">URLSession</span>.shared</span><br><span class="line">            .downloadTaskPublisher(<span class="keyword">for</span>: <span class="type">ViewController</span>.url)</span><br><span class="line">            .subscribe(<span class="type">DownloadTaskSubscriber</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;真的很好, 我们可以使用自定义的基于 <code>Combine</code> 的 <code>URLSession扩展名</code> 下载文件。</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要忘记 <strong>存储</strong> <code>AnyCancellable指针</code> ，否则在你可以从链/流中接收任何内容之前，将重新分配整个 <code>Combine操作</code> 。</p></blockquote><h2 id="把所有的操作放在一起"><a href="#把所有的操作放在一起" class="headerlink" title="把所有的操作放在一起"></a><strong><em>把所有的操作放在一起</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我保证可以使用图片下载器，所以让我解释一下整个流程。 我们有一个自定义的下载任务发布者，它将在本地保存我们的删除图像文件，并返回一个包含文件url和响应的元组。 ✅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我将简单地假设url后面有一个有效的图像，并且服务器返回了一个有效的响应，因此我将把发布者的输出映射到 <code>UIImage对象</code> 。 我还将用后备图像值替换任何类型的错误。 在实际的应用程序中，你应该始终对 <code>URLResponse对象</code> 进行一些额外的检查，但是为了简单起见，我暂时将其跳过。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一件事是使用返回的图像更新我们的图像视图。 由于这是一个UI任务，它应该在主线程上发生，因此我们必须使用 <code>receive（on :)</code> 操作来切换上下文。 如果要在 <code>Combine框架</code> 中了解有关调度程序的更多信息，则应[<strong><em><code>阅读Vadim Bulavin的文章</code></em></strong>] (<a href="https://www.vadimbulavin.com/understanding-schedulers-in-swift-combine-framework/" target="_blank" rel="noopener">https://www.vadimbulavin.com/understanding-schedulers-in-swift-combine-framework/</a> “”) 。 这是一颗宝石。 💎</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你未在某些 <code>appleOS版本</code> 上接收到值，则可能是因为在2019年12月前后，“合并”中发生了更改。你应检查以下链接： <a href="https://forums.swift.org/t/combine-receive-on-runloop-main-loses-sent-value-how-can-i-make-it-work/28631/47" target="_blank" rel="noopener"><strong><em><code>link1</code></em></strong></a> ， <a href="https://heckj.github.io/swiftui-notes/#coreconcepts-lifecycle" target="_blank" rel="noopener"><strong><em><code>link2</code></em></strong></a></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，这是可能的图像下载操作的最终Swift代码，简单而声明性。 👍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> operation: <span class="type">AnyCancellable?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://images.unsplash.com/photo-1554773228-1f38662139db"</span>)!</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.operation = <span class="type">URLSession</span>.shared</span><br><span class="line">            .downloadTaskPublisher(<span class="keyword">for</span>: url)</span><br><span class="line">            .<span class="built_in">map</span> &#123; <span class="type">UIImage</span>(contentsOfFile: $<span class="number">0</span>.url.path)! &#125;</span><br><span class="line">            .replaceError(with: <span class="type">UIImage</span>(named: <span class="string">"fallback"</span>))</span><br><span class="line">            .receive(on: <span class="type">DispatchQueue</span>.main)</span><br><span class="line">            .assign(to: \.image, on: <span class="keyword">self</span>.imageView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我们可以显示图像。 哎呀，但是等等…还有改进的余地。 缓存呢？ 再加上一个 <code>6000x4000</code> px的图片对于一个小显示器来说是巨大的，我们不应该首先调整图像的大小/缩放比例吗？ 如果我要使用列表中的图像会发生什么，我不应该在用户滚动时取消下载任务吗？ 😳</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也许我会在即将到来的教程中写这些问题，但是我认为这是结束本文的重点。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Combine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Combine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在2020年学习iOS / Swift的最佳实践是什么？</title>
      <link href="/%E5%9C%A82020%E5%B9%B4%E5%AD%A6%E4%B9%A0iOS%20/%20Swift%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/%E5%9C%A82020%E5%B9%B4%E5%AD%A6%E4%B9%A0iOS%20/%20Swift%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你正在学习 <code>iOS开发</code> 吗？ 寻找 <code>Swift</code> 最佳做法？ 这是开始作为移动应用程序开发人员的旅程的正确位置。</p></br><h1 id="Hello-Swift"><a href="#Hello-Swift" class="headerlink" title="Hello Swift!"></a><strong>Hello Swift!</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习编程语言很困难。 即使经过十多年的软件开发人员经验，仍然觉得自己只是在摸索。 我对底层汇编代码不了解，也不知道如何使用着色器等创建3D游戏。 仍然，我们每天都在学习新的东西。 这是终生的旅程，道路上充满了障碍，但是如果你继续前进，你会发现路的尽头有金子。 我仍然喜欢用纯代码来创建新东西。 😍</p><p><strong><em><code>Everyone can code</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚开始时，你会感觉必须学习一百万件事，但你不必担心，因为时间是你的朋友。 每天你都会学到一些新知识，这些新知识将帮助你前进以实现下一个目标。 我相信这里最重要的是获得乐趣。 如果因为无法理解某件事而感到沮丧，请寻求帮助或休息一下。  <code>Swift社区</code> 是一群很棒的人，每个人都非常有帮助，因此，如果你选择这种编程语言来实现你的想法，那么你将遇到一些很棒的人。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我向你展示开始 <code>Swift应用程序开发人员</code> 所需要的条件。👨💻</p></br><h1 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a><strong>Hardware</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开始你的 <code>Apple开发人员</code> 职业所需的第一件事是 <code>Mac</code> 。 不幸的是， <code>Mac</code> 如今是非常昂贵的机器，当前的 <code>MacBook系列（Air和Pro都具有完全损坏的蝶形键盘机制）</code> 。 希望这将很快改变。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我想说，你应该使用蝴蝶前款式，如果你想便宜的话，可以寻找二手市场。 否则，你可以使用 <code>Mac mini</code> ，但是如果你购买 <code>Mac mini</code>，则应考虑显示器，键盘和鼠标等额外费用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你没有足够的资金，则应该使用一些高端设备，例如新的 <code>MacBook Pro 16“</code> ， <code>iMac Pro</code> 或只是购买 <code>Mac Pro</code> 。尽管如此，你始终应该选择配备SSD的计算机。 2020年，基本的iMac配备了极其慢的HDD。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个选择是建立一个 <code>hackintosh</code> ，但是恕我直言，这是你最糟糕的事情。 你将不会获得相同的经验，而且你将在与系统的斗争中挣扎很多。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会听说有传言说 <code>iPad</code> 和 <code>Swift playgrounds</code> 会很好。 老实说，事实并非如此。 即使使用 <code>Linux机器</code> ，你也可以玩耍并学习 Swift编程语言 ，但是如果你要制作自己的 <code>iOS/iPadOS/macOS/watchOS</code> 应用程序，则肯定需要 <code>Mac</code> 。</p></blockquote></br><h1 id="Software"><a href="#Software" class="headerlink" title="Software"></a><strong>Software</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，你拥有一台不错的 <code>Mac</code> 。 让我们看看如果你要开始开发 iOS应用程序 ，将需要哪种软件。 你可能听说过苹果的操作系统是 <code>macOS</code> 。 首先，如果你以前从未使用过 Mac ，则应该熟悉系统本身。 当我购买第一台 <code>MacBook Pro</code> 时，我花了大约一周的时间来习惯所有应用程序，系统快捷方式和其他所有功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不想自己搞定一切，那么你来对地方了。 让我逐步介绍一下作为专业移动/后端开发人员在我的工作中使用的每个应用程序和工具。</p><h2 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a><strong><em>Terminal</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该习惯的最重要的事情是终端（控制台）应用程序。 如果你之前从未听说过终端，则应该只寻找初学者指南教程，但是我强烈建议你至少学习真正的基本命令。</p><h2 id="Brew-amp-cask"><a href="#Brew-amp-cask" class="headerlink" title="Brew &amp; cask"></a><strong><em>Brew &amp; cask</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该在新 <code>Mac</code> 上安装的第一件事是 <a href="https://brew.sh/" target="_blank" rel="noopener"><strong><em><code>Homebrew</code></em></strong></a> 。 如果你以前使用过 <code>linux</code> ，可能会发现此工具很熟悉（它也可以在 <code>linux</code> 上运行）。 根据 <code>Max Howell</code> （创作者）：</p><blockquote><p><strong><code>适用于macOS（或Linux）的缺少的包管理器.</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以通过使用 <code>cask子命令</code> 将常规应用程序与 <code>brew安装</code> 在一起。 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install firefox</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我更喜欢创建一个我一直使用的工具列表，所以当我重新安装计算机时，我只需将这些命令复制并粘贴到终端中，我就或多或少地准备好恢复过程。 如果必须从头开始重新安装 <code>macOS</code> ，这将非常方便。</p><h2 id="MAS"><a href="#MAS" class="headerlink" title="MAS"></a><strong><em>MAS</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会注意到，我已经为 <code>Terminal</code> 安装了一些软件。 如果你不喜欢<code>App Store</code> 的界面，则可以安装 <a href="https://github.com/mas-cli/mas" target="_blank" rel="noopener"><strong><em><code>MAS（一种辅助工具）</code></em></strong></a> 。 借助它，你可以使用终端命令安装商店中所有可用的内容。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>GitHub</code> 上的自述文件非常好，你应该仔细阅读。 无论如何，你都不需要 <code>mas-cli</code> 来进行 <code>iOS</code> 开发，但是由于它确实很方便，所以我建议你进行检查。</p><h2 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a><strong><em>Xcode</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你肯定需要的第一工具是 <a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener"><strong><code>Xcode</code></strong></a> 。 还有一个名为 <a href="https://www.jetbrains.com/objc/" target="_blank" rel="noopener"><strong><code>AppCode</code></strong></a> 的IDE工具，但它总是落后于其他社区，绝大多数社区都喜欢 <code>Xcode</code> 。 🔨</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每年都会发布具有全新功能的 <code>Xcode新版本</code> 。 我建议使用最新版本（也应始终升级现有项目以支持最新版本）。 你可以从 <code>App Store</code> 获取 <code>Xcode</code> ，它是完全免费的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你的机器上安装 <code>Xcode</code> 会花费很多时间，但是几个小时后不用担心，它可以帮助你编写第一个 <code>iOS应用程序</code> 。 所以要耐心点。 :)</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong><em>Git</em></strong></h2><blockquote><p>Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个开发人员都应使用适当的 <a href="https://en.wikipedia.org/wiki/Version_control" target="_blank" rel="noopener"><strong><em><code>版本控制系统（又名Git）</code></em></strong></a> 。  <code>Git</code> 是事实上的版本控制标准工具，你可以在大约15分钟内<a href="https://try.github.io/levels/1/challenges/1" target="_blank" rel="noopener"><strong><em><code>学习基础知识</code></em></strong></a>。 当然，掌握它会花费更长的时间，但是完全值得一试。</p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a><strong><em>GitHub</em></strong></h2><p><strong><em><code>GitHub是基于Web的托管服务，用于使用git进行版本控制。</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;老实说， <code>GitHub</code> 不再只是一个存储库托管服务，它是一个完整的平台，具有用于问题管理，项目计划，持续集成支持等的工具。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>GitHub</code> 为你提供了针对个人的公共和私有 <code>Git存储库</code> 的 <strong>免费服务</strong> 。 在2019年，它被Microsoft收购（每个人都担心这一变化，因为MS拥有破坏良好服务的历史），但到目前为止，他们推出了许多令人惊叹的新功能。 立即获取免费帐户！</p></br><h1 id="使用Swift进行iOS应用开发"><a href="#使用Swift进行iOS应用开发" class="headerlink" title="使用Swift进行iOS应用开发"></a><strong>使用Swift进行iOS应用开发</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我相信 <code>Swift</code> 在过去5年中已发展成为稳定且成熟的语言。 如果你考虑一下，这是编写具有前瞻性的iOS应用程序的唯一好选择。 你显然应该忘记 <code>Objective-C</code> ，因为苹果已经做出了选择。 最终， <code>Swift</code> 将成为 <code>Apple</code> 支持的唯一编程语言，已经有一些Swift框架“仅”。 只需看看 <a href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener"><strong><em><code>SwiftUI</code></em></strong></a> 。 我的意思是，尽管该框架与基于 <code>Objective-C</code> 的项目100％兼容，但你无法在 <code>Objective-C</code> 中编写 <code>SwiftUI视图</code> 。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a><strong><em>依赖管理</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在某些时候，你不想自己编写所有内容，因为你希望快速进步。 这是外部程序包出现的地方。 听我的劝告：</p><p><strong><em><code>切勿手动连接第三方库</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift软件包管理器</code> 本地集成到 <code>Xcode</code> 中。 过去， <code>CocoaPods</code> 是iOS项目的最终依赖性管理器（有些人更喜欢 <code>Carthage</code> ），但是如今使用 <code>SPM</code> 更好。 如果你需要集成外部库， <code>SwiftPM</code> 是2020年的正确选择。如果你不知道它的工作方式，则应该阅读我有关<a href=""""><strong><em><code>如何使用 Swift Package Manager 的综合教程</code></em></strong></a>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;去年，我还写了一篇相当受欢迎的文章，介绍用 <a href="http://www.xuebaonline.com/Swift%E7%BC%96%E5%86%99%E7%9A%8420%E4%B8%AAiOS%E5%BA%93(%E4%B8%80)/"><strong><em><code>Swift 编写的最好/最受欢迎的iOS库</code></em></strong></a>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，如果你不知道从哪里开始以及将哪些内容集成到 <code>Swift项目</code> 中，则应该阅读我的博客文章，因为它仍然是最新的。 幸运的是，这些事情并没有经常改变。</p><h2 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a><strong><em>应用架构</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为即将到来的 <code>iOS项目</code> 选择正确的架构是最困难的事情之一。另一个正在建立你的用户界面，但让我们将该主题保留。你永远不应该害怕架构。即使你选择 <code>MVC</code> ， <code>MVP</code> ， <code>MVVM</code> 或 <code>VIPER</code> ，你也可以拥有一个编写良好的应用程序结构。这一点非常重要，因为你不想让2000多行 <a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener"><strong><em><code>面条式代码</code></em></strong></a>的视图控制器使自己将来感到生气，但它会带来一些讨厌的副作用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，你应该如何选择架构？由于它们很多，因此你甚至可以随机选择一个。好吧，这是iOS开发人员之间的真正辩论。我最喜欢的是 <code>VIPER</code> ，尽管因此我受到了很多批评。老实说，我真的对此不抱任何想法，因为它对我（和我的团队）有用。不管你是否使用普通的 <code>旧MVC</code> ，直到它可以解决你的问题时，它才真正重要。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你是一个完全初学者，请不要从 <code>VIPER</code> 开始，除非你可以陪伴可以回答你所有问题的人。我在这里的建议只是简单地坐下来，仔细考虑你想要实现的目标并制定基本计划。当然，如果你熟悉这些模式会很有帮助，但是到最后，你会意识到它们都是由人为制作的，而且都不完美。 🤔</p><h2 id="Xcode约定"><a href="#Xcode约定" class="headerlink" title="Xcode约定"></a><strong><em>Xcode约定</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我为 Xcode 制定了一些非常 <a href=""""><strong><em><code>基本的约定</code></em></strong></a> ，如果你不知道如何组织项目，则应检查这些约定。 如果你不熟悉 <code>Xcode格式</code> ，目标，方案，则应在互联网上搜索这样的教程，其中有一些关于整个过程的充分说明的示例。</p><h2 id="使用文件夹表示Xcode中的组"><a href="#使用文件夹表示Xcode中的组" class="headerlink" title="使用文件夹表示Xcode中的组"></a><strong><em>使用文件夹表示Xcode中的组</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你知道，就像在现实生活中一样，你不会将所有衣服都扔到架子上，对吗？ 井井有条是创建一个好的项目的唯一方法。 幸运的是， <code>Apple</code> 也意识到了这一点，现在默认情况下，组以硬盘上的物理文件夹表示。</p><h2 id="始终尝试修复每个警告"><a href="#始终尝试修复每个警告" class="headerlink" title="始终尝试修复每个警告"></a><strong><em>始终尝试修复每个警告</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在警告是有原因的，但是你绝不应在生产代码中留下任何警告。 如果你想变得更激进，可以在Xcode中使用build标志将<a href="http://iosdevelopertips.com/xcode/treat-warnings-as-errors.html" target="_blank" rel="noopener"><strong><em><code>警告视为错误</code></em></strong></a>。 打开它！ 消除所有警告！ 哈哈，不要那样做，但是你应该始终尝试修正所有警告。</p><h2 id="Don’t-let-your-code-to-grow-on-you"><a href="#Don’t-let-your-code-to-grow-on-you" class="headerlink" title="Don’t let your code to grow on you"></a><strong><em>Don’t let your code to grow on you</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你知道这种尴尬的情况，当你打开源文件并开始滚动时，滚动，并且你需要做更多的滚动。 是的，通常这是一个巨大的视图控制器问题，你已经知道自己永远迷路了。 如果到了这一步，你可以尝试通过引入一个新对象来重构代码，该对象可以接管控制器类的某些功能。</p><h2 id="不要重新发明轮子"><a href="#不要重新发明轮子" class="headerlink" title="不要重新发明轮子"></a><strong><em>不要重新发明轮子</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有最佳实践，请使用它。 开始编码之前，应始终查找问题。 在开始编码之前，你还应该仔细考虑问题。 请记住：你并不是唯一一个遇到编码问题的人，我几乎可以保证有人已经遇到了与你正在处理的问题完全相同的问题。  <code>StackOverflow</code> 是寻找解决方案的正确地方。 利用社区的力量，不要害怕在互联网上或从你的同事那里提问，但是不要期望别人会解决你的问题，那就是你的工作。</p></br><h1 id="给初学者的建议-Swift"><a href="#给初学者的建议-Swift" class="headerlink" title="给初学者的建议 Swift"></a><strong>给初学者的建议 Swift</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我将为你提供一些有关如何编写正确的Swift代码的快速建议。我知道我无法在此列表中包含所有内容，但我认为这些是一些非常重要的内容。</p><h2 id="了解如何编写正确的异步代码"><a href="#了解如何编写正确的异步代码" class="headerlink" title="了解如何编写正确的异步代码"></a><strong><em>了解如何编写正确的异步代码</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看，如果你知道厄运的“伟大” <a href="http://www.thomashanning.com/the-pyramid-of-doom/" target="_blank" rel="noopener"><strong><em><code>Pyramid of Doom</code></em></strong></a> 是什么，那么你就会知道我在说什么。你最终将要编写异步代码，大多数API都有异步方法。甚至一个简单的网络任务也是异步的。从一开始就学习如何编写正确的异步代码是明智之举。</p><h2 id="你可以选择几种方法。"><a href="#你可以选择几种方法。" class="headerlink" title="你可以选择几种方法。"></a><strong><em>你可以选择几种方法。</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，你可以通过使用完工块去上学。这是学习该概念的好方法，你可以练习很多，但是有很多更好的方法可以在2020年编写好的异步代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Promises</strong> 是异步任务的高级抽象，它们会让你的生活变得更加美好。你真正的力量来自于你可以使用功能性方法进行链接和转换的事实。 <code>Promises</code> 是惊人的，但实际上并没有内置的取消支持。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以执行 <strong>NSOperation</strong> 任务，但是如果你想使用一些语法糖，建议你使用 <strong>Promises</strong> 。我的问题是，如果必须在操作之间传递数据，则必须创建一个新的操作来执行此操作，但是作为这种不便的交换，它们可以在队列上运行，它们可以具有优先级和依赖性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我相信全新的 <strong>Combine框架</strong> 是2020年处理异步代码的最佳方法。</p><h2 id="仅在必要时使用单例"><a href="#仅在必要时使用单例" class="headerlink" title="仅在必要时使用单例"></a><strong><em>仅在必要时使用单例</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它们是万恶之源。老实说，尽量避免单例。如果你想处理混合状态和不可测试的代码，请与它们一起使用，但是如果你接受我的建议，你的生活会更好。如果你不知道如何避免单例模式，请进行一些研究。网上有很多关于该主题的精彩文章。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个例外：如果你特别在寻找共享状态（例如缓存机制）或本地存储对象（例如UserDefaults），则可以使用单例。否则不要使用单例。</p><h2 id="不要创建-helpers（或-managers）"><a href="#不要创建-helpers（或-managers）" class="headerlink" title="不要创建 helpers（或 managers）"></a><strong><em>不要创建 helpers（或 managers）</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你需要 <code>helpers</code> 课程，那么你做错了！每个对象在你的代码库中都有其自己的位置， <code>helpers</code> 是无用的，对任何事情都没有好处。重新思考，重新定义，重构（如果需要），但不惜一切代价避免使用辅助类。了解 <code>Swift设计模式</code> 或绘制有关模型的图表，但请相信我，代码中没有帮助者的位置。</p><h2 id="避免副作用和全局状态"><a href="#避免副作用和全局状态" class="headerlink" title="避免副作用和全局状态"></a><strong><em>避免副作用和全局状态</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用全局变量是一个非常糟糕的做法。最终，你的代码的某些部分将覆盖global属性，并且事情将变得一团糟。你只需消除这些全局变量即可避免产生副作用。使功能正常运行也是改善代码的一种好方法。</p><h2 id="写一些测试"><a href="#写一些测试" class="headerlink" title="写一些测试"></a><strong><em>写一些测试</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该始终编写测试，我并不是说你应该使用 <code>TDD</code> ，但是 <code>单元测试</code> 是一种好习惯。他们将帮助你考虑可能的错误，并验证你的代码库。 UI测试也很适合验证用户界面，此外，如果不必运行手动测试，则可以节省大量时间。</p></br><h1 id="非技术技能"><a href="#非技术技能" class="headerlink" title="非技术技能"></a><strong>非技术技能</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我知道这是一个清单。不要害怕，你不必一次学习所有内容。开始你的iOS生涯不仅是学习新知识，还应该在旅途中玩得开心。 😊</p><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a><strong><em>时间</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要有耐心和一致。始终每天指定固定的时间进行编码。仅仅半个小时就没关系，如果每天都这样做，就会养成一个习惯，数字也会累加。在这个繁忙的世界中，很难找到时间真正专注于某些事情，但是如果你真的想学习如何编写Swift代码，这是你需要采取的最重要的步骤。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a><strong><em>动机</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你有“梦想”，那么上进很容易。你要构建一个应用程序吗？你是否想学习如何在Swift中写东西？你想找到更好的工作吗？你想为孩子们制作游戏吗？所有这些都可以成为巨大的动力。当你不断遇到障碍时，问题就开始了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要害怕！成为程序员意味着有时你会尝试并失败。如果你想成为一名真正的优秀开发人员，则应该从这些错误中吸取教训，并在第二次做得更好。当然，你也会从其他人那里学到很多东西，但是有时你必须解决自己的问题。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong><em>目标</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要试图追求一个真正的大目标。庆祝小小的成功故事和成就。你还应该为“今天”所做的事情感到自豪。忘记这些小事情很容易，但是开发一个应用程序或学习一种新的编程语言是一个长期的项目。如果你没有时间可以庆祝，那么你最终将失去对“项目”的动力和兴趣。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想学习Swift，我认为这三件事是最重要的非技术技能。每天都有自己专用的时间编写代码。从梦想中获得动力（跟随大局），同时也庆祝你取得的每一个小小的成功故事。循序渐进，你会发现没有什么是你不能学的。无论如何，技术技能只是次要的……🤷️</p></br><h1 id="Swift-社区很棒"><a href="#Swift-社区很棒" class="headerlink" title="Swift 社区很棒"></a><strong>Swift 社区很棒</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很高兴看到仍然有很多专职人员继续撰写有关 <code>iOS/Swift</code> 开发的优缺点的文章。 这是2020年你应该知道的最佳资源。</p><h2 id="最佳iOS-Swift教程网站"><a href="#最佳iOS-Swift教程网站" class="headerlink" title="最佳iOS / Swift教程网站"></a><strong><em>最佳iOS / Swift教程网站</em></strong></h2><ul><li><a href="https://www.raywenderlich.com/" target="_blank" rel="noopener"><strong><em><code>Ray Wenderlich</code></em></strong></a></li><li><a href="https://nshipster.com/" target="_blank" rel="noopener"><strong><em><code>nshipster.com</code></em></strong></a></li><li><a href="https://www.objc.io/blog/" target="_blank" rel="noopener"><strong><em><code>objc.io</code></em></strong></a></li><li><a href="https://www.appcoda.com/" target="_blank" rel="noopener"><strong><em><code>AppCoda</code></em></strong></a></li><li><a href="https://www.pointfree.co/" target="_blank" rel="noopener"><strong><em><code>pointfree.co</code></em></strong></a></li></ul><h2 id="最佳iOS-Swift博客"><a href="#最佳iOS-Swift博客" class="headerlink" title="最佳iOS / Swift博客"></a><strong><em>最佳iOS / Swift博客</em></strong></h2><ul><li><p><a href="https://hackingwithswift.com/" target="_blank" rel="noopener"><strong><em><code>Paul Hudson</code></em></strong></a></p></li><li><p><a href="https://www.swiftbysundell.com/" target="_blank" rel="noopener"><strong><em><code>John Sundell</code></em></strong></a></p></li><li><p><a href="https://www.avanderlee.com/" target="_blank" rel="noopener"><strong><em><code>Antoine van der Lee</code></em></strong></a></p></li><li><p><a href="https://www.vadimbulavin.com/" target="_blank" rel="noopener"><strong><em><code>Vadim Bulavin</code></em></strong></a></p></li><li><p><a href="https://useyourloaf.com/" target="_blank" rel="noopener"><strong><em><code>Keith Harrison</code></em></strong></a></p></li><li><p><a href="https://swiftwithmajid.com/" target="_blank" rel="noopener"><strong><em><code>Majid Jabrayilov</code></em></strong></a></p></li><li><p><a href="https://cocoacasts.com/" target="_blank" rel="noopener"><strong><em><code>Bart Jacobs</code></em></strong></a></p></li><li><p><a href="http://khanlou.com/" target="_blank" rel="noopener"><strong><em><code>Soroush Khanlou</code></em></strong></a></p></li><li><p><a href="https://ericasadun.com/" target="_blank" rel="noopener"><strong><em><code>Erica Sadun</code></em></strong></a></p></li><li><p><a href="https://www.andrewcbancroft.com/" target="_blank" rel="noopener"><strong><em><code>Andrew Bancroft</code></em></strong></a></p></li></ul><h2 id="最佳iOS-Swift新闻通讯"><a href="#最佳iOS-Swift新闻通讯" class="headerlink" title="最佳iOS / Swift新闻通讯"></a><strong><em>最佳iOS / Swift新闻通讯</em></strong></h2><ul><li><a href="http://ios-goodies.com/" target="_blank" rel="noopener"><strong><em><code>iOS Goodies</code></em></strong></a></li><li><a href="https://iosdevweekly.com/" target="_blank" rel="noopener"><strong><em><code>iOS Dev Weekly</code></em></strong></a></li><li><a href="https://andybargh.com/swiftdevelopments/" target="_blank" rel="noopener"><strong><em><code>Swift Developments</code></em></strong></a></li><li><a href="http://indieiosfocus.com/" target="_blank" rel="noopener"><strong><em><code>Indie iOS focus weekly</code></em></strong></a></li></ul><h2 id="最佳iOS-Swift播客"><a href="#最佳iOS-Swift播客" class="headerlink" title="最佳iOS / Swift播客"></a><strong><em>最佳iOS / Swift播客</em></strong></h2><ul><li><a href="https://podcasts.apple.com/us/podcast/ios-dev-discussions-sean-allen/id1426167395" target="_blank" rel="noopener"><strong><em><code>iOS Dev Discussions</code></em></strong></a></li><li><a href="https://podcasts.apple.com/us/podcast/swift-over-coffee/id1435076502" target="_blank" rel="noopener"><strong><em><code>Swift over Coffee</code></em></strong></a></li><li><a href="https://swiftbysundell.com/podcast/" target="_blank" rel="noopener"><strong><em><code>Swift by Sundell</code></em></strong></a></li><li><a href="https://devchat.tv/iphreaks/" target="_blank" rel="noopener"><strong><em><code>iPhreaks</code></em></strong></a></li></ul><h2 id="最佳iOS-Swift播客-1"><a href="#最佳iOS-Swift播客-1" class="headerlink" title="最佳iOS / Swift播客"></a><strong><em>最佳iOS / Swift播客</em></strong></h2><ul><li><a href="https://podcasts.apple.com/us/podcast/ios-dev-discussions-sean-allen/id1426167395" target="_blank" rel="noopener"><strong><em><code>iOS Dev Discussions</code></em></strong></a></li><li><a href="https://podcasts.apple.com/us/podcast/swift-over-coffee/id1435076502" target="_blank" rel="noopener"><strong><em><code>Swift over Coffee</code></em></strong></a></li><li><a href="https://swiftbysundell.com/podcast/" target="_blank" rel="noopener"><strong><em><code>Swift by Sundell</code></em></strong></a></li><li><a href="https://devchat.tv/iphreaks/" target="_blank" rel="noopener"><strong><em><code>iPhreaks</code></em></strong></a></li></ul><h2 id="关注Twitter帐户"><a href="#关注Twitter帐户" class="headerlink" title="关注Twitter帐户"></a><strong><em>关注Twitter帐户</em></strong></h2><ul><li><a href="https://twitter.com/aciidb0mb3r" target="_blank" rel="noopener"><strong><em><code>Ankit Aggarwal</code></em></strong></a></li><li><a href="https://twitter.com/harlanhaskins" target="_blank" rel="noopener"><strong><em><code>Harlan Haskins</code></em></strong></a></li><li><a href="https://twitter.com/nnnnnnnn" target="_blank" rel="noopener"><strong><em><code>Nate Cook</code></em></strong></a></li><li><a href="https://twitter.com/slava_pestov" target="_blank" rel="noopener"><strong><em><code>Slava Pestov</code></em></strong></a></li><li><a href="https://twitter.com/tkremenek" target="_blank" rel="noopener"><strong><em><code>Ted Kremenek</code></em></strong></a></li><li><a href="https://twitter.com/simjp" target="_blank" rel="noopener"><strong><em><code>JP Simard</code></em></strong></a></li><li><a href="https://twitter.com/daniel_dunbar" target="_blank" rel="noopener"><strong><em><code>Daniel Dunbar</code></em></strong></a></li><li><a href="https://twitter.com/dgregor79" target="_blank" rel="noopener"><strong><em><code>Doug Gregor</code></em></strong></a></li><li><a href="https://twitter.com/jckarter" target="_blank" rel="noopener"><strong><em><code>Joe Groff</code></em></strong></a></li><li><a href="https://twitter.com/AirspeedSwift" target="_blank" rel="noopener"><strong><em><code>Ben Cohen</code></em></strong></a></li><li><a href="https://twitter.com/tanner0101" target="_blank" rel="noopener"><strong><em><code>Tanner Wayne Nelson</code></em></strong></a></li><li><a href="https://twitter.com/ashfurrow" target="_blank" rel="noopener"><strong><em><code>Ash Furrow</code></em></strong></a></li><li><a href="https://twitter.com/olebegemann" target="_blank" rel="noopener"><strong><em><code>Ole Begemann</code></em></strong></a></li><li><a href="https://twitter.com/_bartjacobs" target="_blank" rel="noopener"><strong><em><code>Bart Jacobs</code></em></strong></a></li><li><a href="https://twitter.com/daveverwer" target="_blank" rel="noopener"><strong><em><code>Dave Verwer</code></em></strong></a></li><li><a href="https://twitter.com/rwenderlich" target="_blank" rel="noopener"><strong><em><code>Ray Wenderlich</code></em></strong></a></li><li><a href="https://twitter.com/objcio" target="_blank" rel="noopener"><strong><em><code>objc.io</code></em></strong></a></li><li><a href="https://twitter.com/NSHipster" target="_blank" rel="noopener"><strong><em><code>NSHipster</code></em></strong></a></li><li><a href="https://twitter.com/merowing_" target="_blank" rel="noopener"><strong><em><code>Krzysztof Zabłocki</code></em></strong></a></li><li><a href="https://twitter.com/krzyzanowskim" target="_blank" rel="noopener"><strong><em><code>Marcin Krzyzanowski</code></em></strong></a></li><li><a href="https://twitter.com/steipete" target="_blank" rel="noopener"><strong><em><code>Peter Steinberger</code></em></strong></a></li><li><a href="https://twitter.com/chriseidhof" target="_blank" rel="noopener"><strong><em><code>Chris Eidhof</code></em></strong></a></li><li><a href="https://twitter.com/khanlou" target="_blank" rel="noopener"><strong><em><code>soroush</code></em></strong></a></li><li><a href="https://twitter.com/ericasadun" target="_blank" rel="noopener"><strong><em><code>ericasadun</code></em></strong></a></li><li><a href="https://twitter.com/clattner_llvm" target="_blank" rel="noopener"><strong><em><code>Chris Lattner</code></em></strong></a></li><li><a href="https://twitter.com/siracusa" target="_blank" rel="noopener"><strong><em><code>John Siracusa</code></em></strong></a></li><li><a href="https://twitter.com/siracusa" target="_blank" rel="noopener"><strong><em><code>Sean Allen</code></em></strong></a></li><li><a href="https://twitter.com/marcoarment" target="_blank" rel="noopener"><strong><em><code>Marco Arment</code></em></strong></a></li><li><a href="https://twitter.com/twostraws" target="_blank" rel="noopener"><strong><em><code>Paul Hudson</code></em></strong></a></li><li><a href="https://twitter.com/johnsundell" target="_blank" rel="noopener"><strong><em><code>John Sundell</code></em></strong></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift URLSession 和 Combine framework</title>
      <link href="/Swift%20URLSession%20%E5%92%8C%20Combine%20framework/"/>
      <url>/Swift%20URLSession%20%E5%92%8C%20Combine%20framework/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用带有 <code>基础网络</code> 的全新 <code>Combine框架</code> 发出 <code>HTTP请求</code> 并解析响应。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这将是一个非常简短但希望非常有用的教程，它讲述了我如何开始利用 <a href="https://heckj.github.io/swiftui-notes/" target="_blank" rel="noopener"><strong><em><code>Combine框架</code></em></strong></a> 来缓慢替换 <code>Promise库</code> 。 🤫</p></br><h1 id="API-amp-data-structure"><a href="#API-amp-data-structure" class="headerlink" title="API &amp; data structure"></a><strong>API &amp; data structure</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们将需要某种API进行连接，像往常一样，我将对以下数据模型使用我最喜欢的 <a href="https://jsonplaceholder.typicode.com/" target="_blank" rel="noopener"><strong><em><code>JSONPlaceholder</code></em></strong></a> 服务：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTPError</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> statusCode</span><br><span class="line">    <span class="keyword">case</span> post</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> body: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> userId: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Todo</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> completed: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">let</span> userId: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，没有什么特别的，只是一些基本的 <code>Codable元素</code> 和一个简单的错误，如果某件事失败，我们希望显示一些错误。 ❌</p></br><h1 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a><strong>传统方式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中执行 <code>HTTP请求</code> 非常容易，你可以将内置的共享 <code>URLSession</code> 与简单的数据任务结合使用，然后响应一下。 当然，你可能想检查有效的状态码，如果一切正常，则可以使用 <code>Foundation</code> 中的 <code>JSONDecoder</code> 对象来 <a href=""""><strong><em><code>解析响应JSON</code></em></strong></a> 。</p><!-- more --><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//somewhere in viewDidLoad</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Error: \(error.localizedDescription)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>, response.statusCode == <span class="number">200</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Error: invalid HTTP response code"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Error: missing response data"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">        <span class="keyword">let</span> posts = <span class="keyword">try</span> decoder.decode([<span class="type">Post</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">        <span class="built_in">print</span>(posts.<span class="built_in">map</span> &#123; $<span class="number">0</span>.title &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error: \(error.localizedDescription)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task.resume()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要忘记继续 <strong>执行</strong> 数据任务，否则该请求将根本不会触发。 🔥</p></br><h1 id="Data-tasks-和-the-Combine-framework"><a href="#Data-tasks-和-the-Combine-framework" class="headerlink" title="Data tasks 和 the Combine framework"></a><strong>Data tasks 和 the Combine framework</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在你可以看到传统的 <code>“基于块”</code> 的方法很好，但是我们可以在这里做些更好的事情吗？ 你知道吗，就像将整个事物描述成一个链条一样，就像我们过去对 <code>Promises</code> 所做的那样？ 从 <code>iOS13</code> 开始，借助惊人的 <code>Combine框架</code> ，你实际上可以超越！ 😃</p><p><strong><em><code>我最喜欢组合的部分是内存管理和取消。</code></em></strong></p><h2 id="合并数据任务"><a href="#合并数据任务" class="headerlink" title="合并数据任务"></a><strong><em>合并数据任务</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，最常见的示例通常是以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> cancellable: <span class="type">AnyCancellable?</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">self</span>.cancellable = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url)</span><br><span class="line">.<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;</span><br><span class="line">.decode(type: [<span class="type">Post</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line">.replaceError(with: [])</span><br><span class="line">.eraseToAnyPublisher()</span><br><span class="line">.sink(receiveValue: &#123; posts <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(posts.<span class="built_in">count</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">self</span>.cancellable?.cancel()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我喜欢代码 <code>“解释自己”</code> 的方式：</p><ul><li>首先，我们为你的 Publisher 制作一个可取消的存储</li><li>然后，我们创建一个全新的数据任务 publisher 对象</li><li>映射响应，我们只关心数据部分（忽略错误）</li><li>使用 JSONDecoder 解码数据的内容</li><li>如果有任何问题，请使用一个空数组</li><li>消除基本复杂性到简单的 AnyPublisher </li><li>使用接收器显示有关最终值的一些信息</li><li>可选：你可以随时取消网络请求</li></ul><h2 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a><strong><em>Error handling</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们介绍一些 <a href="https://medium.com/codequest/error-handling-in-combine-b6150a9fc2a7" target="_blank" rel="noopener"><strong><em><code>错误处理</code></em></strong></a> ，因为我不喜欢隐藏错误的想法。 发出带有实际错误消息的警报要好得多，不是吗？ 🤔</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTPError</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> statusCode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.cancellable = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url)</span><br><span class="line">.tryMap &#123; output <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> response = output.response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>, response.statusCode == <span class="number">200</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">HTTPError</span>.statusCode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output.data</span><br><span class="line">&#125;</span><br><span class="line">.decode(type: [<span class="type">Post</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line">.eraseToAnyPublisher()</span><br><span class="line">.sink(receiveCompletion: &#123; completion <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> completion &#123;</span><br><span class="line">    <span class="keyword">case</span> .finished:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">fatalError</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, receiveValue: &#123; posts <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(posts.<span class="built_in">count</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，这次我们检查响应代码，如果出现问题，则抛出错误。 现在，由于 <code>publisher</code> 可能会导致错误状态，因此 <code>sink</code> 具有另一个变体，你可以在其中检查整个操作的结果，以便在那里进行自己的错误操作，例如显示警报。 🚨</p><h2 id="将结果分配给属性"><a href="#将结果分配给属性" class="headerlink" title="将结果分配给属性"></a><strong><em>将结果分配给属性</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个常见的模式是将响应存储在视图控制器中某个位置的内部变量中。 你可以简单地通过使用 <code>assign函数</code> 来做到这一点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cancellable: <span class="type">AnyCancellable?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> posts: [<span class="type">Post</span>] = [] &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"posts --&gt; \(self.posts.count)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>)!</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.cancellable = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url)</span><br><span class="line">        .<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;</span><br><span class="line">        .decode(type: [<span class="type">Post</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line">        .replaceError(with: [])</span><br><span class="line">        .eraseToAnyPublisher()</span><br><span class="line">        .assign(to: \.posts, on: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非常简单，你还可以使用 <code>didSet</code> 属性观察器来获取有关更改的通知。</p><h2 id="分组多个请求"><a href="#分组多个请求" class="headerlink" title="分组多个请求"></a><strong><em>分组多个请求</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过去，发送多个请求是一个痛苦的过程。 现在我们有了 <code>Compose</code> ，使用 <code>Publishers.Zip</code> 可以轻松完成此任务。 你可以将多个请求合并在一起，然后等待它们都完成。 🤐</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url1 = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>)!</span><br><span class="line"><span class="keyword">let</span> url2 = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> publisher1 = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url1)</span><br><span class="line">.<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;</span><br><span class="line">.decode(type: [<span class="type">Post</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> publisher2 = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url2)</span><br><span class="line">.<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;</span><br><span class="line">.decode(type: [<span class="type">Todo</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.cancellable = <span class="type">Publishers</span>.<span class="type">Zip</span>(publisher1, publisher2)</span><br><span class="line">.eraseToAnyPublisher()</span><br><span class="line">.<span class="keyword">catch</span> &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="type">Just</span>(([], []))</span><br><span class="line">&#125;</span><br><span class="line">.sink(receiveValue: &#123; posts, todos <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(posts.<span class="built_in">count</span>)</span><br><span class="line">    <span class="built_in">print</span>(todos.<span class="built_in">count</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在我们和以前一样，只是将两个 <code>publishers</code> 压缩在一起。</p><h2 id="请求依赖"><a href="#请求依赖" class="headerlink" title="请求依赖"></a><strong><em>请求依赖</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 有时，你必须从给定的URL加载资源，然后使用另一个资源以其他方式扩展对象。 我说的是请求依赖，如果没有 <code>Combine</code> ，这将是一个很大的问题，但是现在你可以将两个 <code>HTTP调用</code> 与几行 <code>Swift</code> 代码链接在一起。 让我给你演示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> url1 = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>)!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.cancellable = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url1)</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;</span><br><span class="line">    .decode(type: [<span class="type">Post</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line">    .tryMap &#123; posts <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> id = posts.first?.id <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">HTTPError</span>.post</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id</span><br><span class="line">    &#125;</span><br><span class="line">    .flatMap &#123; id <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.details(<span class="keyword">for</span>: id)</span><br><span class="line">    &#125;</span><br><span class="line">    .sink(receiveCompletion: &#123; completion <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    &#125;) &#123; post <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(post.title)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">details</span><span class="params">(<span class="keyword">for</span> id: Int)</span></span> -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">Post</span>, <span class="type">Error</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts/\(id)"</span>)!</span><br><span class="line">    <span class="keyword">return</span> <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url)</span><br><span class="line">        .mapError &#123; $<span class="number">0</span> <span class="keyword">as</span> <span class="type">Error</span> &#125;</span><br><span class="line">        .<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;</span><br><span class="line">        .decode(type: <span class="type">Post</span>.<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line">        .eraseToAnyPublisher()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的技巧是你可以将一个 <code>publisher</code> <strong><code>flatMap</code></strong> 映射到另一个 <code>publisher</code> 。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Combine</code> 是一个了不起的框架，它可以完成很多工作，但是肯定有一些学习过程。 可悲的是，仅当你针对 <code>iOS13或更高版本</code> 时才可以使用它（这意味着你有一年的时间来学习框架的每一点），因此在采用这种新技术之前请三思而后行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还应该注意，当前没有 <a href="http://www.xuebaonline.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Codable%20protocol%E5%9C%A8Swift%E4%B8%AD%E8%A7%A3%E6%9E%90JSON%EF%BC%9F/"><strong><em><code>上载和下载任务publisher</code></em></strong></a> ，但是你可以制定自己的解决方案，直到Apple正式发布某些东西。  🤞</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我真的很喜欢 <code>Apple</code> 如何实现 ··· 的一些概念，我迫不及待地希望 <code>Combine</code> 成为具有 <code>Linux</code> 支持的开源软件包。 ❤️</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Combine framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Combine framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift Promises 探究</title>
      <link href="/Swift%20Promises%20%E6%8E%A2%E7%A9%B6/"/>
      <url>/Swift%20Promises%20%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Promises</code> 是链接异步任务的一种方法。 通常，异步任务以块的形式进行回调（或有时两个，一个用于成功，一个用于失败），该回调在异步操作完成时被调用。 要执行多个异步操作，你必须将第二个嵌套在第一个的完成块中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">APIClient</span>.fetchCurrentUser(success: &#123; currentUser <span class="keyword">in</span></span><br><span class="line"><span class="type">APIClient</span>.fetchFollowers(user: currentUser, success: &#123; followers <span class="keyword">in</span></span><br><span class="line"><span class="comment">// you now have an array of followers</span></span><br><span class="line">&#125;, failure: &#123; error <span class="keyword">in</span></span><br><span class="line"><span class="comment">// handle the error</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;, failure: &#123; error <span class="keyword">in</span></span><br><span class="line"><span class="comment">// handle the error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Promises</code> 是一种形式化这些完成模块的方法，以使链接异步过程变得更加容易。 如果系统知道成功和失败的代码，那么编写这些异步操作将变得更加容易。 例如，编写可重复使用的代码可以：</p><ul><li>最后执行一个相关的异步操作链，并带有一个完成块</li><li>一个完成块同时执行许多独立的异步操作</li><li>开启许多异步操作并返回第一个要完成的值</li><li>重试异步操作</li><li>为异步操作添加超时</li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码示例转换为 <code>Promise</code> 时，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">APIClient</span>.fetchCurrentUser().then(&#123; currentUser <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">APIClient</span>.fetchFollowers(user: currentUser)</span><br><span class="line">&#125;).then(&#123; followers <span class="keyword">in</span></span><br><span class="line"><span class="comment">// you now have an array of followers</span></span><br><span class="line">)&#125;.onFailure(&#123; error <span class="keyword">in</span></span><br><span class="line"><span class="comment">// hooray, a single failure block!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（你会注意到， <code>promise</code> 是将嵌套/缩进代码转换为 <code>flat</code> 代码的东西： <code>promise</code> 是 <code>monad</code> 。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>JavaScript社区</code> 中， <code>promise</code> 逐渐兴起。因为 <code>Node.js</code> 被设计为具有许多异步功能，所以即使是简单的任务也需要具有异步回调的方法调用链。即使仅执行了其中的3或4个操作，操作也变得很笨拙。 <code>Promise</code> 挽救了这一天，现在已成为 <code>JavaScript ES6</code> 官方规范的一部分。这篇<a href="http://www.mattgreer.org/articles/promises-in-wicked-detail/" target="_blank" rel="noopener"><strong><code>博客文章</code></strong></a> 详细介绍了 <code>JavaScript</code> 的 <code>promise</code> 如何运作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>JavaScript Promise</code> 实现的一大优点是有一个非常明确定义的规范，称为 <strong>A +</strong> ，可以在 <a href="https://www.promisejs.org/" target="_blank" rel="noopener"><strong><code>promisejs.org</code></strong></a> 中找到。这意味着由于 <code>JavaScript</code> 的弱类型系统，可能会出现多个 <code>promise</code> 实现，并且它们可以完全互操作。只要你的 <code>Promise</code> 实现具有符合规范的 <code>then函数</code> ，就可以将其与其他库中的 <code>promise链接</code> 在一起。这太棒了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编写 <code>Backchannel API（位于Node中）</code> 时，我开始喜欢 <code>Promises</code> 。  <strong>A+规范</strong> 具有一个非常不错的 <code>API</code> ，避免了你希望在 <code>monad</code> 上使用的功能名称，以便于这样更简单，更易于理解（将其重载为 <code>flatMap和map</code> ）。尽管该 <code>API</code> 并非适合所有人（特别是，我可以完全理解为什么你偏爱函数名称的显式性），但我确实很喜欢它，并且着手在 <code>Swift</code> 中实现类似的库。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以在 <a href="https://github.com/khanlou/Promise" target="_blank" rel="noopener"><strong><code>Github</code></strong></a> 上找到此库。编写过程很有启发性，我想分享一些我在这里学到的东西。</p></br><h1 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a><strong>Enums</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是的，大家都知道。 枚举很棒。 但是因为 <code>Promises</code> 本质上是一个 <strong>状态机</strong> ，所以枚举在这里特别适合。  <code>JavaScript</code> 的 <code>Promise</code> 的参考实现开始如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="type">PENDING</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="type">FULFILLED</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="type">REJECTED</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">function <span class="type">Promise</span>() &#123;</span><br><span class="line">  <span class="comment">// store state which can be PENDING, FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">var</span> state = <span class="type">PENDING</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store value or error once FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">var</span> value = null;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store success &amp; failure handlers attached by calling .then or .done</span></span><br><span class="line">  <span class="keyword">var</span> handlers = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果尝试，我无法为 <code>Swift的枚举</code> 构想出更完美的例子。 这是 <code>Swift</code> 中的相同代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">State</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Pending</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Fulfilled</span>(value: <span class="type">Value</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Rejected</span>(error: <span class="type">ErrorType</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Promise</span>&lt;<span class="title">Value</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> state: <span class="type">State</span>&lt;<span class="type">Value</span>&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> callbacks: [<span class="type">Callback</span>&lt;<span class="type">Value</span>&gt;] = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于附加数据取决于 <code>Promise</code> 所处的特定状态，因此附加数据将作为关联值存储在每个枚举案例中。 由于将 <code>Promise</code> 置于 <code>.Pending状态</code> 并没有任何价值，因此枚举使其在类型系统中完全无法表达。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我唯一的批评是，泛型类型不能嵌套在其他类型中。</p></br><h1 id="Type-systems"><a href="#Type-systems" class="headerlink" title="Type systems"></a><strong>Type systems</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建新的 <code>JavaScript Promise</code> 时，可以使用便捷的初始化程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">someAsyncRequest(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">reject(error);</span><br><span class="line">&#125;</span><br><span class="line">resolve(result);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你将其传递给一个具有以下两个功能的函数：一个用于 <code>Promise</code> 是否成功，另一个用于 <code>Promise</code> 是否失败。 对于这两个功能，顺序很重要。 而且由于 <code>JavaScript</code> 不是类型安全的，如果你在上面第一行中对函数进行了错误排序，编写了 <code>reject</code> ， <code>resolve</code> （我做得比我想承认的要多得多），你可以轻松地将错误传递给 resolve 功能。 <code>另一方面，Swift</code> 的类型安全性意味着 <code>reject</code> 函数的类型为 <code>（ErrorType）-&gt; Void</code> ，并且不会接受你的成功结果。 担心我会搞混 <code>reject</code> 和 <code>resolve</code> 功能的顺序，这已经成为过去。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Promise类型</code> 是 <code>Value</code> 之上的泛型， <code>Value</code> 是它产生的值的类型。 这意味着你可以依靠类型推断来编写没有类型的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>(value: <span class="string">"initialValue"</span>) <span class="comment">// a fulfilled Promise&lt;String&gt;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>promise</code> 通常是链接在一起的，因此依靠推断来找出你的类型将是特别有用的。 必须在链中的每个步骤中添加显式类型将非常令人沮丧，并且最终不会特别像 <code>Swift</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对此的第一个破解也是对 <code>Error的泛型</code> 。 这种严格性意味着要实现 <code>promise</code> ，就需要你每次都预先指定错误的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>&lt;<span class="built_in">String</span>, APIError&gt;(value: <span class="string">"initialValue"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这在以前的简单代码行中增加了很多不必要的负担，因此我删除了指定错误类型的功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不幸的是，删除显式错误类型意味着我不得不错过一个小型的类型系统好东西。 如果你创建一个名为 <code>NoError</code> 的空枚举，则可以有效地表示诺言不会失败。 由于无法初始化空的枚举，因此无法使 <code>promise</code> 进入 <code>rejected</code> 状态。 这是一个可悲的损失，但是最终，我认为这是值得的，因为它使在其他情况下使用 <code>promise</code> 更加简单。 我希望在实践中使用该课程可以让我深入了解这是否是一个明智的决定。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与此相关， <code>Swift</code> 的泛型清单包含 <code>“默认泛型参数”</code> ，这将是解决此问题的好方法：你可以说默认值为 <code>ErrorType</code> ，并且如果有人想更具体地讲，他们就有这种能力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Promise</code> 类型是 <code>monad</code> ，这意味着你可以在其上调用 <code>flatMap</code> 。你传递给 <code>flatMap</code> 的函数将返回一个新的 <code>Promise</code> ，并且 <code>Promise</code> 的状态成为链的状态。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是， <code>flatMap函数</code> 的名称是完全不可理解的。它无法以一种易于阅读的方式来表示此处实际发生的情况。这是我偏爱 <code>A+</code> 的 <code>Promise API</code> 的部分原因。  <code>JavaScript</code> 中的 <code>then函数</code> 被重载，以充当 <code>flatMap</code> （为链返回一个新的承诺）和 <code>map</code> （为链中的下一个承诺返回一个新值）。那么现在的意思就是“不做下一步”，而不必考虑下一步的工作方式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>Swift的类型系统</code> 知道函数何时返回 <code>Void</code> ，因此还可以重载以接受不返回任何内容的函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦编写了该类的基本实现，就编写了一些测试。 我对 <code>XCTest</code> 的 <code>ExpectationWithDescription</code> 和 <code>waitForExpectationsWithTimeout</code> 有了一些经验，它们是非常不错的 <code>API</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为 <code>Promise类</code> 提供一整套测试非常有用。 与往常一样，编写测试会产生一些前期费用，但这完全值得。 当我重构和清理此代码时，测试捕获了许多错误。  <code>promise</code> 实现非常多样，有关代码执行顺序的微小细节以微妙的方式改变了类的行为。 拥有一个确认重构确实是同构的测试套件非常棒。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为 <code>Promise</code> 本质上处理 线程和异步性 ，所以它必须是 <code>线程安全</code> 的类。为了使该类具有线程安全性，需要从同一队列中全部访问其实例变量。这比我预期的要难。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别是其中两个测试非常不稳定，我运行测试套件每5-10次就会失败一次。没有什么比片状测试更可怕的了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中一项不稳定的测试导致了 <code>EXC_BAD_ACCESS</code> 的产生，这非常令人困惑，因为我无法想到 <code>Swift</code> 中的一种方式来访问不良内存。我花了一段时间，但最终得到一条日志消息，提示它是线程问题。我正在同时将多个线程中的东西添加到数组中。我更正了访问实例变量的代码，以正确使用调度队列，并且不稳定的测试变得可靠。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Promises </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Promises </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift Promises 初体验</title>
      <link href="/Swift%20Promises%20%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/Swift%20Promises%20%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你想要了解的有关 <code>futures</code> 和 <code>promises</code> 的一切。 关于 <code>Swift</code> 中异步编程的初学者指南。</p></br><h1 id="同步与异步执行"><a href="#同步与异步执行" class="headerlink" title="同步与异步执行"></a><strong>同步与异步执行</strong></h1><blockquote><p>编写异步代码是构建应用程序中最难的部分之一。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>同步执行</code> 和 <code>异步执行</code> 之间到底有什么区别？ 好了，我已经在 <a href="http://www.xuebaonline.com/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Swift%E4%B8%AD%E7%9A%84Grand%20Central%20Dispatch/"><strong><em><code>Dispatch框架教程</code></em></strong></a> 中对此进行了解释，但是这里有一个简短的回顾。 同步函数通常会阻塞当前线程，并在以后返回一些值。 一个异步函数将立即返回并将结果值传递给完成处理程序。 你可以使用GCD框架在给定队列上异步执行任务同步。 让我给你看一个简单的例子：</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aBlockingFunction</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    sleep(.random(<span class="keyword">in</span>: <span class="number">1</span>...<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syncMethod</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aBlockingFunction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asyncMethod</span><span class="params">(completion block: @escaping <span class="params">(<span class="params">(String)</span></span></span></span> -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global(qos: .background).async &#123;</span><br><span class="line">        block(aBlockingFunction())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(syncMethod())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"sync method returned"</span>)</span><br><span class="line">asyncMethod &#123; value <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"async method returned"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// "Hello world!"</span></span><br><span class="line"><span class="comment">// "sync method returned"</span></span><br><span class="line"><span class="comment">// "async method returned"</span></span><br><span class="line"><span class="comment">// "Hello world!"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见， <code>async方法</code> 完全在后台队列上运行，该函数不会阻塞当前线程。 这就是为什么异步方法可以立即返回的原因，因此你将始终在最后一个 <code>hello</code> 输出之前看到 <code>return</code> 输出。 存储异步方法的完成块以供以后执行，这就是为什么可以在原始函数返回之后以回调方式返回字符串值的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不使用其他队列会怎样？ 完成块将在当前队列上执行，因此你的函数将对其进行阻止。 这将有点异步，但是实际上你只是将返回值移到完成块中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syncMethod</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fakeAsyncMethod</span><span class="params">(completion block: <span class="params">(<span class="params">(String)</span></span></span></span> -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">    block(<span class="string">"Hello world!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(syncMethod())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"sync method returned"</span>)</span><br><span class="line">fakeAsyncMethod &#123; value <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"fake async method returned"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，我真的不想集中讨论完成块，这可能是一篇独立的文章，但是如果你在并发模型上仍然遇到问题，或者你不了解任务和线程的工作方式，则应该阅读一下 很少研究。</p></br><h1 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a><strong>回调地狱</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;异步代码有什么问题？ 还是编写异步代码的结果是什么？ 简短的答案是，你必须使用完成块（回调）才能处理将来的结果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更详细的答案是管理回调很糟糕。 你必须要小心，因为在一个块中你可以轻松地创建一个 <code>retain-cycle</code> ，因此你必须将变量作为弱引用或 <code>unowned references</code> 来传递。 另外，如果必须使用多个异步方法，那将是非常的痛苦。 🐴</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Todo</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> completed: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Network error: "</span> + error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Not a HTTP response"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> response.statusCode &lt;= <span class="number">200</span>, response.statusCode &gt; <span class="number">300</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Invalid HTTP status code"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"No HTTP data"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> todos = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode([<span class="type">Todo</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">        <span class="built_in">print</span>(todos)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"JSON decoder error: "</span> + error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码段是一个简单的 <code>异步HTTP数据请求</code> 。 如你所见，其中涉及许多可选值，而且，如果要使用自己的类型，则必须执行一些 <code>JSON解析</code> 。 这只是一个请求，但是如果你需要从第一个元素中获取一些详细信息怎么办？ 让我们写一个助手！ ＃没有🤫</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(<span class="number">_</span> url: URL, completion: @escaping <span class="params">(<span class="params">(Data)</span></span></span></span> -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">    <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Network error: "</span> + error.localizedDescription)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Not a HTTP response"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> response.statusCode &lt;= <span class="number">200</span>, response.statusCode &gt; <span class="number">300</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid HTTP status code"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"No HTTP data"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        completion(data)</span><br><span class="line">    &#125;.resume()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos"</span>)!</span><br><span class="line">request(url) &#123; data <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> todos = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode([<span class="type">Todo</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> first = todos.first <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos/\(first.id)"</span>)!</span><br><span class="line">        request(url) &#123; data <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> todo = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">Todo</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">                <span class="built_in">print</span>(todo)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="built_in">fatalError</span>(<span class="string">"JSON decoder error: "</span> + error.localizedDescription)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"JSON decoder error: "</span> + error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到？ 我的问题是我们正在慢慢地向兔子洞下移动。 现在，如果我们有第三个请求怎么办？ 一定不行！ 你必须将所有内容再嵌套一层，而且还必须传递必要的变量，例如。 <code>weak</code> 或 <code>unowned</code> 的视图控制器引用，因为在某个时间点，你必须根据结果更新整个UI。 必须有更好的方法来解决此问题。 🤔</p></br><h1 id="Results-vs-futures-vs-promises"><a href="#Results-vs-futures-vs-promises" class="headerlink" title="Results vs futures vs promises?"></a><strong>Results vs futures vs promises?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.xuebaonline.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Result%20Type%E6%9D%A5%E5%A4%84%E7%90%86Swift%205%E4%B8%AD%E7%9A%84Errors%EF%BC%9F/"><strong><em><code>result type</code></em></strong></a> 是在 <code>Swift 5</code> 中引入的，它对于从公式中消除可选因子非常有用。 这意味着你不必处理可选的数据和可选的错误类型，但是结果就是其中之一。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Futures</strong> 基本上代表着 <code>Futures</code> 的价值。 基础值可以是例如结果，并且应具有以下状态之一：</p><ul><li><strong>pending</strong> - 尚无价值，正在等待…</li><li><strong>fulfilled</strong> - 成功，现在结果有价值</li><li><strong>rejected</strong> - 失败并出现错误</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据定义， <code>futures</code> 不应由最终用户编写。 这意味着开发人员不应创建，实现或拒绝开发者。 但是，如果是这样，并且我们遵守规则，我们将如何制作 <code>futures</code> ？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们向他们保证。 你必须创建一个 <code>Promise</code> ，基本上是一个 <code>futures</code> 的包装，可以根据需要编写（实现，拒绝）或转换。 你不写 <code>futures</code> ，而是 <code>Promise</code> 。 但是，有些框架允许你取回 <code>Promise</code> 的 <code>futures values</code> ，但你根本不应该写那个 <code>futures</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;足够的理论，你准备好爱上 <code>Promise</code> 了吗？ ❤️</p></br><h1 id="Promises-101-入门指南"><a href="#Promises-101-入门指南" class="headerlink" title="Promises 101-入门指南"></a><strong>Promises 101-入门指南</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们使用 <a href="https://github.com/CoreKit/Promises" target="_blank" rel="noopener"><strong><em><code>promise框架</code></em></strong></a> 重构前面的示例！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">HTTPError</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> invalidResponse</span><br><span class="line">        <span class="keyword">case</span> invalidStatusCode</span><br><span class="line">        <span class="keyword">case</span> noData</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dataTask</span><span class="params">(url: URL)</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">Data</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">Data</span>&gt; &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] fulfill, reject <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="type">HTTPError</span>.invalidResponse)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">guard</span> response.statusCode &lt;= <span class="number">200</span>, response.statusCode &gt; <span class="number">300</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="type">HTTPError</span>.invalidStatusCode)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="type">HTTPError</span>.noData)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                fulfill(data)</span><br><span class="line">            &#125;.resume()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TodoError</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> missing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos"</span>)!</span><br><span class="line"><span class="type">URLSession</span>.shared.dataTask(url: url)</span><br><span class="line">.thenMap &#123; data <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode([<span class="type">Todo</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">&#125;</span><br><span class="line">.thenMap &#123; todos -&gt; <span class="type">Todo</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> first = todos.first <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">TodoError</span>.missing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br><span class="line">.then &#123; first <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos/\(first.id)"</span>)!</span><br><span class="line">    <span class="keyword">return</span> <span class="type">URLSession</span>.shared.dataTask(url: url)</span><br><span class="line">&#125;</span><br><span class="line">.thenMap &#123; data <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">Todo</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">&#125;</span><br><span class="line">.onSuccess &#123; todo <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(todo)</span><br><span class="line">&#125;</span><br><span class="line">.onFailure(queue: .main) &#123; error <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚刚发生什么事了？ 好吧，我整理了在 <code>URLSession对象</code> 上实现的数据任务方法的扩展版本。 当然，如果你需要网络层的更多信息，则可以返回 <code>HTTP结果</code> 或仅返回状态代码以及数据。 你可以使用新的响应数据模型，甚至可以使用元组。 🤷‍♂️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，更有趣的部分是源的下半部分。 如你所见，我正在调用全新的 <code>dataTask方法</code> ，该方法返回 <code>Promise &lt;Data&gt;</code>对象。 正如我之前提到的，诺言可以转换。 还是我应该说： <code>chained</code> ？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Chaining promises</code> 是优于回调的最大优势。 源代码看起来不再像是带有疯狂压痕和尝试捕获块的金字塔，而是更像是一连串的动作。 在每一步中，你都可以将先前的结果值转换为其他值。 如果你熟悉一些功能范例，那么将很容易理解以下内容：</p><ul><li><strong><code>thenMap</code></strong> 是 Promise 上的 map</li><li><strong><code>then</code></strong> 基本上是 Promise 上的 flatMap </li><li><strong><code>onSuccess</code></strong> 仅当链中一切正常时才调用 onSuccess</li><li><strong><code>onFailure</code></strong> 仅当链中发生某些错误时，才会调用onFailure</li><li><strong><code>always</code></strong> 始终运行，无论结果如何</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要获取 <code>主队列</code> ，则可以像通过 <code>onFailure</code> 方法一样，通过队列参数进行传递，但是它适用于链中的每个元素。 以上这些功能只是冰山一角。 你还可以进入一条链， <code>validate</code> 结果，对其进行 <code>timeout</code> 或从失败的 <code>promises</code> 中 <code>recover</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一个 <code>Promises命名空间</code> ，用于其他有用的方法，例如 <code>zip</code> ，它可以将 <code>2、3或4种不同类型的promise</code> 压缩在一起。 就像 <code>Promises.all方法</code> 一样， <code>zip函数</code> 会等到每个 <code>promises</code> 都完成后，再在一个块中为你提供所有 <code>promises</code> 的结果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//executing same promises from the same kind, eg. [Promise&lt;Data&gt;]</span></span><br><span class="line"><span class="type">Promises</span>.all(promises)</span><br><span class="line">.thenMap &#123; arrayOfResults <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// e.g. [Data]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//zipping together different kind of promises, eg. Proimse&lt;[Todos]&gt;, Promise&lt;Todo&gt;;</span></span><br><span class="line"><span class="type">Promises</span>.<span class="built_in">zip</span>(promise1, promise2)</span><br><span class="line">.thenMap &#123; result1, result2 <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//e.g [Todos], Todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还值得一提的是， <code>Promises名称空间</code> 下有一个 <code>first</code> ， <code>delay</code> ， <code>timeout</code> ， <code>race</code> ， <code>wait</code> 和 <code>retry</code> 方法。 也可以随意使用它们，有时它们也非常有用和强大。 💪</p></br><h1 id="Promises-有两个问题"><a href="#Promises-有两个问题" class="headerlink" title="Promises 有两个问题"></a><strong>Promises 有两个问题</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个问题是 <strong>取消</strong> 。 你不能简单地取消 <code>running Promises</code> 。 这是可行的，但是它需要一些高级技术或某些说“ hacky”技术。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个是 <strong>异步/等待</strong> 。 如果你想了解更多有关它的信息，则应该阅读Chis Lattner的<a href="https://gist.github.com/lattner/31ed37682ef1576b16bca1432ea9f782" target="_blank" rel="noopener"><strong><em><code>并发宣言</code></em></strong></a>，因此我们只能说这两个关键字可以在代码中添加一些语法糖。 你将不再需要多余的行（然后是 <code>thenMap</code> ， <code>onSuccess</code> ， <code>onFailure</code> ），这样你就可以专注于代码了。 我真的希望我们能在 <code>Swift 6</code>中得到类似的东西，这样我就可以永久丢弃 <code>Promise库</code> 。 哦，顺便说一句， <strong>libraries</strong> …</p></br><h1 id="Promise-值得一看"><a href="#Promise-值得一看" class="headerlink" title="Promise 值得一看"></a><strong>Promise 值得一看</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章值得一读 <a href="http://www.xuebaonline.com/Swift%20Promises%20%E6%8E%A2%E7%A9%B6/"><strong><em><code>Promises In Swift</code></em></strong></a>。 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>github</code> 上有很多 <code>promise库</code> ，但是如果我不得不从中选择（而不是我自己的实现），我肯定会选择以下其中一个：</p><ul><li><a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener"><strong><code>PromiseKit</code></strong></a> - 最受欢迎的一款</li><li><a href="https://github.com/google/promises" target="_blank" rel="noopener"><strong><code>Promises</code></strong></a>  - Google的，功能丰富，也很受欢迎</li><li><a href="https://github.com/khanlou/promise" target="_blank" rel="noopener"><strong><code>Promise</code></strong></a> - 小，但基于<code>JavaScript Promises/A+</code>规范</li><li><a href="https://github.com/apple/swift-nio" target="_blank" rel="noopener"><strong><code>SwiftNIO</code></strong></a> - 不是一个实际的 <code>Promise库</code> ，但是它在后台有一个编写精美的基于事件循环的 <code>Promise</code> 实现</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;专家提示：不要尝试制作自己的 <strong>Promise框架</strong> ，因为多线程非常困难，而且你也不想弄乱线程和锁。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Promise</strong> 确实会上瘾。 一旦开始使用它们，就无法简单地返回并使用回调编写异步代码了。 😅</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Promises </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Promises </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 自定义视图，输入表单和错误提示</title>
      <link href="/iOS%20%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE%EF%BC%8C%E8%BE%93%E5%85%A5%E8%A1%A8%E5%8D%95%E5%92%8C%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/"/>
      <url>/iOS%20%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE%EF%BC%8C%E8%BE%93%E5%85%A5%E8%A1%A8%E5%8D%95%E5%92%8C%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于以编程方式创建自定义视图的一些建议，以及关于为什么使用集合视图构建表单的真相。</p></br><h1 id="如何不为iOS应用构建表单？"><a href="#如何不为iOS应用构建表单？" class="headerlink" title="如何不为iOS应用构建表单？"></a><strong>如何不为iOS应用构建表单？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从一个诚实的声明开始：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.xuebaonline.com/%E4%B8%BAiOS%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E8%BE%93%E5%85%A5%E8%A1%A8%E5%8D%95/"><strong><em><code>为iOS应用构建输入表单</code></em></strong></a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实是，这种表格构建方法仅在单元格始终在屏幕上可见的情况下才有效，这种情况很少见。 我在处理当前项目时发现了此问题，并且当单元格超出框架时，某些字段不断消失，并且将光标移至下一个输入字段停止了工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em><code>可重用性和内存效率并不总是你想要的。</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;似乎 <code>UICollectionView</code> 并不是制作输入表单的最佳解决方案，因为恒定的单元可重用性会弄乱某些预期的行为。 它对于具有“一千个元素”的列表仍然很好，但是对于输入表单，我不再推荐这种技术。 是的，我的错，对此感到抱歉…😬</p><a id="more"></a></br><h1 id="在犯错中学习"><a href="#在犯错中学习" class="headerlink" title="在犯错中学习"></a><strong>在犯错中学习</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长话短说，我犯了一个错误，在你的开发人员职业生涯中，你可能也会收获很多。 这会使你成为一个不好的程序员吗？ 一点也不。 我们是人类，我们不断犯越来越小的错误，但是…</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的错误将永远存在，但是你可以从中学到很多东西。 仅当你一次又一次地犯同样的错误，或者你甚至没有意识到自己在做错事情时，问题才会开始。 退后一步，从更大的角度看问题确实是很难的。 有时你只需要其他人为你指出问题，但是负面反馈也可能会很痛苦。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，我不想太哲学，这是一个Swift开发者博客。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我学到的一些东西：</p><ul><li>我的想法并不总是奏效的🤣</li><li>与其他人一起编码/工作总是更好</li><li>有时“ padawan”会教“大师”😉</li><li>专业的质量检查团队可以为你节省很多时间</li><li><a href="http://www.xuebaonline.com/iOS%20VIPER%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"><strong><em><code>VIPER 是我的架构的杀手锏</code></em></strong></a>，而不是 <a href="http://www.xuebaonline.com/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><strong><em><code>UIcollection视图</code></em></strong></a></li><li>基于UICollectionView的表单构建不起作用…</li><li>…但是集合视图框架仍然适用于复杂的界面</li><li>有一些专用时间来编码美化和重构</li><li>以编程方式使用视图子类（或将来的SwiftUI）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一点是最有趣的一点，让我解释一下原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅来自代码的自定义视图子类</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以编程方式创建 <code>UIView子类</code> 是一项相对容易的任务。 你可以加载一个 <code>nib文件</code> ，也可以直接从代码中加载它。 几周前，我学到了一个新技巧，就是在我使用 <code>Swift</code> 创建新子类时一直困扰着我：</p><blockquote><p>如果根本不使用IB，为什么还要执行 <code>init（coder :)</code>？</p></blockquote><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有 <code>init（frame :)</code> 到底发生了什么，我不想再处理这两个 <code>init</code> 方法，因为我正在使用自动布局，并且我完全试图忽略混乱的 <code>Storyboard</code> 中的界面生成器 和 <code>nibs</code> 。</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">View</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(*, unavailable)</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(*, unavailable)</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方案：将这些愚蠢的 ··· 标记为不可用，因此没有人可以使用它们。 唯一的做法将是你自己的 ··· ，如果你像我一样对如此混乱的初始化过程感到恼火，则这是一种缓解。 😤</p><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，你有了自己的基类，可以将其用作将来视图的父级。 当然，你几乎需要对每个UI元素（例如标签，按钮，文本字段等）执行相同的操作。这需要大量工作，但从长远来看，这是完全值得的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleLabel</span>: <span class="title">Label</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.initialize()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textAlignment = .center</span><br><span class="line">        <span class="keyword">self</span>.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .largeTitle)</span><br><span class="line">        <span class="keyword">self</span>.textColor = .systemBlue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">constraints</span><span class="params">(<span class="keyword">in</span> view: UIView, padding: CGFloat = <span class="number">8</span>)</span></span> -&gt; [<span class="type">NSLayoutConstraint</span>] &#123;</span><br><span class="line">        [</span><br><span class="line">            <span class="keyword">self</span>.topAnchor.constraint(equalTo: view.topAnchor, constant: padding),</span><br><span class="line">            <span class="keyword">self</span>.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: padding),</span><br><span class="line">            <span class="keyword">self</span>.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -<span class="number">1</span> * padding),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个好的做法是为每个自定义用户界面组件都具有子类，例如主按钮，辅助按钮，标题标签，标题标签等。这样，你不必在视图控制器中配置视图，再加上 你可以使用一些辅助方法将常用约束放入子类中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，你还可以进行一些扩展，这些扩展可以帮助你进行视图配置。 你知道，就像 <code>SwiftUI</code> 中的修饰符一样。 你甚至可以重新创建完全相同的语法。 基本行为将不同，但这是另一回事。 📚</p></br><h1 id="iOS中的表单新生成器怎么样？"><a href="#iOS中的表单新生成器怎么样？" class="headerlink" title="iOS中的表单新生成器怎么样？"></a><strong>iOS中的表单新生成器怎么样？</strong></h1><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我有一个全新的但仍然非常相似的解决方案。 我使用的是视图子类，而不是集合视图组件，而且集合视图已被 <code>UIScrollView + UIStackView</code> 组合替换。 🐐</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> scrollView: <span class="type">ScrollView!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> stackView: <span class="type">VerticalStackView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> scrollView = <span class="type">ScrollView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(scrollView)</span><br><span class="line">        <span class="keyword">self</span>.scrollView = scrollView</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([<span class="comment">/*...*/</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> stackView = <span class="type">VerticalStackView</span>()</span><br><span class="line">        <span class="keyword">self</span>.scrollView.addSubview(stackView)</span><br><span class="line">        <span class="keyword">self</span>.stackView = stackView</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([<span class="comment">/*...*/</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.title = <span class="string">"StackForm"</span></span><br><span class="line">        <span class="keyword">self</span>.navigationController?.navigationBar.prefersLargeTitles = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> email = <span class="type">EmailTextField</span>(id: <span class="string">"email-input"</span>, placeholder: <span class="string">"Email"</span>)</span><br><span class="line">        <span class="keyword">self</span>.stackView.addArrangedSubview(email)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> password = <span class="type">PasswordTextField</span>(id: <span class="string">"password-input"</span>, placeholder: <span class="string">"Password"</span>)</span><br><span class="line">        <span class="keyword">self</span>.stackView.addArrangedSubview(password)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> submit = <span class="type">SubmitButton</span>(id: <span class="string">"submit-button"</span>, title: <span class="string">"Submit"</span>)</span><br><span class="line">        .onTouch &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span> <span class="keyword">self</span>?.submit() &#125;</span><br><span class="line">        <span class="keyword">self</span>.stackView.addArrangedSubview(submit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">submit</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> email = (<span class="keyword">self</span>.view.view(withId: <span class="string">"email-input"</span>) <span class="keyword">as</span>? <span class="type">UITextField</span>)?.text,</span><br><span class="line">            <span class="keyword">let</span> password = (<span class="keyword">self</span>.view.view(withId: <span class="string">"password-input"</span>) <span class="keyword">as</span>? <span class="type">UITextField</span>)?.text</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Account: \(email) - \(password)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我仍在使用相同的 <a href="http://www.xuebaonline.com/Swift%20%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%9A%84%E8%A7%86%E5%9B%BE/"><strong><em><code>视图识别技术</code></em></strong></a> ，而且我仍然更喜欢使用类似 <code>SwiftUI</code> 的 <code>.onTouch</code> 操作处理程序。 你可能会问：</p><p><strong><em><code>为什么不简单地使用SwiftUI？</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，事实是 <code>SwiftUI</code> 仅是 <code>iOS13</code> ，如今大约只有55％的采用率，这是主要原因之一，但是 <code>SwiftUI</code> 还是不完整的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我正在尝试尽可能地接近 <code>SwiftUI</code> ，因此过渡到时候来的时候会减少痛苦。  <code>SwiftUI</code> 将会很棒，但是仍然是一个巨大的飞跃。 有时，我认为Apple只是出于市场/开发人员的需求而奔波（是的，我们是非常耐心的动物）。 第一步，也许一个围绕UIKit / AppKit的简单包装框架而没有整个声明性语法会是一个更好的主意…谁知道… CoreKit-&gt; AppleKit？ 🤔</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，你可以从 <a href="https://github.com/theswiftdev/tutorials" target="_blank" rel="noopener"><strong><em><code>GitHub</code></em></strong></a> 下载 <code>Swift 5</code> 中最新的表单构建解决方案的工作示例。 只需在存储库中查找 <code>StackForm</code> 文件夹。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为iOS应用构建输入表单</title>
      <link href="/%E4%B8%BAiOS%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E8%BE%93%E5%85%A5%E8%A1%A8%E5%8D%95/"/>
      <url>/%E4%B8%BAiOS%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E8%BE%93%E5%85%A5%E8%A1%A8%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>了解如何使用更新的集合视图视图模型框架构建复杂的表单，而无需使用 <code>Swift</code> 。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此方法不起作用，因为表单中的单元格将被重用，这会导致某些不一致的情况…… <a href="http://www.xuebaonline.com/iOS%20%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE%EF%BC%8C%E8%BE%93%E5%85%A5%E8%A1%A8%E5%8D%95%E5%92%8C%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/"><strong><em><code>请阅读我的其他文章</code></em></strong></a> 。🤷‍♂️</p></blockquote></br><h1 id="CollectionView和输入表单"><a href="#CollectionView和输入表单" class="headerlink" title="CollectionView和输入表单"></a><strong>CollectionView和输入表单</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/corekit/collectionview" target="_blank" rel="noopener"><strong><em><code>CollectionView框架</code></em></strong></a> 刚刚进行了巨大更新。有很多新变化，但是最大的改进之一是我处理视图模型的方式。过去，你必须在视图模型中使用长函数名，包括通用视图和模型类名。如果你曾经阅读过 <a href="http://www.xuebaonline.com/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><strong><em><code>最终UICollectionView指南</code></em></strong></a> ，那么你应该了解我在说什么。好消息：我现在有一种更好的解决方案！ 😉</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此更新不仅可以清理很多代码，还可以添加自定义视图模型处理程序，因此我可以以一种非常简单的方式与输入字段，切换等交互。另一个巨大的改进是，我开始使用视图标识符。那是偶然的发现，我只想寻找 <a href="http://www.xuebaonline.com/Swift%20%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%9A%84%E8%A7%86%E5%9B%BE/"><strong><em><code>一种通过标签识别视图的替代解决方案</code></em></strong></a> ，然后我有了一个绝妙的主意：为什么不也通过id查找单元格呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果，我现在可以使用框架来创建表单。我仍然相信集合视图是大多数应用程序的最终构建块。是的，你仍然可以说没有灵丹妙药，但是如果此解决方案可以覆盖我90％的用例，那很好。毕竟，大多数应用程序只是以一种不错的或不太好的方式可视化 <code>JSON数据</code> 。 🤷‍♂️</p></br><h1 id="可重复使用的表单组件"><a href="#可重复使用的表单组件" class="headerlink" title="可重复使用的表单组件"></a><strong>可重复使用的表单组件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们使用全新的框架来构建表单。 首先，你需要使用包管理器对其进行集成。 我真的希望在几周内我们可以使用 <code>Swift Package Manager</code> ，直到比你应该使用 <code>CocoaPods</code> 或 <code>carthage</code> 为止。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cocoapods</span><br><span class="line">source 'https:<span class="comment">//github.com/CoreKit/CocoaPods.git'</span></span><br><span class="line">pod '<span class="type">CollectionView'</span>, '~&gt; <span class="number">2.0</span>.<span class="number">0</span>'</span><br><span class="line"></span><br><span class="line"># carthage</span><br><span class="line">github <span class="string">"CoreKit/CollectionView"</span> <span class="string">"2.0.0"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在让我们为输入字段创建一个可重用的单元格。 可以像往常一样随意使用 <code>xib文件</code> ，实现上的唯一区别是，我将在 <code>reset方法</code> 中删除目标侦听器。 我们稍后将在视图模型中添加一个。 🎯</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CollectionView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputCell</span>: <span class="title">Cell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textField: <span class="type">UITextField!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.reset()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textField.removeTarget(<span class="literal">nil</span>, action: <span class="literal">nil</span>, <span class="keyword">for</span>: .editingChanged)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我还将创建一个简单的实体，用于在表单字段为空时显示占位符并存储输入字段的实际值，我们将其称为 <code>InputEntity</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> placeholder: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">String?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在最困难的部分是：在视图和模型之间建立连接。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CollectionView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputViewModel</span>: <span class="title">ViewModel</span>&lt;<span class="title">InputCell</span>, <span class="title">InputEntity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> editingChangeHandler: <span class="type">ViewModelHandler?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> height: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">60</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">updateView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view?.textField.placeholder = <span class="keyword">self</span>.model.placeholder</span><br><span class="line">        <span class="keyword">self</span>.view?.textField.text = <span class="keyword">self</span>.model.value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.view?.textField.addTarget(<span class="keyword">self</span>,</span><br><span class="line">                                       action: #selector(<span class="keyword">self</span>.editingChanged(<span class="number">_</span>:)),</span><br><span class="line">                                       <span class="keyword">for</span>: .editingChanged)</span><br><span class="line">        <span class="keyword">self</span>.view?.textField.addTarget(<span class="keyword">self</span>,</span><br><span class="line">                                       action: #selector(<span class="keyword">self</span>.editingDidEnd(<span class="number">_</span>:)),</span><br><span class="line">                                       <span class="keyword">for</span>: .editingDidEnd)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onEditingChange</span><span class="params">(<span class="number">_</span> handler: @escaping ViewModelHandler)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.editingChangeHandler = handler</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">editingChanged</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.model.value = textField.text</span><br><span class="line">        <span class="keyword">self</span>.editingChangeHandler?(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">editingDidEnd</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"nothing-to-do-here-now..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个非常复杂的视图模型，但是它也可以做很多事情。 你应该了解的第一件事是 <code>ViewModelHandler</code> ，它基本上是可以在视图模型中使用的通用别名。 它使你能够传递回调的类型安全视图模型。 你稍后会看到。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个主要更改是 <code>updateView方法</code> ，该方法用于基于来自模型的数据来更新视图。 我还将目标侦听器添加到视图中，以便可以直接在 <code>view-model类</code> 内部处理用户输入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>onEditingChange</code> 方法是视图模型的 <code>“公共” api</code> 。 我现在使用on前缀将处理程序和侦听器添加到我的视图模型。 如果发生更改事件，它将基本上调用存储的块。 你可以根据需要添加任意数量的事件处理程序块。 我真的希望你能掌握这种方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一件事：现在返回单元格的高度是单线！ 🎊</p></br><h1 id="Composing-forms-and-more"><a href="#Composing-forms-and-more" class="headerlink" title="Composing forms and more"></a><strong>Composing forms and more</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前，该计划将具有一个包含两个输入字段的输入表单。 一个用于电子邮件地址，另一个将用于密码。 诀窍是，这次我不会向你展示整个代码，但是你必须弄清楚其余的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，我将向你展示制作自己的表单所需的所有知识，甚至包括一些复杂的表单。 不用担心，这只是几行代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> CollectionView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">CollectionViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> grid = <span class="type">Grid</span>(columns: <span class="number">1</span>, margin: <span class="type">UIEdgeInsets</span>(all: <span class="number">16</span>), padding: .zero)</span><br><span class="line">        <span class="keyword">self</span>.collectionView.source = .<span class="keyword">init</span>(grid: grid, [</span><br><span class="line">            [</span><br><span class="line">                <span class="type">InputViewModel</span>(id: <span class="string">"email-input"</span>, .<span class="keyword">init</span>(placeholder: <span class="string">"Email"</span>, value: <span class="literal">nil</span>))</span><br><span class="line">                .onEditingChange &#123; viewModel <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> passwordViewModel = viewModel.by(id: <span class="string">"password-input"</span>) <span class="keyword">as</span>? <span class="type">InputViewModel</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    passwordViewModel.model.value = viewModel.model.value ?? <span class="string">""</span></span><br><span class="line">                    passwordViewModel.updateView()</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="type">InputViewModel</span>(id: <span class="string">"password-input"</span>, .<span class="keyword">init</span>(placeholder: <span class="string">"Password"</span>, value: <span class="literal">nil</span>)),</span><br><span class="line">            ],</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你曾经使用过集合视图框架，那么你应该知道我一直使用网格系统，因为我真的不喜欢计算数字。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源是一组按部分分组的视图模型。这里唯一有趣的部分是，现在可以使用节和视图模型的数组来初始化源。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你使用和标识符初始化一个视图模型，则以后可以通过ID查询该视图模型。这正是在编辑更改处理程序块内发生的事情。每个视图模型都可以通过id返回其他一些视图模型。默认情况下，视图模型是类型安全的，由于通用的 <code>ViewModelHandler</code> 别名， <code>viewModel</code> 也在块内传递。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在这个小示例中，如果你在第一个输入字段中键入内容，则完全相同的文本将出现在第二个文本字段中。你可以在需要时按ID获取所有视图模型。例如，如果你必须提交此表单，则可以使用相同的方法来获取电子邮件和密码字段。</p></br><h1 id="建立登录表单"><a href="#建立登录表单" class="headerlink" title="建立登录表单"></a><strong>建立登录表单</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要求你使用我的框架自行构建一个登录表单。 我保证不超过30分钟的工作时间。 我将向你展示我将使用的最终视图控制器，因此这可能会给你一些帮助。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想稍微增加点趣味，甚至可以添加一个复选框以接受隐私策略。 这里的主要思想是你应该为表单中的每个项目创建可重用的组件。 因此，例如，具有相应视图模型的 <code>ToggleView</code> 是一种很好的方法（也适用于按钮）。 🤫</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是最终的提示，你只需要创建自己的视图模型和视图即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> CollectionView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">CollectionViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Ids</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> email = <span class="string">"email-input"</span></span><br><span class="line">        <span class="keyword">case</span> password = <span class="string">"password-input"</span></span><br><span class="line">        <span class="keyword">case</span> privacyPolicy = <span class="string">"privacy-policy-checkbox"</span></span><br><span class="line">        <span class="keyword">case</span> submit = <span class="string">"submit-button"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> grid = <span class="type">Grid</span>(columns: <span class="number">1</span>, margin: <span class="type">UIEdgeInsets</span>(all: <span class="number">16</span>), padding: .zero)</span><br><span class="line">        <span class="keyword">self</span>.collectionView.source = .<span class="keyword">init</span>(grid: grid, [</span><br><span class="line">            [</span><br><span class="line">                <span class="type">InputViewModel</span>(id: <span class="type">Ids</span>.email.rawValue, .<span class="keyword">init</span>(placeholder: <span class="string">"Email"</span>, value: <span class="literal">nil</span>))</span><br><span class="line">                .onEditingEnd &#123; viewModel <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> passwordViewModel = viewModel.by(id: <span class="type">Ids</span>.password.rawValue) <span class="keyword">as</span>? <span class="type">InputViewModel</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    passwordViewModel.view?.textField.becomeFirstResponder()</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="type">InputViewModel</span>(id: <span class="type">Ids</span>.password.rawValue, .<span class="keyword">init</span>(placeholder: <span class="string">"Password"</span>, value: <span class="literal">nil</span>, secure: <span class="literal">true</span>))</span><br><span class="line">                .onEditingEnd &#123; viewModel <span class="keyword">in</span></span><br><span class="line">                    viewModel.view?.textField.endEditing(<span class="literal">true</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">                <span class="type">ToggleViewModel</span>(id: <span class="type">Ids</span>.privacyPolicy.rawValue, .<span class="keyword">init</span>(label: <span class="string">"Privacy policy"</span>, value: <span class="literal">false</span>))</span><br><span class="line">                .onValueChange &#123; viewModel <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> submitViewModel = viewModel.by(id: <span class="type">Ids</span>.submit.rawValue) <span class="keyword">as</span>? <span class="type">ButtonViewModel</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">var</span> model = submitViewModel.model</span><br><span class="line">                    model.enabled = viewModel.model.value</span><br><span class="line">                    submitViewModel.model = model</span><br><span class="line">                    submitViewModel.updateView()</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">                <span class="type">ButtonViewModel</span>(id: <span class="type">Ids</span>.submit.rawValue, .<span class="keyword">init</span>(title: <span class="string">"Submit"</span>, enabled: <span class="literal">false</span>))</span><br><span class="line">                .onSubmit &#123; viewModel <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">guard</span></span><br><span class="line">                        <span class="keyword">let</span> emailViewModel = viewModel.by(id: <span class="type">Ids</span>.email.rawValue) <span class="keyword">as</span>? <span class="type">InputViewModel</span>,</span><br><span class="line">                        <span class="keyword">let</span> passwordViewModel = viewModel.by(id: <span class="type">Ids</span>.password.rawValue) <span class="keyword">as</span>? <span class="type">InputViewModel</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* ... */</span></span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到此为止，这是一个几乎完整的登录表单，仅包含几行代码。 当然有一个基础框架，但是如果你检查 <a href="https://github.com/corekit/collectionview" target="_blank" rel="noopener"><strong><em><code>源代码</code></em></strong></a> ，你实际上会发现它不包含任何被视为黑魔法的东西。 💫</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift编写的20个iOS库(一)</title>
      <link href="/Swift%E7%BC%96%E5%86%99%E7%9A%8420%E4%B8%AAiOS%E5%BA%93(%E4%B8%80)/"/>
      <url>/Swift%E7%BC%96%E5%86%99%E7%9A%8420%E4%B8%AAiOS%E5%BA%93(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我在 <code>github</code> 上收集了最好的开源 <code>Swift框架</code> ，这些框架将帮助你在2020年加快移动应用程序的开发速度。更多精彩的类库持续更新中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，最好使用第三方框架而不是重新发明轮子，但是你首先要提出一些重要问题：</p><ul><li>我真的需要 <code>library</code> 吗？</li><li>我应该怎么用？</li><li>它会得到支持吗？</li><li>如果是 <code>bug</code> 怎么办？ 🐛</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在项目中添加依赖项也会导致技术负担。 不要懒惰，首先学习基础技术（或者至少阅读它，或者问一个真正了解它的人），如果你确定该框架是一个不错的选择，那就给它一个机会。 在此列表中，我尝试收集了大多数开发人员社区使用的面向未来的，可靠的，知名的iOS库。 ⭐️</p><a id="more"></a></br><p><strong><code>选择标准</code></strong></p><ul><li>该框架必须用 <code>Swift</code> 编写</li><li>库不应该是特定于设计的（对此有 <code>cocoacontrols</code> ）</li><li>它应该是一个运行时框架，而不是一个工具包（也就是导入 <code>XY</code> ）</li><li>应该有一些程序包管理器支持（ <code>Carthage</code> ， <code>CocoaPods</code> ， <code>SPM</code> ）</li><li>它必须支持 <code>Swift</code> 的最新主要版本</li><li><code>github</code> 上必须至少有 <code>1000颗星星</code> </li></ul></br><h1 id="🌎与网络相关的库"><a href="#🌎与网络相关的库" class="headerlink" title="🌎与网络相关的库"></a><strong>🌎与网络相关的库</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正在连接…</p><h2 id="Alamofire"><a href="#Alamofire" class="headerlink" title="Alamofire"></a><a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener"><strong><em><code>Alamofire</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Alamofire</code> 是用 <code>Swift</code> 编写的 <code>HTTP网络库</code> 。</p><h2 id="Kingfisher"><a href="#Kingfisher" class="headerlink" title="Kingfisher"></a><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener"><strong><em><code>Kingfisher</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Kingfisher</code> 是一个功能强大的 <code>纯Swift库</code> ，用于从 <strong>Web下载和缓存图像</strong> 。 它为你提供了使用 <code>纯Swift</code> 方法在下一个应用程序中处理远程图像的机会。</p><h2 id="Starscream"><a href="#Starscream" class="headerlink" title="Starscream"></a><a href="https://github.com/daltoniam/Starscream" target="_blank" rel="noopener"><strong><em><code>Starscream</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Starscream</code> 是 <code>Swift</code> 中符合标准的 <code>WebSocket</code> （ <a href="http://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener"><strong><em><code>RFC 6455</code></em></strong></a> ）客户端库。</p></br><h1 id="📦服务器端Swift"><a href="#📦服务器端Swift" class="headerlink" title="📦服务器端Swift"></a><strong>📦服务器端Swift</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;听…</p><h2 id="Vapor"><a href="#Vapor" class="headerlink" title="Vapor"></a><a href="https://github.com/vapor/vapor" target="_blank" rel="noopener"><strong><em><code>Vapor</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Vapor</code> 是 <code>Swift</code> 的 <strong>Web框架</strong> 。 它为你的下一个网站， <code>API</code> 或 <code>云项目</code> 提供了精美而易用的基础。</p><h2 id="SwiftNIO"><a href="#SwiftNIO" class="headerlink" title="SwiftNIO"></a><a href="https://github.com/apple/swift-nio" target="_blank" rel="noopener"><strong><em><code>SwiftNIO</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SwiftNIO</code> 是跨平台的 <strong>异步事件驱动的网络应用程序框架</strong> ，用于快速开发可维护的高性能协议服务器和客户端。</p></br><h1 id="🔨响应式编程"><a href="#🔨响应式编程" class="headerlink" title="🔨响应式编程"></a><strong>🔨响应式编程</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Streams</code> ,  <code>observers</code> , 等…</p><h2 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener"><strong><em><code>ReactiveCocoa</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <code>ReactiveSwift</code> 提供了可组合的，声明性的和灵活的基元，这些基元是围绕随着时间流逝的价值流这一宏伟概念而构建的。 这些原语可用于统一表示常见的可可和通用编程模式，这些模式从根本上是一种观察行为。</p><h2 id="RxSwift"><a href="#RxSwift" class="headerlink" title="RxSwift"></a><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener"><strong><em><code>RxSwift</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Rx</code> 是通过 <code>Observable &lt;Element&gt;</code> 接口表示的通用计算抽象。 这是 <code>Rx</code> 的 <code>Swift版本</code> 。</p></br><h1 id="🦋动画"><a href="#🦋动画" class="headerlink" title="🦋动画"></a><strong>🦋动画</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIView.animated...</code></p><h2 id="Hero"><a href="#Hero" class="headerlink" title="Hero"></a><a href="https://github.com/HeroTransitions/Hero" target="_blank" rel="noopener"><strong><em><code>Hero</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Hero</code> 是用于构建 <code>iOS视图控制器过渡</code> 的库。 它在 <code>UIKit</code> 繁琐的 <code>过渡API</code> 之上提供了一个声明性层-使自定义过渡对于开发人员而言是一项轻松的任务。</p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><a href="https://github.com/MengTo/Spring" target="_blank" rel="noopener"><strong><em><code>Spring</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个库，用于简化 <code>Swift</code> 中的 <code>iOS动画</code> 。</p></br><h1 id="📐自动布局助手"><a href="#📐自动布局助手" class="headerlink" title="📐自动布局助手"></a><strong>📐自动布局助手</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Anchors vs...</code></p><h2 id="SnapKit"><a href="#SnapKit" class="headerlink" title="SnapKit"></a><a href="https://github.com/SnapKit/SnapKit" target="_blank" rel="noopener"><strong><em><code>SnapKit</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SnapKit</code> 是一种 <code>DSL</code> ，可在 <code>iOS</code> 和 <code>OS X</code> 上简化自动布局。</p><h2 id="TinyConstraints"><a href="#TinyConstraints" class="headerlink" title="TinyConstraints"></a><a href="https://github.com/roberthein/TinyConstraints" target="_blank" rel="noopener"><strong><em><code>TinyConstraints</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>TinyConstraints</code> 是使 <code>Auto Layout</code> 更适合人类使用的语法糖。</p></br><h1 id="❌测试"><a href="#❌测试" class="headerlink" title="❌测试"></a><strong>❌测试</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TDD FTW...</code></p><h2 id="Quick"><a href="#Quick" class="headerlink" title="Quick"></a><a href="https://github.com/Quick/Quick" target="_blank" rel="noopener"""><strong><em><code>Quick</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Quick</code> 是 <code>Swift</code> 和 <code>Objective-C</code> 的行为驱动开发框架。</p><h2 id="Nimble"><a href="#Nimble" class="headerlink" title="Nimble"></a><a href="https://github.com/Quick/Nimble" target="_blank" rel="noopener"><strong><em><code>Nimble</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用 <code>Nimble</code> 表示 <code>Swift</code> 或 <code>Objective-C</code> 表达式的预期结果。</p></br><h1 id="⚙️实用工具"><a href="#⚙️实用工具" class="headerlink" title="⚙️实用工具"></a><strong>⚙️实用工具</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我错过了什么？</p><h2 id="PromiseKit"><a href="#PromiseKit" class="headerlink" title="PromiseKit"></a><a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener"><strong><em><code>PromiseKit</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>PromiseKit</code> 是对任何具有 <code>swiftc</code> 平台的 <strong>Promise的深思熟虑和完整的实现</strong> 。</p><h2 id="CryptoSwift"><a href="#CryptoSwift" class="headerlink" title="CryptoSwift"></a><a href="https://github.com/krzyzanowskim/CryptoSwift" target="_blank" rel="noopener"><strong><em><code>CryptoSwift</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>CryptoSwift</code> 是在 <code>Swift</code> 中实现的越来越多的标准和<strong>安全密码算法</strong>集合。</p><h2 id="SwiftDate"><a href="#SwiftDate" class="headerlink" title="SwiftDate"></a><a href="https://github.com/malcommac/SwiftDate" target="_blank" rel="noopener"><strong><em><code>SwiftDate</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SwiftDate</code> 是确定的工具链，可在所有 <code>Apple平台</code> 上甚至在 <code>Linux</code> 和 <code>Vapor</code> 或 <code>Kitura</code> 等 <code>Swift Server Side框架</code> 上操纵和显示日期和时区。</p><h2 id="SwiftyBeaver"><a href="#SwiftyBeaver" class="headerlink" title="SwiftyBeaver"></a><a href="https://github.com/SwiftyBeaver/SwiftyBeaver" target="_blank" rel="noopener"><strong><em><code>SwiftyBeaver</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 <code>Swift 2、3和4、5</code> 中开发和发布期间的便捷日志记录。</p><h2 id="Swinject"><a href="#Swinject" class="headerlink" title="Swinject"></a><a href="https://github.com/Swinject/Swinject" target="_blank" rel="noopener"><strong><em><code>Swinject</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swinject</code> 是 <code>Swift</code> 的轻量级 <code>依赖注入框架</code> 。</p><h2 id="SwiftyJSON"><a href="#SwiftyJSON" class="headerlink" title="SwiftyJSON"></a><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="noopener"><strong><em><code>SwiftyJSON</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SwiftyJSON</code>  使你可以轻松地在 <code>Swift</code> 中处理 <code>JSON数据</code> 。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你正在寻找更多的 <code>Swift库</code> ，则可以随时在 <a href="https://github.com/topics/swift" target="_blank" rel="noopener"><strong><em><code>github</code></em></strong></a> 上探索最受欢迎的 <code>Swift库</code> ，请记住：<strong>始终通过包管理器连接你的依赖项</strong>。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 三方类库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 三方类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 用 compactMap 替换 flatMap</title>
      <link href="/Swift%20%E7%94%A8%20compactMap%20%E6%9B%BF%E6%8D%A2%20flatMap/"/>
      <url>/Swift%20%E7%94%A8%20compactMap%20%E6%9B%BF%E6%8D%A2%20flatMap/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Xcode 9.3</code> 随附的 <code>Swift 4.1</code> 带来了对 <code>Swift语言</code> 和 <code>Swift标准库</code> 的更多更改。 苹果原本打算将其作为对 <code>Swift 4.0</code> 的源兼容升级，但我遭到一次源代码更改的打击，我猜这将是广泛的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在不建议在序列（如 <code>Array</code> ）上使用 <code>flatMap</code> 来过滤映射到 <code>nil</code> 的任何内容，并由 <code>compactMap</code> 取代。</p><h1 id="改变的简短版本"><a href="#改变的简短版本" class="headerlink" title="改变的简短版本"></a><strong>改变的简短版本</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是否正在使用 <code>flatMap</code> 从可选数组中删除 <code>nil</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: [<span class="type">String?</span>] = [<span class="string">"Tom"</span>, <span class="literal">nil</span>, <span class="string">"Peter"</span>, <span class="literal">nil</span>, <span class="string">"Harry"</span>]</span><br><span class="line"><span class="keyword">let</span> valid = names.flatMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// ["Tom", "Peter", "Harry"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Xcode 9.3</code> 显示了以这种方式使用 <code>flatMap</code> 的弃用警告：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/rfc-stp1.png" alt="flatMap"></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Xcode</code> 建议的修复程序将 <code>flatMap</code> 重命名为 <code>compactMap</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: [<span class="type">String?</span>] = [<span class="string">"Tom"</span>, <span class="literal">nil</span>, <span class="string">"Peter"</span>, <span class="literal">nil</span>, <span class="string">"Harry"</span>]</span><br><span class="line"><span class="keyword">let</span> valid = names.compactMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// ["Tom", "Peter", "Harry"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要你在带有闭包的序列上使用 <code>flatMap</code> 并返回可选值，该方法就适用。 所以这也被弃用了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> words = [<span class="string">"53"</span>, <span class="string">"nine"</span>, <span class="string">"hello"</span>,<span class="string">"0"</span>]</span><br><span class="line"><span class="keyword">let</span> values = words.flatMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用 <code>compactMap</code> 替换 <code>flatMap</code> 会删除弃用警告：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = words.compactMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125; <span class="comment">// Returns [Int]</span></span><br><span class="line"><span class="comment">// [53, 0]</span></span><br></pre></td></tr></table></figure></br><h1 id="More"><a href="#More" class="headerlink" title="More"></a><strong>More</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>首先， <code>Swift 4.1</code>不会弃用 <code>flatMap</code> 的所有用法-只有一种情况正在改变。</strong> <code>Swift 4.0</code> 在三种情况下可以使用 <code>flatMap</code> ：</p><ul><li>在具有返回序列的闭包的序列上使用 <code>flatMap</code> ：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sequence</span>.flatMap&lt;<span class="type">S</span>&gt;(<span class="number">_</span> transform: (<span class="type">Element</span>) -&gt; <span class="type">S</span>)</span><br><span class="line">  -&gt; [<span class="type">S</span>.<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">S</span> : <span class="type">Sequence</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为这可能是我在 Swift 中遇到的 <code>flatMap</code> 的首次使用。 使用它对序列的每个元素应用闭包并展平结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scores = [[<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>], [<span class="number">4</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="keyword">let</span> allScores = scores.flatMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// [5, 2, 7, 4, 8, 9, 1, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> passMarks = scores.flatMap &#123; $<span class="number">0</span>.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt; <span class="number">5</span>&#125; &#125;</span><br><span class="line"><span class="comment">// [7, 8, 9]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift 4.1</code> 不会更改 <code>flatMap</code> 的用法。</p><ul><li>在可选值上使用 <code>flatMap</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闭包采用可选值的 <code>非null值</code> ，并返回可选值。 如果原始可选参数为 <code>nil</code> ，则 <code>flatMap</code> 返回 <code>nil</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Optional</span>.flatMap&lt;<span class="type">U</span>&gt;(<span class="number">_</span> transform: (<span class="type">Wrapped</span>) -&gt; <span class="type">U?</span>) -&gt; <span class="type">U?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> input: <span class="type">Int?</span> = <span class="type">Int</span>(<span class="string">"8"</span>)</span><br><span class="line"><span class="keyword">let</span> passMark: <span class="type">Int?</span> = input.flatMap &#123; $<span class="number">0</span> &gt; <span class="number">5</span> ? $<span class="number">0</span> : <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="comment">// Optional(8)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift 4.1</code> 不会更改 <code>flatMap</code> 的用法。</p><ul><li>在带有返回可选项的闭包的序列上使用 <code>flatMap</code> 。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sequence</span>.flatMap&lt;<span class="type">U</span>&gt;(<span class="number">_</span> transform: (<span class="type">Element</span>) -&gt; <span class="type">U?</span>) -&gt; <span class="type">U?</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是 <code>Swift 4.1（Xcode 9.3</code>） 替换为 <code>compactMap</code> 的 <code>flatMap</code> 的使用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: [<span class="type">String?</span>] = [<span class="string">"Tom"</span>, <span class="literal">nil</span>, <span class="string">"Peter"</span>, <span class="literal">nil</span>, <span class="string">"Harry"</span>]</span><br><span class="line"><span class="keyword">let</span> counts = names.compactMap &#123; $<span class="number">0</span>?.<span class="built_in">count</span> &#125;</span><br><span class="line"><span class="comment">// [3, 5, 5]</span></span><br></pre></td></tr></table></figure></br><h1 id="重点是什么？"><a href="#重点是什么？" class="headerlink" title="重点是什么？"></a><strong>重点是什么？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总而言之，当 <code>plain map</code> 可以完成此工作时，似乎可以减少对 <code>flatMap</code> 的滥用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNames: [<span class="type">String</span>] = [<span class="string">"John"</span>, <span class="string">"Joe"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// No need to flatMap (or compactMap)</span></span><br><span class="line"><span class="keyword">let</span> myCounts = myNames.flatMap &#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;</span><br><span class="line"><span class="comment">// [4, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map is enough</span></span><br><span class="line"><span class="keyword">let</span> myCounts = myNames.<span class="built_in">map</span> &#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;</span><br><span class="line"><span class="comment">// [4, 3, 4]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将名称更改为 ··· 的想法是为了更好地描述该功能的作用。 映射序列，然后通过从结果中删除 <code>值为nil的元素</code> 进行压缩。 <code>Swift</code> 的未来版本可能还会为我们提供从通常情况下从序列中删除 <code>nil值</code> 的紧凑函数。</p></br><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a><strong>扩展阅读</strong></h1><ul><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0187-introduce-filtermap.md" target="_blank" rel="noopener"><strong><em><code>SE-0187 Introduce Sequence.compactMap(_:)</code></em></strong></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift CompactMap vs flatMap：差异说明</title>
      <link href="/Swift%20CompactMap%20vs%20flatMap%EF%BC%9A%E5%B7%AE%E5%BC%82%E8%AF%B4%E6%98%8E/"/>
      <url>/Swift%20CompactMap%20vs%20flatMap%EF%BC%9A%E5%B7%AE%E5%BC%82%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CompactMap</code> 和 <code>flatMap</code> 有什么区别？何时使用它们？  <code>Swift 4.1</code> 在 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0187-introduce-filtermap.md" target="_blank" rel="noopener"><strong><em><code>提案0187</code></em></strong></a> 中引入了这种新方法：引入 <code>Filtermap</code> 可以在 <code>flatMap</code> 用例中获得更多的清晰度。</p></br><h1 id="何时使用compactMap"><a href="#何时使用compactMap" class="headerlink" title="何时使用compactMap"></a><strong>何时使用compactMap</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当转换产生可选值时，使用此方法接收非可选值数组。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以下示例中查看 <code>map</code> 和 <code>compactMap</code> 之间的区别：</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scores = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"5"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapped: [<span class="type">Int?</span>] = scores.<span class="built_in">map</span> &#123; str <span class="keyword">in</span> <span class="type">Int</span>(str) &#125;</span><br><span class="line"><span class="comment">// [1, 2, nil, nil, 5] - Two nil values as "three" and "four" are strings.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compactMapped: [<span class="type">Int</span>] = scores.compactMap &#123; str <span class="keyword">in</span> <span class="type">Int</span>(str) &#125;</span><br><span class="line"><span class="comment">// [1, 2, 5] - The nil values for "three" and "four" are filtered out.</span></span><br></pre></td></tr></table></figure></br><h1 id="何时使用flatMap"><a href="#何时使用flatMap" class="headerlink" title="何时使用flatMap"></a><strong>何时使用flatMap</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当转换为每个元素生成序列或集合时，请使用此方法来接收单级集合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以下示例中查看 <code>map</code> 与 <code>flatMap</code> 之间的区别：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scoresByName = [<span class="string">"Henk"</span>: [<span class="number">0</span>, <span class="number">5</span>, <span class="number">8</span>], <span class="string">"John"</span>: [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapped = scoresByName.<span class="built_in">map</span> &#123; $<span class="number">0</span>.value &#125;</span><br><span class="line"><span class="comment">// [[0, 5, 8], [2, 5, 8]] - An array of arrays</span></span><br><span class="line"><span class="built_in">print</span>(mapped)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flatMapped = scoresByName.flatMap &#123; $<span class="number">0</span>.value &#125;</span><br><span class="line"><span class="comment">// [0, 5, 8, 2, 5, 8] - flattened to only one array</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上， <code>s.flatMap(transform)</code> 等效于 <code>Array(s.map(transform).joined())</code> 。</p></br><h1 id="compactMap-vs-flatMap"><a href="#compactMap-vs-flatMap" class="headerlink" title="compactMap vs flatMap"></a><strong>compactMap vs flatMap</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的一般经验法则提醒你编写代码时的注意事项：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在序列上使用并具有返回可选值的转换，请使用 <code>compactMap</code> 。 如果没有，则 <code>map</code> 或 <code>flatMap</code> 应该会为你提供所需的结果。</p></blockquote><h2 id="命名为compactMap的原因"><a href="#命名为compactMap的原因" class="headerlink" title="命名为compactMap的原因"></a><strong><em>命名为compactMap的原因</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管有人提议引入 <code>filterMap</code> 作为方法名，但是 <code>Swift团队</code> 还是决定使用 <code>compactMap</code> 。 读懂他们的动机可以使事情变得很多，并解释该方法的功能。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>“filterMap”</code> 是其他编程语言中有先例的名称，尤其是功能性语言，但有些人强烈认为该名称具有误导性，因为作为一个组合操作，它并不是一个过滤器或地图。 在替代方案中，最受支持的方案似乎是 <code>“ compactMap”</code> ，它基于 <code>“ compact”</code> 的先例， <code>compactMap</code> 是来自其他语言（尤其是Ruby）的一种操作，它返回输入的副本而没有 <code>nil值</code> 。 <code>Swift</code> 目前没有这样的操作，事实上，目前尚无法表达它。 但是，核心团队同意添加是一个合理的操作，并且 <code>“ compactMap”</code> 是该操作的好名字。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Functional Swift 初探</title>
      <link href="/Functional%20Swift%20%E5%88%9D%E6%8E%A2/"/>
      <url>/Functional%20Swift%20%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您将永远只需要学习一个高阶函数，例如： <code>map</code> ， <code>flatMap</code> ， <code>compactMap</code> ， <code>reduce</code> ， <code>filter</code> 等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener"><strong><em><code>函数式编程</code></em></strong></a>（英语：functional programming）或称 <code>函数程序设计</code> 、 <code>泛函编程</code> ，是一种 <code>编程范式</code> ，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比起 <code>指令式编程</code> ， <code>函数式编程</code> 更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</p><a id="more"></a></br><h1 id="函数式编程说明"><a href="#函数式编程说明" class="headerlink" title="函数式编程说明"></a>函数式编程说明</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先让我强调一件事：<strong><em><code>不要害怕函数式编程！</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使您是新手开发人员，也会看到 <code>函数式编程</code> 并不像您想象的那么难。 如果您仅学习基础知识，则可以节省大量时间，并可以帮助您编写更好的应用程序。 FP范例的主要概念是通过以特殊方式使用函数来消除可变状态和数据。 💫</p><h2 id="一等公民：-函数"><a href="#一等公民：-函数" class="headerlink" title="一等公民： 函数"></a><strong><em>一等公民： 函数</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果编程语言将函数视为一等的公民（与我们期望的类型行为相同），我们就说它具有一等的函数。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这意味着该语言支持将函数作为参数传递给其他函数，将它们作为其他函数的值返回，并将其分配给变量或存储在数据结构中。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中，您可以使用函数指针， <code>闭包（匿名函数）</code> ，因此，是的， <code>Swift</code> 基本上是一种真正的函数式语言。 示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an old-school function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// it's a block!</span></span><br><span class="line"><span class="keyword">let</span> hi: () -&gt; <span class="type">Void</span> = &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hi!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this points to a function</span></span><br><span class="line"><span class="keyword">let</span> function = hello</span><br><span class="line"><span class="comment">// this is a copy of the closure</span></span><br><span class="line"><span class="keyword">let</span> block = hi</span><br><span class="line"></span><br><span class="line">hello() <span class="comment">// simple function call</span></span><br><span class="line">function() <span class="comment">// call through "function pointer"</span></span><br><span class="line"></span><br><span class="line">hi() <span class="comment">// simple closure call</span></span><br><span class="line">block() <span class="comment">// closure call through another variable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// closure parameter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">async</span><span class="params">(completion: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// usually we'd do something here first...</span></span><br><span class="line">    completion()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calling the method with a closure</span></span><br><span class="line">async(completion: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Completed."</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// trailing closure syntax</span></span><br><span class="line">async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Completed."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，有时我将闭包称为块，为简单起见，让我们假装它们是完全相同的东西，并且不要过多地讨论细节。 🙄</p><h2 id="函数组成，柯里化和可变参数"><a href="#函数组成，柯里化和可变参数" class="headerlink" title="函数组成，柯里化和可变参数"></a><strong><em>函数组成，柯里化和可变参数</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>组成函数</code> 基本上是将一个函数的输出传递给另一个函数。 这不是那么有趣，我们一直都在做。 另一方面， <code>泛函函数</code> 是一个更令人兴奋的话题。 基本上， <code>柯里化</code> 将具有多个参数的函数转换为具有一个参数和返回函数的函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>柯里化</code> 有什么用？ 好吧，有人说这只是语法糖，有人说这很有用，因为您可以将逻辑拆分为更小的，更专业的块。 无论您是否发现 <code>柯里化</code> 有用，我都取决于您，但是我认为这是一种非常有趣的技术，值得学习 <code>柯里化</code> 的基础知识。 🍛</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用可变参数表示接受零个或多个指定类型的值。 因此，这意味着您可以使用可变参数Int参数输入任意数量的整数。 创建可变参量非常简单，只需在类型之后添加三个点即可。让我们来看一下这些事情：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function composition</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = increment(increment(increment(increment(<span class="number">10</span>))))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// function currying</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decrement</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> &#123; $<span class="number">0</span> * x &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> y = decrement(<span class="number">10</span>)(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a variadic function that accepts a block as a parameter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variadic</span><span class="params">(<span class="number">_</span> blocks: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)...) &#123;</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> blocks &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// it means you can pass as many parameters as you want...</span></span><br><span class="line">variadic(&#123; <span class="built_in">print</span>(<span class="string">"a"</span>) &#125;, &#123; <span class="built_in">print</span>(<span class="string">"b"</span>) &#125;, &#123; <span class="built_in">print</span>(<span class="string">"c"</span>) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// lol, trailing closure syntax works with variadic block params.</span></span><br><span class="line">variadic &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"d"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这几乎是 <code>Swift</code> 功能功能的快速介绍。 当然，您可以添加更多参数（但仅允许使用一个可变参数），使用泛型等等，但在深入探讨之前，让我们稍等一下。 🏊‍♂️</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a><strong><em>高阶函数</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果至少满足以下规则之一，则该函数为高阶函数：</p><ul><li>将一个或多个函数作为参数</li><li>返回一个函数作为其结果。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换句话说，甚至在 <code>Swift</code> 中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a function that takes another function as a parameter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(value: Int, <span class="number">_</span> transformation: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> transformation(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = transform(value: <span class="number">10</span>) &#123; value -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">// a function that returns another function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increase</span><span class="params">(withMultiplication shouldMultiply: Bool)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> x: Int, <span class="number">_</span> y: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(<span class="number">_</span> x: Int, <span class="number">_</span> y: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x * y &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldMultiply ? multiply : add</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = increase(withMultiplication: <span class="literal">true</span>)(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，正如您所看到的，它不像魔术，我们只是在传递函数。 乍一看，语法似乎很复杂，但是请相信我，这并不难。 如果遇到麻烦，请尝试为函数类型定义自己的类型别名，这将使代码更具可读性。 <code>typealias VoidBlock = () -&gt; Void</code>👍</p><h2 id="一般函数"><a href="#一般函数" class="headerlink" title="一般函数"></a><strong><em>一般函数</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您试图概括 <code>高阶函数</code> ，就会出现真正的问题。 在涉及 <code>泛型</code> 的情况下，语法看起来有些混乱。  <code>Gererics（又称参数多态性）</code> 使我们可以抽象出常规类型。 因此，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this only works for integers</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseInt</span><span class="params">(<span class="number">_</span> x: Int, or y: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Bool</span>.random() ? x : y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// whoa, this is a generic function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choose</span>&lt;T&gt;<span class="params">(<span class="number">_</span> x: T, or y: T)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Bool</span>.random() ? x : y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = chooseInt(<span class="number">1</span>, or: <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">// 1 or 2, but who knows this for sure</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = choose(<span class="string">"heads"</span>, or: <span class="string">"tails"</span>)</span><br><span class="line"><span class="built_in">print</span>(y) <span class="comment">// maybe heads or maybe tails</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的示例中，我们抽象了带有泛型T类型的整数类型，该类型可以是任何类型。 如果我们以字符串作为第一个参数调用泛型函数，则所有剩余的T类型都将用作字符串。 这有意义吗？ 如果是，那么恭喜您，现在您知道什么是通用函数。 🎊</p><h2 id="容器和箱子📦"><a href="#容器和箱子📦" class="headerlink" title="容器和箱子📦"></a><strong><em>容器和箱子📦</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从一个通用框开始。 您可以将任何值放入盒子中（就像您在现实生活中使用的普通纸箱一样），您始终可以打开盒子并使用 <code>value属性</code> 直接从内部获取值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> value: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="type">Box</span>&lt;<span class="type">Int</span>&gt;(<span class="number">360</span>)</span><br><span class="line"><span class="built_in">print</span>(x.value)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，继续讲一些理论，但是我保证我会做的很简短，因为已经用简单的 <a href="http://www.russbishop.net/monoids-monads-and-functors" target="_blank" rel="noopener"><strong><em><code>解释了函子，代名词和单子</code></em></strong></a> 。 我将尽力使它变得更加简单。 😉</p><h3 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a><strong><em>Functors</em></strong></h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函子是可以调用 <code>map</code> 的容器。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接受挑战！ 让我们用 box 类型做一个函子，但是映射到底是什么呢？ 好吧，它基本上将一个值转换为另一个值。 您可以提供自己的转换方法，在该方法中，您将接收原始值作为参数，并且必须以相同或不同的类型返回“新”值。 编码时间！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transformation: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Box</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Box</span>&lt;<span class="type">U</span>&gt;(transformation(<span class="keyword">self</span>.value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="type">Box</span>&lt;<span class="type">Int</span>&gt;(<span class="number">360</span>)</span><br><span class="line"><span class="keyword">let</span> y = x.<span class="built_in">map</span> &#123; <span class="string">"\($0) degrees"</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(y.value)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此 <code>map</code> 只是一个通用的 <code>高阶函数</code> ！ 只是一个 <code>高阶函数</code> …🤔只是一个函数传递给另一个函数。 哦，这是唯一可行的，因为 <code>Swift</code> 支持 <code>first-class</code> 的函数！ 现在您懂了！ 没什么神奇的，只是功能！</p><h3 id="单子"><a href="#单子" class="headerlink" title="单子"></a><strong><em>单子</em></strong></h3><blockquote><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Monad</code> 是可以调用 <code>flatMap</code> 的容器。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这很容易。  <code>flatMap</code> 是一种函数，可以转换值，然后将其重新包装为原始容器类型。 就像地图一样，但是您必须在转换函数中提供容器。 我将向您展示实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transformation: <span class="params">(T)</span></span></span> -&gt; <span class="type">Box</span>&lt;<span class="type">U</span>&gt;) -&gt; <span class="type">Box</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> transformation(<span class="keyword">self</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="type">Box</span>&lt;<span class="type">Int</span>&gt;(<span class="number">360</span>)</span><br><span class="line"><span class="keyword">let</span> y = x.flatMap &#123; <span class="type">Box</span>&lt;<span class="type">String</span>&gt;(<span class="string">"\($0) degrees"</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(y.value)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您准备好迎接更复杂的事情了吗？ 😅</p><h3 id="应用程式"><a href="#应用程式" class="headerlink" title="应用程式"></a><strong><em>应用程式</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://kandelvijaya.com/2018/03/25/functorapplicativemonad/#orgff1f53e" target="_blank" rel="noopener"><strong><em><code>Applicatives</code></em></strong></a> 可让您将转换功能放入容器中。 因此，只有在可以将转换函数应用到包装的值中之后，才必须首先包装转换函数。 这意味着您还必须在转换之前 <code>“取消装箱”</code> 值。 解释事情是一项艰巨的工作，让我在Swift中尝试一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">apply</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transformation: Box&lt;<span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>&gt;) -&gt; <span class="type">Box</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Box</span>&lt;<span class="type">U</span>&gt;(transformation.value(<span class="keyword">self</span>.value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="type">Box</span>&lt;<span class="type">Int</span>&gt;(<span class="number">360</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> transformation = <span class="type">Box</span>&lt;((<span class="type">Int</span>) -&gt; <span class="type">String</span>)&gt;(&#123; x -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(x) degrees"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = x.apply(transformation)</span><br><span class="line"><span class="built_in">print</span>(y.value)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如您所见，这一切都取决于容器，因此，如果您想使用一个看上去有点不同的 <code>apply函数</code> 扩展 <code>Optional枚举</code> 。 容器化很难！ 🤪</p><p>快速回顾：</p><blockquote><p>Container = M Functor = map(f: T -&gt; U) -&gt; M Monad = flatMap(f: T -&gt; M) -&gt; M Applicative = apply(f: M U)&gt;) -&gt; M</p></blockquote><h3 id="更高种类的类型"><a href="#更高种类的类型" class="headerlink" title="更高种类的类型"></a><strong><em>更高种类的类型</em></strong></h3><blockquote><p>其他高阶类型的想法是使多态函数成为first-class</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前，这尚未在 <code>Swift编程语言</code> 中实现，并且不会成为 <code>swift 5发行版</code>的一部分，但是您可以通过一些技巧在 Swift中 模拟 <a href="https://stackoverflow.com/questions/52905485/how-to-declare-protocol-for-hkt-in-swift" target="_blank" rel="noopener"><strong><em><code>HKT功能</code></em></strong></a> 。 老实说，我真的不想现在再谈论更高种类的类型，因为如果您想拥有更多类似的内容，这可能是下一章功能性编程教程中的核心话题。 😉</p><h3 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a><strong><em>Futures</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们谈谈 <code>Futures</code> 。 根据定义，它们是对尚未计算值的只读引用。 换句话说：<code>future</code> 是一个尚不存在的结果的占位符对象。 对于异步编程，这可能超级有用。 您是否听说过回调地狱？ 😈</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>future</code> 基本上是一个通用的 <code>result wrapper</code> ，结合了回调和一些额外的状态管理。 <code>Futures</code> 既是函子又是单子，这意味着您通常可以在其上同时调用 <code>map</code> 和 <code>flatMap</code> ，但是由于 <code>Futures</code> 的只读性质，您通常必须做出 <a href="https://stackoverflow.com/questions/14541975/whats-the-difference-between-a-future-and-a-promise" target="_blank" rel="noopener"><strong><em><code>promise</code></em></strong></a> 才能创建新的 <code>Future对象</code> 。 您可以在 <code>Swift-NIO</code> 中找到一个非常不错的实现。 😎</p><h3 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a><strong><em>Promises</em></strong></h3><blockquote><p>一个 <code>Promises</code> 是一个可写的单任务容器，它完成了 <code>Futures</code> 。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，您必须做出 <code>Promises</code> 而不是 <code>Futures</code> ，因为 <code>Futures</code> 是按设计只读的。  <code>Promises</code> 是可以完成未来的唯一对象（通常只有一次）。 我们可以说，将来的结果将始终由其他人设置（私有结果变量），而 <code>Promises</code> （基础的 <code>Futures</code> ）将由您设置，因为它具有公共拒绝和解决方法。 🚧</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一些 <code>promise</code> 还实现了 <code>future接口</code> ，因此这意味着您可以在 <code>promise</code> 上直接调用 <code>map</code> ， <code>flatMap</code> （通常都称为简单的重载then方法）。 此外，您还可以捕获错误并使用 <code>Promise</code> 做更多伟大的事情，可以随时查看我简单的 <code>Promise</code> 实现或事实上的标准 <a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener"><strong><em><code>PromiseKit</code></em></strong></a> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您准备好使用一些功能强大的 <code>Swift代码</code> 了吗？</p></br><h1 id="Swift-5中的函数式编程"><a href="#Swift-5中的函数式编程" class="headerlink" title="Swift 5中的函数式编程"></a><strong>Swift 5中的函数式编程</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在该练习我们所学的知识了。 在本节中，我将介绍 <code>Swift 5</code> 中最受欢迎的函数方法，并向您展示一些最佳实践。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a><strong><em>map</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 中的 <code>map函数</code> 适用于所有 <code>Sequence类型</code> ，而 <code>Swift 5</code> 中全新的 <code>Result类型</code> 也具有 <code>map函数</code> ，因此您可以根据需要转换这些类型的值，在某些情况下，这非常好。 这里有一些例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array</span></span><br><span class="line"><span class="keyword">let</span> numbers = <span class="type">Array</span>(<span class="number">0</span>...<span class="number">100</span>)</span><br><span class="line">numbers.<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">10</span> &#125; <span class="comment">// 0, 10, 20 ... 1000</span></span><br><span class="line">numbers.<span class="built_in">map</span>(<span class="type">String</span>.<span class="keyword">init</span>) <span class="comment">// "0", "1", "2" ... "100"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dictionary</span></span><br><span class="line"><span class="keyword">let</span> params: [<span class="type">String</span>: <span class="type">Any</span>] = [</span><br><span class="line">    <span class="string">"sort"</span>: <span class="string">"name"</span>,</span><br><span class="line">    <span class="string">"order"</span>: <span class="string">"desc"</span>,</span><br><span class="line">    <span class="string">"limit"</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">"offset"</span>: <span class="number">2</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapValues is basically map for the dictionary values</span></span><br><span class="line"><span class="keyword">let</span> queryItems = params.mapValues &#123; <span class="string">"\($0)"</span> &#125;</span><br><span class="line">                       .<span class="built_in">map</span>(<span class="type">URLQueryItem</span>.<span class="keyword">init</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="keyword">let</span> fruits = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;(arrayLiteral: <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>)</span><br><span class="line">fruits.<span class="built_in">map</span> &#123; $<span class="number">0</span>.capitalized &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// range</span></span><br><span class="line">(<span class="number">0</span>...<span class="number">100</span>).<span class="built_in">map</span>(<span class="type">String</span>.<span class="keyword">init</span>)</span><br></pre></td></tr></table></figure><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><strong><em>flatMap</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>flatMap</code> 方法在实现地图功能的大多数类型上也可用。 本质上， <code>flatMap</code> 做以下事情： 映射 和 <code>flattens</code> 。 这意味着您将获得扁平化的子数组数组。 让我告诉你它是如何工作的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flatMap</span></span><br><span class="line"><span class="keyword">let</span> groups = [</span><br><span class="line">    <span class="string">"animals"</span>: [<span class="string">"🐔"</span>, <span class="string">"🦊"</span>, <span class="string">"🐰"</span>, <span class="string">"🦁"</span>],</span><br><span class="line">    <span class="string">"fruits"</span>: [<span class="string">"🍎"</span>, <span class="string">"🍉"</span>, <span class="string">"🍓"</span>, <span class="string">"🥝"</span>]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> emojis = groups.flatMap &#123; $<span class="number">0</span>.value &#125;</span><br><span class="line"><span class="comment">// "🐔", "🦊", "🐰", "🦁", "🍎", "🍉", "🍓", "🥝"</span></span><br></pre></td></tr></table></figure><h2 id="compactMap"><a href="#compactMap" class="headerlink" title="compactMap"></a><strong><em>compactMap</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么， <a href="http://www.xuebaonline.com/Swift%20CompactMap%20vs%20flatMap%EF%BC%9A%E5%B7%AE%E5%BC%82%E8%AF%B4%E6%98%8E/"><strong><em><code>flatMap和compactMap有什么关系</code></em></strong></a> 呢？ 过去， <code>flatMap</code> 可以用于从数组中删除可选元素，但是从 <code>Swift 4.1</code> 开始，有一个名为 <code>compactMap</code> 的新函数可以用于此目的。 在大多数情况下，编译器会警告您将 <a href="http://www.xuebaonline.com/Swift%20%E7%94%A8%20compactMap%20%E6%9B%BF%E6%8D%A2%20flatMap/"><strong><em><code>flatMap 替换为 compactMap</code></em></strong></a> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compactMap</span></span><br><span class="line">[<span class="number">1</span>, <span class="literal">nil</span>, <span class="number">3</span>, <span class="literal">nil</span>, <span class="number">5</span>, <span class="number">6</span>].compactMap &#123; $<span class="number">0</span> &#125; <span class="comment">// 1, 3, 5, 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> possibleNumbers = [<span class="string">"1"</span>, <span class="string">"two"</span>, <span class="string">"3"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>, <span class="string">"6"</span>]</span><br><span class="line">possibleNumbers.compactMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125; <span class="comment">//1, 3, 6</span></span><br></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><strong><em>reduce</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>reduce</code> 方法是一个强大的工具。 它可以用于将集合中的所有元素合并为一个元素。 例如，您可以使用它来汇总元素，但是将元素与初始组件结合在一起也非常方便。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = (<span class="number">0</span>...<span class="number">100</span>).<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"><span class="built_in">print</span>(sum) <span class="comment">//5050</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cats = [<span class="string">"🦁"</span>, <span class="string">"🐯"</span>, <span class="string">"🐱"</span>]</span><br><span class="line">cats.<span class="built_in">reduce</span>(<span class="string">"Cats: "</span>) &#123; sum, cat <span class="keyword">in</span> <span class="string">"\(sum)\(cat)"</span>&#125; <span class="comment">// Cats: 🦁🐯🐱</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> basketballScores = [</span><br><span class="line">    <span class="string">"team one"</span>: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    <span class="string">"team two"</span>: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> points = basketballScores.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; sum, element <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> sum + element.value.<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(points) <span class="comment">// 24 (team one + team two scores together)</span></span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong><em>filter</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您可以使用 <code>filter方法</code> 过滤 <a href="https://medium.com/@JLHLonline/superpowered-sequences-a009ccc1ae43" target="_blank" rel="noopener"><strong><em><code>sequences</code></em></strong></a>  ，这很明显！ 您可以为每个元素定义一个条件块，如果条件为true，则给定元素将包含在结果中。 这就像循环遍历元素并挑选一些元素。 🤪</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> evenNumbers = (<span class="number">0</span>...<span class="number">100</span>).<span class="built_in">filter</span> &#123; $<span class="number">0</span>.isMultiple(of: <span class="number">2</span>) &#125;</span><br><span class="line"><span class="keyword">let</span> oddNumbers = (<span class="number">0</span>...<span class="number">100</span>).<span class="built_in">filter</span> &#123; !evenNumbers.<span class="built_in">contains</span>($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [</span><br><span class="line">    <span class="string">"odd"</span>: oddNumbers,</span><br><span class="line">    <span class="string">"even"</span>: evenNumbers,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> luckyThirteen = numbers</span><br><span class="line">.<span class="built_in">filter</span> &#123; element <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> element.key == <span class="string">"odd"</span></span><br><span class="line">&#125;</span><br><span class="line">.mapValues &#123; element <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> element.<span class="built_in">filter</span> &#123; $<span class="number">0</span> == <span class="number">13</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="promises"><a href="#promises" class="headerlink" title="promises"></a><strong><em>promises</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我喜欢 <code>promises</code> ，如果您不知道 <code>promises</code> 如何运作，也应该学习它们。 否则，您仍然可以使用 <a href="http://www.xuebaonline.com/Swift%20Grand%20Central%20Dispatch%20%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"><strong><em><code>Dispatch框架</code></em></strong></a> ，但我更喜欢 <code>Promise</code> ，因为使用 <code>Promise框架</code> 使传递变量更加容易。 正如我之前在事实上的标准中提到的是 <code>PromiseKit</code> ，但这对于我的口味来说有点太复杂了，我也更喜欢我的 <code>promise方法</code> 名称，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123; fulfill, reject <span class="keyword">in</span></span><br><span class="line">    fulfill(<span class="string">"Hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line">.thenMap &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> result + <span class="string">" World!"</span></span><br><span class="line">&#125;</span><br><span class="line">.then &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">String</span>&gt;(value: result)</span><br><span class="line">&#125;</span><br><span class="line">.tap &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"debug: \(result)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">.onSuccess(queue: .main) &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br><span class="line">.onFailure &#123; error <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br><span class="line">.always &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="下一步是什么？"><a href="#下一步是什么？" class="headerlink" title="下一步是什么？"></a><strong>下一步是什么？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在项目中尝试使用这些新的技能。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 Result Type来处理Swift 5中的Errors？</title>
      <link href="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Result%20Type%E6%9D%A5%E5%A4%84%E7%90%86Swift%205%E4%B8%AD%E7%9A%84Errors%EF%BC%9F/"/>
      <url>/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Result%20Type%E6%9D%A5%E5%A4%84%E7%90%86Swift%205%E4%B8%AD%E7%9A%84Errors%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从本教程中，你可以学习如何使用带有新 <code>result type</code> 的 <code>do-try-catch</code> 语法来处理 <code>Swift</code> 中的错误。</p></br><h1 id="Swift中的错误处理"><a href="#Swift中的错误处理" class="headerlink" title="Swift中的错误处理"></a><strong>Swift中的错误处理</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自第一个 <code>Swift</code> 版本以来，处理错误的方式发生了很大变化。 第一个重大里程碑发生在 <code>Swift 2</code> 中， <code>Apple</code> 彻底改进了错误管理。 如今，你可以使用 <code>do</code> ， <code>try</code> ， <code>catch</code> ， <code>throw</code> ， <code>throws</code> ， <code>rethrows</code> 关键字来代替处理讨厌的 <code>NSError指针</code> ，因此这是该语言的一个受欢迎的补充。 现在，在 <code>Swift 5</code> 中，我们通过将 <code>Result类型</code> 作为内置泛型引入了另一个巨大的飞跃。 首先，让我向你展示 <code>Swift编程语言</code> 中所有错误处理的最佳实践，接下来，我将通过使用结果来处理错误，向你展示一些很棒的东西。 🚧</p><a id="more"></a><h2 id="错误指示器"><a href="#错误指示器" class="headerlink" title="错误指示器"></a><strong><em>错误指示器</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于简单的情况，你始终可以使用可选值来指示发生了一些不良情况。 而且， <code>guard</code> 声明在这种情况下也非常有用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zeroValue = <span class="type">Int</span>(<span class="string">"0"</span>)! <span class="comment">// Int</span></span><br><span class="line"><span class="keyword">let</span> nilValue = <span class="type">Int</span>(<span class="string">"not a number"</span>) <span class="comment">// Int?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> number = <span class="type">Int</span>(<span class="string">"6"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Ooops... this should always work, so we crash."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(number)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不太在意错误的根本类型，则可以使用这种方法，但是有时情况会变得更加复杂，因此你可能需要一些有关该问题的详细信息。 无论如何，你始终可以通过调用 <code>fatalError方法</code> 来停止执行，但是如果这样做，那么你的应用程序将崩溃。 💥</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;停止执行过程还有其他几种方法，但这可能是一个独立的帖子的主题，因此这里只是可用方法的快速备忘单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">precondition</span>(<span class="literal">false</span>, <span class="string">"ouch"</span>)</span><br><span class="line"><span class="built_in">preconditionFailure</span>(<span class="string">"ouch"</span>)</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>, <span class="string">"ouch"</span>)</span><br><span class="line"><span class="built_in">assertionFailure</span>(<span class="string">"ouch"</span>)</span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"ouch"</span>)</span><br><span class="line">exit(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前提条件和断言之间的主要区别在于，断言仅在调试版本中起作用，而前提条件始终被评估（即使在发行版本中）。 如果条件再次失败，则这两种方法都会触发致命错误。 是错误的。 ⚠️</p><h2 id="通过使用Error协议抛出异常"><a href="#通过使用Error协议抛出异常" class="headerlink" title="通过使用Error协议抛出异常"></a><strong><em>通过使用Error协议抛出异常</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以通过简单地确认内置错误协议来定义自己的错误类型。 通常，大多数开发人员都使用枚举来定义不同的原因。 如果你符合 <code>LocalizedError协议</code> ，则还可以有一个自定义错误消息。 现在你可以抛出自定义错误了，如果你想引发类型错误，只需使用 <code>throw关键字</code> ，但是如果在函数中这样做，则必须使用 <code>throws</code> 将该函数标记为 <code>throwing函数</code> 关键字。 🤮</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DivisionError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> zeroDivisor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DivisionError</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> errorDescription: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .zeroDivisor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Division by zero is quite problematic. "</span> +</span><br><span class="line">                   <span class="string">"(https://en.wikipedia.org/wiki/Division_by_zero)"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> x: Int, by y: Int)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> y != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">DivisionError</span>.zeroDivisor</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x / y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很好，因此上面的除法函数可以生成自定义错误消息。 如果除数为零，则会抛出 <code>zeroDivision错误</code> 情况。 现在，设想以下情形：你正在尝试从磁盘读取文件的内容。 可能存在与权限或文件存在等相关的多种错误。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重新抛出函数和方法可以使用 <code>rethrows关键字</code> 声明函数或方法，以表明仅当函数参数之一抛出错误时，它才会抛出错误。 这些功能和方法称为重新抛出函数和重新抛出方法。 抛出函数和方法必须至少具有一个抛出函数参数。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，所以 <code>throwing函数</code> 可以发出不同的错误类型，还可以传播所有参数错误，但是我们如何处理（或者我应该说：捕获）这些错误？</p><h2 id="do-try-catch语法"><a href="#do-try-catch语法" class="headerlink" title="do-try-catch语法"></a><strong><em>do-try-catch语法</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你只需要尝试执行一个 <code>throwing函数</code> 。 因此，不要相信 <code>master</code> ，肯定会有尝试的空间！ 开玩笑吧？ 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="keyword">try</span> divide(<span class="number">10</span>, by: <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">DivisionError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Division error handler block"</span>)</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Generic error handler block"</span>)</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，语法非常简单，你有一个 <code>do块</code> ，你可以在其中尝试执行 <code>throwing函数</code> ，如果出现问题，则可以在不同的 <code>catch块</code> 中处理错误。 默认情况下，每个 <code>catch块</code> 内都有一个 <code>error属性</code> ，因此你不必手动定义一个。 但是，可以通过在 <code>catch关键字</code> 旁边使用 <code>let error as MyType</code> <code>sytnax</code> 强制转换特定错误类型的 <code>catch块</code> 。 因此，始终先尝试，不要只是做！ 🤪</p><h2 id="try-try-and-try-之间的差异"><a href="#try-try-and-try-之间的差异" class="headerlink" title="try, try? and try!之间的差异"></a><strong><em>try, try? and try!之间的差异</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如前所述，你可以简单地尝试调用在 <code>do-catch块</code> 内引发错误的函数。 如果函数触发某种错误，则可以将错误处理逻辑放入 <code>catch块</code> 中。 这非常简单明了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，如果你不太在意潜在的错误，则可以使用 <code>try？</code> 将你的 <code>throwing函数</code> 结果简单地转换为可选结果。 使用这种方法，如果发生不好的情况，你将得到零结果，否则，将按预期返回常规值。 这是上面使用 <code>try？</code> 的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> number = <span class="keyword">try</span>? divide(<span class="number">10</span>, by: <span class="number">2</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"This should work!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(number) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种技术是通过使用 <code>try!</code> 来防止错误传播，但是你必须格外小心，因为如果 <code>“尝试功能”</code> 的执行失败，你的应用程序将崩溃。 因此，仅在绝对确定该函数不会引发错误时使用。 ⚠️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="keyword">try</span>! divide(<span class="number">10</span>, by: <span class="number">2</span>) <span class="comment">// This will work for sure!</span></span><br><span class="line"><span class="built_in">print</span>(number)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在某些地方可以使用强制尝试，但在大多数情况下，应使用适当的错误处理程序在替代路径上。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift 5</code> 中嵌套可选吗？ 值将被展平为单个可选值。  <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0230-flatten-optional-try.md" target="_blank" rel="noopener"><strong><em><code>SE-0230</code></em></strong></a> 是已经实施的建议，可能会破坏一些现有的 <code>Swift</code> 代码。 </p></blockquote><h2 id="Swift-错误也不例外"><a href="#Swift-错误也不例外" class="headerlink" title="Swift 错误也不例外"></a><strong><em>Swift 错误也不例外</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift编译器</code> 总是要求你捕获所有引发的错误，因此永远不会发生未处理错误的情况。 我不是在谈论空的 <code>catch块</code> ，而是在处理未处理的 <code>throw函数</code> ，因此，如果没有 <code>do-catch</code> 伙伴，你将无法尝试。 与例外相比，这是一个主要区别。 同样，当引发错误时，执行将仅退出当前作用域。 异常通常会释放堆栈，这可能导致内存泄漏，但是 <code>Swift错误</code> 并非如此。 👍</p></br><h1 id="介绍-Result-Type"><a href="#介绍-Result-Type" class="headerlink" title="介绍 Result Type"></a>介绍 Result Type</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift 5</code> 引入了期待已久的通用<code>result type</code> 。 这意味着错误处理可以更加简单，而无需添加你自己的结果实现。 让我通过使用 <code>Result</code> 向你展示我们之前的除法函数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> x: Int, by y: Int)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>, <span class="type">DivisionError</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> y != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .failure(.zeroDivisor)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> .success(x / y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = divide(<span class="number">10</span>, by: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">switch</span> result &#123;</span><br><span class="line"><span class="keyword">case</span> .success(<span class="keyword">let</span> number):</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line"><span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 中的 <code>结果类型</code> 基本上是具有 <code>.success</code> 和 <code>.failure</code> 情况的通用枚举。 如果调用成功，则可以传递通用值；如果调用失败，则可以传递错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的一个主要优点是结果返回的错误是 <code>类型安全</code> 的。  抛出函数 可以抛出任何类型的错误，但是在这里，你可以从实现中看到，如果发生不好的情况， <code>DivisionError</code> 将返回。 另一个好处是，即使没有默认情况，你也可以使用穷举开关块来 <code>“遍历”</code> 所有可能的错误情况。 这样编译器可以使你安全，例如。 如果要在枚举声明中引入新的错误类型。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，通过使用 <code>Result类型</code> ，很明显，我们可以获取 <code>结果数据</code> 或 <code>强类型错误</code> 。 不可能两者都获得，但是这比使用 <code>throwing函数</code> 更好吗？ 好吧，让我们散开吧！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> x: Int, by y: Int, completion: <span class="params">(<span class="params">(<span class="params">()</span></span></span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">    <span class="keyword">guard</span> y != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        completion &#123; <span class="keyword">throw</span> <span class="type">DivisionError</span>.zeroDivisor &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    completion &#123; <span class="keyword">return</span> x / y &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divide(<span class="number">10</span>, by: <span class="number">0</span>) &#123; calculate <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> number = <span class="keyword">try</span> calculate()</span><br><span class="line">        <span class="built_in">print</span>(number)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内在封闭！ 完成处理程序接受抛出函数，因此我们可以将抛出的错误传播到外部处理程序了！ 🤬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个选择是，我们完全消除了抛出错误，并因此使用了一个可选参数，但是在这种情况下，我们回到 <code>square one</code> 。 没有基础的错误类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> x: Int, by y: Int, completion: <span class="params">(Int?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> y != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> completion(<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    completion(x / y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divide(<span class="number">10</span>, by: <span class="number">0</span>) &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> number = result <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"nil"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终，我们到了这里，但是这次我们也将错误添加为 <code>闭包参数</code> 。 你应该注意，两个参数都必须是可选的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> x: Int, by y: Int, completion: <span class="params">(Int?, Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> y != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> completion(<span class="literal">nil</span>, <span class="type">DivisionError</span>.zeroDivisor)</span><br><span class="line">    &#125;</span><br><span class="line">    completion(x / y, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divide(<span class="number">10</span>, by: <span class="number">0</span>) &#123; result, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> error == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(error!.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> number = result <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Empty result."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，让我们介绍一下结果，以便我们可以从之前的代码中消除可选参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> x: Int, by y: Int, completion: <span class="params">(Result&lt;Int, DivisionError&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> y != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> completion(.failure(.zeroDivisor))</span><br><span class="line">    &#125;</span><br><span class="line">    completion(.success(x / y))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divide(<span class="number">10</span>, by: <span class="number">0</span>) &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> number):</span><br><span class="line">        <span class="built_in">print</span>(number)</span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;强类型错误，无可选。 通过使用 <code>Result类型</code> ，更好地处理 <code>异步函数</code> 中的错误。 如果你认为大多数应用程序都在进行某种形式的联网，并且结果通常是 <code>JSON响应</code> ，那么你已经必须使用可选参数（响应，数据，错误），并且你还有抛出 <code>JSONDecoder</code> 的方法…可以 等待新的API！ ❤️</p><h2 id="在Swift-5中使用Result类型"><a href="#在Swift-5中使用Result类型" class="headerlink" title="在Swift 5中使用Result类型"></a><strong><em>在Swift 5中使用Result类型</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经知道结果类型基本上是带有通用 <code>.succes（T）</code> 和 <code>.failure（Error）</code> 例的枚举，但是我想在这里向你展示更多。 例如，你可以使用以下抛出函数创建结果类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> divide(<span class="number">10</span>, by: <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以通过调用 <code>get函数</code> 来转换回结果值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="keyword">try</span> result.<span class="keyword">get</span>()</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，还有用于转换成功值的 <code>map</code> ， <code>flatMap</code> ，如果你要转换失败，也可以使用 <code>mapError</code> 或 <code>flatMapError</code> 方法。 😎</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = divide(<span class="number">10</span>, by: <span class="number">2</span>) <span class="comment">// Result&lt;Int, DivisionError&gt;</span></span><br><span class="line"><span class="keyword">let</span> mapSuccess = result.<span class="built_in">map</span> &#123; divide($<span class="number">0</span>, by: <span class="number">2</span>) &#125; <span class="comment">// Result&lt;Result&lt;Int, DivisionError&gt;, DivisionError&gt;</span></span><br><span class="line"><span class="keyword">let</span> flatMapSuccess = result.flatMap &#123; divide($<span class="number">0</span>, by: <span class="number">2</span>) &#125; <span class="comment">// Result&lt;Int, DivisionError&gt;</span></span><br><span class="line"><span class="keyword">let</span> mapFailure = result.mapError &#123; <span class="type">NSError</span>(domain: $<span class="number">0</span>.localizedDescription, code: <span class="number">0</span>, userInfo: <span class="literal">nil</span>) &#125;</span><br><span class="line"><span class="keyword">let</span> flatMapFailure = result.flatMapError &#123; .failure(<span class="type">NSError</span>(domain: $<span class="number">0</span>.localizedDescription, code: <span class="number">0</span>, userInfo: <span class="literal">nil</span>)) &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是 <code>Swift 5</code> 中的 <code>Result类型</code> 。正如你所看到的，直接在语言中内置通用实现非常强大。 现在我们有了结果，我只希望有更高种类的类型或 <code>异步/等待</code> 实现。 👍</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Result Type </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Result Type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Swift中的Grand Central Dispatch</title>
      <link href="/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Swift%E4%B8%AD%E7%9A%84Grand%20Central%20Dispatch/"/>
      <url>/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Swift%E4%B8%AD%E7%9A%84Grand%20Central%20Dispatch/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://developer.apple.com/reference/dispatch" target="_blank" rel="noopener"><strong><em><code>Grand Central Dispatch</code></em></strong></a>（简称GCD）是大多数 <code>Swift开发人员</code> 使用无数次的基本技术之一。 它主要是因为能够在不同的并发队列上分派工作而闻名，并且经常用于编写如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="comment">// Run async code on the main queue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是事实证明，如果我们再深入一点， <code>GCD</code> 还提供了一套并非所有人都知道的真正强大的API和功能。 本周，让我们超越 <code>async {}</code> ，看看在某些情况下GCD确实非常有用，以及它如何为许多其他（更常见的） <code>Foundation API</code> 提供更简单（更“迅速”）的选项。</p><a id="more"></a></br><h1 id="使用DispatchWorkItem延迟可取消的任务"><a href="#使用DispatchWorkItem延迟可取消的任务" class="headerlink" title="使用DispatchWorkItem延迟可取消的任务"></a><strong>使用DispatchWorkItem延迟可取消的任务</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于 <code>GCD</code> 的一个常见误解是 <code>“一旦安排了无法取消的任务，就需要使用Operation API”</code>。 虽然过去确实如此，但在 <code>iOS 8</code> 和 <code>macOS 10.10</code> 中引入了 <code>DispatchWorkItem</code> ，它以非常易于使用的API提供了此确切功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们的用户界面具有搜索栏，当用户键入字符时，我们会通过调用后端进行搜索。 由于用户可以快速键入内容，因此我们不希望立即启动网络请求（这可能会浪费大量数据和服务器容量），而我们将对这些事件进行“反跳”操作，而仅执行请求 一旦用户没有输入0.25秒。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是 <code>DispatchWorkItem</code> 的用处。通过将我们的请求代码封装在一个工作项中，无论何时将其替换为新的请求代码，我们都可以轻松地将其取消，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchViewController</span>: <span class="title">UIViewController</span>, <span class="title">UISearchBarDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We keep track of the pending work item as a property</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> pendingRequestWorkItem: <span class="type">DispatchWorkItem?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">searchBar</span><span class="params">(<span class="number">_</span> searchBar: UISearchBar, textDidChange searchText: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Cancel the currently pending item</span></span><br><span class="line">        pendingRequestWorkItem?.cancel()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wrap our request in a work item</span></span><br><span class="line">        <span class="keyword">let</span> requestWorkItem = <span class="type">DispatchWorkItem</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.resultsLoader.loadResults(forQuery: searchText)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new work item and execute it after 250 ms</span></span><br><span class="line">        pendingRequestWorkItem = requestWorkItem</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + .milliseconds(<span class="number">250</span>),</span><br><span class="line">                                      execute: requestWorkItem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们在上面看到的，由于 <code>尾随闭包语法</code> 以及 <code>GCD</code> 导入 <code>Swift</code> 的效果，在 <code>Swift</code> 中使用 <code>DispatchWorkItem</code> 实际上比必须使用 <code>Timer</code> 或 <code>Operation</code> 简单得多。 我们不需要使用 <code>@objc</code> 标记的方法或 <code>#selector</code> - 都可以使用闭包来完成。</p></br><h1 id="使用DispatchGroup分组和链接任务"><a href="#使用DispatchGroup分组和链接任务" class="headerlink" title="使用DispatchGroup分组和链接任务"></a><strong>使用DispatchGroup分组和链接任务</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时我们需要执行一组操作，然后才能继续执行逻辑。 例如，假设我们需要先从一组数据源中加载数据，然后才能创建模型。 不必自己跟踪所有数据源，我们可以轻松地将工作与 <code>DispatchGroup</code> 同步。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用调度组 还为我们提供了一个很大的优势，因为我们的任务可以在单独的队列中同时运行。 这使我们能够从简单开始，然后在需要时轻松添加并发，而无需重写任何任务。 我们要做的就是在调度组上均衡地调用 <code>enter()</code> 和 <code>leave()</code> ，以使其同步我们的任务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看一个示例，在该示例中，我们从本地存储， <code>iCloud Drive</code> 和后端系统加载笔记，然后将所有结果合并到一个 <code>NoteCollection</code> 中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First, we create a group to synchronize our tasks</span></span><br><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// NoteCollection is a thread-safe collection class for storing notes</span></span><br><span class="line"><span class="keyword">let</span> collection = <span class="type">NoteCollection</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// The 'enter' method increments the group's task count…</span></span><br><span class="line">group.enter()</span><br><span class="line">localDataSource.load &#123; notes <span class="keyword">in</span></span><br><span class="line">    collection.add(notes)</span><br><span class="line">    <span class="comment">// …while the 'leave' methods decrements it</span></span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">iCloudDataSource.load &#123; notes <span class="keyword">in</span></span><br><span class="line">    collection.add(notes)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">backendDataSource.load &#123; notes <span class="keyword">in</span></span><br><span class="line">    collection.add(notes)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This closure will be called when the group's task count reaches 0</span></span><br><span class="line">group.notify(queue: .main) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>?.render(collection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码有效，但是其中有很多重复项。 让我们将其重构为 <code>Array的扩展</code> ，使用 <code>DataSource协议</code> 作为 <code>其Element类型</code> 的同类型约束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span> == <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(completionHandler: @escaping <span class="params">(NoteCollection)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line">        <span class="keyword">let</span> collection = <span class="type">NoteCollection</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// De-duplicate the synchronization code by using a loop</span></span><br><span class="line">        <span class="keyword">for</span> dataSource <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            group.enter()</span><br><span class="line">            dataSource.load &#123; notes <span class="keyword">in</span></span><br><span class="line">                collection.add(notes)</span><br><span class="line">                group.leave()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        group.notify(queue: .main) &#123;</span><br><span class="line">            completionHandler(collection)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过以上扩展，我们现在可以将之前的代码简化为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSources: [<span class="type">DataSource</span>] = [</span><br><span class="line">    localDataSource,</span><br><span class="line">    iCloudDataSource,</span><br><span class="line">    backendDataSource</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">dataSources.load &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] collection <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>?.render(collection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好，紧凑！ 👍</p><h1 id="用DispatchSemaphore等待异步任务"><a href="#用DispatchSemaphore等待异步任务" class="headerlink" title="用DispatchSemaphore等待异步任务"></a><strong>用DispatchSemaphore等待异步任务</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管 <code>DispatchGroup</code> 提供了一种同步一组异步操作而又保持异步的好方法，但 <code>DispatchSemaphore</code> 提供了一种同步等待一组异步任务的方法。 这在命令行工具或脚本中非常有用，因为我们没有应用程序运行循环，而只是在全局上下文中同步执行直到完成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像 <code>DispatchGroup</code> 一样， <code>信号量API</code> 非常简单，因为我们只通过调用 <code>wait()</code> 或 <code>signal()</code> 来增加或减少内部计数器。 在 <code>signal()</code> 之前调用 <code>wait()</code>将阻塞当前队列，直到接收到信号为止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们在之前的 <code>Array扩展</code> 中创建另一个重载，该重载同步返回 <code>NoteCollection</code> ，否则将引发错误。 我们将重用以前基于 <code>DispatchGroup</code> 的代码，而仅使用 <code>信号量</code> 协调该任务。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span> == <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">NoteCollection</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> loadedCollection: <span class="type">NoteCollection?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We create a new queue to do our work on, since calling wait() on</span></span><br><span class="line">        <span class="comment">// the semaphore will cause it to block the current queue</span></span><br><span class="line">        <span class="keyword">let</span> loadingQueue = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"></span><br><span class="line">        loadingQueue.async &#123;</span><br><span class="line">            <span class="comment">// We extend 'load' to perform its work on a specific queue</span></span><br><span class="line">            <span class="keyword">self</span>.load(onQueue: loadingQueue) &#123; collection <span class="keyword">in</span></span><br><span class="line">                loadedCollection = collection</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Once we're done, we signal the semaphore to unblock its queue</span></span><br><span class="line">                semaphore.signal()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait with a timeout of 5 seconds</span></span><br><span class="line">        semaphore.wait(timeout: .now() + <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> collection = loadedCollection <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">NoteLoadingError</span>.timedOut</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> collection</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Array</code> 上使用上述新方法，我们现在可以在脚本或命令行工具中同步加载笔记，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSources: [<span class="type">DataSource</span>] = [</span><br><span class="line">    localDataSource,</span><br><span class="line">    iCloudDataSource,</span><br><span class="line">    backendDataSource</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> collection = <span class="keyword">try</span> dataSources.load()</span><br><span class="line">    output(collection)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    output(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="使用DispatchSource观察文件中的更改"><a href="#使用DispatchSource观察文件中的更改" class="headerlink" title="使用DispatchSource观察文件中的更改"></a><strong>使用DispatchSource观察文件中的更改</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我想提出的 <code>GCD</code> 的最后一个“鲜为人知”的功能是 <strong>它如何提供一种观察文件系统中文件更改</strong> 的方法。 像 <code>DispatchSemaphore</code> 一样，如果我们要自动响应用户正在编辑的文件，则在脚本或命令行工具中这可能是超级有用的。 这使我们能够轻松构建具有 <code>“实时编辑”</code> 功能的开发人员工具。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调度源有几种不同的变体，具体取决于我们要观察的内容。 在这种情况下，我们将使用 <code>DispatchSourceFileSystemObject</code> ，它使我们可以观察文件系统中的事件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看一个简单的 <code>FileObserver</code> 的示例实现，该示例实现使我们附加一个闭包，以在每次更改给定文件时运行该闭包。 它通过使用 <code>fileDescriptor</code> 和 <code>DispatchQueue</code> 创建调度源来执行观察，并使用 <code>Files</code> 引用要观察的文件来工作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> file: <span class="type">File</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> queue: <span class="type">DispatchQueue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> source: <span class="type">DispatchSourceFileSystemObject?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(file: <span class="type">File</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.file = file</span><br><span class="line">        <span class="keyword">self</span>.queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.myapp.fileObserving"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">(closure: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="comment">// We can only convert an NSString into a file system representation</span></span><br><span class="line">        <span class="keyword">let</span> path = (file.path <span class="keyword">as</span> <span class="type">NSString</span>)</span><br><span class="line">        <span class="keyword">let</span> fileSystemRepresentation = path.fileSystemRepresentation</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Obtain a descriptor from the file system</span></span><br><span class="line">        <span class="keyword">let</span> fileDescriptor = <span class="keyword">open</span>(fileSystemRepresentation, <span class="type">O_EVTONLY</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create our dispatch source</span></span><br><span class="line">        <span class="keyword">let</span> source = <span class="type">DispatchSource</span>.makeFileSystemObjectSource(</span><br><span class="line">            fileDescriptor: fileDescriptor,</span><br><span class="line">            eventMask: .write,</span><br><span class="line">            queue: queue</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assign the closure to it, and resume it to start observing</span></span><br><span class="line">        source.setEventHandler(handler: closure)</span><br><span class="line">        source.resume()</span><br><span class="line">        <span class="keyword">self</span>.source = source</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们现在可以像这样使用 <code>FileObserver</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">try</span> <span class="type">FileObserver</span>(file: file)</span><br><span class="line"></span><br><span class="line">observer.start &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"File was changed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象一下可以使用此工具构建的所有出色的开发人员工具！ 😀</p></br><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Grand Central Dispatch</code> 是一个非常强大的框架，其功能远不止最初看起来的样子。 希望这篇文章激发了你对它的用途的想象力，我建议你下次尝试执行我们在本文中介绍的任务之一时尝试一下。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我看来，直接使用 <code>GCD</code> 实际上可以简化许多基于 <code>Timer</code> 或 <code>OperationQueue</code> 的代码，以及使用第三方异步框架。🚀</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Grand Central Dispatch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Grand Central Dispatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Swift中生成随机数</title>
      <link href="/%E5%9C%A8Swift%E4%B8%AD%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/%E5%9C%A8Swift%E4%B8%AD%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用最新方法并涵盖一些旧技术，了解在 <code>Swift</code> 中生成随机值所需的一切。</p></br><h1 id="如何使用Swift生成随机数？"><a href="#如何使用Swift生成随机数？" class="headerlink" title="如何使用Swift生成随机数？"></a><strong>如何使用Swift生成随机数？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，自 <code>Swift 4.2</code> 起，统一了随机数生成功能。 这意味着你不再需要导入的 <code>C API</code>，只需在所有平台上使用本机 <code>Swift</code> 方法即可生成随机值！ 😍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> randomBool = <span class="type">Bool</span>.random()</span><br><span class="line"><span class="keyword">let</span> randomInt = <span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">1</span>...<span class="number">6</span>) <span class="comment">//dice roll</span></span><br><span class="line"><span class="keyword">let</span> randomFloat = <span class="type">Float</span>.random(<span class="keyword">in</span>: <span class="number">0</span>...<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> randomDouble = <span class="type">Double</span>.random(<span class="keyword">in</span>: <span class="number">1</span>..&lt;<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，借助 <code>Swift语言</code> 内置的加密安全随机发生器，现在非常容易生成骰子。 新的随机数生成器 <code>API</code> 也更擅长分配数字。 旧的 <code>arc4random</code> 函数存在一些问题，因为由于模偏差的影响，生成的值不均匀地分布在例如1到6之间。 🎲</p><a id="more"></a></br><h1 id="随机数发生器（RNG）"><a href="#随机数发生器（RNG）" class="headerlink" title="随机数发生器（RNG）"></a><strong>随机数发生器（RNG）</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的这些示例隐式使用了 <code>Swift标准库</code> 提供的默认随机数生成器 <code>（SystemRandomNumberGenerator）</code> 。 每个方法都有第二个参数，因此你可以根据需要使用其他RNG。 如果你想改变分布的行为（或者只是给它一些“熵”！🤪），也可以实现自己的 <a href="https://github.com/t-ae/rng-extension" target="_blank" rel="noopener"><strong><em><code>RNG或扩展内置生成器</code></em></strong></a> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rng = <span class="type">SystemRandomNumberGenerator</span>()</span><br><span class="line"><span class="keyword">let</span> randomBool = <span class="type">Bool</span>.random(using: &amp;rng)</span><br><span class="line"><span class="keyword">let</span> randomInt = <span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">1</span>...<span class="number">6</span>, using: &amp;rng) <span class="comment">//dice roll</span></span><br><span class="line"><span class="keyword">let</span> randomFloat = <span class="type">Float</span>.random(<span class="keyword">in</span>: <span class="number">0</span>...<span class="number">1</span>, using: &amp;rng)</span><br><span class="line"><span class="keyword">let</span> randomDouble = <span class="type">Double</span>.random(<span class="keyword">in</span>: <span class="number">1</span>..&lt;<span class="number">100</span>, using: &amp;rng)</span><br></pre></td></tr></table></figure></br><h2 id="集合，随机元素"><a href="#集合，随机元素" class="headerlink" title="集合，随机元素"></a><strong><em>集合，随机元素</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新的随机 <code>API</code> 引入了一些不错的 <code>集合类型扩展</code> 。 现在，选择一个随机元素并混合一个集合中的元素顺序非常简单且高效（同时具有自定义RNG支持）。 😉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="string">"🐶"</span>, <span class="string">"🐱"</span>, <span class="string">"🐮"</span>, <span class="string">"🐷"</span>, <span class="string">"🐔"</span>, <span class="string">"🐵"</span>]</span><br><span class="line"><span class="keyword">let</span> randomArrayElement = array.randomElement()</span><br><span class="line"><span class="keyword">let</span> shuffledArray = array.shuffled()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dictionary = [</span><br><span class="line">    <span class="string">"🐵"</span>: <span class="string">"🍌"</span>,</span><br><span class="line">    <span class="string">"🐱"</span>: <span class="string">"🥛"</span>,</span><br><span class="line">    <span class="string">"🐶"</span>: <span class="string">"🍖"</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> randomDictionaryElement = dictionary.randomElement()</span><br><span class="line"><span class="keyword">let</span> shuffledDictionary = dictionary.shuffled()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sequence = <span class="number">1</span>..&lt;<span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> randomSequenceElement = sequence.randomElement()</span><br><span class="line"><span class="keyword">let</span> shuffledSequence = sequence.shuffled()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;(arrayLiteral: <span class="string">"🐶"</span>, <span class="string">"🐱"</span>, <span class="string">"🐮"</span>, <span class="string">"🐷"</span>, <span class="string">"🐔"</span>, <span class="string">"🐵"</span>)</span><br><span class="line"><span class="keyword">let</span> randomSetElement = <span class="keyword">set</span>.randomElement()</span><br><span class="line"><span class="keyword">let</span> shuffledSet = <span class="keyword">set</span>.shuffled()</span><br></pre></td></tr></table></figure><h2 id="随机化自定义类型"><a href="#随机化自定义类型" class="headerlink" title="随机化自定义类型"></a><strong><em>随机化自定义类型</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以在自定义类型上实现随机函数。 为了遵循 <code>Swift标准库模式</code> ，应牢记两个简单的事情：</p><ul><li>为 <code>自定义RNG</code> 提供一个具有 <code>（inout）</code> 参数的静态方法</li><li>制作使用 <code>SystemRandomNumberGenerator</code> 的 <code>random()</code> 方法</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Animal</span>: <span class="title">String</span>, <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> dog = <span class="string">"🐶"</span></span><br><span class="line">    <span class="keyword">case</span> cat = <span class="string">"🐱"</span></span><br><span class="line">    <span class="keyword">case</span> cow = <span class="string">"🐮"</span></span><br><span class="line">    <span class="keyword">case</span> pig = <span class="string">"🐷"</span></span><br><span class="line">    <span class="keyword">case</span> chicken = <span class="string">"🐔"</span></span><br><span class="line">    <span class="keyword">case</span> monkey = <span class="string">"🐵"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">random</span>&lt;T: RandomNumberGenerator&gt;<span class="params">(using generator: <span class="keyword">inout</span> T)</span></span> -&gt; <span class="type">Animal</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allCases.randomElement(using: &amp;generator)!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Animal</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> rng = <span class="type">SystemRandomNumberGenerator</span>()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Animal</span>.random(using: &amp;rng)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> random: <span class="type">Animal</span> = .random()</span><br><span class="line">random.rawValue</span><br></pre></td></tr></table></figure></br><h1 id="使用GameplayKit生成随机值"><a href="#使用GameplayKit生成随机值" class="headerlink" title="使用GameplayKit生成随机值"></a><strong>使用GameplayKit生成随机值</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://developer.apple.com/documentation/gameplaykit" target="_blank" rel="noopener"><strong><em><code>GameplayKit</code></em></strong></a> 提供了许多帮助你处理随机数生成的功能。 框架内提供了各种随机源和发行版，让我们快速看一下它们。</p><h2 id="GameplayKit中的随机来源"><a href="#GameplayKit中的随机来源" class="headerlink" title="GameplayKit中的随机来源"></a><strong><em>GameplayKit中的随机来源</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>GameplayKit</code> 实现了三种随机源算法，其背后的原因是很难生成随机数，但是通常你会使用 <code>arc4随机源</code> 。 你应该注意，Apple建议你在将其用于重要内容之前将其前769个值重置（将其舍入为1024以使其看起来更好），否则它将产生可猜测的序列。 🔑</p><p><strong><code>GKARC4RandomSource</code></strong> -好的性能和随机性</p><p><strong><code>GKLinearCongruentialRandomSource</code></strong> -快速，较少随机</p><p><strong><code>GKMersenneTwisterRandomSource</code></strong> -随机性好，但速度慢</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以简单地在上述任何一个源上使用 <code>nextInt()</code>方法从 <code>int min</code> 到 <code>int max</code> 生成一个随机数，或者使用 <code>nextInt(upperBound:)</code>方法从0到上限生成一个随机数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GameplayKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arc4 = <span class="type">GKARC4RandomSource</span>()</span><br><span class="line">arc4.dropValues(<span class="number">1024</span>) <span class="comment">//drop first 1024 values first</span></span><br><span class="line">arc4.nextInt(upperBound: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> linearCongruential = <span class="type">GKLinearCongruentialRandomSource</span>()</span><br><span class="line">linearCongruential.nextInt(upperBound: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> mersenneTwister = <span class="type">GKMersenneTwisterRandomSource</span>()</span><br><span class="line">mersenneTwister.nextInt(upperBound: <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="随机分布算法"><a href="#随机分布算法" class="headerlink" title="随机分布算法"></a><strong><em>随机分布算法</em></strong></h2><blockquote><p><strong>GKRandomDistribution</strong> - 生成随机数的生成器，该随机数在特定范围内，并且在多个采样中表现出特定的分布。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本上可以说，该实现正在尝试为我们提供随机分布的值。 这是共享随机源的默认值。 🤨</p><blockquote><p><strong>GKGaussianDistribution</strong> -随机数生成器，在多个采样中遵循高斯分布（也称为正态分布）。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>高斯分布</code> 是一个整形的随机数生成器，因此中间附近的数字更有可能出现。 换句话说，中间元素的发生率会更高，因此，如果你要模拟骰子掷骰，则3发生的可能性要大于1或6。 😅</p><blockquote><p><strong>GKShuffledDistribution</strong> -生成随机数的发生器，这些随机数在许多采样中均匀分布，但是不可能出现相似值的短序列。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;公平随机数生成器或混洗分布是一种以均等分布的相等数量生成其每个可能值的方法。 如果我们将骰子掷骰示例保留为6卷，则你可能会得到6、2、1、3、4、5，但永远不会得到6 6 6 1 2 6。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6 sided dice</span></span><br><span class="line"><span class="keyword">let</span> randomD6 = <span class="type">GKRandomDistribution</span>.d6()</span><br><span class="line"><span class="keyword">let</span> shuffledD6 = <span class="type">GKShuffledDistribution</span>.d6()</span><br><span class="line"><span class="keyword">let</span> gaussianD6 = <span class="type">GKGaussianDistribution</span>.d6()</span><br><span class="line">randomD6.nextInt()   <span class="comment">// completely random</span></span><br><span class="line">shuffledD6.nextInt() <span class="comment">// see below... // eg. 1</span></span><br><span class="line">gaussianD6.nextInt() <span class="comment">// mostly 3, most likely 2, 4 less likely 1, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//goes through all the possible values again and again...</span></span><br><span class="line">shuffledD6.nextInt() <span class="comment">// eg. 3</span></span><br><span class="line">shuffledD6.nextInt() <span class="comment">// eg. 5</span></span><br><span class="line">shuffledD6.nextInt() <span class="comment">// eg. 2</span></span><br><span class="line">shuffledD6.nextInt() <span class="comment">// eg. 6</span></span><br><span class="line">shuffledD6.nextInt() <span class="comment">// eg. 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 20 sided dice</span></span><br><span class="line"><span class="keyword">let</span> randomD20 = <span class="type">GKRandomDistribution</span>.d20()</span><br><span class="line"><span class="keyword">let</span> shuffledD20 = <span class="type">GKShuffledDistribution</span>.d20()</span><br><span class="line"><span class="keyword">let</span> gaussianD20 = <span class="type">GKGaussianDistribution</span>.d20()</span><br><span class="line">randomD20.nextInt()</span><br><span class="line">shuffledD20.nextInt()</span><br><span class="line">gaussianD20.nextInt()</span><br><span class="line"></span><br><span class="line"><span class="comment">// using custom random source, by default it uses arc4</span></span><br><span class="line"><span class="keyword">let</span> mersenneTwister = <span class="type">GKMersenneTwisterRandomSource</span>()</span><br><span class="line"><span class="keyword">let</span> mersoneTwisterRandomD6 = <span class="type">GKRandomDistribution</span>(randomSource: mersenneTwister, lowestValue: <span class="number">1</span>, highestValue: <span class="number">6</span>)</span><br><span class="line">mersoneTwisterRandomD6.nextInt()</span><br><span class="line">mersoneTwisterRandomD6.nextInt(upperBound: <span class="number">3</span>) <span class="comment">//limiting upper bound</span></span><br></pre></td></tr></table></figure><h2 id="如何使用GameplayKit随机播放数组？"><a href="#如何使用GameplayKit随机播放数组？" class="headerlink" title="如何使用GameplayKit随机播放数组？"></a><strong><em>如何使用GameplayKit随机播放数组？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <strong><em>arrayByShufflingObjects(in :)</em></strong> 方法来混合数组中的元素。 你也可以使用种子值来相同地随机播放元素。 这将是一个随机顺序，但可以预见。 如果你需要在多个设备之间同步两个随机阵列，这将很方便。 📱</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dice = [<span class="type">Int</span>](<span class="number">1</span>...<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> random = <span class="type">GKRandomSource</span>.sharedRandom()</span><br><span class="line"><span class="keyword">let</span> randomRolls = random.arrayByShufflingObjects(<span class="keyword">in</span>: dice)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mersenneTwister = <span class="type">GKMersenneTwisterRandomSource</span>()</span><br><span class="line"><span class="keyword">let</span> mersenneTwisterRolls = mersenneTwister.arrayByShufflingObjects(<span class="keyword">in</span>: dice)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fixedSeed = <span class="type">GKMersenneTwisterRandomSource</span>(seed: <span class="number">1001</span>)</span><br><span class="line"><span class="keyword">let</span> fixed1 = fixedSeed.arrayByShufflingObjects(<span class="keyword">in</span>: dice) <span class="comment">// always the same order</span></span><br></pre></td></tr></table></figure><h2 id="GameplayKit最佳实践以生成随机值"><a href="#GameplayKit最佳实践以生成随机值" class="headerlink" title="GameplayKit最佳实践以生成随机值"></a><strong><em>GameplayKit最佳实践以生成随机值</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一个共享的随机源，可用于生成随机数。 如果你不想弄乱发行版或资源，这是理想的选择。 此共享的随机对象使用arc4作为源和随机分布。 😉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sharedRandomSource = <span class="type">GKRandomSource</span>.sharedRandom()</span><br><span class="line">sharedRandomSource.nextBool() <span class="comment">// true / false</span></span><br><span class="line">sharedRandomSource.nextInt() <span class="comment">//from int min - to int max</span></span><br><span class="line">sharedRandomSource.nextInt(upperBound: <span class="number">6</span>) <span class="comment">//dice roll</span></span><br><span class="line">sharedRandomSource.nextUniform() <span class="comment">//float between 0 - 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，不建议将 <code>GameplayKit框架</code> 提供的这些随机数生成解决方案用于加密目的！</p></br><h1 id="Swift-4-2之前的随机生成方法"><a href="#Swift-4-2之前的随机生成方法" class="headerlink" title="Swift 4.2之前的随机生成方法"></a><strong>Swift 4.2之前的随机生成方法</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于历史原因，我将在这里离开此部分。 😅</p><h2 id="arc4random"><a href="#arc4random" class="headerlink" title="arc4random"></a><strong><em>arc4random</em></strong></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arc4random() % <span class="number">6</span> + <span class="number">1</span> <span class="comment">// dice roll</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个 <code>C函数</code> 在生成骰子掷骰时非常常见，但也很危险，因为它可能导致模偏差（或“孔洞原理”），这意味着某些数字的生成频率比其他数字高。 请不要使用它。 😅</p><h2 id="arc4random-uniform"><a href="#arc4random-uniform" class="headerlink" title="arc4random_uniform"></a><strong><em>arc4random_uniform</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此方法将返回均匀分布的随机数。 这是在 <code>Swift 4.2</code> 之前生成随机数的最佳/推荐方式，因为如果上限不是2的幂，它可以避免模偏差问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rndm</span><span class="params">(<span class="built_in">min</span>: Int, <span class="built_in">max</span>: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">max</span> &lt; <span class="built_in">min</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"The max value should be greater than the min value."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">min</span> == <span class="built_in">max</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>((<span class="built_in">max</span> - <span class="built_in">min</span>) + <span class="number">1</span>))) + <span class="built_in">min</span></span><br><span class="line">&#125;</span><br><span class="line">rndm(<span class="built_in">min</span>: <span class="number">1</span>, <span class="built_in">max</span>: <span class="number">6</span>) <span class="comment">//dice roll</span></span><br></pre></td></tr></table></figure><h2 id="drand48"><a href="#drand48" class="headerlink" title="drand48"></a><strong><em>drand48</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>drand48函数</code> 返回介于 <code>0到1</code> 之间的随机浮点数。它对于为随机 <code>UIColor</code> 对象生成颜色值非常有用。 另一面要注意的是，它会生成一个伪随机数序列，并且你必须使用 <code>srand48</code> 和通常是时间参数来提供种子值。 🤷‍♂️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> red = <span class="type">CGFloat</span>(drand48())</span><br><span class="line"><span class="keyword">let</span> green = <span class="type">CGFloat</span>(drand48())</span><br><span class="line"><span class="keyword">let</span> blue = <span class="type">CGFloat</span>(drand48())</span><br></pre></td></tr></table></figure><h2 id="Linux支持，glibc和rand方法"><a href="#Linux支持，glibc和rand方法" class="headerlink" title="Linux支持，glibc和rand方法"></a><strong><em>Linux支持，glibc和rand方法</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我在下面使用此代码段，以便在 <code>appleOS</code> 和 <code>linux平台</code> 上生成随机数。 我知道这并不完美，但是它为我做了工作。 🤐</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env swift</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> os(iOS) || os(tvOS) || os(macOS) || os(watchOS)</span><br><span class="line">    <span class="keyword">import</span> Darwin</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> os(<span class="type">Linux</span>)</span><br><span class="line">    <span class="keyword">import</span> Glibc</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">rndm</span><span class="params">(to <span class="built_in">max</span>: Int, from <span class="built_in">min</span>: Int = <span class="number">0</span>)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    #<span class="keyword">if</span> os(iOS) || os(tvOS) || os(macOS) || os(watchOS)</span><br><span class="line">        <span class="keyword">let</span> scale = <span class="type">Double</span>(arc4random()) / <span class="type">Double</span>(<span class="type">UInt32</span>.<span class="built_in">max</span>)</span><br><span class="line">    #endif</span><br><span class="line">    #<span class="keyword">if</span> os(<span class="type">Linux</span>)</span><br><span class="line">        <span class="keyword">let</span> scale = <span class="type">Double</span>(rand()) / <span class="type">Double</span>(<span class="type">RAND_MAX</span>)</span><br><span class="line">    #endif</span><br><span class="line">    <span class="keyword">var</span> value = <span class="built_in">max</span> - <span class="built_in">min</span></span><br><span class="line">    <span class="keyword">let</span> maximum = value.addingReportingOverflow(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> maximum.overflow &#123;</span><br><span class="line">        value = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        value = maximum.partialValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> partial = <span class="type">Int</span>(<span class="type">Double</span>(value) * scale)</span><br><span class="line">    <span class="keyword">let</span> result = partial.addingReportingOverflow(<span class="built_in">min</span>)</span><br><span class="line">    <span class="keyword">if</span> result.overflow &#123;</span><br><span class="line">        <span class="keyword">return</span> partial</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.partialValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rndm(to: <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>现在我们已经有了 <code>Swift 4.2</code> ，我想鼓励大家改编新的随机数生成 API方法 。 我非常高兴 <code>苹果公司和社区</code> 能够很好地解决这个问题，结果令人赞叹！ 👏👏👏</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> random </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> random </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift Grand Central Dispatch 深入实践</title>
      <link href="/Swift%20Grand%20Central%20Dispatch%20%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"/>
      <url>/Swift%20Grand%20Central%20Dispatch%20%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解 <code>Swift</code> 中 <code>GCD框架</code> 的 <code>多线程原理</code> 。 我保证，将所有需要的 <code>队列</code> ， <code>任务</code> ， <code>组</code> 进行分组。</p></br><h1 id="适用于初学者的GCD并发教程"><a href="#适用于初学者的GCD并发教程" class="headerlink" title="适用于初学者的GCD并发教程"></a><strong>适用于初学者的GCD并发教程</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://developer.apple.com/documentation/dispatch" target="_blank" rel="noopener"><strong><em><code>Grand Central Dispatch （GCD，或仅调度）</code></em></strong></a>框架基于基础 <code>线程池设计模式</code> 。 这意味着系统会生成固定数量的线程-基于某些因素（例如 <code>CPU内核</code> ），它们始终可用，等待任务同时执行。 🚦</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在运行时创建线程是一项昂贵的任务，因此 <a href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1" target="_blank" rel="noopener"><strong><em><code>GCD</code></em></strong></a> 会将任务组织到特定队列中，稍后，将在池中适当且可用的线程上执行等待这些队列中的任务。 这种方法导致了出色的性能和较低的执行延迟。 我们可以说 <a href="https://www.swiftbysundell.com/posts/a-deep-dive-into-grand-central-dispatch-in-swift" target="_blank" rel="noopener"><strong><em><code>Dispatch框架</code></em></strong></a> 是一个非常快速，高效的并发框架，专为现代多核硬件和需求而设计。</p><a id="more"></a></br><h1 id="并发，多任务，CPU内核，并行性和线程"><a href="#并发，多任务，CPU内核，并行性和线程" class="headerlink" title="并发，多任务，CPU内核，并行性和线程"></a><strong>并发，多任务，CPU内核，并行性和线程</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理器可以以编程方式运行你执行的任务，通常称为编码，开发或编程。  <code>CPU内核</code> 执行的代码是线程。因此，你的应用程序将创建一个由线程组成的进程。 🤓</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过去，处理器只有一个内核，一次只能处理一个任务。稍后引入了 <code>时间片</code> ，因此 <code>CPU</code> 可以使用上下文切换并发执行线程。随着时间的流逝，处理器获得了更多的功能和内核，因此它们能够使用并行机制实现真正的多任务处理。 ⏱</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今， <code>CPU</code> 是一个功能非常强大的单元，它每秒能够执行数十亿个任务（周期）。由于这种 <code>高可用性速度</code> ，英特尔引入了一种称为超线程的技术。他们将 <code>CPU时钟周期</code> 划分为同时运行的（通常是两个）进程之间的时间，因此可用线程的数量实际上增加了一倍。 📈</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，并发执行可以通过各种技术来实现，但是你不必太在意。如何解决并发性取决于 <code>CPU体系结构</code> ，操作系统的任务是为底层线程池产生多少线程。  <code>GCD框架</code> 将隐藏所有复杂性，但是了解基本原理始终是一件好事。 👍</p></br><h1 id="同步和异步执行"><a href="#同步和异步执行" class="headerlink" title="同步和异步执行"></a><strong>同步和异步执行</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个工作项都可以 <code>同步或异步执行</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你听说过 <code>阻塞代码</code> 和 <code>非阻塞代码</code> 吗？ 这是这里相同的情景。 使用同步任务，你将阻止执行队列，但是使用异步任务，你的调用将立即返回，并且队列可以继续执行其余任务（或Apple调用的工作项）。 🚧</p><h2 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a><strong><em>同步执行</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当工作项与 <code>sync方法</code> 同步执行时，程序将等到执行完成后再返回方法调用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果函数具有返回值，则它很可能是同步的，因此 <code>func load() -&gt; String</code> 可能会阻塞正在运行的代码，直到资源完全加载并返回。</p><h2 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a><strong><em>异步执行</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当使用 <code>async方法</code> 异步执行工作项时，该方法调用立即返回。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Completion blocks</code> 是异步方法的很好选择，例如，如果你查看此方法 <code>func load（completion：（String）-&gt; Void）</code>，则可以看到它没有返回类型，但是函数的结果通过 <code>Block</code> 返回 <code>(Block 回调)</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个典型的用例，如果你必须等待方法内部的某些事情（例如，从磁盘读取大文件的内容），则不希望由于 <code>IO操作</code> 缓慢而 <code>阻塞CPU</code> 。 在系统从物理硬盘驱动器中读取文件时，可能还会执行其他任务，而这些任务根本不会占用 <code>大量IO</code> （算术运算等）。 💾</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>分派队列</code> ，你可以同步或异步执行代码。 同步执行时，队列等待工作，异步执行时，代码立即返回，而无需等待任务完成。 ⚡️</p></br><h1 id="Dispatch-queues"><a href="#Dispatch-queues" class="headerlink" title="Dispatch queues"></a><strong>Dispatch queues</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我之前提到的， <code>GCD</code> 将 <code>任务组织成队列</code> ，就像在购物中心的队列一样。 在每个调度队列上，将按照将任务添加到队列中的相同顺序执行任务- <code>FIFO</code> ：该行中的第一个任务将首先执行-但你应注意，不能保证完成的顺序。 任务将根据代码复杂度完成。 因此，如果你将两个任务添加到队列中，先是慢任务，然后是快任务，则快任务可以在慢任务之前完成。 ⌛️</p><h2 id="串行和并发队列"><a href="#串行和并发队列" class="headerlink" title="串行和并发队列"></a><strong><em>串行和并发队列</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有两种类型的调度队列。  <code>串行队列</code> 可以一次执行一个任务，这些队列可用于同步对特定资源的访问。 另一方面， <code>并发队列</code> 可以同时并行执行一个或多个任务。  <code>串行队列</code> 就像商场中只有一个收银员的一条生产线， 并发队列 就像是一条拆分成两个或更多收银员的单条生产线。 💰</p><h2 id="主队列，全局队列和定制队列"><a href="#主队列，全局队列和定制队列" class="headerlink" title="主队列，全局队列和定制队列"></a><strong><em>主队列，全局队列和定制队列</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>主队列</code> 是一个 <code>串行队列</code> ， <code>主队列</code> 上的每个任务都在 <code>主线程</code> 上运行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>全局队列</code> 是系统提供的通过操作系统共享的 <code>并发队列</code> 。 恰好有四个按高优先级，默认优先级，低优先级以及 <code>IO限制</code> 的后台队列进行组织。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>定制队列</code> 可以由用户创建。 通过指定 <code>服务质量属性（QoS）</code> ， <code>自定义并发队列</code> 始终映射到全局队列之一。 在大多数情况下，如果要并行运行任务，建议使用 <code>全局并发队列</code> 之一，则应仅创建 <code>自定义串行队列</code> 。</p><h2 id="系统提供的队列"><a href="#系统提供的队列" class="headerlink" title="系统提供的队列"></a><strong><em>系统提供的队列</em></strong></h2><ul><li>Serial main queue</li><li>Concurrent global queues</li><li>high priority global queue</li><li>default priority global queue</li><li>low priority global queue</li><li>global background queue (io throttled)</li></ul><h2 id="按服务质量定制队列"><a href="#按服务质量定制队列" class="headerlink" title="按服务质量定制队列"></a><strong><em>按服务质量定制队列</em></strong></h2><ul><li><strong>userInteractive</strong> (UI updates) -&gt; serial main queue</li><li><strong>userInitiated</strong> (async UI related tasks) -&gt; high priority global queue</li><li><strong>default</strong> -&gt; default priority global queue</li><li><strong>utility</strong> -&gt; low priority global queue</li><li><strong>background</strong> -&gt; global background queue</li><li><strong>unspecified</strong> (lowest) -&gt; low priority global queue</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从理论上已经足够，让我们看看如何在实际中使用 <code>Dispatch框架</code> ！ 🎬</p></br><h1 id="如何在Swift中使用DispatchQueue类？"><a href="#如何在Swift中使用DispatchQueue类？" class="headerlink" title="如何在Swift中使用DispatchQueue类？"></a><strong>如何在Swift中使用DispatchQueue类？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是使用 <code>Swift 3</code> 提供的全新 <code>GCD语法</code> 从上方获取所有队列的方法。请注意，除非要使用 <code>并发队列</code> ，否则应始终使用 <code>全局并发队列</code> 而不是创建自己的 <code>全局并发队列</code> 。 通过 <code>barriers</code> 进行锁定以实现 <a href="http://basememara.com/creating-thread-safe-arrays-in-swift/" target="_blank" rel="noopener"><strong><em><code>线程安全</code></em></strong></a> ，稍后再进行介绍。 😳</p><h2 id="如何获得队列？"><a href="#如何获得队列？" class="headerlink" title="如何获得队列？"></a><strong><em>如何获得队列？</em></strong></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Dispatch</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.main</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .userInitiated)</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .userInteractive)</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .background)</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .<span class="keyword">default</span>)</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .utility)</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .unspecified)</span><br><span class="line"><span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.serial"</span>)</span><br><span class="line"><span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.concurrent"</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在任务完成后，在 <code>后台队列</code> 上执行任务并更新 <code>主队列</code> 上的 <code>UI</code> 是使用 <code>Dispatch队列</code> 非常容易的一项。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global(qos: .background).async &#123;</span><br><span class="line">    <span class="comment">// do your job here</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="comment">// update ui here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在队列上同步和异步调用"><a href="#在队列上同步和异步调用" class="headerlink" title="在队列上同步和异步调用"></a><strong><em>在队列上同步和异步调用</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列上的 <code>同步和异步方法</code> 之间没有太大区别。  <code>Sync</code> 只是一个带有信号量（稍后说明）的异步调用，该信号量等待返回值。 同步呼叫将被阻止，另一方面，异步呼叫将立即返回。 🎉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = q.sync &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this will block"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"></span><br><span class="line">q.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"this will return instantly"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本上，如果你需要返回值，请使用 sync ，但在其他所有情况下，请使用 async 。 <strong>死锁警告</strong>：<strong><em>永远不要在主队列上调用同步，因为它会导致死锁和崩溃。</em></strong> 如果你正在寻找一种在 <code>主队列/线程上</code> 进行 <code>同步调用</code> 的安全方法，则可以使用此代码段。 👌</p><p><strong><em><code>不要从串行队列的线程在串行队列上调用sync！</code></em></strong></p><h2 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a><strong><em>延迟执行</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <code>Dispatch框架</code> 简单地延迟代码执行。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + .seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="comment">//this code will be executed only after 2 seconds have been passed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行并发循环"><a href="#执行并发循环" class="headerlink" title="执行并发循环"></a><strong><em>执行并发循环</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>调度队列</code> 仅允许你同时执行迭代。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">5</span>) &#123; (i) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a><strong><em>Debugging</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哦，顺便说一句，它仅用于调试目的，但是你可以使用此扩展名来返回当前队列的名称。 不要在生产代码中使用！！！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DispatchQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> currentLabel: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(validatingUTF8: __dispatch_queue_get_label(<span class="literal">nil</span>))!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print(DispatchQueue.currentLabel)</span></span><br></pre></td></tr></table></figure></br><h1 id="在Swift中使用DispatchWorkItem"><a href="#在Swift中使用DispatchWorkItem" class="headerlink" title="在Swift中使用DispatchWorkItem"></a><strong>在Swift中使用DispatchWorkItem</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DispatchWorkItem</code> 封装了可以执行的工作。 可以将工作项目分派到 <code>DispatchQueue</code> 上和 <code>DispatchGroup</code> 中。 也可以将 <code>DispatchWorkItem</code> 设置为 <code>DispatchSource</code> 事件，注册或取消处理程序。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，就像使用工作项进行操作一样，你可以取消正在运行的任务。 工作项也可以在任务完成时通知队列。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> workItem: <span class="type">DispatchWorkItem?</span></span><br><span class="line">workItem = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">6</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> item = workItem, !item.isCancelled <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"cancelled"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workItem?.notify(queue: .main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.global().asyncAfter(deadline: .now() + .seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">    workItem?.cancel()</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.main.async(execute: workItem!)</span><br><span class="line"><span class="comment">// you can use perform to run on the current queue instead of queue.async(execute:)</span></span><br><span class="line"><span class="comment">//workItem?.perform()</span></span><br></pre></td></tr></table></figure></br><h1 id="与-DispatchGroups-并发的任务"><a href="#与-DispatchGroups-并发的任务" class="headerlink" title="与 DispatchGroups 并发的任务"></a><strong>与 DispatchGroups 并发的任务</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，你需要执行多个网络调用以构造视图控制器所需的数据？ 这是 <code>DispatchGroup</code> 可以为你提供帮助的地方。 你所有长时间运行的后台任务都可以同时执行，当一切准备就绪时，你会收到通知。 请注意，你必须使用线程安全的数据结构，因此请务必在同一线程上修改数组！ 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(delay: UInt32, completion: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    sleep(delay)</span><br><span class="line">    completion()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">load(delay: <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">load(delay: <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">load(delay: <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，你始终必须在该组上平衡 进入 和 离开 调用。 调度组还使我们能够跟踪不同工作项的完成情况，即使它们在不同队列中运行也是如此。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.serial"</span>)</span><br><span class="line"><span class="keyword">let</span> workItem = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"start"</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async(group: group) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"group start"</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"group end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.global().async(group: group, execute: workItem)</span><br><span class="line"></span><br><span class="line"><span class="comment">// you can block your current queue and wait until the group is ready</span></span><br><span class="line"><span class="comment">// a better way is to use a notification block instead of blocking</span></span><br><span class="line"><span class="comment">//group.wait(timeout: .now() + .seconds(3))</span></span><br><span class="line"><span class="comment">//print("done")</span></span><br><span class="line"></span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用调度组进行的另一件事：假设你在执行一些实际工作时正在显示动画效果很好的加载指示器。 可能发生的是工作完成得比你预期的快，并且指示符动画无法完成。 为了解决这种情况，你可以添加一个小的延迟任务，以便小组等待直到两个任务都完成。 😎</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">    queue.async(group: group) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(i): Running async task..."</span>)</span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(i): Async task completed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">group.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure></br><h1 id="信号量-Semaphores"><a href="#信号量-Semaphores" class="headerlink" title="信号量(Semaphores)"></a><strong>信号量(Semaphores)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>信号量</code>只是一个变量，用于处理并发系统中的资源共享。 这是一个非常强大的对象，下面是 <code>Swift</code> 中的一些重要示例。</p><h2 id="如何使异步任务同步？"><a href="#如何使异步任务同步？" class="headerlink" title="如何使异步任务同步？"></a><strong><em>如何使异步任务同步？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案很简单，你可以使用信号量！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DispatchError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> timeout</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asyncMethod</span><span class="params">(completion: <span class="params">(String)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    completion(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syncMethod</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String?</span></span><br><span class="line">    queue.async &#123;</span><br><span class="line">        asyncMethod &#123; r <span class="keyword">in</span></span><br><span class="line">            response = r</span><br><span class="line">            semaphore.signal()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    semaphore.wait(timeout: .now() + <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> result = response <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">DispatchError</span>.timeout</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">try</span>? syncMethod()</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><h2 id="锁定-单次访问资源"><a href="#锁定-单次访问资源" class="headerlink" title="锁定/单次访问资源"></a><strong><em>锁定/单次访问资源</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想避免 <code>race condition</code> 问题，则可能要使用互斥。 这可以通过使用信号量对象来实现，但是如果你的对象需要大量读取功能，则应考虑基于 <code>dispatch barrier</code> 的解决方案。 😜</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockedNumbers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> elements: [<span class="type">Int</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> num: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.semaphore.wait(timeout: <span class="type">DispatchTime</span>.distantFuture)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"appended: \(num)"</span>)</span><br><span class="line">        <span class="keyword">self</span>.elements.append(num)</span><br><span class="line">        <span class="keyword">self</span>.semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeLast</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.semaphore.wait(timeout: <span class="type">DispatchTime</span>.distantFuture)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.semaphore.signal()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> !<span class="keyword">self</span>.elements.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="keyword">self</span>.elements.removeLast()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"removed: \(num)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> items = <span class="type">LockedNumbers</span>()</span><br><span class="line">items.append(<span class="number">1</span>)</span><br><span class="line">items.append(<span class="number">2</span>)</span><br><span class="line">items.append(<span class="number">5</span>)</span><br><span class="line">items.append(<span class="number">3</span>)</span><br><span class="line">items.removeLast()</span><br><span class="line">items.removeLast()</span><br><span class="line">items.append(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(items.elements)</span><br></pre></td></tr></table></figure><h2 id="等待多个任务完成"><a href="#等待多个任务完成" class="headerlink" title="等待多个任务完成"></a><strong><em>等待多个任务完成</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像调度组一样，如果多个任务完成，你还可以使用信号量对象来获得通知。 你只需要等待…</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">    queue.async &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"run \(i)"</span>)</span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"wait"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed \(i)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure><h2 id="使用信号量批量执行"><a href="#使用信号量批量执行" class="headerlink" title="使用信号量批量执行"></a><strong><em>使用信号量批量执行</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以创建类似于行为的线程池，以使用调度信号量来模拟有限的资源。 因此，例如，如果你想从服务器下载大量图像，则可以每次运行一批。 非常方便。 🖐</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"start"</span>)</span><br><span class="line"><span class="keyword">let</span> sem = <span class="type">DispatchSemaphore</span>(value: <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        sem.wait()</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        sem.signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"end"</span>)</span><br></pre></td></tr></table></figure></br><h1 id="DispatchSource对象"><a href="#DispatchSource对象" class="headerlink" title="DispatchSource对象"></a><strong>DispatchSource对象</strong></h1><p><strong><em><code>调度源是一种基本数据类型，可协调特定底层系统事件的处理。</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信号，描述符，进程，端口，计时器等。 一切都通过 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html" target="_blank" rel="noopener"><strong><em><code>调度源</code></em></strong></a> 对象处理。 我真的不想深入细节，这是相当底层的东西。 你可以使用调度源监视文件，端口，信号。 请只阅读苹果官方文档。 📄</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我只想在此使用 <a href="https://www.cocoawithlove.com/blog/2016/07/30/timer-problems.html" target="_blank" rel="noopener"><strong><em><code>调度源计时器</code></em></strong></a> 来举例说明。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer = <span class="type">DispatchSource</span>.makeTimerSource()</span><br><span class="line">timer.schedule(deadline: .now(), repeating: .seconds(<span class="number">1</span>))</span><br><span class="line">timer.setEventHandler &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line">timer.resume()</span><br></pre></td></tr></table></figure></br><h1 id="使用调度框架的线程安全"><a href="#使用调度框架的线程安全" class="headerlink" title="使用调度框架的线程安全"></a><strong>使用调度框架的线程安全</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果涉及多线程代码，则 <a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8" target="_blank" rel="noopener"><strong><em><code>线程安全性</code></em></strong></a> 是不可避免的主题。 在开始时，我提到在GCD的内部有一个线程池。 每个线程都有一个与之关联的运行循环对象，你甚至可以手动运行它们。 如果手动创建线程，则会将运行循环自动添加到该线程。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="type">Thread</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.current.name ?? <span class="string">""</span>)</span><br><span class="line">     <span class="keyword">let</span> timer = <span class="type">Timer</span>(timeInterval: <span class="number">1</span>, repeats: <span class="literal">true</span>) &#123; t <span class="keyword">in</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">"tick"</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">RunLoop</span>.current.add(timer, forMode: .defaultRunLoopMode)</span><br><span class="line"></span><br><span class="line">    <span class="type">RunLoop</span>.current.run()</span><br><span class="line">    <span class="type">RunLoop</span>.current.run(mode: .commonModes, before: <span class="type">Date</span>.distantPast)</span><br><span class="line">&#125;</span><br><span class="line">t.name = <span class="string">"my-thread"</span></span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">//RunLoop.current.run()</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你不应该这样做，仅出于演示目的，请始终使用 <code>GCD队列</code> ！</p><h2 id="Queue-Thread"><a href="#Queue-Thread" class="headerlink" title="Queue != Thread"></a><strong><em>Queue != Thread</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>GCD队列</code> 不是线程，如果你在并发队列上运行多个异步操作，则代码可以在满足需求的任何可用线程上运行。</p><p><strong><em><code>线程安全就是要避免混乱的变量状态</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象一下 <code>Swift</code> 中的可变数组。 可以从任何线程进行修改。 那不是很好，因为如果数组不是线程安全的，最终其中的值将像地狱一样被弄乱。 例如，多个线程试图将值插入数组。 怎么了？ 如果它们并行运行，将首先添加哪个元素？ 现在，这就是为什么有时需要创建线程安全资源的原因。</p><h2 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a><strong><em>串行队列</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <code>串行队列</code> 强制执行 <code>互斥</code> 。 队列中的所有任务将连续运行（以 <code>FIFO顺序</code> ），一次仅运行一个进程，任务必须互相等待。 解决方案的一大缺点是 <code>速度</code> 。 🐌</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q = <span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.serial"</span>)</span><br><span class="line"></span><br><span class="line">q.async() &#123;</span><br><span class="line">  <span class="comment">// writes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q.sync() &#123;</span><br><span class="line">  <span class="comment">// reads</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-barriers-的并发队列"><a href="#使用-barriers-的并发队列" class="headerlink" title="使用 barriers 的并发队列"></a><strong><em>使用 barriers 的并发队列</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果为异步方法提供了额外的标志，则可以将 <code>barriers</code> 任务发送到队列。 如果这样的任务到达队列，它将确保在 <code>barriers</code> 任务完成之前不会执行任何其他操作。 综上所述， <code>barriers</code> 任务是并发队列的同步（点）任务。 使用异步 <code>barriers</code> 进行写入，使用同步块进行读取。 😎</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q = <span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.concurrent"</span>, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line">q.async(flags: .barrier) &#123;</span><br><span class="line">  <span class="comment">// writes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q.sync() &#123;</span><br><span class="line">  <span class="comment">// reads</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在线程安全的环境中，此方法将导致读取速度极快。 你还可以使用串行队列，信号量，锁定它们都取决于你当前的情况。 🤐</p></br><h1 id="一些反模式"><a href="#一些反模式" class="headerlink" title="一些反模式"></a><strong>一些反模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你必须非常小心 <a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81" target="_blank" rel="noopener"><strong><em><code>死锁</code></em></strong></a> ， <a href="https://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3" target="_blank" rel="noopener"><strong><em><code>竞态条件</code></em></strong></a> 和 <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem" target="_blank" rel="noopener"><strong><em><code>读者作家</code></em></strong></a> 的问题。 通常在串行队列上调用 <code>sync方法</code> 会给你带来很多麻烦。 另一个问题是 <code>线程安全性</code> ，但是我们已经介绍了该部分。 😉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.serial"</span>)</span><br><span class="line"></span><br><span class="line">queue.sync &#123;</span><br><span class="line">    <span class="comment">// do some sync work</span></span><br><span class="line">    queue.sync &#123;</span><br><span class="line">        <span class="comment">// this won't be executed -&gt; deadlock!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//What you are trying to do here is to launch the main thread synchronously from a background thread before it exits. This is a logical error.</span></span><br><span class="line"><span class="comment">//https://stackoverflow.com/questions/49258413/dispatchqueue-crashing-with-main-sync-in-swift?rq=1</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .utility).sync &#123;</span><br><span class="line">    <span class="comment">// do some background task</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line">        <span class="comment">// app will crash</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你必须非常小心 <a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81" target="_blank" rel="noopener"><strong><em><code>死锁</code></em></strong></a> ， <a href="https://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3" target="_blank" rel="noopener"><strong><em><code>竞态条件</code></em></strong></a> 和 <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem" target="_blank" rel="noopener"><strong><em><code>读者作家</code></em></strong></a> 的问题。 通常在串行队列上调用 <code>sync方法</code> 会给你带来很多麻烦。 另一个问题是 <code>线程安全性</code> ，但是我们已经介绍了该部分。 😉<br> <code>Dispatch框架</code> （又名GCD）是一个了不起的框架，它具有如此巨大的潜力，并且确实需要一些时间来掌握它。 真正的问题是，为了将并发编程提升到一个全新的高度，苹果将采取什么道路？ 承诺或等待，也许是全新的东西，希望我们能在 <code>Swift 6</code> 中看到一些东西。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Grand Central Dispatch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Grand Central Dispatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS如何使用iCloud文档？</title>
      <link href="/iOS%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8iCloud%E6%96%87%E6%A1%A3%EF%BC%9F/"/>
      <url>/iOS%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8iCloud%E6%96%87%E6%A1%A3%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用最新版本的 <code>Swift编程语言</code> 通过共享的 <code>iCloud驱动器文件夹</code> 同步文件和数据。</p></br><h1 id="iCloud驱动器项目设置教程"><a href="#iCloud驱动器项目设置教程" class="headerlink" title="iCloud驱动器项目设置教程"></a><strong>iCloud驱动器项目设置教程</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从为 <code>iOS</code> 创建一个新项目开始。 你可以选择单视图应用程序模板，不必太担心基于文档的应用程序，因为在本教程中，我们根本不会涉及 <code>UIDocument类</code> 。 🤷‍♂️</p><a id="more"></a><p><img src="http://q8wtfza4q.bkt.clouddn.com/iu-stp1.png" alt="UIDocument类"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步是启用 <code>iCloud功能</code> ，它将为你生成一个新的权利文件。 另外，你还必须在 <code>Apple开发者网站</code> 上为 <code>appID启用</code> <code>iCloud应用程序服务</code> 。 你还应该分配将用于存储数据的 <code>iCloud容器</code> 。 只需单击几下，但你必须手动执行此操作。 💩</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你需要有效的 <code>Apple Developer Program</code> 成员身份才能设置高级应用程序功能，例如 <code>iCloud支持</code> 。 因此，你必须每年支付$99。 🤑</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/iu-stp2.png" alt="UIDocument类"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，我相信现在你已经有了启用 <code>iCloud功能</code> 和应用程序服务的正确的 <code>iOS应用程序标识符</code> 。 下一步是最后一步，你必须将这几行添加到 <code>Info.plist</code> 文件中，以便定义要使用的 <code>iCloud驱动器容器（文件夹名称）</code> 。 请注意，一个应用程序可以有多个容器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;<span class="type">NSUbiquitousContainers</span>&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;iCloud.com.tiborbodecs.teszt&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;<span class="type">NSUbiquitousContainerIsDocumentScopePublic</span>&lt;/key&gt;</span><br><span class="line">        &lt;<span class="literal">true</span>/&gt;</span><br><span class="line">        &lt;key&gt;<span class="type">NSUbiquitousContainerName</span>&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;<span class="type">Teszt</span>&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;<span class="type">NSUbiquitousContainerSupportedFolderLevels</span>&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;<span class="type">Any</span>&lt;/string&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我们准备继续进行一些实际的编码。 💻</p><br><h1 id="iCloud-drive-容器中的文件"><a href="#iCloud-drive-容器中的文件" class="headerlink" title="iCloud drive 容器中的文件"></a><strong>iCloud drive 容器中的文件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>Swift</code> 使用 <code>iCloud文件</code> 相对容易。 基本上，你只需要获取 <code>iCloud驱动器</code> 容器的基本 <code>URL</code> ，就可以做任何你想做的事情。 🤔但是，我将向你展示一些最佳做法和技巧。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，你必须检查你的容器文件夹是否已经存在，如果不存在，则应使用 <code>FileManager类</code> 手动创建它。 我还为容器基本 <code>URL</code> 设置了“快捷方式”变量，因此我不必再次写所有这些长单词。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> containerUrl: <span class="type">URL?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.url(forUbiquityContainerIdentifier: <span class="literal">nil</span>)?.appendingPathComponent(<span class="string">"Documents"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// check for container existence</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> url = <span class="keyword">self</span>.containerUrl, !<span class="type">FileManager</span>.<span class="keyword">default</span>.fileExists(atPath: url.path, isDirectory: <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.createDirectory(at: url, withIntermediateDirectories: <span class="literal">true</span>, attributes: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>iCloud驱动器</code> 容器内的路径很简单，你可以将路径组件附加到基本 <code>URL</code> 并根据需要使用该确切的 <code>位置URL</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDocumentUrl = <span class="keyword">self</span>.containerUrl?</span><br><span class="line">        .appendingPathComponent(subDirectory)</span><br><span class="line">        .appendingPathComponent(fileName)</span><br><span class="line">        .appendingPathExtension(fileExtension)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择现有文件也非常简单。 你可以使用 <code>UIKit</code> 中的内置文档选择器类。 这里只有两个 <code>catches</code> 。 🤦‍♂️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，你需要提供要访问的文档的类型。 你听说过 <a href="https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_intro/understand_utis_intro.html#//apple_ref/doc/uid/TP40001319-CH201-SW1" target="_blank" rel="noopener"><strong><em><code>UTI</code></em></strong></a> 吗？ 事实是，你必须为每种文件类型找到合适的 <code>统一类型标识符</code> ，而不是提供扩展名或 <code>mime-type</code> 或一些常用的东西。 🧠</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> picker = <span class="type">UIDocumentPickerViewController</span>(documentTypes: [<span class="string">"public.json"</span>], <span class="keyword">in</span>: .<span class="keyword">open</span>)</span><br><span class="line">picker.delegate = <span class="keyword">self</span></span><br><span class="line">picker.modalPresentationStyle = .fullScreen</span><br><span class="line"><span class="keyword">self</span>.present(picker, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个要点是，在开始读取所选文件之前，你必须对其进行 <code>“解锁”</code> 。 可以通过调用 <code>startAccessingSecurityScopedResource</code> 方法来完成。 不要忘记调用 <code>stopAccessingSecurityScopedResource</code> 方法，否则事情将变得不平衡。 你不要那个，相信我！ 🧤</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">documentPicker</span><span class="params">(<span class="number">_</span> controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL])</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span></span><br><span class="line">        controller.documentPickerMode == .<span class="keyword">open</span>,</span><br><span class="line">        <span class="keyword">let</span> url = urls.first,</span><br><span class="line">        url.startAccessingSecurityScopedResource()</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        url.stopAccessingSecurityScopedResource()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do some work with the url</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他一切都按你的预期工作。 你可以通过 <code>文件API</code> 或使用 <code>UIDocumentPickerViewController</code> 实例将文件直接保存到容器中。 这是一些最常见的 <code>api调用</code> ，可用于处理文件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">try</span> string.write(to: url, atomically: <span class="literal">true</span>, encoding: .utf8)</span><br><span class="line"><span class="keyword">try</span> <span class="type">String</span>(contentsOf: url)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="keyword">try</span> data.write(to: url, options: [.atomic])</span><br><span class="line"><span class="keyword">try</span> <span class="type">Data</span>(contentsOf: url)</span><br><span class="line"></span><br><span class="line"><span class="comment">// file manager</span></span><br><span class="line"><span class="type">FileManager</span>.<span class="keyword">default</span>.copyItem(at: local, to: url)</span><br><span class="line"><span class="type">FileManager</span>.<span class="keyword">default</span>.removeItem(at: url)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以读写任何类型的字符串，数据。 通过使用 <code>FileManager</code> ，你可以复制，移动，删除项目或更改文件属性。 你存储在 <code>iCloud驱动器</code> 中的所有文档都可以在每台设备上使用。 显然，你必须使用 <code>iCloud帐户登录</code> ，并具有足够的免费存储空间。 💰</p><br><h1 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a><strong>Debugging</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你更改设置中的某些内容，则可能还需要增加内部版本号，以便将更改通知操作系统。 💡</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Mac</code> 上，所有 <code>iCloud驱动器文件/容器</code> 都位于 <code>Mobile Documents</code> 目录内用户的 <code>Library文件夹</code> 下。 你只需使用 <code>Terminal</code> 或 <code>Finder</code> 到那里并列出所有文件即可。 专业提示：寻找隐藏的东西！ 😉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Library/Mobile\ Documents</span><br><span class="line">ls -la</span><br><span class="line"><span class="comment"># ls -la|grep tiborbodecs</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以通过使用以下命令来监视 <code>CloudDocs</code> 守护程序的活动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># man brctl</span></span><br><span class="line">brctl <span class="built_in">log</span> --<span class="built_in">wait</span> --shorten</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出日志将告诉你同步期间实际发生的情况。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/iu-stp3.png" alt="UIDocument类"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我建议你检查 <code>brctl</code> 命令的手动输入，因为还有其他一些标志可以调试问题更加容易。 🤐</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> iCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> iCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>appleOS的Networking示例</title>
      <link href="/appleOS%E7%9A%84Networking%E7%A4%BA%E4%BE%8B/"/>
      <url>/appleOS%E7%9A%84Networking%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何将 <code>Bonjour</code> 与 <code>UDP/TCP套接字</code>， <code>streams</code> 一起使用，以及如何通过 <code>CoreBluetooth</code> 或 <code>watch API</code> 进行通信。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想学习如何使用 <a href="https://help.dyn.com/bonjour-and-dns-discovery/" target="_blank" rel="noopener"><strong><em><code>Bonjour</code></em></strong></a> 发现服务在设备之间 <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/UsingSocketsandSocketStreams.html#//apple_ref/doc/uid/CH73-SW2" target="_blank" rel="noopener"><strong><em><code>建立网络连接</code></em></strong></a> ，那么你来对地方了。 在这篇文章中，我将向你展示基础知识，例如，你将能够从 <code>手表</code> 或 <code>iOS设备</code> 制作遥控器，以便将数据直接发送到任何 <code>tvOS</code> 或 <code>macOS</code> 机器。</p><a id="more"></a></br><h1 id="多平台开发"><a href="#多平台开发" class="headerlink" title="多平台开发"></a><strong>多平台开发</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要创建支持多个平台的应用程序，则可能要针对 <code>macOS</code> ， <code>iOS</code> ， <code>watchOS</code> ， <code>tvOS</code> 以及 <code>Linux</code> 。 下面的代码段将帮助你检测正在使用的当前平台。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(iOS)</span><br><span class="line">    <span class="keyword">let</span> platform = <span class="string">"iOS"</span></span><br><span class="line">#elseif os(macOS)</span><br><span class="line">    <span class="keyword">let</span> platform = <span class="string">"macOS"</span></span><br><span class="line">#elseif os(watchOS)</span><br><span class="line">    <span class="keyword">let</span> platform = <span class="string">"watchOS"</span></span><br><span class="line">#elseif os(tvOS)</span><br><span class="line">    <span class="keyword">let</span> platform = <span class="string">"tvOS"</span></span><br><span class="line">#elseif os(<span class="type">Linux</span>)</span><br><span class="line">    <span class="keyword">let</span> platform = <span class="string">"linux"</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    <span class="keyword">let</span> platform = <span class="string">"unknown"</span></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(platform)</span><br></pre></td></tr></table></figure></br><h1 id="Network-connection-101"><a href="#Network-connection-101" class="headerlink" title="Network connection 101"></a><strong>Network connection 101</strong></h1><h2 id="Bonjour发现服务"><a href="#Bonjour发现服务" class="headerlink" title="Bonjour发现服务"></a><strong><em>Bonjour发现服务</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Bonjour</code> ，也称为零配置网络，可使用 <code>行业标准IP协议</code> 在局域网上自动发现设备和服务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，基本上，你可以使用 <a href="https://www.eltima.com/dev/post/99996366184/using-bonjour-in-swift" target="_blank" rel="noopener"><strong><em><code>Bonjour</code></em></strong></a> 在本地网络上找到网络设备。 如果你想弄清楚连接到 <code>LAN的设备列表</code> ，这将非常方便。 使用 <code>NetService类</code> 将帮助你检测具有它们支持的可用服务的所有设备。 整个 <code>Bonjour API</code> 相对较小且编写良好。 从服务器方面，你只需创建 <code>NetService对象</code>  ，并通过 <code>NetServiceDelegate监听</code> 传入的连接。</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你必须与所有设备/模拟器都在同一WiFi网络上。</p></blockquote><h2 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a><strong><em>TCP 连接</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>TCP</code> 在通过 <code>IP网络</code> 进行通信的主机上运行的应用程序之间，提供可靠，有序且经过错误检查的八位位组（字节）流交付。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;借助 <a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener"><strong><em><code>TCP</code></em></strong></a> ，你可以建立可靠的网络连接。  Foundation 中有一个 Stream类 ，可帮助你在设备之间来回发送数据。 如果你具有可以正常使用的 NetServiceDelegate 连接形式，则只需侦听流事件以通过 StreamDelegate 处理传入数据。 我不想详细介绍，只需下载 <a href="https://gitlab.com/theswiftdev/networking-for-appleos" target="_blank" rel="noopener"><strong><em><code>示例代码</code></em></strong></a> 并亲自检查一下即可。</p><h2 id="UDP-连接"><a href="#UDP-连接" class="headerlink" title="UDP 连接"></a><strong><em>UDP 连接</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <a href="https://developer.apple.com/library/archive/samplecode/UDPEcho/Listings/Read_Me_About_UDPEcho_txt.html" target="_blank" rel="noopener"><strong><em><code>UDP</code></em></strong></a> ，计算机应用程序可以将消息（在这种情况下称为数据报）发送到 <code>Internet协议（IP）网络</code> 上的其他主机。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果查看有关 <a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener"><strong><em><code>UDP</code></em></strong></a> 的文章，你会清楚地看到与 <code>TCP</code> 的主要区别在于该协议不能保证你数据传输的安全。 数据可能无序到达或重复到达，这是处理这些情况的任务，但是 <code>UDP</code> 很快。 如果要构建文件传输应用程序，则绝对应该使用 <code>TCP</code> ，但是例如控制实时动作游戏 <code>UDP</code> 就足够了。</p><h2 id="CocoaAsyncSocket"><a href="#CocoaAsyncSocket" class="headerlink" title="CocoaAsyncSocket"></a><strong><em>CocoaAsyncSocket</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个库非常好用，对于所有想快速建立网络连接的人来说，它可能是最好的选择，因为与实现委托相比，它所需的代码更少。 当然，你仍然需要在整个内容上方添加 <code>Bonjour层</code> ，但这很好。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你使用的是 <a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener"><strong><em><code>CocoaAsyncSocket</code></em></strong></a> ，你会发现该 <code>API</code> 很简单，只有5分钟后，我才能相对容易地了解发生了什么，并且能够通过网络发送消息。 它支持所有 <code>Apple平台</code> ，你可以使用 <code>Carthage</code> 或 <code>CocoaPods</code> 无缝集成。</p><h2 id="CoreBluetooth-APIs"><a href="#CoreBluetooth-APIs" class="headerlink" title="CoreBluetooth APIs"></a><strong><em>CoreBluetooth APIs</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对 <code>CoreBluetooth框架API</code> 并不是很熟悉，这就是为什么我基本上只是遵循并把这个 <a href="https://code.tutsplus.com/tutorials/ios-7-sdk-core-bluetooth-theoretical-overview--mobile-20728" target="_blank" rel="noopener"><strong><em><code>tutsplus.com</code></em></strong></a> 代码示例移植到 <code>Swift 4</code> 的原因。老实说，我觉得 <code>API</code> 与所有这些凌乱的委托函数过于复杂。 如果必须在 <code>CoreBluetooth</code> 或 <code>CocoaAsyncSocket</code> 之间进行选择，那么我会选择最后一个。 所以，是的，显然我不是蓝牙专家，但是这个小项目对 <code>CB框架</code> 内部的工作原理是一个很好的第一印象。</p><h2 id="WatchConnectivity-framework"><a href="#WatchConnectivity-framework" class="headerlink" title="WatchConnectivity framework"></a><strong><em>WatchConnectivity framework</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要在 <code>iOS</code> 和 <code>watchOS</code> 之间进行通信，则可能会使用 <code>WatchConnectivity框架</code> ，尤其是 <code>WKSession类</code> 。 它实际上并没有那么复杂，只需几行代码，你就可以将手表的信息发送到 <code>iPhone</code> 。 你可以阅读 <a href="https://www.hackingwithswift.com/read/37/8/communicating-between-ios-and-watchos-wcsession" target="_blank" rel="noopener"><strong><em><code>这篇文章</code></em></strong></a> ，但是，如果下载 <a href="https://gitlab.com/theswiftdev/networking-for-appleos" target="_blank" rel="noopener"><strong><em><code>源代码</code></em></strong></a>，则在包中将发现几乎相同的内容。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> appleOS Networking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> appleOS Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Codable protocol在Swift中解析JSON？</title>
      <link href="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Codable%20protocol%E5%9C%A8Swift%E4%B8%AD%E8%A7%A3%E6%9E%90JSON%EF%BC%9F/"/>
      <url>/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Codable%20protocol%E5%9C%A8Swift%E4%B8%AD%E8%A7%A3%E6%9E%90JSON%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本 <code>Swift</code> 教程中，我想为你提供一个有关使用 <code>URLSession</code> 和 <code>Codable协议</code> 获取和解析 <code>JSON</code> 数据的示例。</p></br><h1 id="依存关系"><a href="#依存关系" class="headerlink" title="依存关系"></a><strong>依存关系</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，有关依赖的几句话。 从 <code>Swift 4</code> 开始，你不需要任何依赖来解析 <code>JSON数据</code> ，因为内置的协议可以处理所有事情。 如果你仍在使用某种第三方，则为简单起见，一定要放弃它。 顺便说一句，在将任何外部依赖项添加到项目中之前，请三思。 🤔</p><a id="more"></a></br><h1 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a><strong>Networking</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你的任务仅仅是从 <code>Web</code> 上通过 <code>HTTP</code> 加载某种 <code>JSON文档</code> ，那么-你完全不需要 <code>Alamofire</code> 。 你可以使用内置的 <code>URLSession类</code> 进行请求，并获取所需的一切。  <code>Foundation网络堆栈</code> 已经是一个复杂且非常有用的堆栈，不要通过额外的层使事情变得更加复杂。</p></br><h1 id="JSON-解析"><a href="#JSON-解析" class="headerlink" title="JSON 解析"></a><strong>JSON 解析</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，在简短的介绍之后，让我们深入研究一下，并从 <a href="https://jsonplaceholder.typicode.com/" target="_blank" rel="noopener"><strong><em><code>JSONPlaceholder</code></em></strong></a>   <code>Web服务</code> 获取一些 <code>假JSON数据</code> 。 我将把整个东西放在这里，你可以选择它，将其复制并粘贴到 <code>Swift playground</code> 文件中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"></span><br><span class="line"><span class="type">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> id</span><br><span class="line">        <span class="keyword">case</span> title</span><br><span class="line">        <span class="keyword">case</span> body</span><br><span class="line">        <span class="keyword">case</span> userIdentifier = <span class="string">"userId"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> body: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> userIdentifier: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error: \(error.localizedDescription)"</span>)</span><br><span class="line">        <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>, httpResponse.statusCode == <span class="number">200</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error: invalid HTTP response code"</span>)</span><br><span class="line">        <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error: missing data"</span>)</span><br><span class="line">        <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// feel free to uncomment this for debugging data</span></span><br><span class="line">    <span class="comment">// print(String(data: data, encoding: .utf8))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">        <span class="keyword">let</span> posts = <span class="keyword">try</span> decoder.decode([<span class="type">Post</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(posts.<span class="built_in">map</span> &#123; $<span class="number">0</span>.title &#125;)</span><br><span class="line">        <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error: \(error.localizedDescription)"</span>)</span><br><span class="line">        <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，从 <code>Web</code> 下载和 <code>解析JSON</code> 是一项非常简单的任务。 整个代码段约为 <code>50行</code> 。 当然，这只是概念上的证明，但是它有效，并且你不需要任何 <code>依赖</code> 。 它是 <code>纯Swift</code> 和 <code>Foundation</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Codable协议</code> -实际上是 <code>Encodable＆Decodable协议</code> 的复合类型别名-使在 <code>Swift</code> 中解析 <code>JSON数据</code> 的过程变得神奇。 💫</p><blockquote><p><strong><code>提示:</code></strong><br>为了减少一些输入，你还可以直接使用这些 <a href="https://gitlab.com/-/users/terms?redirect=%2Ftheswiftdev%2Fawesome-xcode-extensions" target="_blank" rel="noopener"><strong><em><code>amazing Xcode extensions</code></em></strong></a> 从JSON结构生成最终对象。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Codable protocol </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Codable protocol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift枚举值</title>
      <link href="/Swift%E6%9E%9A%E4%B8%BE%E5%80%BC/"/>
      <url>/Swift%E6%9E%9A%E4%B8%BE%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本快速教程中，我将向您展示如何使用以 <code>Swift 4</code> 编写的通用解决方案获取 <code>Swift枚举类型</code> 的所有可能值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 <code>Swift 4.2</code> 开始，您只需遵循 <code>CaseIterable协议</code> ，即可获得 <code>allCases静态属性</code> 。 应该将 <code>Swift</code> 语言版本升级到最新版本。 🎉🎉🎉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ABC</span>: <span class="title">String</span>, <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> a, b, <span class="built_in">c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">ABC</span>.allCases.<span class="built_in">map</span> &#123; $<span class="number">0</span>.rawValue &#125;)</span><br></pre></td></tr></table></figure><a id="more"></a></br><h1 id="EnumCollection协议方法"><a href="#EnumCollection协议方法" class="headerlink" title="EnumCollection协议方法"></a><strong>EnumCollection协议方法</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要定义一个新的 <code>EnumCollection协议</code> ，然后在其上进行协议扩展，因此您根本不必编写太多代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">EnumCollection</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cases</span><span class="params">()</span></span> -&gt; <span class="type">AnySequence</span>&lt;<span class="type">Self</span>&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> allValues: [<span class="type">Self</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">EnumCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cases</span><span class="params">()</span></span> -&gt; <span class="type">AnySequence</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AnySequence</span> &#123; () -&gt; <span class="type">AnyIterator</span>&lt;<span class="type">Self</span>&gt; <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">var</span> raw = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">AnyIterator</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> current: <span class="type">Self</span> = <span class="built_in">withUnsafePointer</span>(to: &amp;raw) &#123; $<span class="number">0</span>.withMemoryRebound(to: <span class="keyword">self</span>, capacity: <span class="number">1</span>) &#123; $<span class="number">0</span>.pointee &#125; &#125;</span><br><span class="line">                <span class="keyword">guard</span> current.hashValue == raw <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">                raw += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> current</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> allValues: [<span class="type">Self</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Array</span>(<span class="keyword">self</span>.cases())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从现在开始，您只需要使枚举类型符合 <code>EnumCollection协议</code> ，就可以使用全新的 <code>case方法</code> 和 <code>allValues属性</code> ，其中将包含给定枚举的所有可能值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekdays</span>: <span class="title">String</span>, <span class="title">EnumCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> sunday, monday, tuesday, wednesday, thursday, friday, saturday</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> weekday <span class="keyword">in</span> <span class="type">Weekdays</span>.cases() &#123;</span><br><span class="line">    <span class="built_in">print</span>(weekday.rawValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Weekdays</span>.allValues.<span class="built_in">map</span> &#123; $<span class="number">0</span>.rawValue.capitalized &#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，枚举的基本类型需要为 <code>Hashable</code> ，但这并不重要。 但是，此解决方案就像 <code>Swift 4</code> 一样过去时，请考虑将项目升级到 <code>Swift5</code> 。 👋</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> enum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> enum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode扩展</title>
      <link href="/Xcode%E6%89%A9%E5%B1%95/"/>
      <url>/Xcode%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是当前可用的本地创建的 <code>Xcode源代码编辑器</code> 扩展的最大和最好的集合。</p></br><h1 id="Xcode-extensions"><a href="#Xcode-extensions" class="headerlink" title="Xcode extensions"></a><strong>Xcode extensions</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以找到托管在 <a href="https://github.com/theswiftdev/awesome-xcode-extensions" target="_blank" rel="noopener"><strong><em><code>GitHub</code></em></strong></a> （2,2k +⭐️）上的实际列表。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样做的主要原因是该项目几乎完全由社区推动，这一事实确实令人惊讶！ 在不到一年的时间里，该存储库在 <code>GitHub</code> 上拥有一千颗星，而且还在不断增加！ 很棒的 <code>Xcode扩展列表</code> 对所有人开放，因此，如果你有扩展，请不要犹豫并创建请求请求！</p><a id="more"></a></br><h1 id="如何创建Xcode扩展？"><a href="#如何创建Xcode扩展？" class="headerlink" title="如何创建Xcode扩展？"></a><strong>如何创建Xcode扩展？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会渴望实现自己的扩展。 没问题 这里有一些非常神奇的资源，可以教你如何制作 <code>Xcode插件</code> 。</p><ul><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionCreation.html" target="_blank" rel="noopener"><strong><em><code>Apple - Creating an App extension</code></em></strong></a></li><li><a href="https://developer.apple.com/documentation/xcodekit/creating_a_source_editor_extension" target="_blank" rel="noopener"><strong><em><code>Apple - Creating a Source Editor Extension</code></em></strong></a> </li><li><a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="noopener"><strong><em><code>WWDC16 - Using and Extending the Xcode Source Editor</code></em></strong></a></li><li><a href="http://www.russbishop.net/xcode-extensions" target="_blank" rel="noopener"><strong><em><code>Russ Bishop - Xcode Extensions</code></em></strong></a></li><li><a href="http://allblue.me/xcode/2016/06/28/Build-your-own-Xcode-8-source-editor-extension/" target="_blank" rel="noopener"><strong><em><code>Victor S. Wang - Build your own Xcode 8 Source Editor Extension</code></em></strong></a></li><li><a href="https://code.tutsplus.com/tutorials/how-to-create-an-xcode-source-editor-extension--cms-26772" target="_blank" rel="noopener"><strong><em><code>EnvatoTuts+ - How to Create an Xcode Source Editor Extension</code></em></strong></a></li><li><a href="https://www.youtube.com/watch?v=5m9DOuP4udE" target="_blank" rel="noopener"><strong><em><code>NSCoconut - Build an Xcode Source Editor Extension</code></em></strong></a></li><li><a href="https://littlebitesofcocoa.com/239-creating-an-xcode-source-editor-extension" target="_blank" rel="noopener"><strong><em><code>Little bites of Cocoa - Creating an Xcode Source Editor Extension 🛠</code></em></strong></a></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些篇文章都是非常出色的，我不想深入探讨构建 <code>Xcode源代码编辑器</code> 扩展的细节，你应该阅读（观看）它们并开始构建自己的东西。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Xcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择Swift而不是Objective-C的5个理由</title>
      <link href="/%E9%80%89%E6%8B%A9Swift%E8%80%8C%E4%B8%8D%E6%98%AFObjective-C%E7%9A%845%E4%B8%AA%E7%90%86%E7%94%B1/"/>
      <url>/%E9%80%89%E6%8B%A9Swift%E8%80%8C%E4%B8%8D%E6%98%AFObjective-C%E7%9A%845%E4%B8%AA%E7%90%86%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在进行 <code>iOS开发</code> 时，最大的问题之一是你应该使用 <code>Objective-C</code> 还是 <code>Swift</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，编程语言的寿命比你预期的更长。 但是，开发人员无法继续使用过时的方法。 他们需要了解所有最新的发展和趋势，这有时意味着做出艰难的选择。 在进行 <code>iOS开发</code> 时，最大的问题之一是你应该使用 <code>Objective-C</code> 还是 <code>Swift</code> 。</p></br><h1 id="语言历史"><a href="#语言历史" class="headerlink" title="语言历史"></a><strong>语言历史</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天， <code>Objective-C</code> 是一种用于开发 <code>iPhone应用程序</code> 的语言。但是，这种语言创建于1980年代。该语言已获得 <code>史蒂夫·乔布斯（Steve Jobs ）</code>的 <code>NeXT Computer Inc.</code> 的许可，用于开发 <code>NeXTStep框架</code> 。随着时间的流逝，它成为了 <code>Apple</code> 创造的许多标志性产品的基础。  <code>Objective-C</code> 基于两种语言： <code>Smalltalk</code> 和 <code>C</code> 。它使用来自 <code>C语言</code> 的语法进行非面向对象的操作，使用来自 <code>Smalltalk</code> 的语法进行面向对象的操作。  <code>Objective-C</code> 的主要优点之一是该语言不是新语言，并且开发人员已经对其进行了多年的测试。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 由苹果公司于2014年发布。据 <code>蒂姆·库克（Tim Cook）</code> 称，新语言在发布后一个月内被下载了超过1100万次。根据 <code>TIOBE Index</code> ， <code>Swift</code> 在2015年成为增长最快的语言。该语言是免费的，所有人均可使用，因此毫不奇怪，它在 <code>iOS开发人员</code> 中迅速流行。  <code>Swift 5.0</code> 于 2019年 发布。它具有一个稳定的二进制接口，可在包括 <code>macOS</code> ， <code>tvOS</code> 和 <code>watchOS</code> 在内的不同 <code>Apple</code> 平台上很好地运行。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Objective-C</code> 基础框架是许多 <code>Swift</code> 功能的基础。 例如， <code>Swift</code> 数据桥接到 <code>NSData</code> 。 但是， <code>Swift</code> 还具有许多 <code>Objective-C</code> 所没有的独特功能。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift 5</code> 发布后，其 <code>核心库</code> 已集成到 <code>iOS</code> ， <code>macOS</code> ， <code>watchOS</code> 和 <code>tvOS版本</code> 中。 因此，由于包含了库，因此为这些平台创建的应用现在可以较小。 稳定的应用程序二进制接口也使 <code>Apple</code> 可以跨平台提供支持。 但是， <code>Apple</code> 继续支持 <code>Objective-C</code> ，因此许多开发人员需要做出选择。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哪种语言对企业更具成本效益且更易于使用？ 这是选择 <code>Swift</code> 而不是 <code>Objective-C</code> 的一些充分理由。</p></br><h1 id="Swift易于阅读"><a href="#Swift易于阅读" class="headerlink" title="Swift易于阅读"></a><strong>Swift易于阅读</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Objective-C</code> 要求你使用带有 <code>“ @”</code> 符号的关键字来制作 <code>NSString</code> 文字。 这样一来，计算机就可以将 <code>NSString</code> 对象与常规 <code>C</code> 中使用的元素区分开。鉴于 <code>Swift</code> 不是基于 <code>C</code> 的，因此你无需使用任何标记对象，因此 <code>Swift</code> 可以统一所有关键字。 这是用 <code>Objective-C</code> 和 <code>Swift</code> 编写的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Objective-C</span><br><span class="line">const int count &#x3D; 10;</span><br><span class="line">double price &#x3D; 23.55;</span><br><span class="line"></span><br><span class="line">NSString *firstMessage &#x3D; @&quot;Swift is awesome. &quot;;</span><br><span class="line">NSString *secondMessage &#x3D; @&quot;What do you think?&quot;;</span><br><span class="line">NSString *message &#x3D; [NSString stringWithFormat: @&quot;%@%@&quot;, firstMessage, secondMessage];</span><br><span class="line"></span><br><span class="line">NSLog(message)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> price = <span class="number">23.55</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstMessage = <span class="string">"Swift is awesome. "</span></span><br><span class="line"><span class="keyword">let</span> secondMessage = <span class="string">"What do you think?."</span></span><br><span class="line"><span class="keyword">let</span> message = firstMessage + secondMessage</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 还摆脱了传统约定。 例如，你不需要在条件表达式中使用括号或在分行中使用分号。  <code>Swift</code> 使用标准方法，将列表和参数括在括号内，并用逗号分隔。 因此， <code>Swift</code> 是一种更具表现力的语言。 它更干净，并且简化了语法和语法。</p></br><h1 id="Swift-是-互动的"><a href="#Swift-是-互动的" class="headerlink" title="Swift 是 互动的"></a><strong>Swift 是 互动的</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;借助 <code>Swift Playgrounds</code>，开发人员可以快速测试其代码，而无需编译大块代码或创建完整的应用程序。 <code>Playgrounds</code> 上可以直观地呈现数据，以便程序员可以当场检查和更改其代码。 感谢最新的 <code>Xcode IDE</code> ，开发人员可以使用简单的编辑器进行实验，该编辑器包括带有图像，线条和最终视图的面板。</p></br><h1 id="Swift更安全"><a href="#Swift更安全" class="headerlink" title="Swift更安全"></a><strong>Swift更安全</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>Objective-C</code> 时，如果调用带有未初始化指针变量的方法，则不会发生任何事情。 在这种情况下，表达式变为空运算。 尽管它不会崩溃，但它引起了许多错误，因为无操作会导致不可预测的行为。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 具有 <code>静态类型系统</code> 。 当程序员使用 <code>nil</code> 可选值时，它通过触发运行时崩溃来确保可预测的行为。 由于这种方法，错误修复过程变得更加容易，因为迅速迫使开发人员立即修复所有问题。 运行时崩溃在包含 <code>nil</code> 可选值的代码行上停止，因此可以更快地修复错误。</p></br><h1 id="Swift更易于维护"><a href="#Swift更易于维护" class="headerlink" title="Swift更易于维护"></a><strong>Swift更易于维护</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>C</code> 不发展，那么 <code>Objective-C</code> 就不会发展。 程序员必须维护两个代码文件，以提高可执行应用程序开发的效率和构建时间。  <code>Swift</code> 不需要两个文件。  <code>LLVM编译器</code> 和 <code>Xcode</code> 可以在了解依赖关系的情况下自动执行增量构建。 因此，你可以忘记将实现文件与头文件分开的重复任务。  <code>Swift</code> 将实现文件 <code>.m</code> 和标头 <code>.h</code> 替换为单个代码文件<code>-.swift</code> 。 但是，它将仍然生成你可以在 <code>Xcode</code> 中看到的接口文件。</p></br><h1 id="统一内存管理"><a href="#统一内存管理" class="headerlink" title="统一内存管理"></a><strong>统一内存管理</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 支持跨 <code>面向对象</code> 和 <code>过程</code> 代码路径的 <code>自动引用计数（ARC）</code> 。 尽管 <code>Objective-C</code> 在面向对象的代码和 <code>Cocoa API</code> 中都支持 <code>ARC</code> ，但它仍然不适用于其他 <code>API</code> ，例如 <code>Core Graphics</code> 和过程 <code>C代码</code> 。 因此，程序员在使用低级 <code>API</code> 时负责处理内存管理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 消除了 <code>Objective-C</code> 中常见的大量内存泄漏，使开发人员可以专注于开发新功能和核心应用逻辑。 在 <code>Swift</code> 中，即使使用较低级别的 <code>API</code> ， <code>ARC</code> 也可以跨面向对象和过程的代码工作。  <code>Swift</code> 使 <code>Apple</code> 能够解决高性能和自动内存管理的问题，从而提高了生产率。 此外，垃圾收集器不会清理未使用的内存，这在用户输入和响应式图形的情况下是非常重要的因素。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管 <code>Apple</code> 仍然为 <code>老派开发人员</code> 提供<code>Objective-C</code> 支持，但是 <code>Swift</code> 提供了许多不可忽视的优势。 它更安全，所需的代码更少，并且更简单。  <code>Swift</code> 使程序员可以忘记与 <code>Objective-C</code> 中使用的过时方法相关的许多问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想要节省时间和金钱的开发人员应该选择 <code>Swift</code> 作为一种更有效的语言。<br>尽管编程语言的消亡速度很慢，但是可以期望 <code>Swift</code> 完全替代 <code>C</code> 来在 <code>Apple</code> 平台上进行编程。  <code>Swift</code> 不仅从 <code>Objective-C</code> 继承了许多有用的组件，而且还引入了一组新功能，这些功能允许开发人员编写更可靠的代码，从而使程序员可以避免进行大量重复性工作，而将精力集中在更全局的任务上。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入研究Swift框架</title>
      <link href="/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Swift%E6%A1%86%E6%9E%B6/"/>
      <url>/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Swift%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解有关 <code>Swift模块</code> ， <code>库</code> ， <code>软件包</code> ， <code>封闭源框架</code> ， <code>命令行工具</code> 等的一切。</p></br><h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a><strong>基本定义</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，你应该对基本术语有清楚的了解。 如果你已经知道模块，程序包，库或框架之间的区别，则可以跳过本节。 但是，如果你对这些事情仍然有一些困惑，请继续阅读，你将不会后悔。 😉</p><h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a><strong><em>Package</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个包由 <code>Swift</code> 源文件和清单文件组成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包是 <code>Swift</code> 源文件的集合。 如果你使用的是 <code>Swift Package Manager</code>，则还必须提供一个清单文件才能制作一个真正的软件包。 如果你想了解更多有关此工具的信息，请查看我的 <code>Swift Package Manager</code> 教程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：这是你的 <code>package</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sources</span></span><br><span class="line">    my-source-file.swift</span><br><span class="line"><span class="type">Package</span>.swift</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以查看 <code>Apple</code> 提供的开源 <code>swift-corelibs-foundation</code> 软件包，该软件包用于构建 <code>Swift</code> 的 <code>Foundation框架</code> 。</p><a id="more"></a><h2 id="Library"><a href="#Library" class="headerlink" title="Library"></a><strong><em>Library</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;库是程序可以链接到的目标文件的打包集合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，库是一堆编译后的代码。 你可以创建两种库：</p><ul><li>static</li><li>dynamic</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从非常简单的角度来看，它们之间的唯一区别就是 <code>“集成”</code> 的方法。 将它们链接到你的项目。 在我进一步介绍该过程之前，首先我们应该讨论目标文件。</p><h2 id="Mach-O文件格式"><a href="#Mach-O文件格式" class="headerlink" title="Mach-O文件格式"></a><strong><em>Mach-O文件格式</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了创建程序，开发人员将源代码转换为目标文件。 然后将目标文件打包到可执行代码或静态库中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译源文件时，基本上是在使用 <code>Mach-O（MachObject）</code> 文件格式来制作目标文件。 这些文件是应用程序，框架和库（动态和静态）的核心构建块。</p><h2 id="链接库"><a href="#链接库" class="headerlink" title="链接库"></a><strong><em>链接库</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接是指从多个目标文件创建单个可执行文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换一种说法：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译器创建完所有目标文件后，将调用另一个程序将它们捆绑到可执行程序文件中。 该程序称为链接器，而将它们捆绑到可执行文件中的过程称为链接。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接只是将你所有的目标文件组合成一个可执行文件，并解决所有外部问题，因此系统将能够调用二进制文件中的所有函数。</p><p><strong>静态链接</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，该库的源代码将被复制到应用程序的源代码中。 这将导致一个较大的可执行文件，它将花费更多的时间来加载，因此二进制文件的启动时间会更慢。 哦，我是否提到过，如果你尝试多次链接同一库，由于符号重复，该过程将失败？</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sf-stp1.png" alt="静态链接"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法也有优点，例如，可执行文件将始终包含正确版本的库，并且仅将那些真正使用过的部分复制到主应用程序中，因此你不必加载全部内容，但是 在某些情况下，似乎动态链接会更好。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a><strong><em>动态链接</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>动态库</code> 未嵌入到二进制源中，而是在运行时加载的。 这意味着，由于使用了轻量级的二进制文件，因此应用程序可以更小，并且启动时间可以大大缩短。 免费提供的动态库可以与多个可执行文件共享，因此它们可以减少内存占用。 这就是为什么有时将它们称为共享库的原因。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sf-stp2.png" alt="动态链接"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，如果动态库不可用-或可用，但该版本不兼容-你的应用程序将无法运行或崩溃。 另一方面，这可能是一个优势，因为动态库的作者可以发布修补程序，而你的应用程序可以从中受益，而无需重新编译。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，像 <code>UIKit</code> 这样的系统库总是可用的，因此你不必太担心这个问题…</p><h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a><strong><em>Framework</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;框架是分层目录，它将共享资源（例如动态共享库，nib文件，图像文件，本地化字符串，头文件和参考文档）封装在一个程序包中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们简化一下：框架是打包成捆绑有一些额外 <code>assets</code> ，用于版本控制的元描述的 <code>静态</code> 或 <code>动态库</code> 。  <code>UIKit</code> 是一个需要图像 <code>assets</code> 来显示某些 <code>UI元素</code> 的框架，并且具有版本描述，通过这种方式， <code>UIKit</code> 的版本与 <code>iOS</code> 的版本相同。</p><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a><strong><em>Module</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 将代码组织到模块中。 每个模块都指定一个名称空间，并强制执行访问控制，以便可以在模块外部使用该代码的哪些部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>import</code> 关键字，你实际上是将 <code>外部模块</code> 导入到你的 <code>项目</code> 中。 在Swift中，你始终使用框架作为模块，但是让我们回顾一下，来了解为什么我们完全需要 <code>模块</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> my-awesome-module</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用模块之前，你必须将框架标头直接导入代码中，并且还必须在 <code>Xcode</code> 中手动链接框架的二进制文件。  <code>#import宏</code> 实际上将整个已解析的依赖项结构复制粘贴到你的代码中，然后编译器对该庞大的源文件进行了处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个脆弱的系统，宏定义可能会出错，你很容易破坏其他框架。 这就是定义带前缀的大写超长宏名称的原因，例如： <code>NS_MYSUPERLONGMACRONAME</code>  …😒</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有另一个问题：复制粘贴会导致不可扩展的编译时间。 为了解决这个问题，预编译的头文件 <code>（PCH）</code> 诞生了，但这只是部分解决方案，因为它们污染了名称空间（你知道是否将 <code>UIKit</code> 导入 <code>PCH</code> 文件中，它随处可见），而且没有人真正维护过 他们。</p><h2 id="Modules-amp-module-maps"><a href="#Modules-amp-module-maps" class="headerlink" title="Modules &amp; module maps"></a><strong><em>Modules &amp; module maps</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经有了 <code>模块映射</code> （定义什么样的头文件是模块的一部分以及什么是实现的二进制文件），我们已经封装了模块化框架。 🎉它们分别编译一次，头文件定义 <code>接口（API）</code>，并且（自动）链接包含实现的 <code>dylib文件</code> 。 在编译期间（可伸缩性）无需解析框架头，因此本地宏定义不会破坏任何内容。 模块可以包含子模块（继承），而你不必在 <code>（Xcode）</code> 项目中显式链接它们，因为 <code>.modulemap文件</code> 包含构建系统所需的所有信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在你知道导入 <code>Foundation</code> 或 <code>导入UIKit</code> 时会发生什么。</p></br><h1 id="Command-line-tools"><a href="#Command-line-tools" class="headerlink" title="Command line tools"></a><strong>Command line tools</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然你知道整个 <code>动态模块化框架</code> 系统背后的逻辑，我们就应该开始研究使该基础架构成为可能的工具。</p><blockquote><p><strong><em><code>提示：</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总是阅读手册页。 RTFM！ 如果你不喜欢阅读太多内容，可以从gitlab下载示例项目并打开的 <code>makefile</code> 。 将有3个主要类别：<code>C</code>， <code>Swift</code> 和 <code>Xcode</code> 项目示例。</p></blockquote><h2 id="clang"><a href="#clang" class="headerlink" title="clang"></a><strong><em>clang</em></strong></h2><blockquote><p><strong><em><code>the Clang C, C++, and Objective-C compiler</code></em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Clang</code> 是 <code>C语言</code> （ <code>C</code> ， <code>C++</code> ， <code>Objective-C</code> ）的前端编译器。 如果你在大学期间曾经尝试使用 <code>gcc</code> 编译 <code>C代码</code> ，你可以想象 <code>clang</code> 与 <code>gcc</code> 差不多，但如今它可以做更多的事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -c main.c -o main.o <span class="meta">#compiles a C source file</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>LLVM</strong> ：编译器后端系统，可以编译和优化由 <code>clang</code> 或 <code>Swift</code> 编译器生成的中间表示 <code>（IR）</code> 代码。 它是独立于语言的，现在让我们说 <code>LLVM</code> 为你的 <code>可执行文件</code> 制作最终的 <code>机器代码</code> 。</p><h2 id="swiftc"><a href="#swiftc" class="headerlink" title="swiftc"></a><strong><em>swiftc</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift编译器</code> 对此没有手动输入，但是不用担心，只需启动 <code>swiftc -h</code> 并看看能为你提供什么。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftc main.swift <span class="meta">#compiles a Swift source file</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，此工具实际上是可以将 <code>Swift源文件</code> 编译为 <code>Mach-O</code> 或最终 <code>可执行文件</code> 的工具。</p><h2 id="ar"><a href="#ar" class="headerlink" title="ar"></a><strong><em>ar</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>ar</code> 实用程序创建并维护组合成档案的文件组。 创建归档文件后，可以添加新文件，并且可以提取，删除或替换现有文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，简而言之，你可以将 <code>Mach-O文件</code> 压缩为一个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -rcs myLibrary.a *.o</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>ar</code> 的帮助下，你可以创建 <code>静态库文件</code> ，但是如今 <code>libtool</code> 具有相同的功能。</p><h2 id="ranlib"><a href="#ranlib" class="headerlink" title="ranlib"></a><strong><em>ranlib</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>ranlib</code> 生成指向档案内容的索引，并将其存储在档案中。 索引列出了由可重定位目标文件的归档成员定义的每个符号。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Ranlib</code> 可以在 <code>静态库</code> 中创建一个索引文件，因此当你要使用库时，事情将会变得更快。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ranlib myLibrary.a</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此， <code>ranlib＆ar</code> 是维护 <code>静态库</code> 的工具，通常 <code>ar</code> 负责维护索引，并且你不必再运行 <code>ranlib</code> 。 但是，还有一个更好的管理 <code>静态（和动态）库</code> 的选择，你应该学习…</p><h2 id="libtool"><a href="#libtool" class="headerlink" title="libtool"></a><strong><em>libtool</em></strong></h2><blockquote><p><strong><em><code>创建类库</code></em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>libtool</code> 可以创建 <code>动态链接的库</code> 或 <code>静态链接的（归档）库</code> 。 该带有 <code>-static</code> 选项的工具旨在替换 <code>ar＆ranlib</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libtool -static *.o -o myLibrary.a</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今， <code>libtool</code> 是构建库文件的主要选项，如果你是本主题的话，一定要学习该工具。 你可以检查示例项目的 <code>makefile</code> 以获得更多信息，或者通常可以阅读手册（<code>man libtool</code>）。 😉</p><h2 id="ld"><a href="#ld" class="headerlink" title="ld"></a><strong><em>ld</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>ld命令</code> 组合了几个目标文件和库，解析引用，并生成输出文件。  <code>ld</code> 可以产生最终的 <code>链接映像</code> （ <code>可执行文件</code> ， <code>dylib</code> 或 <code>bundle</code> ）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们简单点：这是 <code>链接器工具</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld main.o -lSystem -LmyLibLocation -lmyLibrary -o MyApp</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它可以将多个文件链接到一个实体中，因此你可以从 <code>Mach-O</code> 制作 <code>可执行二进制文件</code> 。  <code>链接</code> 是必需的，因为系统需要从链接的库中解析每种方法的地址。 换句话说，可执行文件将能够运行，并且所有功能都可以调用。 📱</p><h2 id="nm"><a href="#nm" class="headerlink" title="nm"></a><strong><em>nm</em></strong></h2><blockquote><p><strong><em><code>显示名称列表（符号表）</code></em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>nm</code> ，你可以查看文件中包含哪些符号。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nm myLibrary.a</span><br><span class="line"># <span class="number">0000000000001000</span> <span class="type">A</span> __mh_execute_header</span><br><span class="line">#                  <span class="type">U</span> _factorial</span><br><span class="line"># 0000000000001f50 <span class="type">T</span> _main</span><br><span class="line">#                  <span class="type">U</span> _printf</span><br><span class="line">#                  <span class="type">U</span> dyld_stub_binder</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从输出中可以看到，某些符号与某些内存地址相关联。 具有地址的地址实际上已给出，所有其他地址都来自其他库（它们尚未解析）。 因此，这意味着它们将在运行时解决。 另一个选择是你必须链接它们。 😅</p><h2 id="otool"><a href="#otool" class="headerlink" title="otool"></a><strong><em>otool</em></strong></h2><blockquote><p><strong><em><code>目标文件显示工具</code></em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>otool</code> ，你可以检查 <code>Mach-O文件</code> 或 <code>库</code> 的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">otool -L myLibrary.a</span><br><span class="line">otool -tV myLibrary.a</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，你可以列出 <code>链接</code> 的库，或查看文件的 <code>反汇编</code> 文本内容。 如果你熟悉 <code>Mach-O文件格式</code> ，那么它是一个非常有用的工具，也是对现有应用程序进行 <code>逆向工程</code> 的好工具。</p><h2 id="lipo"><a href="#lipo" class="headerlink" title="lipo"></a><strong><em>lipo</em></strong></h2><blockquote><p><strong><em><code>创建通用文件或对其进行操作</code></em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;借助 <code>lipo</code> 工具，你可以创建通用（多体系结构）文件。 通常，此工具用于创建通用框架。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -create -output myFramework.framework devices.framework simulator.framework</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设想以下情形：你为 <code>arm7</code> 和 <code>i386</code> 都构建了类库。 在真实设备上，你需要发布 <code>arm7版本</code> ，但对于 <code>iOS模拟器</code>  ，你将需要 <code>i386版本</code> 。 在 <code>lipo</code> 的帮助下，你可以将这些体系结构组合为一个，并交付该框架，因此最终不必再担心此问题。</p></br><h1 id="Xcode相关工具"><a href="#Xcode相关工具" class="headerlink" title="Xcode相关工具"></a><strong>Xcode相关工具</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些工具也可以从命令行调用，但是它们与 <code>Xcode</code> 的关系比以前更多。 让我们快速了解一下。</p><h2 id="xcode-select"><a href="#xcode-select" class="headerlink" title="xcode-select"></a><strong><em>xcode-select</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;管理 <code>Xcode</code> 和 <code>BSD工具</code> 。 如果你的计算机上具有多个版本的 <code>Xcode</code> ，则此工具可以轻松地在各个版本提供的开发人员工具之间切换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --switch path/to/Xcode.app</span><br></pre></td></tr></table></figure><h2 id="xcrun"><a href="#xcrun" class="headerlink" title="xcrun"></a><strong><em>xcrun</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行或找到开发工具和属性。 使用 <code>xcrun</code> ，你基本上可以运行任何可以通过 <code>Xcode</code> 管理的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl list <span class="comment">#list of simulators</span></span><br></pre></td></tr></table></figure><h2 id="codesign"><a href="#codesign" class="headerlink" title="codesign"></a><strong><em>codesign</em></strong></h2><blockquote><p><strong><em><code>创建和操作代码签名</code></em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它可以选择适当的签名对你的应用程序进行签名。 通常，在引入自动签名之前尝试对应用程序进行签名时，此操作失败。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">codesign -s <span class="string">"Your Company, Inc."</span> /path/to/MyApp.app</span><br><span class="line">    codesign -v /path/to/MyApp.app</span><br></pre></td></tr></table></figure><h2 id="xcodebuild"><a href="#xcodebuild" class="headerlink" title="xcodebuild"></a><strong><em>xcodebuild</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构建 <code>Xcode</code> 项目和 <code>workspaces</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它将解析 <code>Xcode项目</code> 或 <code>workspaces</code> 文件，并基于该文件执行适当的 <code>buid命令</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -project Example.xcodeproj -target Example</span><br><span class="line">    xcodebuild -list</span><br><span class="line">    xcodebuild -showsdks</span><br></pre></td></tr></table></figure></br><h1 id="如何使iOS的封闭源通用FATtened（多体系结构）Swift框架？"><a href="#如何使iOS的封闭源通用FATtened（多体系结构）Swift框架？" class="headerlink" title="如何使iOS的封闭源通用FATtened（多体系结构）Swift框架？"></a><strong>如何使iOS的封闭源通用FATtened（多体系结构）Swift框架？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们在这里，整篇文章都是为了学习本教程背后的逻辑而写的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我不想重新发明轮子。 但是，我想为你提供一些更详细的说明，并对脚本进行一些修改。</p><h2 id="Thin-vs-fat-frameworks"><a href="#Thin-vs-fat-frameworks" class="headerlink" title="Thin vs. fat frameworks"></a><strong><em>Thin vs. fat frameworks</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Thin frameworks</code> 仅包含一种体系结构的编译代码。 另一方面，<code>fat frameworks</code> 包含用于多种体系结构的 <code>“slices”</code> 。 架构基本上被称为片，例如 <code>i386</code> 或 <code>arm7 slice</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>slice</code> 这意味着，如果仅针对 <code>i386</code> 和 <code>x86_64架构编译框架</code> ，则该框架仅在模拟器上有效，而在实际设备上则失败。 因此，如果你想构建一个真正的通用框架，则必须为所有现有架构进行编译。</p><h2 id="构建一个-fat-framework"><a href="#构建一个-fat-framework" class="headerlink" title="构建一个 fat framework"></a><strong><em>构建一个 fat framework</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对你有个好消息。 你只需要一个构建阶段脚本和一个聚合目标即可构建一个多体系结构框架。 在这里，从原始文章中无耻地撕下来，进行了一些额外的更改…😁</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">BUILD_PATH=<span class="string">"<span class="variable">$&#123;SRCROOT&#125;</span>/build"</span></span><br><span class="line">DEPLOYMENT_PATH=<span class="string">"<span class="variable">$&#123;SRCROOT&#125;</span>"</span></span><br><span class="line">TARGET_NAME=<span class="string">"Console-iOS"</span></span><br><span class="line">FRAMEWORK_NAME=<span class="string">"Console"</span></span><br><span class="line">FRAMEWORK=<span class="string">"<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>.framework"</span></span><br><span class="line">FRAMEWORK_PATH=<span class="string">"<span class="variable">$&#123;DEPLOYMENT_PATH&#125;</span>/<span class="variable">$&#123;FRAMEWORK&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean the build folder</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    rm -rf <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build the framework for every architecture using xcodebuild</span></span><br><span class="line">xcodebuild -target <span class="string">"<span class="variable">$&#123;TARGET_NAME&#125;</span>"</span> -configuration Release \</span><br><span class="line">    -arch arm64 -arch armv7 -arch armv7s \</span><br><span class="line">    only_active_arch=no defines_module=yes -sdk <span class="string">"iphoneos"</span></span><br><span class="line"></span><br><span class="line">xcodebuild -target <span class="string">"<span class="variable">$&#123;TARGET_NAME&#125;</span>"</span> -configuration Release \</span><br><span class="line">    -arch x86_64 -arch i386 \</span><br><span class="line">    only_active_arch=no defines_module=yes -sdk <span class="string">"iphonesimulator"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove previous version from the deployment path</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;FRAMEWORK_PATH&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    rm -rf <span class="string">"<span class="variable">$&#123;FRAMEWORK_PATH&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy freshly built version to the deployment path</span></span><br><span class="line">cp -r <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>/Release-iphoneos/<span class="variable">$&#123;FRAMEWORK&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;FRAMEWORK_PATH&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># merge all the slices and create the fat framework</span></span><br><span class="line">lipo -create -output <span class="string">"<span class="variable">$&#123;FRAMEWORK_PATH&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>"</span> \</span><br><span class="line">    <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>/Release-iphoneos/<span class="variable">$&#123;FRAMEWORK&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>"</span> \</span><br><span class="line">    <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>/Release-iphonesimulator/<span class="variable">$&#123;FRAMEWORK&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy Swift module mappings for the simulator</span></span><br><span class="line">cp -r <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>/Release-iphonesimulator/<span class="variable">$&#123;FRAMEWORK&#125;</span>/Modules/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>.swiftmodule/"</span> \</span><br><span class="line">    <span class="string">"<span class="variable">$&#123;FRAMEWORK_PATH&#125;</span>/Modules/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>.swiftmodule"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean up the build folder again</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    rm -rf <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以使用 <code>lipo</code> 工具检查创建的框架。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lipo -info Console.framework/Console</span><br><span class="line">    <span class="comment">#Architectures in the fat file: Console.framework/Console are: x86_64 i386 armv7 armv7s arm64</span></span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong><em>用法</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你只需要将全新的框架嵌入到要使用的项目中并设置一些路径即可。 </p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sf-stp3.png" alt="静态链接"></p><h2 id="提交至App-Store"><a href="#提交至App-Store" class="headerlink" title="提交至App Store"></a><strong><em>提交至App Store</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>fat frameworks</code> 只有一个问题。 它们也包含模拟器的切片。 如果要向应用商店提交应用，则必须从框架中切断与模拟器相关的代码库。 其背后的原因是，没有真正的实际设备需要此代码块，那么为什么要提交它呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">APP_PATH=<span class="string">"<span class="variable">$&#123;TARGET_BUILD_DIR&#125;</span>/<span class="variable">$&#123;WRAPPER_NAME&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove unused architectures from embedded frameworks</span></span><br><span class="line">find <span class="string">"<span class="variable">$APP_PATH</span>"</span> -name <span class="string">'*.framework'</span> -<span class="built_in">type</span> d | <span class="keyword">while</span> <span class="built_in">read</span> -r FRAMEWORK</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    FRAMEWORK_EXECUTABLE_NAME=$(defaults <span class="built_in">read</span> <span class="string">"<span class="variable">$FRAMEWORK</span>/Info.plist"</span> CFBundleExecutable)</span><br><span class="line">    FRAMEWORK_EXECUTABLE_PATH=<span class="string">"<span class="variable">$FRAMEWORK</span>/<span class="variable">$FRAMEWORK_EXECUTABLE_NAME</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Executable is <span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>"</span></span><br><span class="line"></span><br><span class="line">    EXTRACTED_ARCHS=()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ARCH <span class="keyword">in</span> <span class="variable">$ARCHS</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Extracting <span class="variable">$ARCH</span> from <span class="variable">$FRAMEWORK_EXECUTABLE_NAME</span>"</span></span><br><span class="line">        lipo -extract <span class="string">"<span class="variable">$ARCH</span>"</span> <span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>"</span> -o <span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>-<span class="variable">$ARCH</span>"</span></span><br><span class="line">        EXTRACTED_ARCHS+=(<span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>-<span class="variable">$ARCH</span>"</span>)</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Merging extracted architectures: <span class="variable">$&#123;ARCHS&#125;</span>"</span></span><br><span class="line">    lipo -o <span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>-merged"</span> -create <span class="string">"<span class="variable">$&#123;EXTRACTED_ARCHS[@]&#125;</span>"</span></span><br><span class="line">    rm <span class="string">"<span class="variable">$&#123;EXTRACTED_ARCHS[@]&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Replacing original executable with thinned version"</span></span><br><span class="line">    rm <span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>"</span></span><br><span class="line">    mv <span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>-merged"</span> <span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个小脚本将删除框架中所有不必要的片段，因此你可以通过 <code>iTunes Connect</code> 提交应用程序，而不会出现任何问题。 （哈哈哈。😅）</p><blockquote><p><strong><em><code>提示：</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你必须将此最后一个脚本添加到应用程序的 <code>build phases</code> 中。</p></blockquote></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果你想熟悉幕后的工具，本文将为你展示基础知识。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 架构设计 </tag>
            
            <tag> Swift Package Manager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何为VIPER编写服务？</title>
      <link href="/%E5%A6%82%E4%BD%95%E4%B8%BAVIPER%E7%BC%96%E5%86%99%E6%9C%8D%E5%8A%A1%EF%BC%9F/"/>
      <url>/%E5%A6%82%E4%BD%95%E4%B8%BAVIPER%E7%BC%96%E5%86%99%E6%9C%8D%E5%8A%A1%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并非所有内容都是 <code>VIPER模块</code> 。 在本文中，我将向你展示如何使用 <code>Swift</code> 将 <code>服务层</code> 与 <code>模块</code> 分离。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我可以想象你刚刚开始编写第一个 <a href="http://www.xuebaonline.com/iOS%20VIPER%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"><strong><em><code>VIPER模块</code></em></strong></a> ，你可能会想：我应该把所有与用户界面都不相关的所有 <code>网络通信</code> ， <code>CoreLocation</code> ， <code>CoreData</code> 或 <code>“任何服务”</code> 代码放在哪里？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我通常将它们称为 API ， 位置 ， 存储即服务 ，因为它们为你的 模块 提供某种信息。 另外，它们可以封装基础层，为 VIPER模块 提供定义明确的 API接口 。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，但是 <code>interactors</code> 呢？ 我不应该在这里实现这种东西吗？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，我的答案是否定的，因为 <code>服务</code> 和 <code>interactors</code> 之间存在重大差异。 虽然服务只是一个“虚拟”包装器，但例如 一个 <code>RESTful API</code> ，另一个围绕 <code>CoreData存储</code> ， <code>interactors</code> 可以使用它们两者通过API请求某种数据，并使用存储服务将其保存在本地。  <code>interactors</code> 还可以在 <code>数据传输对象（DTO）</code> 和实体之间进行排序，过滤和转换，稍后将对其进行更多介绍。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，理论足够了，让我们创建一个新服务。</p><a id="more"></a></br><h1 id="服务接口"><a href="#服务接口" class="headerlink" title="服务接口"></a><strong>服务接口</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次如协议目标编程范式所示：            <code>通过定义协议开始设计我们的系统。</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的第一个服务将是对所有服务而言非常简单的服务：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServiceInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// do nothing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在服务初始化过程中将为每个服务调用安装程序。 我们可以扩展基本服务，因此我们不必实现此方法，而仅当我们确实必须执行某些操作（例如设置 <code>CoreData堆栈</code> ）时才可以实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们可以提供我们的 <code>API</code> 服务，在这种情况下，我将实现一个虚拟端点，该端点使用带有 <code>URLSession</code> 的新 <code>Combine框架</code> 加载一些数据，但是当然你也可以使用完成块或 <code>Promises</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ApiServiceInterface</span>: <span class="title">ServiceInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">todos</span><span class="params">()</span></span> -&gt; <span class="type">AnyPublisher</span>&lt;[<span class="type">TodoObject</span>], <span class="type">HTTP</span>.<span class="type">Error</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，我正在为所有与网络相关的内容使用 <code>HTTP</code> 名称空间，例如请求方法，响应，错误等。可以根据需要随意扩展它。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Method</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">get</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Error</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> invalidResponse</span><br><span class="line">        <span class="keyword">case</span> statusCode(<span class="type">Int</span>)</span><br><span class="line">        <span class="keyword">case</span> unknown(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，它非常轻巧，但是非常方便。 我们还没有谈论过 <code>TodoObject</code> 。 这将是我们的第一个 <code>DTO</code> 。 😱</p></br><h1 id="数据传输对象"><a href="#数据传输对象" class="headerlink" title="数据传输对象"></a><strong>数据传输对象</strong></h1><blockquote><figure class="highlight plain"><figcaption><span>-维基百科```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在这种情况下，我们谈论的不是流程，而是 &#96;&#96;&#96;服务&#96;&#96;&#96; 和 [***&#96;&#96;&#96;VIPER模块&#96;&#96;&#96;***](http:&#x2F;&#x2F;www.xuebaonline.com&#x2F;%E6%8E%8C%E6%8F%A1VIPER%E6%9E%B6%E6%9E%84&#x2F; &quot;&quot;) 。 它们存在，因此我们可以将服务层与模块分离。  &#96;&#96;&#96;interactor&#96;&#96;&#96; 可以将 &#96;&#96;&#96;DTO&#96;&#96;&#96; 转换为 &#96;&#96;&#96;模块实体&#96;&#96;&#96; ，因此 &#96;&#96;&#96;VIPER模块&#96;&#96;&#96; 的所有其他部分将完全独立于服务。 值得一提的是， &#96;&#96;&#96;DTO&#96;&#96;&#96; 通常非常简单，在 &#96;&#96;&#96;RESTful API&#96;&#96;&#96; 服务中， &#96;&#96;&#96;DTO&#96;&#96;&#96; 可以实现 &#96;&#96;&#96;Codable&#96;&#96;&#96; 接口，仅此而已；对于 &#96;&#96;&#96;CoreData&#96;&#96;&#96; ， &#96;&#96;&#96;DTO&#96;&#96;&#96; 只能是 &#96;&#96;&#96;NSManagedObject&#96;&#96;&#96; 子类。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; Swift</span><br><span class="line">struct TodoObject: Codable &#123;</span><br><span class="line">   let id: Int</span><br><span class="line">   let title: String</span><br><span class="line">   let completed: Bool</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以使用简单的 <code>DTO</code> 包装请求参数。 例如，你可以使用可以包含一些过滤器或排序参数的 <code>TodoRequestObject</code> 。 你可能会注意到，我始终在 <code>DTO</code> 中使用对象后缀，这是个人喜好，但这有助于我将它们与实体区分开。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进一步介绍一下：你可以使用 <code>SPM</code> 将整个服务层作为封装的 <code>Swift软件包发布</code> ，从Xcode 11开始，这些软件包都受本机支持，因此，如果你仍在使用 <code>CocoaPods</code> ，则应考虑迁移到 <code>Swift软件包管理器</code> ，如下所示： 尽快。</p></br><h1 id="实现-Service"><a href="#实现-Service" class="headerlink" title="实现 Service"></a><strong>实现 Service</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开始构建真实的服务实现之前，最好有一个用于演示或测试目的的假冒产品。 我之所以称其为伪造的，是因为我们将返回固定数量的伪造数据，但这与我们的实际实现很接近。 如果我们的请求将包括过滤或排序，那么此伪造的实现服务应像最终响应那样对我们的响应进行过滤或排序。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FakeApiService</span>: <span class="title">ApiServiceInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> delay: <span class="type">TimeInterval</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(delay: <span class="type">TimeInterval</span> = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.delay = delay</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">fakeRequest</span>&lt;T&gt;<span class="params">(response: T)</span></span> -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">T</span>, <span class="type">HTTP</span>.<span class="type">Error</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Future</span>&lt;<span class="type">T</span>, <span class="type">HTTP</span>.<span class="type">Error</span>&gt; &#123; promise <span class="keyword">in</span></span><br><span class="line">            promise(.success(response))</span><br><span class="line">        &#125;</span><br><span class="line">        .delay(<span class="keyword">for</span>: .<span class="keyword">init</span>(<span class="keyword">self</span>.delay), scheduler: <span class="type">RunLoop</span>.main)</span><br><span class="line">        .eraseToAnyPublisher()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">todos</span><span class="params">()</span></span> -&gt; <span class="type">AnyPublisher</span>&lt;[<span class="type">TodoObject</span>], <span class="type">HTTP</span>.<span class="type">Error</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> todos = [</span><br><span class="line">            <span class="type">TodoObject</span>(id: <span class="number">1</span>, title: <span class="string">"first"</span>, completed: <span class="literal">false</span>),</span><br><span class="line">            <span class="type">TodoObject</span>(id: <span class="number">2</span>, title: <span class="string">"second"</span>, completed: <span class="literal">false</span>),</span><br><span class="line">            <span class="type">TodoObject</span>(id: <span class="number">3</span>, title: <span class="string">"third"</span>, completed: <span class="literal">false</span>),</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.fakeRequest(response: todos)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我想给假对象增加一些延迟，因为它可以帮助我测试 <code>UI堆栈</code> 。 <a href="https://www.scotthurff.com/posts/why-your-user-interface-is-awkward-youre-ignoring-the-ui-stack/" target="_blank" rel="noopener"><strong><em><code>如何解决不良用户界面</code></em></strong></a> 你绝对应该阅读它，因为它很棒，它将帮助你设计更好的产品。 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续前进，这是该服务的实际“实际”实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApiService</span>: <span class="title">ApiServiceInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> baseUrl: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(baseUrl: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.baseUrl = baseUrl</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">todos</span><span class="params">()</span></span> -&gt; <span class="type">AnyPublisher</span>&lt;[<span class="type">TodoObject</span>], <span class="type">HTTP</span>.<span class="type">Error</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="keyword">self</span>.baseUrl + <span class="string">"todos"</span>)!</span><br><span class="line">        <span class="keyword">var</span> request = <span class="type">URLRequest</span>(url: url)</span><br><span class="line">        request.httpMethod = <span class="type">HTTP</span>.<span class="type">Method</span>.<span class="keyword">get</span>.rawValue.uppercased()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: request)</span><br><span class="line">        .tryMap &#123; data, response <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="type">HTTP</span>.<span class="type">Error</span>.invalidResponse</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">guard</span> httpResponse.statusCode == <span class="number">200</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="type">HTTP</span>.<span class="type">Error</span>.statusCode(httpResponse.statusCode)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125;</span><br><span class="line">        .decode(type: [<span class="type">TodoObject</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line">        .mapError &#123; error -&gt; <span class="type">HTTP</span>.<span class="type">Error</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> httpError = error <span class="keyword">as</span>? <span class="type">HTTP</span>.<span class="type">Error</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> httpError</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">HTTP</span>.<span class="type">Error</span>.unknown(error)</span><br><span class="line">        &#125;</span><br><span class="line">        .eraseToAnyPublisher()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题是我们可以做得更好，但是为了简单起见，我将“一起”实现。 我不喜欢隐式解包的 <code>url</code> 和其他许多小细节，但是出于学习目的，这是完全可以的。 😛</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以现在最大的问题是，如何将事情放在一起？ 我的意思是我们有一个有效的服务实现，一个伪造的服务实现，但是如果不将伪造的代码运送到生产环境中，我们应该怎么把所有东西放到一个真正的Xcode项目中呢？</p></br><h1 id="目标环境"><a href="#目标环境" class="headerlink" title="目标环境"></a><strong>目标环境</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，你将具有现场生产环境，开发环境，也许是测试环境，以及用于QA，UAT或演示目的的其他环境。 对于这些环境，情况可能会有所不同，例如最终的 <code>API URL</code>或应用程序图标等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，我将建立一个具有3个独立环境的项目：</p><ul><li>Production</li><li>Development</li><li>Fake</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你从一个新项目开始，则默认情况下将有一个主要（非测试）目标。 你可以通过右键单击目标来复制它。 让我们做两次。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ws-stp1.png" alt="Production"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我通常为目标和方案名称加上后缀，但生产环境除外，在生产环境中，我使用“基本名称”而不使用<code>-Production</code> 后缀。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如你在屏幕截图上所看到的，我具有用于环境的基本文件夹结构。 每个目标都必须有一个单独的 <code>Info.plist</code> 文件，因此我将它们放入适当的 <code>Assets</code> 文件夹中。 <code>FakeApiService.swift</code> 只是伪造目标的一部分，其他所有文件都是共享的。 等等， <code>ServiceBuilder</code> 到底是什么？</p></br><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多种环境意味着我们必须为每个构建目标使用正确的服务（或配置）。 为此，我正在使用依赖项注入设计模式。 服务构建者只是有助于实现此目标的协议。 它定义了如何根据环境设置服务。 让我告诉你它是如何工作的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceBuilderInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> api: <span class="type">ApiServiceInterface</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServiceBuilderInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.api.setup()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，对于每个目标（环境），我都在实际的 <code>ServiceBuilder.swift</code> 文件中实现 <code>ServiceBuilderInterface</code> ，因此可以根据需要设置服务。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBuilder</span>: <span class="title">ServiceBuilderInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> api: <span class="type">ApiServiceInterface</span> = &#123;</span><br><span class="line">        <span class="comment">// this can be the url of the development server</span></span><br><span class="line">        <span class="type">MyApiService</span>(baseUrl: <span class="string">"https://jsonplaceholder.typicode.com"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我通常有一个基本的 <code>service-interactor</code> 类，它将在初始化过程中接收所有服务。 因此，我可以轻松地交换任何东西。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceInteractor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> services: <span class="type">ServiceBuilderInterface</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(services: <span class="type">ServiceBuilderInterface</span> = <span class="type">App</span>.shared.services) &#123;</span><br><span class="line">        <span class="keyword">self</span>.services = services</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DI很不错，但是我不想重复太多，这就是为什么要为此属性提供默认值的原因，该属性位于我唯一的 <code>单例类App</code> 中。 我知道，单例是邪恶的，但是我已经在这里有了一个反模式，所以再引入一个并没有关系，对吗？🤔</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> services = <span class="type">ServiceBuilder</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - singleton</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">App</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// do nothing...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - api</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.services.setup()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要进行测试，此设置非常有用。 如果要测试一个 <code>interactor</code> ，则可以简单地模拟所有服务。 它也很干净，因为你可以像这样在 <code>interactor</code> 中访问方法：<code>self.services.api.todos（）</code> 。</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以对模块应用相同的模式，例如，你可以拥有一个实现 <code>ModuleBuilderInterface</code> 的 <code>ModuleBuilder</code> ，并且所有 <code>routers</code> 都可以通过 <code>DI</code> 来拥有它们，因此你不必使用构建就从头开始初始化所有内容 模块的功能。 😉</p></blockquote></br><h1 id="对象，模型，实体，…是什么？"><a href="#对象，模型，实体，…是什么？" class="headerlink" title="对象，模型，实体，…是什么？"></a><strong>对象，模型，实体，…是什么？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于命名约定的一点建议（我一直都将它们用作后缀）：</p><ul><li>Object</li><li>Entity</li><li>Model</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我的字典中，对象始终是 ··· ，它仅存在于服务层中。 这是一个愚蠢的傻子，没有比提供一个不错的 <code>Swiftish API</code> 多的目的。 这意味着你不必处理 <code>JSON对象</code> 或类似的疯狂对象，但是你可以直接使用这些对象，通常很高兴拥有此功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>实体</code> 与 <code>VIPER模块</code> 相关。 其目的是充当可在视图， <code>interactor</code> ， <code>presenter</code> ， <code>router</code> 之间传递的通信对象，或充当另一个模块的参数。 它可以封装模块所需的本地内容。 这意味着，如果服务层（可能是 <code>DTO</code> ）中的某些内容发生变化，则你的模块将能够工作，则只需对齐 <code>interactor</code> 即可。 😬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模型是指视图模型，它是我在 <code>UICollectionView</code> 类之上的基于 <code>组件</code> 的 <code>UI</code> 构建方法的一部分。 如果你想了解更多信息，则应该查看链接，其语法与 <code>SwiftUI</code> 非常相似，但显然不那么高级。 总之，模型始终具有呈现视图所需的数据，仅此而已。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我希望这篇小文章能帮助你更好地构建应用程序。 由于你必须设计应用程序，因此 <code>VIPER</code> 有时可能会遇到很多问题。 使用这类服务是分离所有不同的API连接，传感器等的好方法，最后请记住：<br><code>并非所有内容都是 VIPER模块 。</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <a href="https://github.com/theswiftdev/tutorials" target="_blank" rel="noopener"><strong><em><code>GitHub</code></em></strong></a> 上的下载本文的源文件。👏</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用VIPER构建SwiftUI Apps？</title>
      <link href="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VIPER%E6%9E%84%E5%BB%BASwiftUI%20Apps%EF%BC%9F/"/>
      <url>/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VIPER%E6%9E%84%E5%BB%BASwiftUI%20Apps%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这篇文章中，我将向你展示如何在真实的 <code>iOS应用程序</code> 示例中将 <code>SwiftUI</code> 与 <code>VIPER架构</code> 结合起来。</p></br><h1 id="SwiftUI-初学者"><a href="#SwiftUI-初学者" class="headerlink" title="SwiftUI-初学者"></a><strong>SwiftUI-初学者</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网上确实有成百上千的 <code>SwiftUI</code> 教程，但是我只能找到一两个专门针对现实用例的东西，而不是像在 <code>SwiftUI</code> 中配置/制作X这样的较小细节。！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对 <code>SwiftUI</code> 也有自己的 “挣扎” ，因为我的集合视图框架的结构与编写 <code>SwiftUI</code> 代码的方式完全相同。😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，我从零开始就知道会有大量新的 <code>SwiftUI</code> 教程到来，并且每个人都会对新的声明性 <code>UI框架</code> 大肆宣传，但是老实说，我已经有了通用的工具包。这就是为什么我不想写它。坦率地说， 比起 <code>SwiftUI</code> 更喜欢 <code>Combine</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终，因为到底是什么让我们尝试了新事物，并且我对 <code>SwiftUI</code> 如何适合我的应用程序构建方法感到好奇，所以我开始根据这些视图创建新的 <code>VIPER模板</code> 。我还想使用最新的新框架制作一个有用的，可扩展的，模块化的实际应用示例。 😛</p><a id="more"></a></br><h1 id="了解现代VIPER架构"><a href="#了解现代VIPER架构" class="headerlink" title="了解现代VIPER架构"></a><strong>了解现代VIPER架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我在过去两年中一直使用 <code>VIPER架构</code> 。 有人说“这太复杂了”或“这不适合小型团队”。 我只能告诉他们一个字：扯！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我相信我已经创建了一种现代且相对简单的模式，几乎可以用于任何东西。得益于简洁的架构和 <code>SOLID原理</code> ，学习 <code>VIPER</code> 肯定会提高你的代码质量。你将更好地了解较小的部分如何协同工作并相互交流。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;孤立的较小组件可以加快开发速度，因为你只需一次做一点工作，而且你可以为特定的事物创建测试，这对于可测试性和代码覆盖率来说是一个巨大的胜利（你不必运行你的应用程序始终都在运行，如果你想测试某些东西，则可以使用你只需要的模块）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我通常使用一个非常简单的代码生成器来启动新模块，这样我可以节省很多时间。如果你必须独自处理项目，则模块生成器和预定义的结构甚至可以为你节省更多时间。而且，如果遵循基本 <code>VIPER规则</code> ，你真的不会弄乱搞乱项目结构。 ⏰</p></br><h1 id="VIPER到底是什么？"><a href="#VIPER到底是什么？" class="headerlink" title="VIPER到底是什么？"></a><strong>VIPER到底是什么？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你以前从未听说过 <code>VIPER</code> ，首先应该知道 <code>VIPER模块</code> 包含以下组件：</p><ul><li><strong>Vi</strong>ew = UIViewController子类或SwiftUI视图</li><li><strong>I</strong>nteractor = 以正确的格式提供所需的数据</li><li><strong>P</strong>resenter = 独立于UI的业务逻辑（具体操作）</li><li><strong>E</strong>ntity = 数据对象（有时模块中不存在）</li><li><strong>R</strong>outer = 建立视图控制器层次结构（显示，显示，关闭等）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这些文件旁边，我总是有一个模块文件，其中我定义了一个模块构建器，该构建器从上面的组件中构建了整个组件，在该文件中，我还定义了特定于模块的协议。 我通常将这些协议称为接口，它们使使用依赖注入可以替换任何组件成为可能。 这样，我们可以在单元测试中使用模拟对象来测试任何东西。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有人说带有 <code>Builder</code> 的 <code>VIPER模块</code> 称为 <code>VIPER/B</code>。 我认为模块文件是存储模块构建器对象，模块接口和模块委托（如果需要的话）的理想场所。</p></blockquote></br><h1 id="面向协议的VIPER架构"><a href="#面向协议的VIPER架构" class="headerlink" title="面向协议的VIPER架构"></a><strong>面向协议的VIPER架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，关键是连接 <code>View-Interactor-Presenter-Router</code> 的6个主要协议。 这些协议确保 <code>VIPER组件</code> 看不到超出要求的内容。 🐛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">View</span>-to-<span class="type">Presenter</span></span><br><span class="line"><span class="type">Presenter</span>-to-<span class="type">View</span></span><br><span class="line"></span><br><span class="line"><span class="type">Router</span>-to-<span class="type">Presenter</span></span><br><span class="line"><span class="type">Presenter</span>-to-<span class="type">Router</span></span><br><span class="line"></span><br><span class="line"><span class="type">Interactor</span>-to-<span class="type">Presenter</span></span><br><span class="line"><span class="type">Presenter</span>-to-<span class="type">Interactor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Module</span></span><br><span class="line"># ---</span><br><span class="line">builds up pointers and returns a <span class="type">UIViewController</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">View</span> implements <span class="type">View</span>-to-<span class="type">Presenter</span></span><br><span class="line"># ---</span><br><span class="line">strong presenter <span class="keyword">as</span> <span class="type">Presenter</span>-to-<span class="type">View</span>-interface</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Presenter</span> implements <span class="type">Presenter</span>-to-<span class="type">Router</span>, <span class="type">Presenter</span>-to-<span class="type">Interactor</span>, <span class="type">Presenter</span>-to-<span class="type">View</span></span><br><span class="line"># ---</span><br><span class="line">strong router <span class="keyword">as</span> <span class="type">Router</span>-to-<span class="type">Presenter</span>-interface</span><br><span class="line">strong interactor <span class="keyword">as</span> <span class="type">Interactor</span>-to-<span class="type">Presenter</span>-interface</span><br><span class="line"><span class="keyword">weak</span> view <span class="keyword">as</span> <span class="type">View</span>-to-<span class="type">Presenter</span>-interface</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Interactor</span> implements <span class="type">Interactor</span>-to-<span class="type">Presenter</span></span><br><span class="line"># ---</span><br><span class="line"><span class="keyword">weak</span> presenter <span class="keyword">as</span> <span class="type">Presenter</span>-to-<span class="type">Interactor</span>-interface</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Router</span> implemenents <span class="type">Presenter</span>-to-<span class="type">Router</span></span><br><span class="line"># ---</span><br><span class="line"><span class="keyword">weak</span> presenter <span class="keyword">as</span> <span class="type">Presenter</span>-to-<span class="type">Router</span>-interface</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，视图（可以是 <code>UIViewController</code> 子类）牢固地保持了 <code>presenter</code> ，并且 <code>presenter</code> 将保留 <code>interactor</code> 和 <code>router</code> 类。 其他所有东西都是弱指针，因为我们不喜欢持有。 乍一看似乎有些复杂，但是在编写了最初的几个模块之后，你将发现将逻辑组件彼此分离是多么的好。 🐍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，并非所有内容都是 <code>VIPER模块</code> 。 不要尝试将你的 <code>API通信层</code> 或 <code>CoreLocation服务</code> 编写为模块，因为这类东西是独立的，例如：服务。 我将在下一篇文章中介绍它们，但现在，我们仅关注 <code>VIPER模块</code> 的剖析。</p></br><h1 id="Swift-5中的VIPER实现"><a href="#Swift-5中的VIPER实现" class="headerlink" title="Swift 5中的VIPER实现"></a><strong>Swift 5中的VIPER实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你准备好编写一些 <code>Swift</code> 代码了吗？ 好吧，让我们创建一些通用的 <code>VIPER接口</code> ，以后可以扩展它们，不要担心不会那么难。 😉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - interfaces</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">RouterPresenterInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">InteractorPresenterInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">PresenterRouterInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">PresenterInteractorInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">PresenterViewInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ViewPresenterInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - viper</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">RouterInterface</span>: <span class="title">RouterPresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">PresenterRouter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">PresenterRouter!</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">InteractorInterface</span>: <span class="title">InteractorPresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">PresenterInteractor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">PresenterInteractor!</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">PresenterInterface</span>: <span class="title">PresenterRouterInterface</span> &amp; <span class="title">PresenterInteractorInterface</span> &amp; <span class="title">PresenterViewInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">RouterPresenter</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">InteractorPresenter</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">ViewPresenter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> router: <span class="type">RouterPresenter!</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> interactor: <span class="type">InteractorPresenter!</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> view: <span class="type">ViewPresenter!</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ViewInterface</span>: <span class="title">ViewPresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">PresenterView</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">PresenterView!</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">EntityInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ModuleInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">View</span> <span class="keyword">where</span> <span class="type">View</span>: <span class="type">ViewInterface</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Presenter</span> <span class="keyword">where</span> <span class="type">Presenter</span>: <span class="type">PresenterInterface</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Router</span> <span class="keyword">where</span> <span class="type">Router</span>: <span class="type">RouterInterface</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Interactor</span> <span class="keyword">where</span> <span class="type">Interactor</span>: <span class="type">InteractorInterface</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">assemble</span><span class="params">(view: View, presenter: Presenter, router: Router, interactor: Interactor)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">ModuleInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">assemble</span><span class="params">(view: View, presenter: Presenter, router: Router, interactor: Interactor)</span></span> &#123;</span><br><span class="line">        view.presenter = (presenter <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">View</span>.<span class="type">PresenterView</span>)</span><br><span class="line"></span><br><span class="line">        presenter.view = (view <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Presenter</span>.<span class="type">ViewPresenter</span>)</span><br><span class="line">        presenter.interactor = (interactor <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Presenter</span>.<span class="type">InteractorPresenter</span>)</span><br><span class="line">        presenter.router = (router <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Presenter</span>.<span class="type">RouterPresenter</span>)</span><br><span class="line"></span><br><span class="line">        interactor.presenter = (presenter <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Interactor</span>.<span class="type">PresenterInteractor</span>)</span><br><span class="line"></span><br><span class="line">        router.presenter = (presenter <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Router</span>.<span class="type">PresenterRouter</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关联类型只是特定类型的占位符，通过使用通用接口设计，我可以使用通用模块接口扩展来组装模块，如果缺少某些协议，则应用程序将崩溃，就像我尝试初始化不良模块一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我喜欢这种方法，因为它使我省去了许多样板模块构建器代码。 同样，所有内容都将具有基本协议，因此我可以以一种真正整洁的面向协议的方式扩展任何内容。 无论如何，如果你不了解泛型没什么大不了的，那么在实际的模块实现中，你将几乎无法满足它们。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么实际模块的代码如何？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TodoModule.swift</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - router</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoRouterPresenterInterface</span>: <span class="title">RouterPresenterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - presenter</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoPresenterRouterInterface</span>: <span class="title">PresenterRouterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoPresenterInteractorInterface</span>: <span class="title">PresenterInteractorInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoPresenterViewInterface</span>: <span class="title">PresenterViewInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - interactor</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoInteractorPresenterInterface</span>: <span class="title">InteractorPresenterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - view</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoViewPresenterInterface</span>: <span class="title">ViewPresenterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - module builder</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoModule</span>: <span class="title">ModuleInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">View</span> = <span class="type">TodoView</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Presenter</span> = <span class="type">TodoPresenter</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Router</span> = <span class="type">TodoRouter</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Interactor</span> = <span class="type">TodoInteractor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="type">View</span>()</span><br><span class="line">        <span class="keyword">let</span> interactor = <span class="type">Interactor</span>()</span><br><span class="line">        <span class="keyword">let</span> presenter = <span class="type">Presenter</span>()</span><br><span class="line">        <span class="keyword">let</span> router = <span class="type">Router</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.assemble(view: view, presenter: presenter, router: router, interactor: interactor)</span><br><span class="line"></span><br><span class="line">        router.viewController = view</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TodoPresenter.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoPresenter</span>: <span class="title">PresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> router: <span class="type">TodoRouterPresenterInterface!</span></span><br><span class="line">    <span class="keyword">var</span> interactor: <span class="type">TodoInteractorPresenterInterface!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">TodoViewPresenterInterface!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TodoPresenter</span>: <span class="title">TodoPresenterRouterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TodoPresenter</span>: <span class="title">TodoPresenterInteractorInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TodoPresenter</span>: <span class="title">TodoPresenterViewInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TodoInteractor.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoInteractor</span>: <span class="title">InteractorInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> presenter: <span class="type">TodoPresenterInteractorInterface!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TodoInteractor</span>: <span class="title">TodoInteractorPresenterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TodoRouter.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoRouter</span>: <span class="title">RouterInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> presenter: <span class="type">TodoPresenterRouterInterface!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> viewController: <span class="type">UIViewController?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TodoRouter</span>: <span class="title">TodoRouterPresenterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TodoView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoView</span>: <span class="title">UIViewController</span>, <span class="title">ViewInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">TodoPresenterViewInterface!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TodoView</span>: <span class="title">TodoViewPresenterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>VIPER模块</code> 由五个文件组成，与我的旧方法相比，这是一个巨大的改进（我为单个模块使用了9个文件，这仍然比2000行代码的大规模视图控制器要好，但是是的，它的文件很多 …😂）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要，可以使用 <a href="https://github.com/corekit/viper" target="_blank" rel="noopener"><strong><em><code>VIPER协议库</code></em></strong></a> ，也可以将这些接口复制并粘贴到你的项目中。 我还有一个完全用 <code>Swift</code> 编写的 <a href="https://github.com/corekit/vipera" target="_blank" rel="noopener"><strong><em><code>VIPER模块生成器</code></em></strong></a> ，它可以基于此模板生成模块（或者你可以自己创建）。</p><br><h1 id="如何创建VIPER接口？"><a href="#如何创建VIPER接口？" class="headerlink" title="如何创建VIPER接口？"></a><strong>如何创建VIPER接口？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一起看一个示例流程，请考虑以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoRouterPresenterInterface</span>: <span class="title">RouterPresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dismiss</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - presenter</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoPresenterRouterInterface</span>: <span class="title">PresenterRouterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoPresenterInteractorInterface</span>: <span class="title">PresenterInteractorInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didLoadWelcomeText</span><span class="params">(<span class="number">_</span> text: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoPresenterViewInterface</span>: <span class="title">PresenterViewInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ready</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - interactor</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoInteractorPresenterInterface</span>: <span class="title">InteractorPresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startLoadingWelcomeText</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - view</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoViewPresenterInterface</span>: <span class="title">ViewPresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setLoadingIndicator</span><span class="params">(visible: Bool)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setWelcomeText</span><span class="params">(<span class="number">_</span> text: String)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;视图在某个时间点在 <code>presenter</code> 上调用 <code>ready（）</code> ，因此 <code>presenter</code> 可以开始。首先，它通过调用 <code>setLoadingIndicator（visible：true）</code> 告诉视图显示加载指示符，然后要求 <code>interactor</code> 异步加载start欢迎文本<code>(startLoadingWelcomeText（）)</code>。数据返回到 <code>interactor</code> 之后，它可以使用 <code>didLoadWelcomeText（“”）</code> 方法通知 <code>presenter</code> 。现在， <code>presenter</code> 可以使用相同的方法 <code>setLoadingIndicator（visible：false）</code> 和 <code>false</code> 参数告诉视图隐藏加载指示器，并使用<code>setWelcomeText（“”）</code> 显示欢迎文本。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个用例是有人点击视图上的按钮以关闭控制器。该视图在 <code>presenter</code> 上调用close（）， <code>presenter</code> 只需在 <code>router</code> 上调用 <code>dismiss（）</code> 。在要求 <code>router</code> 关闭视图控制器之前，演示者还可以做其他事情（例如清理一些资源）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我希望你能得到例子，自己动手做所有的事情，这是一个很好的练习任务。当然，你可以利用区块，承诺或全新的 <code>Combine框架</code> 使你的生活更轻松。例如，你可以在某些异步数据加载完成后自动通知演示者。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，既然你对现代 <code>VIPER架构</code> 有了基本的了解，就可以讨论如何用 <code>SwiftUI</code> 替换传统的 <code>ViewController</code> 子类。</p><br><h1 id="如何设计基于VIPER的SwiftUI应用程序？"><a href="#如何设计基于VIPER的SwiftUI应用程序？" class="headerlink" title="如何设计基于VIPER的SwiftUI应用程序？"></a><strong>如何设计基于VIPER的SwiftUI应用程序？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SwiftUI</code> 是相当独特的。 视图是结构，因此我们的通用 <code>VIPER协议</code> 需要进行一些更改才能使所有功能正常工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你要做的第一件事是摆脱 <code>ViewPresenterInterface</code> 协议。 接下来，你可以从 <code>PresenterInterface</code> 中删除 <code>view属性</code> ，因为我们将使用可观察的 <code>view-model模式</code> 来自动更新数据视图。 最后的修改是你必须从 <code>ModuleInterface</code> 扩展内的 <code>assemble函数</code> 的默认实现中删除 <code>view</code> 参数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我提到了一个视图模型，让我们做一个。 为了简单起见，我将使用 <code>Bool</code> 来指示是否出了问题，但是你可以使用其他视图，也可以使用独立的 <code>VIPER模块</code> 来显示 <code>提示消息</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Combine</span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoViewModel</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> objectWillChange = <span class="type">ObservableObjectPublisher</span>()</span><br><span class="line"></span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> error: <span class="type">Bool</span> = <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.objectWillChange.send()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> todos: [<span class="type">TodoEntity</span>] = [] &#123;</span><br><span class="line">       <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.objectWillChange.send()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此类符合 <code>ObservableObject</code> ，它使 <code>SwiftUI</code> 可以检查更新并在发生某些更改时重新呈现视图层次结构。 你只需要具有 <code>ObservableObjectPublisher</code> 类型的属性，并从字面上发送一条消息（如果发生某些更改会触发此消息，从而触发视图中的自动更新）。 🔥</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>TodoEntity</code> 只是一个基本结构，它遵循一堆协议，例如 <code>SwiftUI</code> 的新 <code>Identifiable</code> ，因为我们希望在列表中显示实体。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TodoEntity</span>: <span class="title">EntityInterface</span>, <span class="title">Codable</span>, <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> completed: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基本的 <code>SwiftUI</code> 视图仍将实现 <code>ViewInterface</code> ，并且将具有对 <code>presenter</code> 的引用。 我们的 <code>view-model属性</code> 还将在这里使用 <code>@ObservedObject</code> 属性包装器进行标记。 到目前为止的代码是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TodoView</span>: <span class="title">ViewInterface</span>, <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">TodoPresenterViewInterface!</span></span><br><span class="line"></span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">TodoViewModel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"SwiftUI ❤️ VIPER"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>presenter</code> 还将拥有一个弱的 <code>var viewModel：TodoViewModel！</code> 参考以能够更新视图模型。 好像我们通过使用视图模型在视图和 <code>presenter</code> 之间存在双向通信流。 在我看来很好。 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们想在视图层次结构中传递一些数据，我们还可以使用全新的 <code>@EnvironmentObject</code> 。 你只需在环境对象中实现与对视图模型相同的观察协议即可。 例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> Combine</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoEnvironment</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> objectWillChange = <span class="type">ObservableObjectPublisher</span>()</span><br><span class="line"></span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> title: <span class="type">String</span> = <span class="string">"Todo list"</span> &#123;</span><br><span class="line">       <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.objectWillChange.send()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，让我向你展示如何实现模块构建器，因为这非常棘手。 你必须使用新的通用 <code>UIHostingController</code> ，这是一个 <code>UIViewController</code> 子类，因此可以在完成模块构建后将其返回。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoModule</span>: <span class="title">ModuleInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">View</span> = <span class="type">TodoView</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Presenter</span> = <span class="type">TodoPresenter</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Router</span> = <span class="type">TodoRouter</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Interactor</span> = <span class="type">TodoInteractor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> presenter = <span class="type">Presenter</span>()</span><br><span class="line">        <span class="keyword">let</span> interactor = <span class="type">Interactor</span>()</span><br><span class="line">        <span class="keyword">let</span> router = <span class="type">Router</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> viewModel = <span class="type">TodoViewModel</span>()</span><br><span class="line">        <span class="keyword">let</span> view = <span class="type">View</span>(presenter: presenter, viewModel: viewModel)</span><br><span class="line">            .environmentObject(<span class="type">TodoEnvironment</span>())</span><br><span class="line">        presenter.viewModel = viewModel</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.assemble(presenter: presenter, router: router, interactor: interactor)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">UIHostingController</span>(rootView: view)</span><br><span class="line">        router.viewController = viewController</span><br><span class="line">        <span class="keyword">return</span> viewController</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从现在开始放在一起只是小菜一碟。 如果需要，你可以挑战自己构建东西，而无需下载 <a href="https://github.com/theswiftdev/tutorials/tree/master/iOS/VIPERAndSwiftUI" target="_blank" rel="noopener"><strong><code>最终项目</code></strong></a>。 🍰</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> SwiftUI </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> SwiftUI </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>掌握VIPER架构</title>
      <link href="/%E6%8E%8C%E6%8F%A1VIPER%E6%9E%B6%E6%9E%84/"/>
      <url>/%E6%8E%8C%E6%8F%A1VIPER%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>Swift</code> 使用一些 <code>面向协议</code> 的编程技术来掌握 <code>VIPER架构设计模式</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在写了关于 <a href="http://www.xuebaonline.com/%E9%80%82%E7%94%A8%E4%BA%8EiOS%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84VIPER%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"><strong><em><code>VIPER的最佳实践</code></em></strong></a> 之后，我对代码库进行了一些更改。 我已经想到了这些想法，但是却没有足够的时间正确地实施它们。 </p></br><h1 id="VIPER协议"><a href="#VIPER协议" class="headerlink" title="VIPER协议"></a><strong>VIPER协议</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我希望每个 <code>模块组件</code> 都有一个通用接口。 这就是为什么我为以下内容创建 <code>简单协议</code> 的原因：</p><ul><li><strong>View</strong></li><li><strong>Interactor</strong></li><li><strong>Presenter</strong></li><li><strong>Entity</strong></li><li><strong>Router</strong></li><li><strong>Module</strong></li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，通过这种方式，我的 <code>路由器对象</code> 正在实现 <code>路由器协议</code> ，因此，如果在其上进行扩展，则每一个都将具有该特定功能。 这是一个很小但非常令人愉快的功能，使我的模块比以前更强大。 老实说，我从一开始就应该拥有这种功能，但是无论如何从现在开始就应该是这样。 😬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此举意味着将我的 <code>VIPER协议</code> 组织到一个自定义框架中，因此我使用这些组件创建了一个。 你可以在 <a href="https://github.com/CoreKit/VIPER" target="_blank" rel="noopener"><strong><em><code>github</code></em></strong></a> 上找到它，这是一个非常基本的应用程序，可以随时使用，只需在项目中导入 <code>VIPER</code> 。</p><br><h1 id="模块协议"><a href="#模块协议" class="headerlink" title="模块协议"></a><strong>模块协议</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自从我使用 <code>VIPER</code> 以来，它非常渴望实现一个自定义模块，以在 <code>iOS</code> 上呈现系统默认警报消息。 你知道 <code>UIAlertController</code> 是我正在谈论的那个。 </p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们为什么不为路由器创建协议，以便可以在其他所有路由器上实现该协议，也可以简单地在它们上调用 <code>show（alert :)</code> ？</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我喜欢这种方法，因此我们已经建立了它。 原来，它真是太棒了。 因此，我们为模块路由器引入了新协议，实现了默认协议扩展，并且路由器现在能够显示错误消息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，你也可以将相同的模式用于许多其他（相似）的事物。 基本实现如下所示，希望你能理解。 💡</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VIPER</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlertModule</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AlertModuleRouter</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(alert: AlertEntity)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AlertModuleRouter</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">Router</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(alert: AlertEntity)</span></span> &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - other module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyModuleRouter</span>: <span class="title">Router</span>, <span class="title">AlertModuleRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// show(alert:) is now available from this router too</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，该技术也可以用于其他 <code>VIPER组件</code> ，实现起来非常容易，并且 <code>面向协议</code> 的方法为我们带来了巨大的方便。 🏆</p></br><h1 id="Presenter-to-presenter-interactions"><a href="#Presenter-to-presenter-interactions" class="headerlink" title="Presenter to presenter interactions"></a><strong>Presenter to presenter interactions</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我也对参与模块通信流程中的委托实现的位置改变了想法。 在上一篇文章中，我告诉你我将委托存储在路由器上，但是后来我意识到委托主要与业务逻辑有关，因此我只是将它们移到了 <code>presenter层</code> 。 🤷‍♂️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VIPER</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AModulePresenterDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didDoSomething</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AModule</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(with delegate: AModulePresenterDelegate? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="comment">// insert classic viper stuff here</span></span><br><span class="line"></span><br><span class="line">        presenter.delegate = delegate</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AModulePresenter</span>: <span class="title">Presenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">someAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate?.didDoSomething()</span><br><span class="line">        <span class="keyword">self</span>.router?.dismiss()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - other module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BModulePresenter</span>: <span class="title">Presenter</span>, <span class="title">AModulePresenterDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didDoSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello from module A!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，你可以跳过整个路由器层，并且所有与业务相关的逻辑都将在 <code>presenter层</code> 中实现，这应该是唯一的方法。 🤪</p></br><h1 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a><strong>Entities</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了服务层之外，有时使用带有一些额外的元数据的实体包装对于模型对象是非常有用的。 这就是为什么我也创建了一个实体协议，并开始在我的模块中使用它的原因。 例如，可以打开链接的 <code>Web视图模块</code> 可以具有带有标题和内容 <code>url</code> 属性的 <code>WebViewEntity</code> 。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VIPER</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlertEntity</span>: <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的示例 <code>提示信息模块</code> 可以将 <code>AlertEntity</code> 与某些属性一起使用，这些属性可以定义标题，消息或按钮。 这样，你就不必真正考虑将这些对象放在哪里，因为它们是真正的 <code>VIPER实体</code> 。</p></br><h1 id="IO协议"><a href="#IO协议" class="headerlink" title="IO协议"></a><strong>IO协议</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我想尝试的想法，但是基本概念有点像我想为 <code>VIPER模块</code> 层分离输入和输出协议。 同样，这种 IO 差异也可以反映在服务层上（也许将来服务层中的整个对象“ mess”将用作IO实体），一团糟，我的意思是，其中可能存在太多对象 服务/对象目录，因此这意味着它们也可以按模块（也称为实体）进行分组。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，我正在考虑像 <code>RequestEntity</code> ， <code>ResponseEntity</code> 这样的服务通信，对于 <code>VIPER层</code> 通信，我可以想象两个单独的协议，例如。  <code>PresenterInput</code> ， <code>PresenterOutput</code> 。 我们将看到，但是乍一看，这似乎是一件过度设计的事情。</p><br><h1 id="VIPER与"><a href="#VIPER与" class="headerlink" title="VIPER与[*]"></a><strong>VIPER与[*]</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有！请不要认为x优于y。架构和设计模式是简单的工具，可用于使你的生活更轻松。如果你不喜欢x，则应尝试y，但不要怪x，因为那是你的个人看法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我目前最喜欢的架构是 <code>VIPER</code> ，那又如何呢？也许在一两年之内，我会爱上反应式编程而发疯。真的重要吗？我不这么认为。过去，我已经学习并尝试了很多东西，甚至不记得了。 🧠</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适用于iOS开发人员的VIPER最佳实践</title>
      <link href="/%E9%80%82%E7%94%A8%E4%BA%8EiOS%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84VIPER%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/%E9%80%82%E7%94%A8%E4%BA%8EiOS%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84VIPER%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本教程中，我将向你展示有关如何构建完全基于 <code>Swift</code> 的基于 <code>VIPER</code> 的 <code>iOS</code> 应用程序的完整指南。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章有点过时了，请期待很快会有新版本…</p></blockquote></br><h1 id="VIPER入门"><a href="#VIPER入门" class="headerlink" title="VIPER入门"></a><strong>VIPER入门</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，你应该阅读 <a href="http://www.xuebaonline.com/iOS%20VIPER%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"><strong><em><code>关于VIPER架构本身的文章（理论上更深入）</code></em></strong></a>。 这是一个相当不错的文章，解释了所有 <code>VIPER组件</code> 和 <code>内存管理</code> 。  ⭐️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，那篇文章的问题在于，我还没有向你展示真正的技术细节。 用于实现 <code>VIPER</code> 的 <code>Swift</code> 代码。 在使用该体系结构进行了整整一年的项目之后，现在我终于可以与你分享我所有的最佳实践。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们开始创建一个全新的 <code>Xcode</code> 项目，使用单视图应用程序模板，将该项目命名（  <code>VIPER最佳实践</code> ），使用 <code>Swift</code> ，现在你准备好进行下一步，以制作出色的 <code>“企业级” iOS 应用</code> 。</p><a id="more"></a></br><h1 id="生成VIPER模块"><a href="#生成VIPER模块" class="headerlink" title="生成VIPER模块"></a><strong>生成VIPER模块</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;永远不要手动创建模块，始终使用代码生成器，因为这是一项重复性的任务，这很无聊，而且你应该专注于比制作样板代码更重要的事情。 你可以使用轻量级模块生成器：</p><p><a href="https://github.com/binarybirds/swift-template" target="_blank" rel="noopener"><strong><em><code>VIPERA</code></em></strong></a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需从 <code>github</code> 下载或克隆存储库即可。你可以通过运行<code>swift run install --with-templates</code> 安装二进制工具。这会将 <code>vipera</code> 应用程序安装在 <code>/usr/local/bin/</code> 下，并将基本模板安装在 <code>〜/.vipera</code> 目录下。你也可以使用自己的模板，但是现在我将使用默认模板。 🔨</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我通常从名为 <code>Main</code> 的模块开始，这是应用程序的根视图。你可以通过在项目目录中调用 <code>vipera Main</code> 来生成它，因此生成器可以为模板文件中的标题注释使用正确的项目名称。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过应用我的 <code>Xcode</code> 约定来稍微整理项目结构，这意味着资源将转到 <code>Assets文件夹</code> ，所有 <code>Swift</code> 文件都将移至 <code>Sources</code> 目录。如今，我还更改了 <code>AppDelegate.swift</code>文件，并为 <code>UIApplicationDelegate</code> 协议进行了单独的扩展。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Sources</code> 目录下创建一个 <code>Modules组</code> （也有一个物理文件夹），并将新生成的 <code>Main模块</code> 移到该组下。现在，通过从 <code>Assets文件夹</code> 中为当前目标选择 <code>Info.plist</code> 文件来解决项目问题。还要删除 <code>Main Interface</code> ，然后你可以安全地删除 <code>Main.storyboard</code> 和 <code>ViewController.swift</code> 文件，因为我们根本不需要它们。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>AppDelegate.swift</code> 文件中，你必须将 <code>Main模块</code> 的视图控制器设置为根视图控制器，因此它看起来应该像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDelegate</span>: <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication,</span></span></span><br><span class="line"><span class="function"><span class="params">                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class="keyword">Any</span>]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.window = <span class="type">UIWindow</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line">        <span class="keyword">self</span>.window?.rootViewController = <span class="type">MainModule</span>().buildDefault()</span><br><span class="line">        <span class="keyword">self</span>.window?.makeKeyAndVisible()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恭喜，你已经创建了第一个 <code>VIPER模块</code> ！ 🎉</p></br><h1 id="UITabBarController-amp-VIPER"><a href="#UITabBarController-amp-VIPER" class="headerlink" title="UITabBarController &amp; VIPER"></a><strong>UITabBarController &amp; VIPER</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于在 <code>VIPER模块</code> 中使用 <code>UITabBarController</code> ，我有一个非常简单的解决方案。首先，让我们生成一些新模块，这些模块将成为 <code>Tabs</code> 。我将使用 <code>JSONPlaceholder服务</code> ，所以让我们为每个资源设想一个单独的选项卡：帖子，相册，照片，待办事项（具有相同的模块名称）。全部生成它们，然后将其移动到 <code>modules文件夹</code> 中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们再生成一个称为 <code>Home的模块</code> 。这将实现我们的 <code>UITabBarController</code> 。如果你愿意，可以将 <code>Main模块</code> 用于此目的，但我想保留该动画的目的，以便在加载屏幕和 <code>Home模块</code> 之间进行巧妙的转换（这完全取决于你的需求）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，我们要实现的主要逻辑是：主视图将通知 <code>presenter</code> 有关 <code>viewDidAppear</code> 事件的信息， <code>presenter</code> 将要求 <code>router</code> 显示 <code>Home模块</code> 。  <code>Home模块</code>  的视图将是 <code>UITabBarController</code> 的子类，它还将通知其 <code>presenter</code> 有关 <code>viewDidLoad</code> 的信息，并且 <code>presenter</code> 将使用其 <code>router</code> 请求适当的 <code>tabs</code> 。</p><p>这是没有接口的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainDefaultView</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">MainPresenter?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presenter?.viewDidAppear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainDefaultPresenter</span>: <span class="title">MainPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.router?.showHome()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainDefaultRouter</span>: <span class="title">MainRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showHome</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">HomeModule</span>().buildDefault()</span><br><span class="line">        <span class="keyword">self</span>.viewController?.present(viewController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HomeDefaultView</span>: <span class="title">HomeView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(<span class="number">_</span> viewControllers: [UIViewController])</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.viewControllers = viewControllers</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - Home module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HomeDefaultPresenter</span>: <span class="title">HomePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setupViewControllers</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> controllers = <span class="keyword">self</span>.router?.getViewControllers() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.view?.display(controllers)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HomeDefaultRouter</span>: <span class="title">HomeRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getViewControllers</span><span class="params">()</span></span> -&gt; [<span class="type">UIViewController</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="type">PostsModule</span>().buildDefault(),</span><br><span class="line">            <span class="type">AlbumsModule</span>().buildDefault(),</span><br><span class="line">            <span class="type">PhotosModule</span>().buildDefault(),</span><br><span class="line">            <span class="type">TodosModule</span>().buildDefault(),</span><br><span class="line">        ].<span class="built_in">map</span> &#123; <span class="type">UINavigationController</span>(rootViewController: $<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildDefault</span><span class="params">()</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        presenter.setupViewControllers()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“主页”模块构建器函数内部还有另外一行可触发 <code>presenter</code> 设置正确的视图控制器。 那只是因为在初始化过程完成之前调用了 <code>UITabBarController</code>   <code>viewDidLoad</code> 方法。 这种行为是完全没有加载的，但是我认为这是为了保持对视图引用。 😊</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，现在你在项目中有一个适当的选项卡栏，已集成为 <code>VIPER模块</code> 。 现在是时候从服务器中获取一些数据了，这是另一个重要的教训：不是所有的东西都是 <code>VIPER模块</code> 。</p></br><h1 id="Services-amp-Entities"><a href="#Services-amp-Entities" class="headerlink" title="Services &amp; Entities"></a><strong>Services &amp; Entities</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会注意到，我的模块中没有实体。 我通常将 <code>API</code> ， <code>CoreData</code> 和 <code>许多其他数据</code> 提供程序包装为服务。 这样，所有相关实体都可以被抽象化，因此可以轻松地替换服务（例如，使用模拟），并且我所有的 <code>interactors</code> 都可以通过协议定义使用该服务，而无需了解底层实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一件事是，如果我不得不处理异步代码，我总是使用 <a href="https://github.com/corekit/promises" target="_blank" rel="noopener"><strong><em><code>promise</code></em></strong></a> 库。 其背后的原因很简单：与使用回调和可选的结果元素相比，它更优雅。 你也应该学习 <code>promise</code> 。 因此，这是我围绕 <code>JSONPlaceholder API</code> 实现服务的一部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">posts</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Post</span>]&gt;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">comments</span><span class="params">(<span class="keyword">for</span> post: Post)</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Comment</span>]&gt;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">albums</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Album</span>]&gt;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">photos</span><span class="params">(<span class="keyword">for</span> album: Album)</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Photo</span>]&gt;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">todos</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Todo</span>]&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - entities</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> body: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - API implementation</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONPlaceholderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> baseUrl = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/"</span>)!</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Error</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> invalidStatusCode</span><br><span class="line">        <span class="keyword">case</span> emptyData</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">request</span>&lt;T&gt;<span class="params">(path: String)</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt; <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Decodable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> promise = <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">        <span class="keyword">let</span> url = baseUrl.appendingPathComponent(path)</span><br><span class="line">        <span class="built_in">print</span>(url)</span><br><span class="line">        <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">                promise.reject(error)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>, httpResponse.statusCode == <span class="number">200</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.reject(<span class="type">Error</span>.invalidStatusCode)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.reject(<span class="type">Error</span>.emptyData)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> model = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">T</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">                promise.fulfill(model)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> &#123;</span><br><span class="line">                promise.reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.resume()</span><br><span class="line">        <span class="keyword">return</span> promise</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">JSONPlaceholderService</span>: <span class="title">Api</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">posts</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Post</span>]&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.request(path: <span class="string">"posts"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，我在这里有一个模拟服务实现，因此我可以轻松地测试所需的一切。 如何在这些服务之间切换？ 好吧，我有一个共享的（单人-不要讨厌我，这是完全可以的）应用程序类，我主要将其用于样式设计，但我也将与依赖项注入 <code>（DI）</code> 相关的代码放在了那里。 这样，我可以为 <code>VIPER模块</code> 传递适当的服务对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">App</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> apiService: <span class="type">Api</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">JSONPlaceholderService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostsModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildDefault</span><span class="params">()</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="type">PostsDefaultView</span>()</span><br><span class="line">        <span class="keyword">let</span> interactor = <span class="type">PostsDefaultInteractor</span>(apiService: <span class="type">App</span>.shared.apiService)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - interactor</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostsDefaultInteractor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> presenter: <span class="type">PostsPresenter?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> apiService: <span class="type">Api</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(apiService: <span class="type">Api</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.apiService = apiService</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostsDefaultInteractor</span>: <span class="title">PostsInteractor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">posts</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Post</span>]&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.apiService.posts()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用其他100种方法来执行此操作，但是我目前更喜欢这种方法。 通过这种方式， <code>interactors</code> 可以直接使用一些额外的细节来调用服务，例如过滤器，订单，排序等。基本上，该服务只是端点周围的高级概念包装，并且 <code>interactors</code> 为该接口创建经过微调（更好）的 <code>API</code> 给 <code>presenter</code> 。</p></br><h1 id="promises"><a href="#promises" class="headerlink" title="promises"></a><strong>promises</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实施业务逻辑是 <code>presenter</code> 的任务。 我总是使用 <code>Promise</code> ，因此基本的 <code>Presenter</code> 实现只能异步加载一些内容并显示结果，否则错误（加上加载指示符）只有几行。 我一直在尝试通过在视图上使用相同的协议命名约定来实现三个基本的 <code>UI堆栈元素</code> （加载，数据，错误）。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在视图方面，我使用的是很好的旧的集合视图逻辑，这大大减少了我必须编写的代码量。 你可以采用传统方式，毕竟为表或集合视图实现一些数据源和委托方法并不是很多代码。 这是我的视图示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostsDefaultPresenter</span>: <span class="title">PostsPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view?.displayLoading()</span><br><span class="line">        <span class="keyword">self</span>.interactor?.posts()</span><br><span class="line">        .onSuccess(queue: .main) &#123; posts  <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.view?.display(posts)</span><br><span class="line">        &#125;</span><br><span class="line">        .onFailure(queue: .main) &#123; error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.view?.display(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - view</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostsDefaultView</span>: <span class="title">CollectionViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">PostsPresenter?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.title = <span class="string">"Posts"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presenter?.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostsDefaultView</span>: <span class="title">PostsView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">displayLoading</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"loading..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(<span class="number">_</span> posts: [Post])</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> grid = <span class="type">Grid</span>(columns: <span class="number">1</span>, margin: <span class="type">UIEdgeInsets</span>(all: <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.source = <span class="type">CollectionViewSource</span>(grid: grid, sections: [</span><br><span class="line">            <span class="type">CollectionViewSection</span>(items: posts.<span class="built_in">map</span> &#123; <span class="type">PostViewModel</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(<span class="number">_</span> error: Error)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>cell</code> 和 <code>ViewModel</code> 在 <code>VIPER模块</code> 之外，我倾向于将 <code>App文件夹</code> 专用于自定义应用程序特定的视图， <code>extensions</code> ， <code>view models</code> 等。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostCell</span>: <span class="title">CollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostViewModel</span>: <span class="title">CollectionViewViewModel</span>&lt;<span class="title">PostCell</span>, <span class="title">Post</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">config</span><span class="params">(cell: PostCell, data: Post, indexPath: IndexPath, grid: Grid)</span></span> &#123;</span><br><span class="line">        cell.textLabel.text = data.title</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">(data: Post, indexPath: IndexPath, grid: Grid, view: UIView)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> width = grid.width(<span class="keyword">for</span>: view, items: grid.columns)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: width, height: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没什么特别的，如果你想了解更多有关此集合视图架构的信息，可以看看这篇文章 <a href="http://www.xuebaonline.com/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><strong><em><code>掌握集合视图的教程</code></em></strong></a> 。</p><br><h1 id="模块通讯"><a href="#模块通讯" class="headerlink" title="模块通讯"></a><strong>模块通讯</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个重要的教训是学习如何在两个 <code>VIPER模块</code> 之间进行通信。 通常，我使用简单的变量-如果必须将信息发送回原始模块，则使用 <code>delegates</code> -在构建方法中传递。 我还将向你展示一个非常简单的示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostsDefaultRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> presenter: <span class="type">PostsPresenter?</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> viewController: <span class="type">UIViewController?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostsDefaultRouter</span>: <span class="title">PostsRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showComments</span><span class="params">(<span class="keyword">for</span> post: Post)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">PostDetailsModule</span>().buildDefault(with: post, delegate: <span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">self</span>.viewController?.show(viewController, sender: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostsDefaultRouter</span>: <span class="title">PostDetailsModuleDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toggleBookmark</span><span class="params">(<span class="keyword">for</span> post: Post)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.presenter?.toggleBookmark(<span class="keyword">for</span>: post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - details</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PostDetailsModuleDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toggleBookmark</span><span class="params">(<span class="keyword">for</span> post: Post)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostDetailsModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildDefault</span><span class="params">(with post: Post, delegate: PostDetailsModuleDelegate? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="type">PostDetailsDefaultView</span>()</span><br><span class="line">        <span class="keyword">let</span> interactor = <span class="type">PostDetailsDefaultInteractor</span>(apiService: <span class="type">App</span>.shared.apiService,</span><br><span class="line">                                                      bookmarkService: <span class="type">App</span>.shared.bookmarkService)</span><br><span class="line">        <span class="keyword">let</span> presenter = <span class="type">PostDetailsDefaultPresenter</span>(post: post)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostDetailsDefaultRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> presenter: <span class="type">PostDetailsPresenter?</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> viewController: <span class="type">UIViewController?</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">PostDetailsModuleDelegate?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostDetailsDefaultRouter</span>: <span class="title">PostDetailsRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toggleBookmark</span><span class="params">(<span class="keyword">for</span> post: Post)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate?.toggleBookmark(<span class="keyword">for</span>: post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostDetailsDefaultPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> router: <span class="type">PostDetailsRouter?</span></span><br><span class="line">    <span class="keyword">var</span> interactor: <span class="type">PostDetailsInteractor?</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">PostDetailsView?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> post: <span class="type">Post</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(post: <span class="type">Post</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.post = post</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostDetailsDefaultPresenter</span>: <span class="title">PostDetailsPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reload</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view?.setup(with: <span class="keyword">self</span>.interactor!.bookmark(<span class="keyword">for</span>: <span class="keyword">self</span>.post))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//display loading...</span></span><br><span class="line">        <span class="keyword">self</span>.interactor?.comments(<span class="keyword">for</span>: <span class="keyword">self</span>.post)</span><br><span class="line">        .onSuccess(queue: .main) &#123; comments <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.view?.display(comments)</span><br><span class="line">        &#125;</span><br><span class="line">        .onFailure(queue: .main) &#123; error <span class="keyword">in</span></span><br><span class="line">            <span class="comment">//display error...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toggleBookmark</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.router?.toggleBookmark(<span class="keyword">for</span>: <span class="keyword">self</span>.post)</span><br><span class="line">        <span class="keyword">self</span>.view?.setup(with: <span class="keyword">self</span>.interactor!.bookmark(<span class="keyword">for</span>: <span class="keyword">self</span>.post))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>builder</code> 方法中，我可以访问 <code>VIPER模块</code> 的每个组件，因此我可以将变量简单地传递到指定的位置（对于 <code>delegates</code> 参数也是如此）。 我通常在 <code>presenter</code> 上设置输入变量，在 <code>router</code> 上设置 <code>delegates</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常是 <code>presenter</code> 需要原始模块中的数据，我喜欢将 <code>delegates</code> 存储在 <code>router</code> 上，因为如果导航模式发生更改，我根本就不需要更改 <code>presenter</code> 。 这只是个人喜好，但我喜欢代码中的风格。 在一篇文章中很难写下这些东西，所以我建议从 <a href="https://github.com/theswiftdev/tutorials" target="_blank" rel="noopener"><strong><em><code>github</code></em></strong></a> 下载完成的示例代码。</p><br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，在此 <code>VIPER体系结构</code> 教程中，我正在使用各种设计模式。 有人说这没有灵丹妙药，但我相信我发现了一种非常了不起的方法，可以利用我的优势在短时间内构建高质量的应用程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 <code>VIPVM架构</code> 与 <code>MVVM</code> 与 <code>Promises</code> 结合在一起，可以将每个零件放在正确的位置。 工程过度？ 也许。 对我来说，这是值得的开销。 你怎么看待这件事？ </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VIPER体系结构：我们的最佳实践，像老板一样构建应用程序</title>
      <link href="/VIPER%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E5%83%8F%E8%80%81%E6%9D%BF%E4%B8%80%E6%A0%B7%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/VIPER%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E5%83%8F%E8%80%81%E6%9D%BF%E4%B8%80%E6%A0%B7%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Cheesecake Labs</code> 的开发团队使用 <code>VIPER</code> 进行 <code>iOS</code> 和 <code>Android</code> 移动应用程序开发已有一年多了，我们喜欢这种简洁的架构！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文使用 <code>VIPER</code> 样板中的代码示例总结了关于 <code>VIPER</code> 架构的最佳实践。 这里使用的代码示例在 <code>Swift</code> 中，但是提到的所有概念都可以应用于使用 <code>Java</code> 或 <code>Kotlin</code> 用 <code>VIPER</code> 开发的 <code>Android</code> 项目。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你仍然需要熟悉基本的 <code>VIPER</code> 概念以及该体系结构如何使你的代码更具组织性和可伸缩性，建议你阅读以下文章：</p><ul><li><a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52" target="_blank" rel="noopener"><strong><em><code>最常见的移动应用程序设计模式之间的比较</code></em></strong></a></li><li><a href="https://www.ckl.io/blog/ios-project-architecture-using-viper" target="_blank" rel="noopener"><strong><em><code>在iOS上使用VIPER的第一步的绝佳指南</code></em></strong></a></li><li><a href="https://cheesecakelabs.com/blog/using-viper-architecture-android/" target="_blank" rel="noopener"><strong><em><code>适用于Android的VIPER架构上的独特内容</code></em></strong></a></li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，你准备好学习有关如何使用 <code>VIPER</code> 构建应用程序的最佳实践吗？</p></br><h1 id="真正的VIPER模块解耦的项目结构"><a href="#真正的VIPER模块解耦的项目结构" class="headerlink" title="真正的VIPER模块解耦的项目结构"></a><strong>真正的VIPER模块解耦的项目结构</strong></h1><p><img src="http://q8wtfza4q.bkt.clouddn.com/va-stp1.png" alt="真正的VIPER模块解耦的项目结构" title="VIPER的iOS文件夹结构"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你会看到，我们将所有 <code>VIPER</code> 的模块保持尽可能的分离，从而使我们免于在项目扩展或规格更改时遇到的麻烦。 如果删除其中任何一个，则仅在引用该模型的路由器上会出现一些错误，而在 <code>Views</code> , <code>Presenters</code>, <code>Interactors</code>,<code>Data Managers</code> , <code>Entity</code> 上则不会。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;帮助你真正分离模块的一个关键点是将所有实体保留在单独的文件夹中，将它们链接到项目本身而不是任何特定模块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，使用数据管理器执行 <code>API</code> 请求和操作本地数据库是增加项目组织的一种极好的方法，但需要注意以下几点：</p><ul><li>将数据管理器保留在 <code>Utils</code> 文件夹中，将其与模块分开；</li><li>将类似实体（例如用户，个人档案和公司档案）的方法分组到一个 <code>Data Manager</code> 中，以避免为每个实体创建一个 <code>Data Manager</code> 的开销；</li><li>将每个 <code>Data Manager</code> 分为 <code>Local</code> 和 <code>API</code> 类，以使 <code>Interactors</code> 上的代码更具可读性：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainSearchInteractor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Properties</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">MainSearchInteractorOutput?</span></span><br><span class="line">    <span class="keyword">var</span> apiDataManager = <span class="type">ProfileApiDataManager</span>()</span><br><span class="line">    <span class="keyword">var</span> localDataManager = <span class="type">ProfileLocalDataManager</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainSearchInteractor</span>: <span class="title">MainSearchUseCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Code below show how interactor get data from API and then saves it on local DB with separate data managers</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">searchProducts</span><span class="params">(with searchTerm: String, onPage page: Int)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.apiDataManager.searchProducts(with: searchTerm, forPage: page) &#123; (products) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> products = products &#123;</span><br><span class="line">                <span class="keyword">self</span>.localDataManager.updateSearchResultFavorites(products) &#123; (products) <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">self</span>.output?.onFetchProductsSuccess(<span class="type">Array</span>(products), shouldAppend: page != <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.output?.onFetchProductsSuccess(<span class="literal">nil</span>, shouldAppend: page != <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="生成VIPER的文件"><a href="#生成VIPER的文件" class="headerlink" title="生成VIPER的文件"></a><strong>生成VIPER的文件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你已经使用 <code>VIPER</code> 进行过开发，那么你将无法创建一个简单的屏幕（在导航栏上具有三个标签）所需的所有 <code>20+</code> 个 <code>Swift</code> 文件。 但是，隧道尽头有一个亮点：这个令人惊叹的 <code>Xcode插件</code> ，只需单击三下，即可自动为一个模块生成所有 <code>VIPER</code> 文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你认为太多，请使用 <a href="https://github.com/strongself/Generamba" target="_blank" rel="noopener"><strong><em><code>Generamba</code></em></strong></a> ： <code>Generamba</code> ：一种代码生成器，旨在从终端创建 <code>VIPER</code> 模块，非常容易为其他任何类定制。</p></br><h1 id="用协议定义-contracts"><a href="#用协议定义-contracts" class="headerlink" title="用协议定义 contracts"></a><strong>用协议定义 contracts</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像对我们人类一样，<code>VIPER contracts</code> 是两方（模块组件）之间关于协议所产生的权利（方法）和义务（论据）的自愿协议。 在 <code>Cheesecake Labs</code> ，我们使用协议定义模块组件可以从同一模块上的其他组件调用的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，例如，在开始为新的 <code>View</code> 或 <code>Presenter</code> 编写代码之前，请考虑两个组件之间的信息流，并首先在 <code>Contract</code> 上声明其方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainSearchContract.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchView</span>: <span class="title">BaseView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showCustomError</span><span class="params">(<span class="number">_</span> message: String?)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateVisibility</span><span class="params">(onSearchController willBeActive: Bool)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showSearchResult</span><span class="params">(<span class="number">_</span> products: [Product]?, shouldAppend: Bool)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchPresentation</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onViewDidLoad</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onWillPresentSearchController</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onSearchTermChanged</span><span class="params">(to searchTerm: String)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductFavoriteChanged</span><span class="params">(<span class="number">_</span> product: Product, to isFavorite: Bool)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductSelected</span><span class="params">(<span class="number">_</span> product: Product)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onInfiniteScrollTriggered</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchUseCase</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">searchProducts</span><span class="params">(with searchTerm: String, onPage page: Int)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateProductFavorited</span><span class="params">(<span class="number">_</span> product: Product, to newValue: Bool)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchInteractorOutput</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onFetchProductsSuccess</span><span class="params">(<span class="number">_</span> products: [Product]?, shouldAppend: Bool)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onFetchProductsFailure</span><span class="params">(message: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchWireframe</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showProductScreen</span><span class="params">(delegate: ProductScreenDelegate, product: Product?)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面提到的 <code>Xcode插件</code> 还将创建具有所有协议的 <code>ModuleNameContract.swift</code> 文件，等待你声明必要的方法。 一旦定义了这些协议，就可以完全控制 <code>VIPER</code> 模块各组件之间的信息流。</p></br><h1 id="在路由器上自动进行模块初始化"><a href="#在路由器上自动进行模块初始化" class="headerlink" title="在路由器上自动进行模块初始化"></a><strong>在路由器上自动进行模块初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在显示 <code>VIPER</code> 模块的视图之前，你需要确保所有组件均已正确初始化。 我可以想到至少三种非常不同的方法，但是下面的流程是我们想出的最佳选择。 这里的王牌是每个路由器上都有一个静态函数，用于初始化自己的模块以及一些 <code>UIViewController</code> 和 <code>UIStoryboard</code> 扩展。 然后，如果 <code>模块A</code> 要提供 <code>模块B</code> ：</p><ul><li><code>模块A</code> 的路由器将调用 <code>模块B</code> 的静态函数来初始化其所有组件，并返回一个视图。</li><li><code>模块A</code> 的路由器显示 <code>模块B</code> 的视图。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就如此容易。 在自己的路由器上拥有模块初始化代码将消除大量的代码重复，特别是对于大型项目。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你需要一次创建这些扩展：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReusableView.swift</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ReusableView</span>: <span class="title">class</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ReusableView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> reuseIdentifier: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UIViewController.swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span>: <span class="title">ReusableView</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">// UIStoryboard.swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIStoryboard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">instantiateViewController</span><span class="params">()</span></span> -&gt; <span class="type">T</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">ReusableView</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiateViewController(withIdentifier: <span class="type">T</span>.reuseIdentifier) <span class="keyword">as</span>! <span class="type">T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，在每个 <code>VIPER模块</code> 的 <code>路由器</code> 上保留初始化代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainSearchRouter.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainSearchRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: Properties</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">UIViewController?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: Static methods</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setupModule</span><span class="params">()</span></span> -&gt; <span class="type">MainSearchViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">UIStoryboard</span>(name: <span class="type">MainSearchViewController</span>.storyboardName, bundle: <span class="literal">nil</span>).instantiateViewController() <span class="keyword">as</span> <span class="type">MainSearchViewController</span></span><br><span class="line">        <span class="keyword">let</span> presenter = <span class="type">MainSearchPresenter</span>()</span><br><span class="line">        <span class="keyword">let</span> router = <span class="type">MainSearchRouter</span>()</span><br><span class="line">        <span class="keyword">let</span> interactor = <span class="type">MainSearchInteractor</span>()</span><br><span class="line"></span><br><span class="line">        viewController.presenter =  presenter</span><br><span class="line"></span><br><span class="line">        presenter.view = viewController</span><br><span class="line">        presenter.router = router</span><br><span class="line">        presenter.interactor = interactor</span><br><span class="line"></span><br><span class="line">        router.view = viewController</span><br><span class="line"></span><br><span class="line">        interactor.output = presenter</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> viewController</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看来似乎有很多步骤，但有个好消息：前述插件对我们也能实现自动化！ 🙂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果要将 <code>UITabBarController</code> 或 <code>UIPageViewController</code> 装入 <code>VIPER</code> 架构，则需要采取一些其他步骤。 如果你需要任何帮助，请在此信息上发表评论，我会为你准备一个特定的 <code>Gist</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;亲爱的读者，如果你到目前为止已经提出了建议，那么你确实渴望获得知识。 因此，我将为你提供3条建议，以确保你完全了解路由器的职责：</p><ul><li>如果你需要在用户单击按钮时打开 <code>URL</code> ，请在路由器上调用 <code>UIApplication.shared.openURL（url）</code> ，因为你正在导航（即路由）到当前模块之外；</li><li>社交媒体共享也使用相同的概念：从 <code>Router</code> 调用 <code>UIActivityViewController</code> ，因为 <code>iOS</code> 会将用户从当前模块发送到 <code>View</code> 或 <code>app</code> ；</li><li>如果你仅要调用操作表来获得用户输入，那就是添加到当前模块中的UI组件。 因此，你可以从 <code>View</code> 中调用它，并从 <code>UIAlertController</code> 享受直接的回调。</li></ul></br><h1 id="使用-delegates-在-VIPER-模块之间发送数据"><a href="#使用-delegates-在-VIPER-模块之间发送数据" class="headerlink" title="使用 delegates 在 VIPER 模块之间发送数据"></a><strong>使用 delegates 在 VIPER 模块之间发送数据</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能已经遇到了这样的情况： <code>模块A</code> 上的一个字段填充有 <code>模块B</code> 的所选项目。因此，当用户单击该字段时， <code>模块A</code> 调用 <code>模块B</code> ，而 <code>模块B</code> 通过以下方式将所选项目返回给现有的 <code>模块A</code> ： <code>delegates</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代表们是在 <code>VIPER</code> 模块之间来回发送信息的绝佳方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Declare which messages can be sent to the delegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ProductScreenDelegate.swift</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProductScreenDelegate</span> </span>&#123;</span><br><span class="line"><span class="comment">//Add arguments if you need to send some information</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductScreenDismissed</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductSelected</span><span class="params">(<span class="number">_</span> product: Product?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Call the delegate when you need to send him a message</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ProductPresenter.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: Properties</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">ProductView?</span></span><br><span class="line">    <span class="keyword">var</span> router: <span class="type">ProductWireframe?</span></span><br><span class="line">    <span class="keyword">var</span> interactor: <span class="type">ProductUseCase?</span></span><br><span class="line">    <span class="keyword">var</span> delegate: <span class="type">ProductScreenDelegate?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductPresenter</span>: <span class="title">ProductPresentation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//View tells Presenter that view disappeared</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onViewDidDisappear</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Presenter tells its delegate that the screen was dismissed</span></span><br><span class="line">        delegate?.onProductScreenDismissed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Implement the delegate protocol to do something when you receive the message</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ScannerPresenter.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScannerPresenter</span>: <span class="title">ProductScreenDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Presenter receives the message from the sender</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductScreenDismissed</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Presenter tells view what to do once product screen was dismissed</span></span><br><span class="line">        view?.startScanning()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Link the delegate from the Product presenter in order to proper initialize it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File ScannerRouter.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setupModule</span><span class="params">(delegate: ProductScreenDelegate?)</span></span> -&gt; <span class="type">ProductViewController</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">let</span> presenter = <span class="type">ScannerPresenter</span>()</span><br><span class="line"></span><br><span class="line">        presenter.view = view</span><br><span class="line">        presenter.interactor = interactor</span><br><span class="line">        presenter.router = router</span><br><span class="line">        presenter.delegate = delegate <span class="comment">// Add this line to link the delegate</span></span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="避免使用-dictionaries-在VIPER组件之间传递数据"><a href="#避免使用-dictionaries-在VIPER组件之间传递数据" class="headerlink" title="避免使用 dictionaries 在VIPER组件之间传递数据"></a><strong>避免使用 dictionaries 在VIPER组件之间传递数据</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想 <code>100％</code> 兼容 <code>VIPER架构</code> ，最好使用 <code>POSO（普通老式Swift对象）</code> 在 <code>VIPER</code> 的组件之间发送信息。 但是在 <code>VIPER组件</code> 之间发送实体本身可以很好地工作，并且消除了创建 <code>POSO</code> 的开销。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，如果你不想在项目开始成长和变化时迷失键名，请避免使用字典发送此数据。</p><br><h1 id="专注于VIPER"><a href="#专注于VIPER" class="headerlink" title="专注于VIPER"></a><strong>专注于VIPER</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想充分利用此架构，请务必让你的团队与 <code>VIPER模块</code> 中每个组件的职责保持完全同步。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使在了解了每个特定组件的作用之后，我们的团队仍然面临一些疑问，这主要是受以前在 <code>MVC</code> 方面的经验影响。</p><ul><li>视图是处理 UI元素 的视图：它导入 <code>UIKit</code> 并从其模块中实现有关 <code>UI元素</code> 的所有逻辑。 例如， <code>TableView</code> 逻辑是在视图上实现的。 如果要使代码更具可读性，请在扩展名上拆分 <code>TableView</code> 逻辑。 如果要使你的项目更加简洁，请使用 <code>TableViewDataManager</code> 。</li><li><code>presenter</code> 不会导入 <code>UIKit</code> ，也不会处理 <code>UI元素</code> ，但是会以视图所需的格式准备数据，并根据视图中的 <code>UI事件</code> 做出决定。 不要在 <code>presenter</code> 上操纵任何 <code>UI元素</code> ，它不应处理它们。</li><li><code>Interactor</code> 也可以准备数据，但要用于数据库。 例如，一旦 <code>ApiDataManager</code> 提取了一些数据， <code>Interactor</code> 就可以在要求 <code>LocalDataManager</code> 保存数据之前进行一些排序或过滤。 但是请注意， <code>Interactor</code> 不了解 <code>视图</code> ，因此不知道应如何为视图准备数据。</li></ul></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;产品团队决定从你的项目中删除功能吗？ 还是你的小型项目开始变得庞大？ 使用正确的 <code>VIPER架构</code> ，避免将来出现麻烦！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动化 <code>VIPER文件</code> 创建和模块初始化将消除使用该工具的开销（乍看之下很复杂），但架构清晰而出色。 <code>Android开发人员</code> 也可以使用它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经看到，我们的 VIPER架构 方法实际上是由 <code>VIPRC模块</code> <strong><em>（View-Interactor-Presenter-Router-Contract）</em></strong> 组成的，而实体与模块以及数据管理器是分离的。 我知道 <code>VIPRC</code> 这个名字一点也不性感，但是它可以让你像老板一样构建应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS项目架构：使用VIPER</title>
      <link href="/iOS%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BD%BF%E7%94%A8VIPER/"/>
      <url>/iOS%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BD%BF%E7%94%A8VIPER/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发 <code>iOS</code> 应用时，请务必考虑应使用哪种 <code>iOS项目架构</code> 。 大多数开发人员使用 <code>Apple</code> 建议的模式：所谓的<code>MVC（模型-视图-控制器）架构</code>。 但是， <code>MVC</code> 本身已经建立了完善的缺陷。 一方面，由于其简单性，它甚至可以使最有经验的工程师将不属于视图或模型的任何代码放入控制器的逻辑中–在控制器中生成大量代码，并真正压缩视图和模型 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这篇文章中，我们将介绍 <code>VIPER</code> ，这是 <code>MVC</code> 的一种流行替代品，它可以帮助你克服其限制，同时保持代码模块化和组织良好，从而改善开发过程。</p><a id="more"></a></br><h1 id="什么是VIPER？"><a href="#什么是VIPER？" class="headerlink" title="什么是VIPER？"></a><strong>什么是VIPER？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>VIPER</code> 是 <code>View</code> ， <code>Interactor</code> ， <code>Presenter</code> ， <code>Entity</code> 和 <code>Router</code> 的反义词。 基本上，这是一种实施 <code>“单一责任原则”</code> 的方法，可以为你的 <code>iOS</code> 项目创建更简洁，更模块化的结构。 这种模式背后的思想是隔离应用程序的依赖关系，以平衡实体之间的职责委派。 这是通过使用以下体系结构来实现的：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/vu-stp1.png" alt="什么是VIPER？"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图说明了 <code>VIPER</code> 体系结构，其中每个块对应于具有特定任务，输入和输出的对象。 将这些块视为装配线中的工人：工人完成对某个对象的工作后，该对象将传递给下一个工人，直到完成产品为止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;块之间的连接表示对象之间的关系，以及它们之间传递的信息类型。 从一个实体到另一个实体的通信是通过协议进行的，我们将在本文中进一步说明。</p></br><h1 id="iOS项目架构"><a href="#iOS项目架构" class="headerlink" title="iOS项目架构"></a><strong>iOS项目架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到 <code>VIPER</code> 架构的真正目的，现在重要的是要多了解每个部分以及它们的职责。 为此，我们将开发一个基本应用程序（代码也可在 <a href="https://github.com/pedrohperalta/Articles-iOS-VIPER" target="_blank" rel="noopener"><strong><em><code>GitHub</code></em></strong></a> 上找到），该应用程序从 <code>REST API</code> 中获取文章列表，并在用户屏幕上显示这些文章。</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a><strong><em>View</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>iOS</code> 应用程序中的 <code>VIPER</code> <code>View</code> 是一个 <code>UIViewController</code> ，其中包含一个子视图，该子视图可以通过编程方式实现，也可以使用接口生成器 <code>（IB）</code> 来实现。 它的唯一责任是显示演示者要告诉的内容，并处理用户与屏幕的交互。 当用户触发任何需要处理的事件时， <code>View</code> 会简单地将其委托给 <code>Presenter</code> ，并等待响应以告知下一步应显示什么。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们的商品可视化应用程序的 <code>“View”</code> 在 <code>Swift</code> 中的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the view input methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesViewInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showArticlesData</span><span class="params">(articles: [Article])</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showNoContentScreen</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A view responsible for displaying a list</span></span><br><span class="line"><span class="comment"> * of articles fetched from some source.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlesViewController</span> : <span class="title">UIViewController</span>, <span class="title">ArticlesViewInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Reference to the Presenter's interface.</span></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">ArticlesModuleInterface!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Once the view is loaded, it sends a command</span></span><br><span class="line"><span class="comment">     * to the presenter asking it to update the UI.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.presenter.updateView()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesViewInterface</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showArticlesData</span><span class="params">(articles: [Article])</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.articles = articles</span><br><span class="line">        <span class="keyword">self</span>.tableView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showNoContentScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Show custom empty screen.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a><strong><em>Presenter</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Presenter</code> 的工作就像 <code>VIPER</code> 模块主要部分之间的桥梁。 一种方式是，它接收来自 <code>View</code> 的输入事件，并通过向 <code>Interactor</code> 请求数据来对它们做出反应。 另一方面，它接收来自 <code>Interactor</code> 的数据结构，在该数据上应用视图逻辑以准备内容，最后告诉视图显示什么。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们的文章可视化应用程序的 <code>Presenter</code> 的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the commands sent from the View to the Presenter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesModuleInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateView</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showDetailsForArticle</span><span class="params">(article: Article)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the commands sent from the Interactor to the Presenter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesInteractorOutput</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">articlesFetched</span><span class="params">(articles: [Article])</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Presenter is also responsible for connecting</span></span><br><span class="line"><span class="comment"> * the other objects inside a VIPER module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlesPresenter</span> : <span class="title">ArticlesModuleInterface</span>, <span class="title">ArticlesInteractorOutput</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Reference to the View (weak to avoid retain cycle).</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">ArticlesViewInterface!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the Interactor's interface.</span></span><br><span class="line">    <span class="keyword">var</span> interactor: <span class="type">ArticlesInteractorInput!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the Router</span></span><br><span class="line">    <span class="keyword">var</span> wireframe: <span class="type">ArticlesWireframe!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesModuleInterface</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.interactor.fetchArticles()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showDetailsForArticle</span><span class="params">(article: Article)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.wireframe.presentDetailsInterfaceForArticle(article)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesInteractorOutput</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">articlesFetched</span><span class="params">(articles: [Article])</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> articles.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.articles = articles</span><br><span class="line">            <span class="keyword">self</span>.view.showArticlesData(articles)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.view.showNoContentScreen()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Interactor"><a href="#Interactor" class="headerlink" title="Interactor"></a><strong><em>Interactor</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以将此对象视为特定模块内用例的集合。  <code>Interactor</code> 包含与实体相关的所有业务逻辑，并且应完全独立于用户界面 <code>（UI）</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的 <code>Article Visualization</code> 应用程序中，一个用例示例是从服务器获取文章列表。 进行请求，处理响应并将其转换为实体（在本例中为商品对象）是 <code>Interactor</code> 的责任。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦 <code>Interactor</code> 完成运行某些任务，它将通知 <code>Presenter</code> 获得的结果。 要牢记的一件重要事情是，发送给 <code>Presenter</code> 的数据不应实现任何业务逻辑，因此 <code>Interactor</code> 提供的数据应整洁并可以使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的文章可视化应用程序中， <code>Interactor</code> 将负责从 <code>API</code> 提取文章：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the Interactor's use case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesInteractorInput</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fetchArticles</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Interactor responsible for implementing</span></span><br><span class="line"><span class="comment"> * the business logic of the module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlesInteractor</span> : <span class="title">ArticlesInteractorInput</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Url to the desired API.</span></span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">"https://www.myendpoint.com"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the Presenter's output interface.</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">ArticlesInteractorOutput!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesInteractorInput</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fetchArticles</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Alamofire</span>.request(.<span class="type">GET</span>, url).responseArray &#123; (response: <span class="type">Response</span>) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> articlesArray = response.result.value</span><br><span class="line">            <span class="keyword">self</span>.output.articlesFetched(articlesArray!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a><strong><em>Entity</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Entity</code> 可能是 <code>VIPER</code> 结构中最简单的元素。 它封装了不同类型的数据，通常在其他 <code>VIPER</code> 组件中被视为有效负载。 需要注意的一件事是实体与数据访问层不同，后者应由交互器处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的 <code>Article Visualization</code>应用程序中， <code>Article</code> 类将是 <code>Entity</code> 的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> website: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> authors: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> imageUrl: <span class="type">String?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a><strong><em>Router</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>VIPER</code> 架构中的最后一个，也许是最特殊的元素是 <code>Router</code> ，它负责模块之间的导航逻辑，以及模块的发生方式（例如，定义用于呈现屏幕的动画，或者应如何完成两个屏幕之间的转换） ）。它从 <code>Presenters</code> 接收输入命令，说出应该路由到哪个屏幕。另外， <code>Router</code> 应负责将数据从一个屏幕传递到另一个屏幕。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Router</code> 应实施一个协议，该协议定义特定模块的所有导航可能性。很好，因为它可以仅查看 <code>Router</code> 的协议即可快速概览应用程序可以采用的所有路径。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>iOS</code> 框架的限制，只有 <code>ViewController</code> 可以在屏幕之间执行转换，因此 <code>Router</code> 必须包含对模块控制器或其任何子级的引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们的 <code>Router</code> 在“文章可视化”应用程序中的外观（请注意，该路由器被广泛称为 <code>“Wireframe”</code> ）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the possible routes from the Articles module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesWireframeInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">presentDetailsInterfaceForArticle</span><span class="params">(article: Article)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Router responsible for navigation between modules.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlesWireframe</span> : <span class="title">NSObject</span>, <span class="title">ArticlesWireframeInput</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Reference to the ViewController (weak to avoid retain cycle).</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> articlesViewController: <span class="type">ArticlesViewController!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the Router of the next VIPER module.</span></span><br><span class="line">    <span class="keyword">var</span> detailsWireframe: <span class="type">DetailsWireframe!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesWireframeInput</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">presentDetailsInterfaceForArticle</span><span class="params">(article: Article)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Create the Router for the upcoming module.</span></span><br><span class="line">        <span class="keyword">self</span>.detailsWireframe = <span class="type">DetailsWireframe</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sends the article data to the next module's Presenter.</span></span><br><span class="line">        <span class="keyword">self</span>.sendArticleToDetailsPresenter(<span class="keyword">self</span>.detailsWireframe.detailsPresenter, article: article)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Presents the next View.</span></span><br><span class="line">        <span class="keyword">self</span>.detailsWireframe.presentArticleDetailsInterfaceFromViewController(<span class="keyword">self</span>.articlesViewController)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: Private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">sendArticleToDetailsPresenter</span><span class="params">(detailsPresenter: DetailsPresenter, article: Article)</span></span> &#123;</span><br><span class="line">        detailsPresenter.article = article</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="什么时候应该使用VIPER？"><a href="#什么时候应该使用VIPER？" class="headerlink" title="什么时候应该使用VIPER？"></a><strong>什么时候应该使用VIPER？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在创建具有发展潜力的项目时，重要的是要考虑一个可以很好地扩展并允许许多开发人员同时无缝地进行工作的结构- <code>MVC</code> 结构可能不足以保持你的项目充分组织 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发人员发现自己调试大型类确实很常见，例如试图在大海捞针中找针。 通过 <code>VIPER</code> 建议的对象之间的松散耦合，你会注意到：</p><ul><li>通过崩溃报告更容易跟踪问题（由于“单一责任原则”）</li><li>添加新功能更容易</li><li>源代码将更加干净，紧凑和可重用</li><li>与其他开发团队的冲突更少</li><li>由于你的 <code>UI</code> 逻辑与业务逻辑是分开的，因此编写自动化测试（！）更容易。</li></ul></br><h1 id="什么时候不应该使用VIPER？"><a href="#什么时候不应该使用VIPER？" class="headerlink" title="什么时候不应该使用VIPER？"></a><strong>什么时候不应该使用VIPER？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于你要解决的每个问题，你都应使用最适合你需求的工具。 由于涉及的元素数量众多，因此该体系结构在启动新项目时会产生开销（尽管从长远来看，这在很大程度上会得到回报），因此 <code>VIPER</code> 对于不打算扩展的小型项目而言可能是一个过大的杀伤力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果团队不完全保持 <code>VIPER</code> 结构的一致性，那么你最终会遇到 <code>MVC-VIPER</code> 混合问题，这可能会令人头疼–因此在继续使用 <code>VIPER</code> 之前，请确保团队完全同步。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>VIPER</code> 是一种非常酷的 <code>iOS</code> 项目架构模式，例如 <code>MVP</code> 和 <code>MVVM</code> 。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS VIPER架构深入实践</title>
      <link href="/iOS%20VIPER%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"/>
      <url>/iOS%20VIPER%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>VIPER</code> 架构编写可伸缩的 <code>iOS</code> 代码，并牢记一些 <code>MVVM</code> 和 <code>MVC</code> 技巧和协调器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件工程中，<a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener"><strong><em><code>设计模式（design pattern）</code></em></strong></a> 是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。</p><a id="more"></a></br><h1 id="Swift-设计模式和-iOS-架构"><a href="#Swift-设计模式和-iOS-架构" class="headerlink" title="Swift 设计模式和 iOS 架构"></a><strong>Swift 设计模式和 iOS 架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;软件设计模式基本上是关于如何解决特定（但通常是结合业务场景）情况的通用模板。 结构模式对整个代码库影响更大，它们是高级通用模板。 请记住一件事：</p><blockquote><p>架构没有好坏之分。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择的武器仅取决于情况，但你知道一切都是相对的。 让我们快速快速地了解所有 <code>iOS</code> 设计模式和体系结构，并开始学习 <a href="http://www.xuebaonline.com/iOS%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BD%BF%E7%94%A8VIPER/"><strong><em><code>VIPER</code></em></strong></a> 。 🐍</p></br><h2 id="Swift-设计模式"><a href="#Swift-设计模式" class="headerlink" title="Swift 设计模式"></a><strong><em>Swift 设计模式</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从基础开始吧？ 如果不熟悉 <code>UIKit</code> ，我们会发现发明了许多设计模式，也许你已经知道其中一些。 但是，嘿，由于我们没有太多时间，我想谈谈 <a href="http://www.xuebaonline.com/VIPER%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E5%83%8F%E8%80%81%E6%9D%BF%E4%B8%80%E6%A0%B7%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"><strong><em><code>VIPER</code></em></strong></a> ，让我们看看使用 <code>MVC</code> 模式构建 <code>UIKit</code> 应用程序的基本原理。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a><strong><em>MVC</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模型-视图-控制器（Massive-View-Controller）模式是一个基本概念。 通常，你有一个庞大的UIViewController子类，该子类控制所有视图并收集需要为最终用户显示的每个模型。 例如，你从控制器使用URLSession或Alamofire调用API终结点，进行响应数据验证和格式化，然后在视图控制器上实现表或集合视图委托，因此基本上所有应用程序逻辑都在该单一的，装满了悲惨的视图控制器中 类。 这会为你敲响钟声吗？ 🙄</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a><strong><em>MVVM</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;意识到问题之后，你可以做的第一件事就是将数据转换或绑定部分外包给单独的类。 这就是 <code>Miscrosoft</code> 的聪明人发明了 <code>Model-View-ViewModel</code> 体系结构模式的方式。 现在，你已经接近了一步，你的数据模型和视图可以在距离控制器域很远的闪亮新文件中的一个全新的高度上“聚在一起”。 但是，此模式不会清除视图控制器内部的所有剩余内容。 请记住，你仍然必须向视图控制器提供数据，处理所有不同的状态。</p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a><strong><em>MVP</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们从视图控制器中移走所有数据加载和演示文稿的东西，然后将它们放到神奇地称为 <code>Presenter</code> 的新类中，该怎么办？ 听起来不错，视图控制器可以拥有新的 <code>presenter</code> 实例，从此以后我们可以过上幸福的生活。 来吧，我们真的应该将其重命名为有史以来最有价值的模式！ 😉</p><h2 id="协调器模式"><a href="#协调器模式" class="headerlink" title="协调器模式"></a><strong><em>协调器模式</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还是应该简单地将其称为“逆模型视图展示者”模式？ 看起来，这很重要，协调员在这个演进过程中处于一个全新的高度，但是他们还有很多事情要做。 这违反了“单一职责”原则，因为现在你必须管理表示上下文，数据存储，路由以及协调器或子协调器中的所有 <code>differnet</code> 状态。但是，最后，你的视图控制器没有任何剩余的负担 它可以直接专注于工作，这是什么？ 🙃<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用与 <code>UIKit</code> 相关的内容呈现视图，并转发事件。</p></br><h1 id="VIPER架构"><a href="#VIPER架构" class="headerlink" title="VIPER架构"></a><strong>VIPER架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，不要仅仅因为有人滥用而认为VIPER不好。我认为这是一个令人惊讶的惊人建筑！你只需要适当地学习它，这很困难，因为缺少好的教程。每个人都在比较架构，但这不是人们应该做的。据我所知，<code>MVP</code> 适用于带有几个屏幕的小型应用程序，你永远不要对这些应用程序使用 <code>VIPER</code> 。如果你的应用不断增长，越来越多的组件加入游戏，那么真正的问题就开始了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你打算编写一个小型应用程序，则从 <code>MVC</code> 开始。稍后，你可以使用 <code>MVVM</code> 解决大型视图控制器的问题，但是如果你想将其进一步发展，可以始终使用MVP或协调器模式来保持可维护性。完全没问题，直到有一天你意识到代码中塞满了实用程序类，管理器，处理程序和所有废话对象。听起来很熟悉？ 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我之前提到的那样，没有糟糕的架构之类的东西。只有错误的选择，这导致我们难以维护的代码库。因此，让我指导你完成你想知道的最有用的设计模式，以编写真正可扩展的 <code>iOS</code> 应用程序：具有模块构建器的 <code>VIPER = VIPER（B）</code>。</p></br><h1 id="了解VIPER"><a href="#了解VIPER" class="headerlink" title="了解VIPER"></a><strong>了解VIPER</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>VIPER</code> 体系结构基于单一责任原则 <code>（S.O.L.I.D.）</code>，这使我们进入了干净体系结构的理论。 假设 <code>VIPERB</code> 模块的核心组件为以下组件：</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a><strong><em>View</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是接口层，表示 <code>UIKit</code> 文件，主要是 <code>UIViewController</code> 子类和所有其他内容。 视图不执行与业务逻辑相关的任何操作，只是演示者使用的演示和事件转发层。 由于视图只是纯视图控制器，因此你可以使用 <code>MVVM</code> 原理或数据管理器来使你的项目更加简洁。</p><h2 id="Interactor-互动者"><a href="#Interactor-互动者" class="headerlink" title="Interactor(互动者)"></a><strong><em>Interactor(互动者)</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;交互器负责从模型层检索数据，其实现完全独立于用户界面。 重要的是要记住，数据管理器（网络，数据库，传感器）不是 <code>VIPER</code> 的一部分，因此它们被视为独立的组件（服务），它们来自 <code>VIPER</code> 模块领域，可以作为交互器的依赖项注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Interactor</code> 可以准备或转换来自服务层的数据。 例如，它可以在要求正确的网络服务实现请求或保存数据之前进行一些排序或过滤。 但是请记住，交互器不了解视图，因此它不知道应如何为视图准备数据，这就是 <code>Presenter</code> 的作用。 🙄</p><h2 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a><strong><em>Presenter</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>UIKit</code> 独立类，以视图所需的格式准备数据并基于视图中的 <code>UI</code> 事件做出决定，这就是为什么有时将其称为事件处理程序的原因。 这是 <code>VIPER</code> 模块的核心类，因为它还与 <code>Interactor</code> 通信并调用路由器进行线框图（也就是提供一个新模块或关闭当前模块）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是唯一与几乎所有其他组件进行通信的类。 那只是演示者的工作，因此它不应该对 <code>UIKit</code> 或低级数据模型一无所知。 基本上，这是应用程序的核心，或者有人会说这是实现所有业务逻辑的地方。 💜</p><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a><strong><em>Entity</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;普通模型类，主要由交互器使用。 通常，我在 <code>VIPER</code> 模块结构之外（在服务层中）定义它们，因为这些实体在系统中共享。 我们可以按模块将它们分开，但是通常我不喜欢这种方法，因为例如。 所有 <code>CoreData</code> 模型都可以生成到一个地方。 如果使用 <code>Swagger</code> 或类似工具，则同样适用。</p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a><strong><em>Router</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>UIKit</code> 类的应用程序的导航逻辑。 例如，如果在 <code>iPad</code> 应用程序中使用相同的iPhone视图，则唯一可能改变的是路由器如何构建结构。 这使你可以保留所有其他内容，但路由器保持不变。 它还会监听来自演示者的导航流更改，因此，如果需要，它将显示正确的屏幕。 同样，如果你需要在路由器内部打开一个外部 <code>URL</code> 调用 <code>UIApplication.shared.openURL（url）</code> ，因为这也是一个路由操作，那么使用 <code>UIActivityViewControlle</code> r进行社交媒体共享的逻辑也相同。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样，如果你必须在 <code>VIPER</code> 模块之间传递数据，则感觉是在路由器中执行此操作的正确位置。 我通常使用委托模式在两个模块之间进行通信，因此我养成了在路由器中调用委托函数的习惯。 📲</p><h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a><strong><em>Builder</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有些人正在使用路由器来构建整个模块，但是我不喜欢这种方法。 这就是为什么我总是使用单独的模块构建器类的原因。 唯一的责任是通过对所有外部服务使用依赖注入来构建完整的模块。 它还可以构建同一模块的模拟或其他版本。 如果涉及单元测试，那将非常有帮助。 完全有道理。 👍</p><h2 id="并非一切都是-VIPER-模块"><a href="#并非一切都是-VIPER-模块" class="headerlink" title="并非一切都是 VIPER 模块"></a><strong><em>并非一切都是 VIPER 模块</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，如果要从 <code>UIView</code> 创建通用子类，请不要尝试将其填充到上面的组件中。 你应该在 <code>VIPER modules</code> 文件夹之外创建一个位置，并将其放置在该位置。 有些用例具有特定的类，最好不要进行 <code>VIPERized</code> ！ 😉</p><h2 id="服务和应用程序代码"><a href="#服务和应用程序代码" class="headerlink" title="服务和应用程序代码"></a><strong><em>服务和应用程序代码</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的应用程序通常有3个单独的层。 模块，服务和应用程序。 所有 <code>VIPER</code> 模块都位于 <code>“Modules”</code> 文件夹中。 与网络或数据相关的所有内容都转到 <code>“Services”</code> 文件夹（ <code>api服务</code> ，<code>核心数据服务</code>，<code>位置服务</code>等），然后根据当前环境在模块构建器中使用（例如，用于测试的模拟实现）。 其余所有东西（例如视图子类和其他与 <code>UI</code> 相关的对象，特定于应用程序的样式或设计方面的东西）都放在 <code>App</code> 目录中。</p></br><h1 id="如何编写VIPER代码？"><a href="#如何编写VIPER代码？" class="headerlink" title="如何编写VIPER代码？"></a><strong>如何编写VIPER代码？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开始使用该体系结构之前，我无法充分强调学习这种体系结构的重要性。 我认为，如果有人误解了 <code>VIPER</code> 并开始将视图逻辑放到演示者中，事情就会变得很糟糕。 如果你以前在 <code>VIPER</code> 方面有过糟糕的经验，请考虑一下这句话：不要怪工具，怪木匠。 🔨</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你遵循 <code>VIPER</code> 的规则，那么非常单一的组件将进入正确的位置。</p></blockquote><h2 id="模块生成"><a href="#模块生成" class="headerlink" title="模块生成"></a><strong><em>模块生成</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;永远不要开始手动创建 <code>VIPER</code> 模块，你应该始终使用代码生成器，因为（不幸的）每个模块都需要大量样板代码。乍一看似乎很不幸，但这才是该架构真正的力量所在。如果发生特定问题，开发人员团队的所有成员都将知道在哪里寻找。如果是视图问题，则必须修复视图；如果涉及导航问题，则是路由器问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现有许多代码生成器解决方案（其中一个著名的是 <code>Generamba</code> ），但是我制作了自己的小 <code>Swift</code> 工具来生成 <code>VIPER</code> 模块。这真是该死的轻量级，但确实非常有用（它利用模板来生成新模块），我称之为：<code>VIPERA</code> 。 （毒蛇蛇的匈牙利名字…哈哈😂）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你只需克隆/下载存储库并运行 <code>swift run install --with-templates</code> 即可使其工作。从现在开始，你只需运行<code>vipera MyModule</code> 即可基于默认模板生成新模块。作为第二个参数，你可以传递自己的模板目录名称（可以在<code>〜/ .vipera</code>文件夹下创建自己的模板，也可以更改默认模板）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本模板的结构非常简单，我没有为每一层创建子文件夹，而是在不同位置分离了接口和默认实现。这让我有点理智，因为大多数 <code>VIPER</code> 模板似乎只是由于项目结构而具有很大的威慑力。</p><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a><strong><em>命名约定</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几乎为每个 <code>VIPER</code> 组件都定义了协议。 每个协议都将以模块名称作为前缀，并且除了层名称（例如 <code>MyModuleRouter</code> ， <code>MyModulePresenter</code> ）外，它将没有任何其他后缀。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认实现用于基本方案，每个协议实现均遵循 <code>ModuleName + Default + Layer</code> 命名约定。 因此，例如 <code>MyModuleDefaultRouter</code> 或 <code>MyModuleDefaultPresenter</code> 。</p><h2 id="使用-delegates-进行模块间通信"><a href="#使用-delegates-进行模块间通信" class="headerlink" title="使用 delegates 进行模块间通信"></a><strong><em>使用 delegates 进行模块间通信</em></strong></h2><p>流程是这样的：</p><p><strong>Router / Presenter</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Presenter</code> 可以使用路由器协议定义发送路由器事件。</p><p><strong>Presenter / Interactor</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Interactor</code> 可以通过演示者的界面通知演示者，并且演示者可以使用 <code>Interactor</code> 协议内部定义的方法来调用交互者。</p><p><strong>Presenter / View</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;视图通常具有 <code>setter</code> 方法来更新其在视图协议上定义的内容。 它还可以通过演示者协议将传入或加载事件通知 <code>Presenter</code> 。</p><h2 id="模块之间的数据传输"><a href="#模块之间的数据传输" class="headerlink" title="模块之间的数据传输"></a><strong><em>模块之间的数据传输</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象一个列表，你选择一个项目并转到新的控制器场景。 为了使之成为可能，你必须在 <code>VIPER</code> 模块之间至少传递一个唯一的标识符。</p><p>通常这样做是这样的：</p><ul><li>该视图使用 <code>ID</code> 调用 <code>Presenter</code> 上的 <code>didSelect</code> 方法</li><li><code>Presenter</code> 使用 <code>routeFor（id）</code> 方法将 <code>ID</code> 转发到路由器</li><li>路由器调用构建器使用 <code>ID</code> 来构建新模块</li><li>生成器使用 <code>id</code> 生成新模块</li><li>路由器使用其视图显示新模块（控制器）</li><li>新模块将ID传递给需要它的每个人（路由器，演示者）</li><li>新模块的演示者获取ID</li><li>新模块的 <code>Interactor</code> 加载数据并将其提供给 <code>Presenter</code></li><li>新模块的 <code>Presenter</code> 为视图提供数据并进行展示</li><li>出现详细信息屏幕，其中包含适当的数据。</li></ul><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你以模态形式显示控制器，则还可以将原始路由器作为委托传递，因此可以在需要时正确关闭它。 😎</p></blockquote><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong><em>内存管理</em></strong></h2><p>长话短说：</p><ul><li><code>builder</code> 不持有任何对象。</li><li><code>Router</code> 对 <code>Views</code> 和 <code>Presenter</code> 保持弱引用。</li><li><code>Presenter</code> 强持有 <code>Router</code>和  <code>Interactor</code> </li><li><code>Interactor</code> 对<code>Presenter</code> 的 弱引用</li><li>该 <code>Views</code> 对 <code>Presenter</code> 强引用</li><li><code>UIKit</code> 持有 <code>views</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该在提供的示例中进行检查，没有泄漏-希望如此-在你返回或关闭模块后，所有内容都会顺利顺利地释放。 🤞</p></br><h1 id="结论：我应该学习VIPER吗？"><a href="#结论：我应该学习VIPER吗？" class="headerlink" title="结论：我应该学习VIPER吗？"></a><strong>结论：我应该学习VIPER吗？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管 <code>VIPER</code> 因其复杂性而备受批评，但我只能说值得努力学习正确的原理。 你会发现使用 <code>VIPER</code> 而不是忽略它会有更多的好处。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong><em>优点</em></strong></h2><ul><li><strong>简单性</strong> -适用于大型团队的复杂项目</li><li><strong>可扩展性</strong> -无缝同时工作</li><li><strong>可重用性</strong> -根据角色分离应用程序组件</li><li><strong>一致性</strong> -模块框架，关注点分离</li><li><strong>清晰度</strong> -单一职责（SOLID）</li><li><strong>可测试性</strong> -分离的小类，TDD，更好的代码覆盖率</li><li><strong>接口</strong> -模块独立性，定义明确的范围</li><li><strong>错误修复</strong> -更容易跟踪问题，查找错误和问题</li><li><strong>源代码控制</strong> -文件更小，冲突更少，代码更简洁</li><li><strong>容易</strong> -代码库看起来很相似，熟悉项目代码更快</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong><em>缺点</em></strong></h2><ul><li><strong>详细程度</strong> -每个模块很多文件</li><li><strong>复杂性</strong> -许多协议和委托</li><li><strong>On-boarding</strong> -缺乏适当的VIPER知识</li><li><strong>Engagement</strong> -VIPER很糟糕，因为它很复杂！</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我写了一篇后续文章，介绍了我在此过程中学到的VIPER最佳实践。👨💻</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 如何学习现代UIKit？</title>
      <link href="/Swift%20%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%8E%B0%E4%BB%A3UIKit%EF%BC%9F/"/>
      <url>/Swift%20%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%8E%B0%E4%BB%A3UIKit%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与我一起采取第一步，学习如何使用 <code>UIKit</code> 框架构建用户界面。 在 <code>Swift</code> 中以编程方式编写，不适用 <code>storyboards</code> 。</p></br><h1 id="UI-frameworks-in-2020"><a href="#UI-frameworks-in-2020" class="headerlink" title="UI frameworks in 2020"></a><strong>UI frameworks in 2020</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我总是告诉所有人，工作中最困难的部分是建立适当的用户界面。 提供最佳的用户体验可能是一项挑战，因为设计师必须遵循人机界面指南，设计出美观的设计，有时还要与客户打交道，以为最终用户找到最佳解决方案。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>Swift</code> 实现图形用户界面的可用选项有哪些？</p><a id="more"></a></br><h1 id="SwiftUI"><a href="#SwiftUI" class="headerlink" title="SwiftUI"></a><strong>SwiftUI</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果在 <code>2019年</code> 发布了<code>SwiftUI</code>，该框架仍然热脆，或者我应该说半熟吗？ 在 <code>WWDC</code> 宣布之后，很多人立即开始使用 <code>SwiftUI</code> ，我对最初的反馈感到非常不满意。 <code>SwiftUI</code> 是未来，这是肯定的。 我相信 <code>Apple</code> 会在框架上做出很多努力，以使其更好。 从概念上讲，它已经很不错了，实现很简单，但是我仍然面临的最大问题是，我还没有看到 <code>SwiftUI</code> 如何改善我的日常工作。 🤔</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声明性接口定义是当今的热门话题，但是我们真的需要它吗？ 我的意思是，基本原型制作速度非常快，但是，如果你必须解决复杂的问题（甚至是一些琐碎的问题，例如设置滚动视图的偏移），则必须与系统抗争或提出自己的 <code>UIViewRepresentable</code> 对象。</p><p><strong><em><code>The truth is: if you choose SwiftUI you still have to interact a LOT with UIKit as well.</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，人们有各种各样的需求。 由于 <code>Flutter</code> ＆ <code>React Native</code>，恕我直言 <code>SwiftUI</code> 在这里。 开发人员喜欢这些框架。 苹果必须想出一种新的解决方案来与他们抗衡，因为他们希望越来越多的有才华的 <code>Swift</code> 编码器能够在 <code>iOS</code> 应用程序上本机工作，而不是在混合应用程序上工作。 从新手的角度来看，选择 <code>SwiftUI</code> 确实很迷人。 即使在这个早期阶段，我仍然可以给你留下深刻的印象。</p><h2 id="是否可以学习-SwiftUI"><a href="#是否可以学习-SwiftUI" class="headerlink" title="是否可以学习 SwiftUI?"></a><strong><em>是否可以学习 SwiftUI?</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是的，绝对可以，如果你已经熟悉 <code>UIKit</code> ，那就去学习 <code>SwiftUI</code> 。 如果你完全没有 <code>UIKit</code> 的经验，你仍然可以精通 <code>SwiftUI</code> ，但是你可能会发现自己在寻找很多与 <code>UIKit</code> 相关的问题。 🔍</p><h2 id="你应该学习SwiftUI还是UIKit？"><a href="#你应该学习SwiftUI还是UIKit？" class="headerlink" title="你应该学习SwiftUI还是UIKit？"></a><strong><em>你应该学习SwiftUI还是UIKit？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，知道我所知道的我将从UIKit开始。 “和这个酷孩子在一起”确实很诱人，但是值得跳过整个课程吗？这也是我的想法：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要说的是 <code>SwiftUI</code> 的存在并没有以某种方式使 <code>UIKit</code> 变得过时：如果你打算在未来三年内获得 <code>iOS</code> 开发工作，那么知道如何使用 <code>UIKit</code> 将会是一项必然的要求。</p></blockquote></br><h1 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a><strong>UIKit</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>UIKit</code> 现在可在以下平台上使用：<code>iOS（iPadOS）</code>，<code>tvOS</code>，<code>macOS（Catalyst）</code>。 除了<code>watchOS</code> 以外，几乎所有这些都已包含在内。 该框架本身是一个巨大的框架，因为它包含了你可以在 <code>iOS</code> 上看到和使用的每个基本构建块。 它不仅是视图，还包括控制器，导航，响应器等等。</p><h2 id="你应该从哪里开始学习UIKit？"><a href="#你应该从哪里开始学习UIKit？" class="headerlink" title="你应该从哪里开始学习UIKit？"></a><strong><em>你应该从哪里开始学习UIKit？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是否正在寻找现代 <code>UIKit</code> 教程？ 好吧，这可能非常困难，因为大多数书籍和课程都已过时。 但是，我必须推荐一个 <code>肖恩·艾伦（Sean Allen）</code> 真正有用的视频课程。 他正在构建一个完整的应用程序，向你教授网络基础知识，集合视图，搜索控制器的适当状态管理以及许多小型实践，如果你想开始作为 <code>iOS</code> 开发人员的职业，这些实践将非常有用。 这就像一个面试的外卖项目教程。 真的很有用！ 🎬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以选择加入我的行列，并每周学习UIKit的工作原理。 我将发布有关过去学习的所有最佳实践的文章。 这将是100％用最新版本的Swift编写的，没有 <code>storyboards</code> 或 <code>nibs</code> 。 这些将是更长的文章，每一次我将专注于对现实项目有用的实践课程。 有什么计划？</p><p><strong>我即将发布的UIKit教程*</strong></p><ul><li><p>如何使用UIKit启动iOS项目？</p><p>  项目设置，基本UIKit概念，AppDelegate，SceneDelegate</p></li><li><p>了解UIKit导航的工作方式</p><p>  UINavigationController，UITabBarController，UISplitViewController，UIPageViewController</p></li><li><p>关于UIViewController类的所有信息</p><p>  UIViewController生命周期，子类化，使用子视图控制器的合成</p></li><li><p>UIView基础知识，使用自定义视图</p><p> UIView生命周期，布局系统，自定义UIView子类，有关图层的一些知识</p></li><li><p>具有UILabel，UIButton，UIImageView的布局锚点</p><p>  了解如何通过使用布局锚点和基本的UIKit组件来构建屏幕</p></li><li><p>使用不同的数据源修改UITableView</p><p>  使用搜索字段，远程图像加载等。</p></li><li><p>UI堆栈，状态，警报，过渡，动画</p><p> UIAlertController，UIActivityIndi​​catorView和一些奇特的效果</p></li><li><p>使用UICollectionView构建复杂的用户界面</p><p>  合成布局，再加上我对基于SwiftUI的可重用单元格有了新的疯狂想法…</p></li><li><p>使用UIStackView和UIScrollView创建复杂的输入表单</p><p>  使用：UITextField，UISlider，UIStepper，UIDatePicker，UISegmentedControl，UISwitch</p></li><li><p>支持更大的屏幕，iPad，macOS（Catalyst）和黑暗模式</p><p>  Windows，适应性，拖放基础，触摸识别器</p></li></ul><p>*请注意：这只是一个基本框架，将来内容可能会有所不同。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我计划在今年晚些时候发布第一期。 当我准备好内容之后，每个星期你都应该期待有一篇新的 <code>UIKit</code> 文章，其中包含一些可以自己解决的小任务（也许你需要做一些研究工作）。</p></br><h1 id="你首选的学习方法是什么？"><a href="#你首选的学习方法是什么？" class="headerlink" title="你首选的学习方法是什么？"></a><strong>你首选的学习方法是什么？</strong></h1><ul><li><strong><em>图书</em></strong></li><li><strong><em><code>Swift playground books</code></em></strong></li><li><strong><em>视频课程</em></strong></li><li><strong><em>撸代码实践</em></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 唯一识别的视图</title>
      <link href="/Swift%20%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%9A%84%E8%A7%86%E5%9B%BE/"/>
      <url>/Swift%20%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%9A%84%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用基于字符串的 <code>UIView</code> 标识符而不是标签。 如果你厌倦了标记视图，请查看这些替代解决方案。</p></br><h1 id="第一种方法：accessibility-to-the-rescue"><a href="#第一种方法：accessibility-to-the-rescue" class="headerlink" title="第一种方法：accessibility to the rescue!"></a><strong>第一种方法：accessibility to the rescue!</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长话短说，我很讨厌用愚蠢的数字值标记视图，因此我寻求一种更好的替代解决方案来解决我的问题。 事实证明，有一个名为 <code>accessibilityIdentifier</code> 的属性可以完成这项工作。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.accessibilityIdentifier</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.accessibilityIdentifier = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">view</span><span class="params">(withId id: String)</span></span> -&gt; <span class="type">UIView?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.id == id &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> view <span class="keyword">in</span> <span class="keyword">self</span>.subviews &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> view = view.view(withId: id) &#123;</span><br><span class="line">                <span class="keyword">return</span> view</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对 <code>UIView</code> 类进行了简单的扩展，因此现在我可以使用适当的字符串值来唯一地标识视图层次结构中的任何视图对象。 这是一个很好的解决方案，现在我可以以一种非常不错的方式命名我的 <code>views</code> 。 免费将名称存储在 <code>accessibilityIdentifier</code> 下将对 <code>UI</code> 测试带来好处。 😉</p></br><h1 id="第二种方法：using-enums"><a href="#第二种方法：using-enums" class="headerlink" title="第二种方法：using enums"></a><strong>第二种方法：using enums</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要思想是为每个视图标识符都具有一个基于 <code>Int</code> 的枚举，因此基本上你可以使用 <code>tag</code> 属性存储枚举的 <code>rawValue</code> 。 它仍然不如上面的那个好，但是比依赖纯整数更安全。 😬</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ViewIdentifier</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> submitButton</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">ViewIdentifier?</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> value = newValue &#123;</span><br><span class="line">                <span class="keyword">self</span>.tag = value.rawValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ViewIdentifier</span>(rawValue: <span class="keyword">self</span>.tag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">view</span><span class="params">(withId id: ViewIdentifier)</span></span> -&gt; <span class="type">UIView?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.viewWithTag(id.rawValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;老实说，在我将第一个代码片段复制并粘贴到本文之后，我只是想出了第二种方法，但是到底是什么，也许有人会喜欢它。 😂</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> Uniquely identifying views </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> Uniquely identifying views </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS子类化样式</title>
      <link href="/iOS%E5%AD%90%E7%B1%BB%E5%8C%96%E6%A0%B7%E5%BC%8F/"/>
      <url>/iOS%E5%AD%90%E7%B1%BB%E5%8C%96%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何通过使用 <code>Swift</code> 中的 <code>UIKit</code> 框架中的自定义视图子类来设计和构建 <strong><em>可重用</em></strong> 的用户界面元素。</p></br><h1 id="问题：UI，UX，设计"><a href="#问题：UI，UX，设计" class="headerlink" title="问题：UI，UX，设计"></a><strong>问题：UI，UX，设计</strong></h1><p><strong><em><code>建立用户界面是工作中最难的部分！</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之：设计是找出适合特定问题的最佳解决方案的过程。图形设计通常是指在画布或纸上的物理图形。 <code>UX</code> 实际上就是用户与应用程序交互的方式，换句话说：“客户”旅程的整体虚拟体验。 <code>UI</code> 是他/她将通过触摸屏幕看到并与之交互的可见界面。 👆</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我不得不戴上设计师的帽子（甚至是开发者的帽子），我必须告诉你，在大多数情况下，弄清和实现适当的用户界面是最具挑战性的问题。如今的前端系统（移动，平板电脑甚至台式机应用程序）只是来自 <code>service</code> / <code>API</code>的一些 <code>JSON</code> 数据之上的漂亮叠加层。 🤷‍♂️</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么这么难？好吧，我相信，如果你想成为一名优秀的设计师，那么你也需要适当的工程思维。你必须能够观察整个系统（大图），构造一致的 <code>UI</code> 元素（实际上到处看起来都是一样的），基于功能规范计划所需的体验等等。成为艺术家，跳出思维框框，并能够向他人解释（描述）你的想法也是一个基本要求。 🤯</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在告诉我，哪个行业的工作最艰辛？是的，如今免费提供的每个人都是设计师，有些公司根本不雇用这类专家，而只是让开发人员完成工作。无论如何，让我们专注于如何通过使用 <code>Swift</code> 中的子类来创建漂亮且可重用的设计实现。 👍</p></br><h1 id="外观，主题和样式"><a href="#外观，主题和样式" class="headerlink" title="外观，主题和样式"></a><strong>外观，主题和样式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我几乎没有使用 <code>UIAppearance API</code> 。 这是个人喜好，但是我想直接在视图实例上设置设计属性，例如 <code>font</code>，<code>textColor</code>，<code>backgroundColor</code>。 尽管在某些情况下，我发现外观代理非常好，但是仍然存在一些问题。 也许这将随着 <code>iOS 13</code> 以及期待已久的 <code>dark mode</code> 的到来而改变。</p><blockquote><p><strong><em><code>Dear Apple please make an auto switch based on day / night cycles (you know like the sunset, sunrise option in the home app). 🌙</code></em></strong></p></blockquote><ul><li><strong><em>样式</em></strong> 是指定单个视图外观的属性的集合。</li><li><strong><em>主题</em></strong> 是应用于整个应用程序的一组外观相似的视图样式。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，我通常会创建一些预定义的样式元素集，最可能是字体，颜色，但有时还会是图标等。我喜欢采用以下结构：</p><p><strong>Fonts</strong></p><ul><li>title</li><li>heading</li><li>subheading</li><li>body</li><li>small</li></ul><p><strong>Colors</strong></p><ul><li>title</li><li>heading</li><li>background</li></ul><p><strong>Icons</strong></p><ul><li>back</li><li>share</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以有更多的元素，但是为了简单起见，让我们使用嵌套结构通过一个非常简单的 <code>Swift</code> 解决方案来实现这些元素：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fonts</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> title = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> heading = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">24</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> subheading = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> body = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> small = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Colors</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> title = <span class="type">UIColor</span>.blue</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> heading = <span class="type">UIColor</span>.black</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> background = <span class="type">UIColor</span>.white</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Icons</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> back = <span class="type">UIImage</span>(named: <span class="string">"BackIcon"</span>)!</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> share = <span class="type">UIImage</span>(named: <span class="string">"ShareIcon"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//usage example:</span></span><br><span class="line"><span class="type">App</span>.<span class="type">Fonts</span>.title</span><br><span class="line"><span class="type">App</span>.<span class="type">Colors</span>.background</span><br><span class="line"><span class="type">App</span>.<span class="type">Icons</span>.back</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，我得到了一个非常简单的语法，这很好，虽然这不会让我进行动态样式设置，所以我无法在浅色/深色主题之间切换，但是我真的不介意，因为在大多数情况下 这不是必需的。 😅</p><p><strong><em>Structs vs enums:</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我可以使用枚举代替具有静态属性的结构，但是在这种情况下，我喜欢这种方法的简单性。 我不想弄乱接受枚举的原始值或扩展名。 这只是个人喜好。</p><p><strong>如果你必须支持多个主题怎么办？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这不是什么大问题，你可以根据需要定义协议，并根据需要实施所需的主题协议。 真正的问题是，当你必须在主题之间切换时，因为必须刷新/重新加载整个UI。 ♻️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一些最佳做法，例如，可以使用 <code>NSNotificationCenter</code> 类来通知应用程序中的每个视图/控制器在发生主题更改时进行刷新。 另一个解决方案是简单地重新初始化应用程序的整个 <code>UI</code> ，因此这意味着你基本上从头开始使用全新的 <code>rootViewController</code> 。 😱</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，如果你需要这样的内容，请查看下面的链接，但是如果你只想在应用程序中支持暗模式，建议你等到第一个 <code>iOS 13 beta</code> 发布。 也许 <code>Apple</code> 会提供一些新颖的 <code>API</code> 来简化事情。</p></br><h1 id="自定义视图作为样式元素"><a href="#自定义视图作为样式元素" class="headerlink" title="自定义视图作为样式元素"></a><strong>自定义视图作为样式元素</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们有了定义字体，颜色和其他基本构建块的好方法，是时候将这些样式应用于实际的 <code>UI</code> 元素了。 当然，你可以使用 <code>UIAppearance API</code> ，但是例如，你不能简单地通过外观代理设置自定义字体。 😢</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一件事是我喜欢设计的一致性。 因此，如果标题是我的应用程序中某处的蓝色 <code>32pt</code> 粗体系统字体，我也希望该元素在其他地方都遵循相同的准则。 我通过为每个应用了自定义样式的单个 <code>view</code> 元素创建子类来解决此问题。 因此，例如：</p><ul><li>TitleLabel (blue color, 32pt system font)</li><li>HeadingLabel (blue color, 24pt system font)</li><li>StandardButton (blue background)</li><li>DestructiveButton (red background)</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你有子类，并且正在使用代码中的自动布局约束，则另一件好事是，你可以将所有约束创建逻辑直接放入子类本身。 让我给你看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleLabel</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.textColor = <span class="type">App</span>.<span class="type">Colors</span>.title</span><br><span class="line">        <span class="keyword">self</span>.font = <span class="type">App</span>.<span class="type">Fonts</span>.title</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">constraints</span><span class="params">(<span class="keyword">in</span> view: UIView)</span></span> -&gt; [<span class="type">NSLayoutConstraint</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="keyword">self</span>.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: <span class="number">16</span>),</span><br><span class="line">            <span class="keyword">self</span>.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -<span class="number">16</span>),</span><br><span class="line">            <span class="keyword">self</span>.centerYAnchor.constraint(equalTo: view.centerYAnchor),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我只需要设置一次 <code>font＆textColor</code> 属性，因此在完成视图初始化之后，我可以确保 <code>TitleLabel</code> 的每个实例看起来都完全相同。 用法也很简单，你只需要在接口构建器中设置类名，或者可以像这样简单地创建视图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadView method in a view controller...</span></span><br><span class="line"><span class="keyword">let</span> titleLabel = <span class="type">TitleLabel</span>()</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(titleLabel)</span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate(titleLabel.constraints(<span class="keyword">in</span>: <span class="keyword">self</span>.view))</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最喜欢这种方法的地方是我的约束将在正确的位置，因此它们不会膨胀我的视图控制器的 <code>loadView</code> 方法。 你还可以根据当前情况使用额外的参数创建多个约束变量，因此它可以针对每种情况进行扩展。 👍</p></br><h1 id="视图初始化很难"><a href="#视图初始化很难" class="headerlink" title="视图初始化很难"></a><strong>视图初始化很难</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该解决方案的缺点是，由于界面构建器的支持，视图初始化有点混乱。 你必须子类化每种视图类型（按钮，标签等），并一次又一次地复制并粘贴初始化方法。 我已经有一些有关此的文章，请查看下面的链接。 👇</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决这个问题，我通常以为自己的样式视图创建一个父类来结束。 这是我的标签的抽象基类的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以从现在开始，我只需要重写 <code>initialize</code> 方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleLabel</span>: <span class="title">Label</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.initialize()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = <span class="type">App</span>.<span class="type">Fonts</span>.title</span><br><span class="line">        <span class="keyword">self</span>.textColor = <span class="type">App</span>.<span class="type">Colors</span>.title</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看，它好多了，因为我不再需要处理所需的视图初始化方法，默认情况下，自动调整大小功能也将关闭。 ❤️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我从本课程中学到的最后一点是，如果涉及到 <code>UIKit</code> 框架，则不必担心类和面向对象的编程。 如果在正确的地方使用面向协议的编程（也就是函数式编程），那将是很好的选择，但是由于 <code>UIKit</code> 确实是一个 <code>OOP</code> 框架，所以我相信遵循这些范式而不是选择某些笨拙的方式还是更好的。 🤪</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> 子类化样式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 子类化样式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 选择和播放视频</title>
      <link href="/Swift%20%E9%80%89%E6%8B%A9%E5%92%8C%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/"/>
      <url>/Swift%20%E9%80%89%E6%8B%A9%E5%92%8C%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用视频选择器控制器和 <code>AVPlayer</code> 类（完全用 <code>Swift 5</code> 编写）来记录或选择视频文件。</p></br><h1 id="让我们挑选一些视频！"><a href="#让我们挑选一些视频！" class="headerlink" title="让我们挑选一些视频！"></a><strong>让我们挑选一些视频！</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你还记得我以前有关 <a href="http://www.xuebaonline.com/Swift%205%E4%BD%BF%E7%94%A8UIImagePickerController%E6%8B%BE%E5%8F%96%E5%9B%BE%E5%83%8F/"><strong><em><code>《iOS中图像拾取》</code></em></strong></a> 的教程，那么你知道我已经在 <code>UIKit</code> 的基础上建立了一个可重用的选择器类。 如果你不知道 <code>UIImagePickerController</code> 类的工作方式，请先阅读该教程，因为它为你提供了有关基础知识的出色概述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，你需要在 <code>Info.plist</code> 文件中添加一些密钥，因为你想访问一些个人数据。 你知道：隐私非常重要。 🤫</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;<span class="type">NSCameraUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to take pictures &amp; videos.&lt;/string&gt;</span><br><span class="line">&lt;key&gt;<span class="type">NSPhotoLibraryUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to use your picture &amp; video library.&lt;/string&gt;</span><br><span class="line">&lt;key&gt;<span class="type">NSMicrophoneUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to record sound.&lt;/string&gt;</span><br><span class="line">&lt;key&gt;<span class="type">NSPhotoLibraryAddUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to save pictures &amp; videos to your library.&lt;/string&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于我们不会捕获无声视频，因此我们还必须添加“隐私-麦克风使用说明”字段。 准备，开始，行动！ 🎬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我不会对你说谎，但是这次我有点懒，所以我们的 <code>VideoPicker</code> 类和 <code>ImagePicker</code> 类是90％。 你可以创建一个抽象类，无论如何，我将向你展示最终代码，然后我们可以讨论它们之间的区别。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">VideoPickerDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didSelect</span><span class="params">(url: URL?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoPicker</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> pickerController: <span class="type">UIImagePickerController</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> presentationController: <span class="type">UIViewController?</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">VideoPickerDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(presentationController: <span class="type">UIViewController</span>, delegate: <span class="type">VideoPickerDelegate</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.pickerController = <span class="type">UIImagePickerController</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presentationController = presentationController</span><br><span class="line">        <span class="keyword">self</span>.delegate = delegate</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.pickerController.delegate = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController.allowsEditing = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController.mediaTypes = [<span class="string">"public.movie"</span>]</span><br><span class="line">        <span class="keyword">self</span>.pickerController.videoQuality = .typeHigh</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(<span class="keyword">for</span> type: UIImagePickerController.SourceType, title: String)</span></span> -&gt; <span class="type">UIAlertAction?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="type">UIImagePickerController</span>.isSourceTypeAvailable(type) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIAlertAction</span>(title: title, style: .<span class="keyword">default</span>) &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.pickerController.sourceType = type</span><br><span class="line">            <span class="keyword">self</span>.presentationController?.present(<span class="keyword">self</span>.pickerController, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(from sourceView: UIView)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="literal">nil</span>, message: <span class="literal">nil</span>, preferredStyle: .actionSheet)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .camera, title: <span class="string">"Take video"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .savedPhotosAlbum, title: <span class="string">"Camera roll"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .photoLibrary, title: <span class="string">"Video library"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        alertController.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"Cancel"</span>, style: .cancel, handler: <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="type">UIDevice</span>.current.userInterfaceIdiom == .pad &#123;</span><br><span class="line">            alertController.popoverPresentationController?.sourceView = sourceView</span><br><span class="line">            alertController.popoverPresentationController?.sourceRect = sourceView.bounds</span><br><span class="line">            alertController.popoverPresentationController?.permittedArrowDirections = [.down, .up]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presentationController?.present(alertController, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">pickerController</span><span class="params">(<span class="number">_</span> controller: UIImagePickerController, didSelect url: URL?)</span></span> &#123;</span><br><span class="line">        controller.dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.delegate?.didSelect(url: url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">VideoPicker</span>: <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pickerController(picker, didSelect: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: <span class="keyword">Any</span>])</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url = info[.mediaURL] <span class="keyword">as</span>? <span class="type">URL</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.pickerController(picker, didSelect: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //uncomment this if you want to save the video file to the media library</span></span><br><span class="line"><span class="comment">//        if UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(url.path) &#123;</span></span><br><span class="line"><span class="comment">//            UISaveVideoAtPathToSavedPhotosAlbum(url.path, self, nil, nil)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController(picker, didSelect: url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">VideoPicker</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅有一些小的变化。 第一个是 <code>mediaTypes</code> 属性，你这次可以使用 <code>“public.movie”</code> 值。 另外，你还应该在 <code>pickerController</code> 上设置 <code>videoQuality</code> 属性，因为 <code>4k</code> 始终优于 <code>320</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;委托是最后一点改变的事情。 选择器完成工作后，你可以获取 <code>.mediaURL</code> 属性，该属性是获取媒体文件（也就是捕获/选定的视频文件）的 <code>URL</code> 。 如果记录了一个新文件，你也可以将其保存到媒体库中，这只是两行额外的代码。</p><p>恭喜，播放时间到了！ 📹</p></br><h1 id="使用AVPlayer和UIView播放视频文件"><a href="#使用AVPlayer和UIView播放视频文件" class="headerlink" title="使用AVPlayer和UIView播放视频文件"></a><strong>使用AVPlayer和UIView播放视频文件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当网页的标题背景中有一些主题很好的视频时，这不是很好吗？好吧，通过使用 <code>AVFoundation</code> ， <code>UIKit</code> 和一些底层魔术，你可以在 <code>iOS</code> 中获得完全相同的东西。不用担心，这并不困难。 😬</p><p>你可以使用常规的 <code>UIView</code> 子类，然后将其默认层替换为 <code>AVPlayerLayer</code> 。这样你就可以在视图中直接播放视频。同样， <code>AVPlayer</code> 只是一个简单的控制器对象，可以管理媒体文件的播放和定时。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最困难的部分是检查媒体文件的状态更改。例如，当我第一次尝试录制新视频时，播放器视图的回报在第二秒后不断停止。我必须搜索答案，因为我根本不是 <code>AVFoundation</code> 专家，但是事实证明，你应该注意 <code>rate</code> 属性，因为系统正在尝试缓冲视频，这可能会引起一些问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，我能够将一个相当不错的 <code>VideoView</code> 与一些不错的附加功能放在一起，例如不断循环播放视频或在填充/适合纵横比内容模式之间进行选择。我并不是在告诉你这是 <code>100％</code> 的防弹解决方案，但这是一个很好的起点，而且在某些情况下还绰绰有余。 👻</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Repeat</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> once</span><br><span class="line">        <span class="keyword">case</span> loop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">layerClass</span>: <span class="title">AnyClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AVPlayerLayer</span>.<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> playerLayer: <span class="type">AVPlayerLayer</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.layer <span class="keyword">as</span>! <span class="type">AVPlayerLayer</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> player: <span class="type">AVPlayer?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.playerLayer.player</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.playerLayer.player = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="keyword">var</span> contentMode: <span class="type">UIView</span>.<span class="type">ContentMode</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> <span class="keyword">self</span>.contentMode &#123;</span><br><span class="line">            <span class="keyword">case</span> .scaleAspectFit:</span><br><span class="line">                <span class="keyword">self</span>.playerLayer.videoGravity = .resizeAspect</span><br><span class="line">            <span class="keyword">case</span> .scaleAspectFill:</span><br><span class="line">                <span class="keyword">self</span>.playerLayer.videoGravity = .resizeAspectFill</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">self</span>.playerLayer.videoGravity = .resize</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> `<span class="keyword">repeat</span>`: <span class="type">Repeat</span> = .once</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> url: <span class="type">URL?</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="keyword">self</span>.url <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.teardown()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.setup(url: url)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(*, unavailable)</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(*, unavailable)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.teardown()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">(url: URL)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player = <span class="type">AVPlayer</span>(playerItem: <span class="type">AVPlayerItem</span>(url: url))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player?.currentItem?.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                              forKeyPath: <span class="string">"status"</span>,</span><br><span class="line">                                              options: [.old, .new],</span><br><span class="line">                                              context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player?.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"rate"</span>, options: [.old, .new], context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                               selector: #selector(<span class="keyword">self</span>.itemDidPlayToEndTime(<span class="number">_</span>:)),</span><br><span class="line">                                               name: .<span class="type">AVPlayerItemDidPlayToEndTime</span>,</span><br><span class="line">                                               object: <span class="keyword">self</span>.player?.currentItem)</span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                               selector: #selector(<span class="keyword">self</span>.itemFailedToPlayToEndTime(<span class="number">_</span>:)),</span><br><span class="line">                                               name: .<span class="type">AVPlayerItemFailedToPlayToEndTime</span>,</span><br><span class="line">                                               object: <span class="keyword">self</span>.player?.currentItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.player?.pause()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player?.currentItem?.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"status"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player?.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"rate"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>,</span><br><span class="line">                                                  name: .<span class="type">AVPlayerItemDidPlayToEndTime</span>,</span><br><span class="line">                                                  object: <span class="keyword">self</span>.player?.currentItem)</span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>,</span><br><span class="line">                                                  name: .<span class="type">AVPlayerItemFailedToPlayToEndTime</span>,</span><br><span class="line">                                                  object: <span class="keyword">self</span>.player?.currentItem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">itemDidPlayToEndTime</span><span class="params">(<span class="number">_</span> notification: NSNotification)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span>.<span class="keyword">repeat</span> == .loop <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.player?.seek(to: .zero)</span><br><span class="line">        <span class="keyword">self</span>.player?.play()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">itemFailedToPlayToEndTime</span><span class="params">(<span class="number">_</span> notification: NSNotification)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.teardown()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          of object: <span class="keyword">Any</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> keyPath == <span class="string">"status"</span>, <span class="keyword">let</span> status = <span class="keyword">self</span>.player?.currentItem?.status, status == .failed &#123;</span><br><span class="line">            <span class="keyword">self</span>.teardown()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">            keyPath == <span class="string">"rate"</span>,</span><br><span class="line">            <span class="keyword">let</span> player = <span class="keyword">self</span>.player,</span><br><span class="line">            player.rate == <span class="number">0</span>,</span><br><span class="line">            <span class="keyword">let</span> item = player.currentItem,</span><br><span class="line">            !item.isPlaybackBufferEmpty,</span><br><span class="line">            <span class="type">CMTimeGetSeconds</span>(item.duration) != <span class="type">CMTimeGetSeconds</span>(player.currentTime())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">self</span>.player?.play()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我为你制作了一个示例项目，说实话，我的视图控制器很简单。 它演示了图像拾取和视频捕获功能。 ❤️</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIImagePickerController </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIImagePickerController </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 5使用UIImagePickerController拾取图像</title>
      <link href="/Swift%205%E4%BD%BF%E7%94%A8UIImagePickerController%E6%8B%BE%E5%8F%96%E5%9B%BE%E5%83%8F/"/>
      <url>/Swift%205%E4%BD%BF%E7%94%A8UIImagePickerController%E6%8B%BE%E5%8F%96%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>Swift 5</code> 中的 <code>UIImagePickerController</code> 类从照片库或直接从相机获取图像。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还在寻找视频选择器吗？ 🍿查看我的另一篇有关在 <a href="http://www.xuebaonline.com/Swift%20%E9%80%89%E6%8B%A9%E5%92%8C%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/"><strong><em><code>《iOS中选择和播放视频文件》</code></em></strong></a> 的文章。</p></blockquote></br><h1 id="适用于iOS的可重用图像选择器类"><a href="#适用于iOS的可重用图像选择器类" class="headerlink" title="适用于iOS的可重用图像选择器类"></a><strong>适用于iOS的可重用图像选择器类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在本教程中，我们将创建一个在 <code>UIKit</code> 之上构建的可重用类，以使图像选择对于你的应用程序而言更加愉悦，所有内容均以 <code>Swift 5</code> 编写。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文的灵感来自于我以前尝试以面向协议的方式解决图像拾取问题，但是如今该文章有些过时，而且我不再使用该技术。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;人们总是从过去中学到东西，所以这次我不使用面向协议的方法，而只是使用 <code>ImagePicker</code> 类。 没有单例，没有额外的库，只有一个可以在适当位置实例化的小型帮助程序类可以完成它的工作。 🌄</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我只专注于选择编辑后的图像，如果你想使用实时照片或电影，则始终可以自定义 <code>ImagePicker</code> 类，或创建一个抽象类并为每种媒体类型实现子类。 我也会这样做。 😅</p></blockquote><p>因此，让我们深入研究。</p></br><h1 id="获取隐私权限"><a href="#获取隐私权限" class="headerlink" title="获取隐私权限"></a><strong>获取隐私权限</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，隐私非常重要，因此你必须在应用程序 <code>Info.plist</code> 文件中添加两个重要的键，否则最终将导致可怕的崩溃！ ⚠️</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp1.jpg" alt="Info.plist"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于你要获取一些私人数据，因此必须向用户（和 <code>Apple</code> ）提供说明消息，说明该应用为何要求访问相机和照片库。  <code>NSCameraUsageDescription</code> 用于相机， <code>NSPhotoLibraryUsageDescription</code> 键用于照片库访问。 这两个值都应该是一个简单的字符串，该字符串将向用户解释你为什么需要他/她的裸照。 谨慎很重要！ 🔒</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;<span class="type">NSCameraUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to take pictures.&lt;/string&gt;</span><br><span class="line">&lt;key&gt;<span class="type">NSPhotoLibraryUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to use your photos.&lt;/string&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，如果你想使用直接从相机拍摄的照片，但又不想访问照片库，则只需添加适当的密钥即可。 就是这样，现在我们准备进行一些实际的编码。 ⌨️</p></br><h1 id="剖析-UIImagePickerController"><a href="#剖析-UIImagePickerController" class="headerlink" title="剖析 UIImagePickerController"></a><strong>剖析 UIImagePickerController</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIPickerController</code> 的结构非常简单。 基本上，它是一个常规的视图控制器，你只需设置一些额外的属性即可使其工作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pickerController = <span class="type">UIImagePickerController</span>()</span><br><span class="line">pickerController.delegate = <span class="keyword">self</span></span><br><span class="line">pickerController.allowsEditing = <span class="literal">true</span></span><br><span class="line">pickerController.mediaTypes = [<span class="string">"public.image"</span>, <span class="string">"public.movie"</span>]</span><br><span class="line">pickerController.sourceType = .camera</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许编辑是一个标志，指示在选择和拍照后是否应显示调整大小和裁剪界面，如果为 <code>true</code> ，则应使用 <code>.editedImage</code> 而不是 <code>.originalImage</code> 键（在选择器委托中），以从中获取正确的图像。图片信息字典。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本上有两种媒体类型可用：图像和电影。你可以通过在选择器上调用类方法来获取每种源类型的可用媒体类型字符串： <code>UIImagePickerController.availableMediaTypes（for：.camera）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共有3种可用的源类型：<code>.camera</code>（即相机），还有另外两个选项可从照片库中获取图片。 <code>.photoLibrary</code> 枚举例将为你提供完全访问权限，但如果选择 <code>.savedPhotosAlbum</code> ，则只能限制相机胶卷的选择范围。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该委托应同时实现 <code>UIImagePickerControllerDelegate</code> 和 <code>UINavigationControllerDelegate</code> 协议，但是通常我的导航控制器委托只是一个空的实现。如果你需要额外的导航相关逻辑，则可能还需要在其中创建一些方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;噢，让我们把所有东西放在一起…</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ImagePickerDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didSelect</span><span class="params">(image: UIImage?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ImagePicker</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> pickerController: <span class="type">UIImagePickerController</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> presentationController: <span class="type">UIViewController?</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">ImagePickerDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(presentationController: <span class="type">UIViewController</span>, delegate: <span class="type">ImagePickerDelegate</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.pickerController = <span class="type">UIImagePickerController</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presentationController = presentationController</span><br><span class="line">        <span class="keyword">self</span>.delegate = delegate</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.pickerController.delegate = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController.allowsEditing = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController.mediaTypes = [<span class="string">"public.image"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(<span class="keyword">for</span> type: UIImagePickerController.SourceType, title: String)</span></span> -&gt; <span class="type">UIAlertAction?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="type">UIImagePickerController</span>.isSourceTypeAvailable(type) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIAlertAction</span>(title: title, style: .<span class="keyword">default</span>) &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.pickerController.sourceType = type</span><br><span class="line">            <span class="keyword">self</span>.presentationController?.present(<span class="keyword">self</span>.pickerController, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(from sourceView: UIView)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="literal">nil</span>, message: <span class="literal">nil</span>, preferredStyle: .actionSheet)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .camera, title: <span class="string">"Take photo"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .savedPhotosAlbum, title: <span class="string">"Camera roll"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .photoLibrary, title: <span class="string">"Photo library"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        alertController.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"Cancel"</span>, style: .cancel, handler: <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="type">UIDevice</span>.current.userInterfaceIdiom == .pad &#123;</span><br><span class="line">            alertController.popoverPresentationController?.sourceView = sourceView</span><br><span class="line">            alertController.popoverPresentationController?.sourceRect = sourceView.bounds</span><br><span class="line">            alertController.popoverPresentationController?.permittedArrowDirections = [.down, .up]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presentationController?.present(alertController, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">pickerController</span><span class="params">(<span class="number">_</span> controller: UIImagePickerController, didSelect image: UIImage?)</span></span> &#123;</span><br><span class="line">        controller.dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.delegate?.didSelect(image: image)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImagePicker</span>: <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pickerController(picker, didSelect: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: <span class="keyword">Any</span>])</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = info[.editedImage] <span class="keyword">as</span>? <span class="type">UIImage</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.pickerController(picker, didSelect: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.pickerController(picker, didSelect: image)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImagePicker</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不需要从源类型中进行选择，那么事情就非常简单了，你只需展示你的选择器视图控制器，处理委托中的所有内容即可。 但是，如果你需要从输入源中进行选择，那会涉及更多的逻辑，尤其是在 <code>iPad</code> 上。 📱</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我正在使用 <code>UIAlertController</code> 来组成源类型选择对话框。 我试图添加3个动作（基于选择源类型），但前提是该源类型在给定设备上可用（例如，<code>.camera</code> 在模拟器中不可用）。 你可以通过以下方式检查可用性：<code>UIImagePickerController.isSourceTypeAvailable（type）</code> 。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIAlertController</code> 在 <code>iPad</code> 上需要一些额外的东西，这就是为什么我要在本方法中设置 <code>popoverPresentationController</code> 属性的原因。 通常只需设置 <code>sourceView</code> 和 <code>sourceRect</code> 属性即可，但是你也可以自定义箭头方向。 ⬅️➡️⬆️⬇️</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检查设备是否为 ··· 并设置正确的源代码视图并根据需要进行调整一直是你的任务，否则你的应用将在 <code>iPad</code> 上崩溃。 另一件事是，在选择器完成工作后，你必须弹出 ··· ！ ⚠️</p></br><h1 id="如何使用图像选择器类？"><a href="#如何使用图像选择器类？" class="headerlink" title="如何使用图像选择器类？"></a><strong>如何使用图像选择器类？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，现在你可以拍照了。 我做了一个简单的视图控制器，向你展示了一个真正的快速示例。 你只需要一个 <code>UIImageView</code> 和一个 <code>UIButton</code> 。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp2-1.jpg" alt="UIImageView"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，这是示例视图控制器的代码。 没什么了不起的，我只是将控制器作为 <code>ImagePicker</code> 的 <code>presentationController</code> 进行传递，因此它可以在此之上呈现 <code>UIImagePickerController</code> 。 我将代表从表示控制器中分离出来，因为有时会派上用场。 🤷‍♂️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> imagePicker: <span class="type">ImagePicker!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imagePicker = <span class="type">ImagePicker</span>(presentationController: <span class="keyword">self</span>, delegate: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">showImagePicker</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.imagePicker.present(from: sender)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">ImagePickerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didSelect</span><span class="params">(image: UIImage?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下， <code>ImagePickerDelegate</code> 委托是我能想到的最简单的委托。 它只是给出选择的图像，因此你可以使用它。 但是，在某些情况下，你可能需要图像选择器提供一些附加信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想进一步采取这种方法，则可以创建定义基本功能的抽象类或协议，并在此基础上实现各种媒体选择器控制器以满足你的需求。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIImagePickerController </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIImagePickerController </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中的UITableView教程</title>
      <link href="/Swift%E4%B8%AD%E7%9A%84UITableView%E6%95%99%E7%A8%8B/"/>
      <url>/Swift%E4%B8%AD%E7%9A%84UITableView%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本指南是供初学者通过 <code>Swift</code> 中的自动布局以编程方式学习 <code>UITableView</code> 类的基础的。</p></br><h1 id="如何以代码方式创建表视图？"><a href="#如何以代码方式创建表视图？" class="headerlink" title="如何以代码方式创建表视图？"></a><strong>如何以代码方式创建表视图？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们直接进入编码部分，但首先：启动 <code>Xcode</code> ，创建一个新的 <code>iOS</code> 单视图应用程序项目，像往常一样输入该项目的名称和详细信息，使用 <code>Swift</code> ，最后立即打开 <code>ViewController.swift</code> 文件。 现在抓住键盘！ ⌨️</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本教程中，我不会使用 <code>Interface Builder</code> ，那么我们如何以代码方式创建视图？ 有一个称为 <code>loadView</code> 的方法，你应该在其中将自定义视图添加到视图层次结构中。 你可以选择+单击Xcode中的方法名称并阅读有关 <code>loadView</code> 方法的讨论，但让我总结一下整个过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将使用弱属性来保存对表格视图的引用。 接下来，我们重写 <code>loadView</code> 方法并调用 <code>super</code> ，以使用视图对象（如果有控制器的话，在 <code>nib or a storyboard</code> 文件中）加载控制器的 <code>self.view</code> 属性。 之后，我们将全新的视图分配给本地属性，关闭系统提供的布局，然后将表视图插入到视图层次结构中。 最后，我们使用锚创建一些实际的约束，并保存指向弱属性的指针。 简单！ 🤪</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tableView: <span class="type">UITableView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> tableView = <span class="type">UITableView</span>(frame: .zero, style: .plain)</span><br><span class="line">        tableView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(tableView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">        <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor.constraint(equalTo: tableView.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: tableView.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.leadingAnchor.constraint(equalTo: tableView.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.trailingAnchor.constraint(equalTo: tableView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.tableView = tableView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;始终使用自动布局锚来指定视图约束，如果你不知道如何使用它们，请查看 <a href="http://www.xuebaonline.com/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/"><strong><em><code>《Swift使用布局锚点添加约束》</code></em></strong></a>，学习此 <code>API</code> 仅需15分钟，并且你不会后悔。 对于任何 <code>iOS</code> 开发者来说，这都是一个非常有用的工具！ 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会问：我应该使用弱属性还是强属性作为视图引用？ 我会说，在大多数情况下，如果你不压制 <code>self.view</code> ，则应使用弱项！ 视图层次结构将通过强大的参考来保存你的自定义视图，因此不需要愚蠢的保留周期和内存泄漏。 相信我！ 🤥</p></br><h1 id="UITableView-DataSource"><a href="#UITableView-DataSource" class="headerlink" title="UITableView DataSource"></a><strong>UITableView DataSource</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，我们有一个空的表格视图，让我们显示一些单元格！ 为了用真实数据填充表格视图，我们必须遵守 <code>UITableViewDataSource</code> 协议。 通过简单的委托模式，我们可以为 <code>UITableView</code> 类提供各种信息，因此它将知道需要多少节和行，应该为每行显示哪种单元格以及更多的小细节。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一件事是，<code>UITableView</code> 是一个非常有效的类。 它会重用当前屏幕上未显示的所有单元格，因此，如果你需要处理数百或数千个项目，它将消耗比 <code>UIScrollView</code> 更少的内存。 为了支持这种行为，我们必须使用重用标识符注册我们的单元格类，因此基础系统将知道特定位置需要哪种单元格。 ⚙️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">String</span>] = [</span><br><span class="line">        <span class="string">"👽"</span>, <span class="string">"🐱"</span>, <span class="string">"🐔"</span>, <span class="string">"🐶"</span>, <span class="string">"🦊"</span>, <span class="string">"🐵"</span>, <span class="string">"🐼"</span>, <span class="string">"🐷"</span>, <span class="string">"💩"</span>, <span class="string">"🐰"</span>,</span><br><span class="line">        <span class="string">"🤖"</span>, <span class="string">"🦄"</span>, <span class="string">"🐻"</span>, <span class="string">"🐲"</span>, <span class="string">"🦁"</span>, <span class="string">"💀"</span>, <span class="string">"🐨"</span>, <span class="string">"🐯"</span>, <span class="string">"👻"</span>, <span class="string">"🦖"</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.tableView.register(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"UITableViewCell"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"UITableViewCell"</span>, <span class="keyword">for</span>: indexPath)</span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.items[indexPath.item]</span><br><span class="line">        cell.textLabel?.text = item</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的视图控制器文件中添加几行代码后，表格视图现在可以显示一个漂亮的表情符号列表！ 我们正在使用 <code>UIKit</code> 的内置 <code>UITableViewCell</code> 类，如果你很好地使用 <code>“iOS-system-like”</code> 的单元格设计，那么它将非常方便。 通过告诉我们的节中有多少项（目前只有一个节），我们还符合数据源协议，并在 <code>indexPath</code> 委托方法的行中为行配置了我们的单元格。 😎</p></br><h1 id="自定义UItableViewCell"><a href="#自定义UItableViewCell" class="headerlink" title="自定义UItableViewCell"></a><strong>自定义UItableViewCell</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UITableViewCell</code> 可以提供一些基本元素来显示数据（标题，详细信息，不同样式的图像），但是通常你需要自定义设计的单元格。 这是自定义单元格子类的基本模板，在代码之后，我将解释所有方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>, reuseIdentifier: <span class="type">String?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    override func awakeFromNib() &#123;</span></span><br><span class="line"><span class="comment">        super.awakeFromNib()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>如果要以编程方式使用默认的UITableViewCell</code> ，但使用不同的样式（在初始化单元格后没有设置 <code>cellStyle</code> 的选项），则 <code>init（style：reuseIdentifier</code>） 方法是重写单元格样式属性的好地方。 例如，如果你需要一个 <code>.value1</code> 样式的单元格，只需将参数直接传递给超级调用即可。 这样，你可以使用 <code>4</code> 种预定义的单元格样式。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还必须实现 <code>init（coder :)</code>，所以你应该创建一个通用的 <code>initialize（）</code> 函数，在其中你可以在视图层次结构中添加自定义视图，就像我们在上面的 <code>loadView</code> 方法中所做的那样。 如果使用的是 <code>xib</code> 文件和 <code>IB</code> ，则可以使用 <code>awakeFromNib</code> 方法通过标准 <code>@IBOutlet</code> 属性为视图添加额外的样式（或向层次结构中添加额外的视图）。 👍</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要讨论的最后一个方法是 <code>prepareForReuse</code> 。 正如我之前提到的，单元格被重用，因此，如果要重置某些属性（例如单元格的背景），可以在此处进行操作。 在单元将被重用之前将调用此方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们创建两个新的单元格子类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>, reuseIdentifier: <span class="type">String?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(style: .subtitle, reuseIdentifier: reuseIdentifier)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// nothing to do here :)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel?.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel?.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.imageView?.image = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的自定义单元格将具有大的图像背景，并在视图的中心添加一个带有自定义大小的系统字体的标题标签。 另外，我已将 S<code>wift logo</code> 作为 <code>asset</code> 添加到项目中，因此我们可以得到一个不错的演示图像。 🖼</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> coverView: <span class="type">UIImageView!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> titleLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>, reuseIdentifier: <span class="type">String?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> coverView = <span class="type">UIImageView</span>(frame: .zero)</span><br><span class="line">        coverView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(coverView)</span><br><span class="line">        <span class="keyword">self</span>.coverView = coverView</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> titleLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        titleLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(titleLabel)</span><br><span class="line">        <span class="keyword">self</span>.titleLabel = titleLabel</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.coverView.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.coverView.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.coverView.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.coverView.trailingAnchor),</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.contentView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.titleLabel.centerXAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.titleLabel.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.titleLabel.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.coverView.image = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，让我们开始使用这些新单元格。 我什至会告诉你如何为给定单元格设置自定义高度，以及如何正确处理单元格选择，但是首先我们需要了解另一个委托协议。 🤝</p></br><h1 id="UITableViewDelegate-使用"><a href="#UITableViewDelegate-使用" class="headerlink" title="UITableViewDelegate 使用"></a><strong>UITableViewDelegate 使用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UITableViewDelegate</code> 负责很多事情，但是现在，我们将只讨论一些有趣的方面，例如如何处理单元格选择以及为表格中的每个项目提供自定义单元格高度。 示例代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.tableView.register(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"UITableViewCell"</span>)</span><br><span class="line">            <span class="keyword">self</span>.tableView.register(<span class="type">DetailCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"DetailCell"</span>)</span><br><span class="line">            <span class="keyword">self</span>.tableView.register(<span class="type">CustomCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"CustomCell"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">            <span class="keyword">self</span>.tableView.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"CustomCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">CustomCell</span></span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.items[indexPath.item]</span><br><span class="line">        cell.titleLabel.text = item</span><br><span class="line">        cell.coverView.image = <span class="type">UIImage</span>(named: <span class="string">"Swift"</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">128</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        tableView.deselectRow(at: indexPath, animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.items[indexPath.item]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: item, message: <span class="string">"is in da house!"</span>, preferredStyle: .alert)</span><br><span class="line">        <span class="keyword">let</span> action = <span class="type">UIAlertAction</span>(title: <span class="string">"Ok"</span>, style: .<span class="keyword">default</span>) &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;</span><br><span class="line">        alertController.addAction(action)</span><br><span class="line">        <span class="keyword">self</span>.present(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我正在 <code>viewDidLoad</code> 方法中注册全新的自定义单元格类。 我还更改了 <code>cellForRowAt indexPath</code> 方法中的代码，因此我们可以使用 <code>CustomCell</code> 类代替 <code>UITableViewCells</code> 。 不必担心强制转换，如果此时出现问题，你的应用程序应该崩溃。 🙃</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在这里使用两种委托方法。 在第一个中，我们必须返回一个数字，系统将使用该高度作为单元格。 如果要在每行中使用不同的单元格高度，则也可以通过检查 <code>indexPath</code> 属性或类似属性来实现。 第二个是选择的处理程序。 如果有人点击某个单元格，则将调用此方法，你可以执行一些操作。</p></br><h1 id="带标题和页脚的-Section"><a href="#带标题和页脚的-Section" class="headerlink" title="带标题和页脚的 Section"></a><strong>带标题和页脚的 Section</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表格视图中可能有多个部分，我不会赘述，因为它非常简单。 你只需要使用 <code>indexPaths</code> 即可获取/设置/返回每个节和单元格的正确数据。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tableView: <span class="type">UITableView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> placeholderView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">    <span class="keyword">var</span> isPullingDown = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> `<span class="keyword">default</span>`</span><br><span class="line">        <span class="keyword">case</span> subtitle</span><br><span class="line">        <span class="keyword">case</span> custom</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> style = <span class="type">Style</span>.<span class="keyword">default</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">String</span>: [<span class="type">String</span>]] = [</span><br><span class="line">        <span class="string">"Originals"</span>: [<span class="string">"👽"</span>, <span class="string">"🐱"</span>, <span class="string">"🐔"</span>, <span class="string">"🐶"</span>, <span class="string">"🦊"</span>, <span class="string">"🐵"</span>, <span class="string">"🐼"</span>, <span class="string">"🐷"</span>, <span class="string">"💩"</span>, <span class="string">"🐰"</span>,<span class="string">"🤖"</span>, <span class="string">"🦄"</span>],</span><br><span class="line">        <span class="string">"iOS 11.3"</span>: [<span class="string">"🐻"</span>, <span class="string">"🐲"</span>, <span class="string">"🦁"</span>, <span class="string">"💀"</span>],</span><br><span class="line">        <span class="string">"iOS 12"</span>: [<span class="string">"🐨"</span>, <span class="string">"🐯"</span>, <span class="string">"👻"</span>, <span class="string">"🦖"</span>],</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> tableView = <span class="type">UITableView</span>(frame: .zero, style: .plain)</span><br><span class="line">        tableView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(tableView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor.constraint(equalTo: tableView.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: tableView.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.leadingAnchor.constraint(equalTo: tableView.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.trailingAnchor.constraint(equalTo: tableView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.tableView = tableView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.tableView.register(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"UITableViewCell"</span>)</span><br><span class="line">        <span class="keyword">self</span>.tableView.register(<span class="type">DetailCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"DetailCell"</span>)</span><br><span class="line">        <span class="keyword">self</span>.tableView.register(<span class="type">CustomCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"CustomCell"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.tableView.delegate = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.tableView.separatorStyle = .singleLine</span><br><span class="line">        <span class="keyword">self</span>.tableView.separatorColor = .lightGray</span><br><span class="line">        <span class="keyword">self</span>.tableView.separatorInset = .zero</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.navigationItem.rightBarButtonItem = .<span class="keyword">init</span>(barButtonSystemItem: .refresh, target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.toggleCells))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">toggleCells</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>.style &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">self</span>.style = .subtitle</span><br><span class="line">        <span class="keyword">case</span> .subtitle:</span><br><span class="line">            <span class="keyword">self</span>.style = .custom</span><br><span class="line">        <span class="keyword">case</span> .custom:</span><br><span class="line">            <span class="keyword">self</span>.style = .<span class="keyword">default</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">self</span>.tableView.reloadData()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - helpers</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">key</span><span class="params">(<span class="keyword">for</span> section: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> keys = <span class="type">Array</span>(<span class="keyword">self</span>.items.keys).sorted &#123; first, last -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> first == <span class="string">"Originals"</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> first &lt; last</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> key = keys[section]</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">items</span><span class="params">(<span class="keyword">in</span> section: Int)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> key = <span class="keyword">self</span>.key(<span class="keyword">for</span>: section)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.items[key]!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">item</span><span class="params">(at indexPath: IndexPath)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> items = <span class="keyword">self</span>.items(<span class="keyword">in</span>: indexPath.section)</span><br><span class="line">        <span class="keyword">return</span> items[indexPath.item]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.items.keys.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.items(<span class="keyword">in</span>: section).<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.item(at: indexPath)</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"CustomCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">CustomCell</span></span><br><span class="line">        cell.titleLabel.text = item</span><br><span class="line">        cell.coverView.image = <span class="type">UIImage</span>(named: <span class="string">"Swift"</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, titleForHeaderInSection section: Int)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.key(<span class="keyword">for</span>: section)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">128</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        tableView.deselectRow(at: indexPath, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.item(at: indexPath)</span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: item, message: <span class="string">"is in da house!"</span>, preferredStyle: .alert)</span><br><span class="line">        <span class="keyword">let</span> action = <span class="type">UIAlertAction</span>(title: <span class="string">"Ok"</span>, style: .<span class="keyword">default</span>) &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;</span><br><span class="line">        alertController.addAction(action)</span><br><span class="line">        <span class="keyword">self</span>.present(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管上面的代码片段中添加了一个有趣的内容。 你可以为每个部分都有一个自定义标题，只需添加 <code>titleForHeaderInSection</code> 数据源方法即可。 是的，看起来像狗屎一样，但这与 <code>UI / UX</code> 无关。 😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果你对部分标题的布局不满意，可以创建一个自定义类并使用它来代替内置类。 这是执行自定义节标题视图的方法。 这是可重用视图的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeaderView</span>: <span class="title">UITableViewHeaderFooterView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> titleLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(reuseIdentifier: <span class="type">String?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(reuseIdentifier: reuseIdentifier)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> titleLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        titleLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(titleLabel)</span><br><span class="line">        <span class="keyword">self</span>.titleLabel = titleLabel</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.titleLabel.centerXAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.titleLabel.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.contentView.backgroundColor = .black</span><br><span class="line">        <span class="keyword">self</span>.titleLabel.font = <span class="type">UIFont</span>.boldSystemFont(ofSize: <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">self</span>.titleLabel.textAlignment = .center</span><br><span class="line">        <span class="keyword">self</span>.titleLabel.textColor = .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只剩下几件事要做，你必须注册标题视图，就像你为单元格所做的一样。 完全相同，只是页眉和页脚视图有一个单独的注册“池”。 最后，你必须实现两个其他但相对简单（和熟悉）的委托方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This goes to viewDidLoad, but I don't want to embedd that much code... :)</span></span><br><span class="line"><span class="comment">// self.tableView.register(HeaderView.self, forHeaderFooterViewReuseIdentifier: "HeaderView")</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">32</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, viewForHeaderInSection section: Int)</span></span> -&gt; <span class="type">UIView?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view = tableView.dequeueReusableHeaderFooterView(withIdentifier: <span class="string">"HeaderView"</span>) <span class="keyword">as</span>! <span class="type">HeaderView</span></span><br><span class="line">        view.titleLabel.text = <span class="keyword">self</span>.key(<span class="keyword">for</span>: section)</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>页脚的工作原理与页眉完全相同，只需支持相应的数据源和委托方法即可。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据行或节的索引或任何特定的业务需求，你甚至可以在同一张表视图中具有多个单元格。 我不会在这里进行演示，因为我有一个更好的解决方案，用于混合和重用 <a href="https://gitlab.com/corekit/CoreKit" target="_blank" rel="noopener"><strong><em><code>CoreKit</code></em></strong></a> 框架中的单元格。  🤓</p></br><h1 id="Section-titles-amp-indexes"><a href="#Section-titles-amp-indexes" class="headerlink" title="Section titles &amp; indexes"></a><strong>Section titles &amp; indexes</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，如果你的大脑还没有融化，我将向你展示另外两个对于初学者来说可能很有趣的小东西。 第一个基于两种其他数据源方法，对于长列表而言，这是一个非常令人愉快的添加。 （我更喜欢搜索栏！）🤯</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sectionIndexTitles</span><span class="params">(<span class="keyword">for</span> tableView: UITableView)</span></span> -&gt; [<span class="type">String</span>]? &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要在上面实现这些方法，则可以在表视图的右侧为各节提供一个小的索引视图，因此最终用户将能够在各节之间快速跳转。 就像在官方联系人应用程序中一样。 📕</p></br><h1 id="Selection-vs-highlight"><a href="#Selection-vs-highlight" class="headerlink" title="Selection vs highlight"></a><strong>Selection vs highlight</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你用手指按住单元格时，单元格高亮。 如果你从单元格中松开手指，则将选择该单元格。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要过于复杂。 你只需在自定义单元格类中实现两个方法即可使所有工作正常进行。 我更喜欢立即取消选择我的单元格（如果某些数据选择器布局未使用它们）。 这是代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setSelected</span><span class="params">(<span class="number">_</span> selected: Bool, animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.coverView.backgroundColor = selected ? .red : .clear</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setHighlighted</span><span class="params">(<span class="number">_</span> highlighted: Bool, animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.coverView.backgroundColor = highlighted ? .blue : .clear</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，这非常简单，但是大多数初学者都不知道该怎么做。 此外，他们通常会在重用逻辑发生之前忘记重置单元格，因此列表会不断弄乱单元格状态。 不必太担心这些问题，它们会消失，因为你将对 <code>UITableView API</code> 更有经验。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITableView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITableView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift结合Xib文件自定义UIView</title>
      <link href="/Swift%E7%BB%93%E5%90%88Xib%E6%96%87%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89UIView/"/>
      <url>/Swift%E7%BB%93%E5%90%88Xib%E6%96%87%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89UIView/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是否想学习如何加载 <code>xib</code> 文件以创建自定义视图对象？ 好吧，这个 <code>UIKit</code> 教程只适合你用 <code>Swift</code> 编写。</p><p><strong><em>使用界面生成器创建自定义视图。🤷‍♂️</em></strong></p></br><h1 id="加载-Xib-文件"><a href="#加载-Xib-文件" class="headerlink" title="加载 Xib 文件"></a><strong>加载 <code>Xib</code> 文件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>xib</code> 文件的内容是一件非常容易的事。 你可以使用以下两种方法来加载文件的内容（也称为视图层次结构）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view = <span class="type">UINib</span>(nibName: <span class="string">"CustomView"</span>, bundle: .main).instantiate(withOwner: <span class="literal">nil</span>, options: <span class="literal">nil</span>).first <span class="keyword">as</span>! <span class="type">UIView</span></span><br><span class="line"><span class="comment">// let view = Bundle.main.loadNibNamed("CustomView", owner: nil, options: nil)!.first as! UIView // does the same as above</span></span><br><span class="line">view.frame = <span class="keyword">self</span>.view.bounds</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(view)</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码片段将简单地从 <code>xib</code> 文件中实例化视图对象。 你可以在视图层次结构中拥有多个根对象，但是这次让我们选择第一个并使用它。 我假设在 <code>99％</code> 的情况下，这是获取定制设计视图所需的条件。 你还可以使用上述任何解决方案扩展 <code>UIView</code> 对象，以创建通用视图加载器。 以后再说吧…😊</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法非常简单且便宜，但是有一个小缺点。 你无法获取视图的命名指针（出口），而只能获取根对象。 如果你将设计元素放到屏幕上，那很好，但是如果你需要显示动态数据，那么你可能还希望伸手去拿基础视图。 😃</p></br><h1 id="Outlets-amp-Actions-自定义视图"><a href="#Outlets-amp-Actions-自定义视图" class="headerlink" title="Outlets &amp; Actions 自定义视图"></a><strong><code>Outlets &amp; Actions</code> 自定义视图</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，从 <code>xib</code> 文件加载自定义视图的正确方法如下所示：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你的自定义视图对象中，你实例化 <code>xib</code> 文件的方式与我在此处告诉你的方式完全相同。 👆唯一的区别是你不需要使用方法返回的对象数组，而必须通过接口构建器连接视图对象，使用文件所有者作为参考点，再加上自定义容器视图出口， 它将包含你需要的一切。 🤨</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note: view object is from my previous tutorial, with autoresizing masks disabled</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this is going to be our container object</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> containerView: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// other usual outlets</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.initialize()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first: load the view hierarchy to get proper outlets</span></span><br><span class="line">        <span class="keyword">let</span> name = <span class="type">String</span>(describing: type(of: <span class="keyword">self</span>))</span><br><span class="line">        <span class="keyword">let</span> nib = <span class="type">UINib</span>(nibName: name, bundle: .main)</span><br><span class="line">        nib.instantiate(withOwner: <span class="keyword">self</span>, options: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next: append the container to our view</span></span><br><span class="line">        <span class="keyword">self</span>.addSubview(<span class="keyword">self</span>.containerView)</span><br><span class="line">        <span class="keyword">self</span>.containerView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.containerView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.containerView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.containerView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.containerView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，这里的 <code>initialize</code> 方法只是将 <code>self</code> 的所有者加载到 <code>nib</code> 文件中。 加载过程完成后，将使用 <code>xib文件</code> 中的适当值填充出口指针。 我们需要做的最后一件事。 甚至 <code>xib文件</code> 中的视图都 <code>“以编程方式”</code> 连接到我们的自定义视图对象，但从视觉上看并不是这样。 因此，我们必须将容器视图添加到视图层次结构中。 🤐</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xu-stp1.jpg" alt="xib文件"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要使用自定义视图对象，只需在视图控制器内部从该对象创建一个新实例，最后随意将其添加为子视图！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建议使用自动布局。😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> customView: <span class="type">CustomView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> customView = <span class="type">CustomView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(customView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            customView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.topAnchor),</span><br><span class="line">            customView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.bottomAnchor),</span><br><span class="line">            customView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.leadingAnchor),</span><br><span class="line">            customView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.customView = customView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.customView.textLabel.text = <span class="string">"Lorem ipsum"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，现在你有了一个可以正常工作的自定义 <code>UIView</code> 对象，该对象可以加载 <code>xib</code> 文件以使用其内容。  🤪</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一件事。 如果你不喜欢以编程方式处理视图，或者只是不想弄乱 <code>loadView</code> 方法，只需将其完全删除即可。 接下来，将 <code>@IBOutlet</code> 关键字放在自定义视图类变量之前。 使用 <code>IB</code> 打开情节提要，然后将新的 <code>UIView</code> 元素拖放到控制器上并连接自定义视图插座。 💫</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xu-stp2.png" alt="xib文件"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们来谈谈 <code>IBAction</code> ，它们的工作原理与你期望使用控制器时完全相同。 你可以简单地将按钮连接到自定义视图，然后将操作委派给自定义视图类。 如果要将触摸或特定操作转发给控制器，则应使用委托模式或使用简单的块。 😎</p></br><h1 id="所有权-容器视图"><a href="#所有权-容器视图" class="headerlink" title="所有权/容器视图"></a><strong>所有权/容器视图</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以从视图实例中省略所有 <code>xib</code> 加载机制。 我们可以创建一组扩展，以便拥有一个漂亮的视图加载器，并带有来自 <code>xib</code> 文件的自定义视图类。 这样，你就不再需要容器视图，文件所有者也可以从游戏中删除，这与 <code>Apple</code> 创建的表和集合的可重用单元格大致相同。 🍎</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该知道，以这种方式你将无法再以编程方式使用默认的 <code>UIView</code> 初始化方法，因为xib文件将负责初始化过程。 同样，如果你尝试使用情节提要或 <code>xib</code> 文件中的这种自定义视图，则将无法使用出口，因为不会加载视图类的对应 <code>xib</code> 。 否则，如果你尝试多次加载它，则会陷入无限循环，最终你的应用程序将崩溃。 😈</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UINib</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">instantiate</span><span class="params">()</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.instantiate(withOwner: <span class="literal">nil</span>, options: <span class="literal">nil</span>).first</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nib: <span class="type">UINib</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UINib</span>(nibName: <span class="type">String</span>(describing: <span class="keyword">self</span>), bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">instantiate</span><span class="params">(autolayout: Bool = <span class="literal">true</span>)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="comment">// generic helper function</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">instantiateUsingNib</span>&lt;T: UIView&gt;<span class="params">(autolayout: Bool)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> view = <span class="keyword">self</span>.nib.instantiate() <span class="keyword">as</span>! <span class="type">T</span></span><br><span class="line">            view.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">            <span class="keyword">return</span> view</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingNib(autolayout: autolayout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage (inside a view controller for example)</span></span><br><span class="line"><span class="comment">// let view = CustomView.instantiate()</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像这次使用表或集合视图单元格一样，你必须在视图对象而不是文件所有者上设置自定义视图类。 你必须连接网点，基本上你已完成了所有工作。 🤞</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xu-stp3.png" alt="xib文件"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从现在开始，你应该始终在自定义视图对象上使用实例化方法。 好消息是该函数是通用的，返回正确的实例类型，并且高度可重用。 哦，顺便说一句。 我已经提到了坏消息…🤪</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过重写 <code>awakeAfter</code> 还有另一种技术，但是我不再依赖该解决方案了。 在大多数情况下，你只需将“文件的所有者”设置为自定义视图，然后使用一个容器，这是一个安全的选择。 如果你有特殊需要，则可能需要第二种方法，但是请谨慎使用。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自定义UIView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UICollectionView data source and delegates</title>
      <link href="/UICollectionView%20data%20source%20and%20delegates/"/>
      <url>/UICollectionView%20data%20source%20and%20delegates/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个快速的 <code>UIKit</code> 教程中，我将向你展示如何在不使用 <code>Interface Builder</code> 而是仅使用 <code>Swift</code> 的情况下创建简单的 <code>UICollectionView</code> 。</p></br><h1 id="UICollectionViewCell-纯代码实现"><a href="#UICollectionViewCell-纯代码实现" class="headerlink" title="UICollectionViewCell 纯代码实现"></a><strong><code>UICollectionViewCell</code> 纯代码实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要向单元格中添加视图，则应使用 <code>init（frame :)</code> 方法，并在那里设置视图层次结构。 而不是 <code>awakeFromNib</code> ，你也应该在 <code>init</code> 方法中设置视图的样式。 你可以在常规的 <code>prepareForReuse</code> 方法中重置所有内容。 如你所见，有时使用锚点值得完全抛弃 <code>IB</code> 。 🎉</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> identifier: <span class="type">String</span> = <span class="string">"Cell"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> textLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        textLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(textLabel)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerXAnchor.constraint(equalTo: textLabel.centerXAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerYAnchor.constraint(equalTo: textLabel.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.textLabel = textLabel</span><br><span class="line">        <span class="keyword">self</span>.reset()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line">        <span class="keyword">self</span>.reset()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.textLabel.textAlignment = .center</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="UICollectionView-纯代码创建"><a href="#UICollectionView-纯代码创建" class="headerlink" title="UICollectionView 纯代码创建"></a><strong><code>UICollectionView</code> 纯代码创建</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅使用 <code>Swift</code> 代码创建集合视图控制器仅需要几行。 你可以实现 <code>loadView</code> 并在那里创建你的 <code>UICollectionView</code> 对象。 将其的弱引用存储在控制器内部，其余部分相同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data: [<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">0</span>..&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> collectionView = <span class="type">UICollectionView</span>(frame: .zero, collectionViewLayout: <span class="type">UICollectionViewFlowLayout</span>())</span><br><span class="line">        collectionView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(collectionView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.view.topAnchor.constraint(equalTo: collectionView.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.bottomAnchor.constraint(equalTo: collectionView.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.leadingAnchor.constraint(equalTo: collectionView.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.trailingAnchor.constraint(equalTo: collectionView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView = collectionView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView.dataSource = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.delegate = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.register(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="type">Cell</span>.identifier)</span><br><span class="line">        <span class="keyword">self</span>.collectionView.alwaysBounceVertical = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.backgroundColor = .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.data.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="type">Cell</span>.identifier, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">self</span>.data[indexPath.item]</span><br><span class="line">        cell.textLabel.text = <span class="type">String</span>(data)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegateFlowLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        sizeForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.bounds.width, height: <span class="number">44</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        insetForSectionAt section: Int)</span></span> -&gt; <span class="type">UIEdgeInsets</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIEdgeInsets</span>(top: <span class="number">0</span>, <span class="keyword">left</span>: <span class="number">0</span>, bottom: <span class="number">0</span>, <span class="keyword">right</span>: <span class="number">0</span>) <span class="comment">//.zero</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumInteritemSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumLineSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那很简单。 <code>Anchors</code> 确实非常强大， <code>Interface Builder</code> 很有帮助，但是有时从代码创建视图只是更快。 选择是你的，但请不要担心对用户界面进行编码！ 😅</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UICollectionView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UICollectionView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中UIColor最佳实践</title>
      <link href="/Swift%E4%B8%ADUIColor%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/Swift%E4%B8%ADUIColor%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解什么是颜色模型，如何将十六进制值转换为 <code>UIColor</code> 并返回，如何生成随机颜色，以及在哪里可以找到漂亮的调色板。</p></br><h1 id="什么是色彩模型和色彩空间？"><a href="#什么是色彩模型和色彩空间？" class="headerlink" title="什么是色彩模型和色彩空间？"></a><strong>什么是色彩模型和色彩空间？</strong></h1><p>色彩模型是描述颜色的方法。</p><ul><li>RGB-红色+绿色+蓝色</li><li>HSB-色相+饱和度+亮度</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有其他几种颜色模型，但是如果你要处理 <code>iOS</code> 颜色，则应该熟悉上面的两种。 通常，你将使用 <code>RGBA</code> 和 <code>HSBA</code> 颜色模型，这些颜色模型基本上与上面的扩展相同，其中字母A代表字母 <code>Alpha</code> 。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色彩空间是可以在介质中显示或复制的一组颜色（无论是存储，打印还是显示）。 例如，<code>sRGB</code> 是红色，绿色和蓝色的一组特定强度，它定义了可以通过混合红色，绿色和蓝色的这些范围来再现的颜色。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从理论上已经足够，让我们做一些色彩魔术吧！ 💫💫💫</p><a id="more"></a></br><h1 id="如何在-Swift-中使用-RGBA-和-HSBA-值处理-UIColor-对象？"><a href="#如何在-Swift-中使用-RGBA-和-HSBA-值处理-UIColor-对象？" class="headerlink" title="如何在 Swift 中使用 RGBA 和 HSBA 值处理 UIColor 对象？"></a><strong>如何在 <code>Swift</code> 中使用 <code>RGBA</code> 和 <code>HSBA</code> 值处理 <code>UIColor</code> 对象？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还记得旧的 <code>Windows</code> 时代的旧 <code>Paint</code> 程序吗？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我经常使用 <code>Microsoft Paint</code> ，并且喜欢它。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那时，在没有任何 <code>CS</code> 知识的情况下，我一直想知道必须选择的0到255之间的数字。 如果你使用 <code>RGB</code> 颜色，通常会以相同的方式定义颜色，除了在 <code>iOS</code> 中，值介于0和1之间，但这只是 <code>255</code> 的一部分的不同表示。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，你可以使用相同的逻辑使用 <code>RGB</code> 代码制作颜色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIColor</span>(red: <span class="type">CGFloat</span>(<span class="number">128</span>)/<span class="type">CGFloat</span>(<span class="number">255</span>),</span><br><span class="line">        green: <span class="type">CGFloat</span>(<span class="number">128</span>)/<span class="type">CGFloat</span>(<span class="number">255</span>),</span><br><span class="line">        blue: <span class="type">CGFloat</span>(<span class="number">128</span>)/<span class="type">CGFloat</span>(<span class="number">255</span>),</span><br><span class="line">        alpha: <span class="number">1</span>)</span><br><span class="line"><span class="comment">// this is just about the same gray color but it's more readable</span></span><br><span class="line"><span class="type">UIColor</span>(red: <span class="number">0.5</span>, green: <span class="number">0.5</span>, blue: <span class="number">0.5</span>, alpha: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，你也可以使用HSB值，几乎相同的逻辑适用于这些值，除了色相从 <code>0&#39;</code> 到 <code>360</code>（由于实际的色轮）之外，但是饱和度和亮度以“百分比百分比”格式 <code>0-100</code> 进行测量 ，因此，如果将它们映射到浮点值，则必须考虑这些数字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIColor</span>(hue: <span class="type">CGFloat</span>(<span class="number">120</span>)/<span class="type">CGFloat</span>(<span class="number">360</span>), saturation: <span class="number">0.5</span>, brightness: <span class="number">0.5</span>, alpha: <span class="number">1</span>)</span><br><span class="line"><span class="type">UIColor</span>(hue: <span class="number">0.3</span>, saturation: <span class="number">0.5</span>, brightness: <span class="number">0.5</span>, alpha: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在让我们扭转这种情况，让我向你展示如何在扩展的帮助下从实际的 <code>UIColor</code> 实例取回这些组件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> rgba: (red: <span class="type">CGFloat</span>, green: <span class="type">CGFloat</span>, blue: <span class="type">CGFloat</span>, alpha: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> r: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> g: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> b: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> a: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)</span><br><span class="line">        <span class="keyword">return</span> (r, g, b, a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> hsba: (hue: <span class="type">CGFloat</span>, saturation: <span class="type">CGFloat</span>, brightness: <span class="type">CGFloat</span>, alpha: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> h: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> s: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> b: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> a: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.getHue(&amp;h, saturation: &amp;s, brightness: &amp;b, alpha: &amp;a)</span><br><span class="line">        <span class="keyword">return</span> (h, s, b, a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，这里是如何从 <code>UIColor</code> 读取红色，绿色蓝色斜线色调饱和度亮度和 <code>alpha</code> 分量的方法。 通过这个小巧的扩展名，你可以简单地获取组件值并通过其专有名称使用它们。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIColor</span>.yellow.rgba.red</span><br><span class="line"><span class="type">UIColor</span>.yellow.hsba.hue</span><br></pre></td></tr></table></figure></br><h1 id="如何在-Swift-中将-UIColor-对象的十六进制颜色转换为-RGB-，反之亦然？"><a href="#如何在-Swift-中将-UIColor-对象的十六进制颜色转换为-RGB-，反之亦然？" class="headerlink" title="如何在 Swift 中将 UIColor 对象的十六进制颜色转换为 RGB ，反之亦然？"></a><strong>如何在 <code>Swift</code> 中将 <code>UIColor</code> 对象的十六进制颜色转换为 <code>RGB</code> ，反之亦然？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iOS开发人员101课程，第一个问题：</p><ul><li>我该如何从十六进制字符串创建UIColor？</li><li>如何将十六进制颜色转换为UIColor？</li><li>如何使用十六进制字符串制作UIColor？</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，也许这些不是第一个问题，但是绝对是常见问题。 答案很简单：通过扩展。 对于你的需求，我有一个非常好的解决方案，它将处理大多数情况，例如仅使用1、2、3或6个十六进制值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(hex: <span class="type">Int</span>, alpha: <span class="type">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> red = <span class="type">CGFloat</span>((hex &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>) / <span class="number">255.0</span></span><br><span class="line">        <span class="keyword">let</span> green = <span class="type">CGFloat</span>((hex &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>) / <span class="number">255.0</span></span><br><span class="line">        <span class="keyword">let</span> blue = <span class="type">CGFloat</span>((hex &amp; <span class="number">0xFF</span>)) / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(red: red, green: green, blue: blue, alpha: alpha)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(hex string: <span class="type">String</span>, alpha: <span class="type">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> hex = string.trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines).uppercased()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hex.hasPrefix(<span class="string">"#"</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> index = hex.index(hex.startIndex, offsetBy: <span class="number">1</span>)</span><br><span class="line">            hex = <span class="type">String</span>(hex[index...])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hex.<span class="built_in">count</span> &lt; <span class="number">3</span> &#123;</span><br><span class="line">            hex = <span class="string">"\(hex)\(hex)\(hex)"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hex.range(of: <span class="string">"(^[0-9A-Fa-f]&#123;6&#125;$)|(^[0-9A-Fa-f]&#123;3&#125;$)"</span>, options: .regularExpression) != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> hex.<span class="built_in">count</span> == <span class="number">3</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> startIndex = hex.index(hex.startIndex, offsetBy: <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">let</span> endIndex = hex.index(hex.startIndex, offsetBy: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> redHex = <span class="type">String</span>(hex[..&lt;startIndex])</span><br><span class="line">                <span class="keyword">let</span> greenHex = <span class="type">String</span>(hex[startIndex..&lt;endIndex])</span><br><span class="line">                <span class="keyword">let</span> blueHex = <span class="type">String</span>(hex[endIndex...])</span><br><span class="line"></span><br><span class="line">                hex = redHex + redHex + greenHex + greenHex + blueHex + blueHex</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> startIndex = hex.index(hex.startIndex, offsetBy: <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> endIndex = hex.index(hex.startIndex, offsetBy: <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">let</span> redHex = <span class="type">String</span>(hex[..&lt;startIndex])</span><br><span class="line">            <span class="keyword">let</span> greenHex = <span class="type">String</span>(hex[startIndex..&lt;endIndex])</span><br><span class="line">            <span class="keyword">let</span> blueHex = <span class="type">String</span>(hex[endIndex...])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> redInt: <span class="type">CUnsignedInt</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> greenInt: <span class="type">CUnsignedInt</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> blueInt: <span class="type">CUnsignedInt</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span>(string: redHex).scanHexInt32(&amp;redInt)</span><br><span class="line">            <span class="type">Scanner</span>(string: greenHex).scanHexInt32(&amp;greenInt)</span><br><span class="line">            <span class="type">Scanner</span>(string: blueHex).scanHexInt32(&amp;blueInt)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(red: <span class="type">CGFloat</span>(redInt) / <span class="number">255.0</span>,</span><br><span class="line">                      green: <span class="type">CGFloat</span>(greenInt) / <span class="number">255.0</span>,</span><br><span class="line">                      blue: <span class="type">CGFloat</span>(blueInt) / <span class="number">255.0</span>,</span><br><span class="line">                      alpha: <span class="type">CGFloat</span>(alpha))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(red: <span class="number">0.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.0</span>, alpha: <span class="number">0.0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hexValue: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> color = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> color.cgColor.numberOfComponents &lt; <span class="number">4</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="built_in">c</span> = color.cgColor.components!</span><br><span class="line">            color = <span class="type">UIColor</span>(red: <span class="built_in">c</span>[<span class="number">0</span>], green: <span class="built_in">c</span>[<span class="number">0</span>], blue: <span class="built_in">c</span>[<span class="number">0</span>], alpha: <span class="built_in">c</span>[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> color.cgColor.colorSpace!.model != .rgb &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#FFFFFF"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">c</span> = color.cgColor.components!</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: <span class="string">"#%02X%02X%02X"</span>, <span class="type">Int</span>(<span class="built_in">c</span>[<span class="number">0</span>]*<span class="number">255.0</span>), <span class="type">Int</span>(<span class="built_in">c</span>[<span class="number">1</span>]*<span class="number">255.0</span>), <span class="type">Int</span>(<span class="built_in">c</span>[<span class="number">2</span>]*<span class="number">255.0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是如何与多种输入形式一起使用的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"#cafe00"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"cafe00"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"c"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"ca"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"caf"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="number">0xcafe00</span>),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> values = colors.<span class="built_in">map</span> &#123; $<span class="number">0</span>.hexValue &#125;</span><br><span class="line"><span class="built_in">print</span>(values) <span class="comment">//["#CAFE00", "#CAFE00", "#CCCCCC", "#CACACA", "#CCAAFF", "#CAFE00"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我已经尝试过复制 <code>CSS</code> 规则的行为，因此，如果像 <code>#ffffff</code> 这样的后继字符串（你可以仅使用f，因为＃是可选的），你将可以减少字符的自由度。 你还可以提供整数，这只是一个简单的“重载”便捷初始化方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样，<code>.hexValue</code> 将返回 <code>UIColor</code> 实例的字符串表示形式。 👏👏👏</p></br><h1 id="如何在-Swift-中生成随机的-UIColor-？"><a href="#如何在-Swift-中生成随机的-UIColor-？" class="headerlink" title="如何在 Swift 中生成随机的 UIColor ？"></a><strong>如何在 <code>Swift</code> 中生成随机的 <code>UIColor</code> ？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于初学者来说，这也是一个非常普遍的问题，我真的不想通过深入的说明在这里浪费时间，<code>arc4random（）</code>只是在做它的工作，输出是一种很好的随机生成的颜色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> random: <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">max</span> = <span class="type">CGFloat</span>(<span class="type">UInt32</span>.<span class="built_in">max</span>)</span><br><span class="line">        <span class="keyword">let</span> red = <span class="type">CGFloat</span>(arc4random()) / <span class="built_in">max</span></span><br><span class="line">        <span class="keyword">let</span> green = <span class="type">CGFloat</span>(arc4random()) / <span class="built_in">max</span></span><br><span class="line">        <span class="keyword">let</span> blue = <span class="type">CGFloat</span>(arc4random()) / <span class="built_in">max</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>(red: red, green: green, blue: blue, alpha: <span class="number">1.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="如何在-Swift-中用单色创建一个-1x1-像素的大-UIImage-对象？"><a href="#如何在-Swift-中用单色创建一个-1x1-像素的大-UIImage-对象？" class="headerlink" title="如何在 Swift 中用单色创建一个 1x1 像素的大 UIImage 对象？"></a><strong>如何在 <code>Swift</code> 中用单色创建一个 <code>1x1</code> 像素的大 <code>UIImage</code> 对象？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我正在使用此技巧来设置 <code>UIButton</code> 对象的背景颜色。 原因是状态管理。 如果按下按钮，则背景图像将变暗，因此用户将获得视觉反馈。 但是，通过直接设置 <code>UIButton</code> 实例的背景颜色将无法正常工作，并且事件上的颜色也不会发生任何变化。 👆</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> imageValue: <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(origin: .zero, size: <span class="type">CGSize</span>(width: <span class="number">1</span>, height: <span class="number">1</span>))</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(rect.size)</span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()!</span><br><span class="line">        context.setFillColor(<span class="keyword">self</span>.cgColor)</span><br><span class="line">        context.fill(rect)</span><br><span class="line">        <span class="keyword">let</span> newImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> newImage!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码段将根据源颜色生成一个 <code>1x1</code> 像素的图像对象。 你可以使用它，但这是带有按钮背景的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setBackgroundImage(<span class="type">UIColor</span>.red.imageValue, <span class="keyword">for</span>: .normal)</span><br></pre></td></tr></table></figure></br><h1 id="在线调色板"><a href="#在线调色板" class="headerlink" title="在线调色板"></a><strong>在线调色板</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你找不到合适的颜色吗？ 没问题，这些链接将帮助你选择合适的链接并获得一些启发。 另外，如果你正在寻找平面UI颜色或材料设计颜色，这些是应该首先前往的正确链接。</p><ul><li><a href="https://www.w3schools.com/colors/colors_names.asp" target="_blank" rel="noopener"><strong><em><code>HTML Color Names</code></em></strong></a></li><li><a href="http://colorhunt.co/" target="_blank" rel="noopener"><strong><em><code>Color Hunt</code></em></strong></a></li><li><a href="https://flatuicolors.com/" target="_blank" rel="noopener"><strong><em><code>Flat UI Colors</code></em></strong></a></li><li><a href="http://www.flatuicolorpicker.com/" target="_blank" rel="noopener"><strong><em><code>flatuicolorpicker</code></em></strong></a></li><li><a href="https://www.materialui.co/colors" target="_blank" rel="noopener"><strong><em><code>Material Design Colors</code></em></strong></a></li></ul><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很重要的事情：亲爱的设计师，请永远不要尝试对 <code>iOS</code> 应用程序使用 <code>material design principles</code> 。 谢谢。</p></blockquote></br><h1 id="在线转换颜色"><a href="#在线转换颜色" class="headerlink" title="在线转换颜色"></a><strong>在线转换颜色</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，有一些很棒的在线颜色转换器工具，如果你正在寻找一个很棒的工具，则应该首先尝试这些工具。</p><ul><li><a href="uicolor.xyz"><strong><em><code>uicolor.xyz</code></em></strong></a></li><li><a href="rgb.to"><strong><em><code>rgb.to</code></em></strong></a></li><li><a href="colorizer.org"><strong><em><code>colorizer.org</code></em></strong></a></li></ul></br><h1 id="管理-UIColors"><a href="#管理-UIColors" class="headerlink" title="管理 UIColors"></a><strong>管理 <code>UIColors</code></strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你的应用程序目标是 <code>iOS 11+</code> ，则可以使用 <code>asset catalogs</code> 来组织你的调色板，但是如果你需要低于 <code>iOS 11</code> ，我建议你使用带有静态 <code>UIColor</code> 属性的枚举或结构。 如今，我通常在做这样的事情。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> green: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> <span class="type">UIColor</span>(hex: <span class="number">0x4cd964</span>) &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> yellow: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> <span class="type">UIColor</span>(hex: <span class="number">0xffcc00</span>) &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> red: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> <span class="type">UIColor</span>(hex: <span class="number">0xff3b30</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">App</span>.<span class="type">Color</span>.yellow</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，我将结构中的字体，颜色等分组在一起，但这只是一种处理方式。 你也可以使用 <a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener"><strong><em><code>R.swift</code></em></strong></a> 之类的东西或你喜欢的任何东西。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，我想我已经涵盖了有关UIColor的大多数基本问题。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIColor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS自定义转场(By Swift)</title>
      <link href="/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA(By%20Swift)/"/>
      <url>/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA(By%20Swift)/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，你将学习如何使用自定义转场和百分比驱动的交互来替换 <code>Push</code> ，<code>pop</code> 和模式动画。</p></br><h1 id="UIKit自定义过渡API-理论知识"><a href="#UIKit自定义过渡API-理论知识" class="headerlink" title="UIKit自定义过渡API-理论知识"></a><strong>UIKit自定义过渡API-理论知识</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在进行 <a href="https://developer.apple.com/videos/play/wwdc2013/218/" target="_blank" rel="noopener"><strong><code>自定义转换</code></strong></a> 的过程中涉及许多类和委托，让我们快速地完成这些项目，然后再进行一些编码。</p></br><h2 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a><strong><em>UIViewControllerTransitioningDelegate</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个视图控制器都可以有一个过渡委托，在该委托实现中，你可以提供自定义动画和交互控制器。 这些对象将负责实际的动画处理，并且可以在此委托中将代码“注入” <code>UIKit</code> 框架。 💉💉💉</p><a id="more"></a></br><h2 id="UINavigationControllerDelegate"><a href="#UINavigationControllerDelegate" class="headerlink" title="UINavigationControllerDelegate"></a><strong><em>UINavigationControllerDelegate</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导航控制器委托还具有两种方法，用于自定义推送和弹出动画。 它与视图控制器的过渡委托几乎相同，但是稍后你将看到它的作用。 💥</p></br><h2 id="UINavigationController-Operation"><a href="#UINavigationController-Operation" class="headerlink" title="UINavigationController.Operation"></a><strong><em>UINavigationController.Operation</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导航控制器操作只是一个枚举，其中包含导航动画的“方向”。 通常按下或弹出。</p><blockquote><p><strong><code>提示:</code></strong> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以模态方式呈现和关闭某些内容与在导航堆栈中推送和弹出视图控制器并不完全相同。 稍后再详细介绍。</p></blockquote></br><h2 id="UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerAnimatedTransitioning"></a><strong><em>UIViewControllerAnimatedTransitioning</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些对象由过渡委托返回，因此基本上这是实现精美的自定义视图动画的地方。 😉</p></br><h2 id="UIViewControllerContextTransitioning"><a href="#UIViewControllerContextTransitioning" class="headerlink" title="UIViewControllerContextTransitioning"></a><strong><em>UIViewControllerContextTransitioning</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该上下文封装了有关过渡的所有信息，你可以从该对象获取参与的视图，控制器以及更多其他信息。 过渡上下文可供你在动画期间使用。</p></br><h2 id="UIPercentDrivenInteractiveTransition"><a href="#UIPercentDrivenInteractiveTransition" class="headerlink" title="UIPercentDrivenInteractiveTransition"></a><strong><em>UIPercentDrivenInteractiveTransition</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个视图控制器和另一个视图控制器之间驱动交互式动画的对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，这是一种神奇的功能，使你能够神奇地用手指从屏幕边缘向后（如果你改变主意了）来回滑动导航控制器。 📱</p></br><h1 id="编码自定义过渡动画"><a href="#编码自定义过渡动画" class="headerlink" title="编码自定义过渡动画"></a><strong>编码自定义过渡动画</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们做一些实际的编码！ 我将向你展示如何在导航堆栈内的视图控制器之间制作基本的淡入淡出动画。 首先，我们将从推动画开始。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">FadePushAnimator</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> toViewController = transitionContext.viewController(forKey: .to)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        transitionContext.containerView.addSubview(toViewController.view)</span><br><span class="line">        toViewController.view.alpha = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> duration = <span class="keyword">self</span>.transitionDuration(using: transitionContext)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class="line">            toViewController.view.alpha = <span class="number">1</span></span><br><span class="line">        &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，创建自定义过渡动画非常简单。 你只需要实现两个委托方法。 其中一个将返回动画的持续时间，而另一个将包含实际的过渡。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过渡上下文提供了一个自定义 <code>containterView</code> 对象，你可以在动画中使用它，也可以像我之前提到的那样从该对象中获取参与的视图和控制器。 现在，让我们反转该动画。 👈</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">FadePopAnimator</span>: <span class="title">CustomAnimator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> fromViewController = transitionContext.viewController(forKey: .from),</span><br><span class="line">            <span class="keyword">let</span> toViewController = transitionContext.viewController(forKey: .to)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transitionContext.containerView.insertSubview(toViewController.view, belowSubview: fromViewController.view)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> duration = <span class="keyword">self</span>.transitionDuration(using: transitionContext)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class="line">            fromViewController.view.alpha = <span class="number">0</span></span><br><span class="line">        &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，你只需要实现导航控制器的委托方法即可替换内置的UIKit系统动画。 🛠</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainViewController</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(<span class="number">_</span> navigationController: UINavigationController,</span></span></span><br><span class="line"><span class="function"><span class="params">                              animationControllerFor operation: UINavigationController.Operation,</span></span></span><br><span class="line"><span class="function"><span class="params">                              from fromVC: UIViewController,</span></span></span><br><span class="line"><span class="function"><span class="params">                              to toVC: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> operation &#123;</span><br><span class="line">        <span class="keyword">case</span> .push:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">FadePushAnimator</span>()</span><br><span class="line">        <span class="keyword">case</span> .pop:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">FadePopAnimator</span>()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，你不必制作两个单独的类（ <code>pop</code> 和 <code>push</code> ），也可以通过操作并在单个动画 <code>tarnsitioning</code> 类中实现动画。</p></br><h1 id="Percent-Driven-Interactive-Transition"><a href="#Percent-Driven-Interactive-Transition" class="headerlink" title="Percent Driven Interactive Transition"></a><strong>Percent Driven Interactive Transition</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，现在你知道了如何实现自定义过渡，但现在该使其具有交互性了！ 该过程非常简单，你只需要一个手势识别器和适当的委托方法即可使事情正常进行。 ⌨️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> interactionController: <span class="type">UIPercentDrivenInteractiveTransition?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.view.backgroundColor = .lightGray</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> edge = <span class="type">UIScreenEdgePanGestureRecognizer</span>(target: <span class="keyword">self</span>,</span><br><span class="line">                                                    action: #selector(<span class="keyword">self</span>.handleEdgePan(<span class="number">_</span>:)))</span><br><span class="line">        edge.edges = .<span class="keyword">left</span></span><br><span class="line">        <span class="keyword">self</span>.view.addGestureRecognizer(edge)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.navigationController?.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">handleEdgePan</span><span class="params">(<span class="number">_</span> gesture: UIScreenEdgePanGestureRecognizer)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> translate = gesture.translation(<span class="keyword">in</span>: gesture.view)</span><br><span class="line">        <span class="keyword">let</span> percent = translate.x / gesture.view!.bounds.size.width</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> gesture.state &#123;</span><br><span class="line">        <span class="keyword">case</span> .began:</span><br><span class="line">            <span class="keyword">self</span>.interactionController = <span class="type">UIPercentDrivenInteractiveTransition</span>()</span><br><span class="line">            <span class="keyword">self</span>.navigationController?.popViewController(animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">case</span> .changed:</span><br><span class="line">            <span class="keyword">self</span>.interactionController?.update(percent)</span><br><span class="line">        <span class="keyword">case</span> .ended:</span><br><span class="line">            <span class="keyword">let</span> velocity = gesture.velocity(<span class="keyword">in</span>: gesture.view)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> percent &amp;gt; <span class="number">0.5</span> || velocity.x &amp;gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.interactionController?.finish()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.interactionController?.cancel()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.interactionController = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DetailViewController</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(<span class="number">_</span> navigationController: UINavigationController,</span></span></span><br><span class="line"><span class="function"><span class="params">                              interactionControllerFor animationController: UIViewControllerAnimatedTransitioning)</span></span></span><br><span class="line">        -&gt; <span class="type">UIViewControllerInteractiveTransitioning?</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.interactionController</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在将要弹出的控制器内部，你可以拥有导航控制器的委托的所有权，并使用左屏幕边缘平移手势识别器实现交互式过渡控制器。 整个代码通常进入 <code>UIPercentDrivenInteractiveTransition</code> 的新子类中，但是为了简单起见，这次我们将跳过该部分，并使用这个非常简单的解决方案。  😅</p></br><h1 id="Navigation-vs-modal-presentation"><a href="#Navigation-vs-modal-presentation" class="headerlink" title="Navigation vs modal presentation"></a><strong>Navigation vs modal presentation</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，让我们快速介绍另一件事：为视图控制器自定义模式演示动画。 自定义导航堆栈动画和模式表示样式之间存在微小差异。 如果要自定义视图控制器转换，通常会执行以下操作。 👍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">(<span class="keyword">for</span> segue: UIStoryboardSegue, sender: <span class="keyword">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepare(<span class="keyword">for</span>: segue, sender: sender)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> controller = segue.destination <span class="keyword">as</span>? <span class="type">ModalViewController</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        controller.transitioningDelegate = <span class="keyword">self</span></span><br><span class="line">        controller.modalPresentationStyle = .custom</span><br><span class="line">        controller.modalPresentationCapturesStatusBarAppearance = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用我们已经拥有的相同对象的过渡委托来了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DetailViewController</span>: <span class="title">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forPresented presented: UIViewController,</span></span></span><br><span class="line"><span class="function"><span class="params">                             presenting: UIViewController,</span></span></span><br><span class="line"><span class="function"><span class="params">                             source: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FadePushAnimator</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forDismissed dismissed: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FadePopAnimator</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你运行代码并提供模态视图控制器，则可以正常工作。 当你尝试关闭显示的视图控制器时，会发生此问题。 整个应用程序将转为死亡黑屏（BSOD）。 🖥</p><p><strong><em><code>(pop != dismiss) &amp;&amp; (push != present)</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你必须修改pop动画才能支持模态解雇动画。 简而言之：问题在于放置视图和内存管理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">FadePopAnimator</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TransitionType</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> navigation</span><br><span class="line">        <span class="keyword">case</span> modal</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> type: <span class="type">TransitionType</span></span><br><span class="line">    <span class="keyword">let</span> duration: <span class="type">TimeInterval</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(type: <span class="type">TransitionType</span>, duration: <span class="type">TimeInterval</span> = <span class="number">0.25</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.type = type</span><br><span class="line">        <span class="keyword">self</span>.duration = duration</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.duration</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> fromViewController = transitionContext.viewController(forKey: .from)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.type == .navigation, <span class="keyword">let</span> toViewController = transitionContext.viewController(forKey: .to) &#123;</span><br><span class="line">            transitionContext.containerView.insertSubview(toViewController.view, belowSubview: fromViewController.view)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> duration = <span class="keyword">self</span>.transitionDuration(using: transitionContext)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class="line">            fromViewController.view.alpha = <span class="number">0</span></span><br><span class="line">        &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最简单的解决方案是引入一个新属性，以便你可以基于该标志来决定是否弹出视图控制器。 现在，你也可以安全地将相同的动画器用于模态显示的视图控制器。 😬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，导航栏将始终使用淡入淡出的动画，但遗憾的是无法自定义。 另外，我进行了自定义的模态演示，并且所有内容都在使用交互式过渡。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，如果你不想手动实现自定义动画效果，则可以使用 <a href="https://github.com/lkzhao/Hero" target="_blank" rel="noopener"><strong><em><code>Hero</code></em></strong></a> 优雅的过渡库。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自定义转场 </tag>
            
            <tag> transition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift UICollectionView使用指南</title>
      <link href="/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>UICollectionView</code> ，具有高度可重用性的 <code>UIKit</code> 组件和一些 <code>MVVM</code> 模式，而不会费力地进行索引路径计算。</p></br><h1 id="UICollectionView类的剖析"><a href="#UICollectionView类的剖析" class="headerlink" title="UICollectionView类的剖析"></a><strong>UICollectionView类的剖析</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不熟悉 <code>UICollectionView</code> ，建议立即熟悉此类。 它们是 <code>Apple</code> 和其他第三方开发人员提供的许多应用程序的基本构建块。 就像 <code>UITableView</code> 一样。 结合 <code>IB</code> 和 <code>Swift</code> 代码快速了解和使用它们。 💻</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp1.png" alt="UICollectionView"></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将仅使用强大的 <code>UICollectionView</code> 类来构建 <code>Apple Music</code> 目录，例如从零开始的外观。 标头，水平和垂直滚动，圆形图像，因此，基本上，构建强大的用户界面所需的几乎所有内容。 🤘🏻</p></br><h1 id="如何使用Xcode中的Interface-Builder（IB）创建-UICollectionView-？"><a href="#如何使用Xcode中的Interface-Builder（IB）创建-UICollectionView-？" class="headerlink" title="如何使用Xcode中的Interface Builder（IB）创建 UICollectionView ？"></a><strong>如何使用Xcode中的Interface Builder（IB）创建 UICollectionView ？</strong></h1><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要使用 <code>IB</code> ！</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你仍然想使用 <code>IB</code> ，这是绝对入门的真正快速教程：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp2.png" alt="IB"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建第一个基于 <code>UICollectionView</code> 的屏幕的主要步骤如下：</p><ul><li>将 <code>UICollectionView</code> 对象拖到你的视图控制器</li><li>在集合视图上设置适当的约束</li><li>设置数据源和集合视图的委托</li><li>在控制器内部对单元布局进行原型设计</li><li>在单元格内的视图中添加约束</li><li>设置原型单元格类和重用标识符</li><li>做一些编码：</li></ul></br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">            flowLayout.itemSize = <span class="type">CGSize</span>(width: <span class="keyword">self</span>.collectionView.bounds.width, height: <span class="number">120</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> collectionView: UICollectionView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">"MyCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">MyCell</span></span><br><span class="line">        cell.textLabel.text = <span class="type">String</span>(indexPath.row + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(indexPath.item + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，数据源将提供有关如何填充集合视图的所有必需数据，并且委托将处理用户事件，例如在单元格上轻按。 你应该对数据源和委托方法有清楚的了解，因此请稍候片刻。 ⌨️</p></br><h1 id="如何在-Swift-5-中使用代码设置创建-UICollectionView"><a href="#如何在-Swift-5-中使用代码设置创建-UICollectionView" class="headerlink" title="如何在 Swift 5 中使用代码设置创建 UICollectionView?"></a><strong>如何在 <code>Swift 5</code> 中使用代码设置创建 <code>UICollectionView</code>?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能已经注意到，单元格是集合视图的核心组件。 它们是从可重用的视图派生的，这意味着，如果你有1000个元素的列表，则不会为每个元素创建一千个单元格，而只有少数几个可以填充屏幕大小，并且当你向下滚动列表时 这些项目将被重复使用以显示你的元素。 这仅仅是出于内存方面的考虑，因此与 <code>UIScrollView</code> 不同， <code>UICollectionView</code> （和 <code>UITableView</code> ）类是一个非常聪明且高效的类，但这也是每次显示之前都必须准备（重置内容）单元格的原因。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化也由系统处理，但是值得一提的是，如果使用 <code>Interface Builder</code> ，则应该在 <code>awakeFromNib</code> 方法内进行自定义，但是如果使用代码，则 <code>init（frame :)</code> 是你的地方。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> textLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        textLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(textLabel)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            textLabel.topAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.topAnchor),</span><br><span class="line">            textLabel.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.bottomAnchor),</span><br><span class="line">            textLabel.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.leadingAnchor),</span><br><span class="line">            textLabel.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.textLabel = textLabel</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.contentView.backgroundColor = .lightGray</span><br><span class="line">        <span class="keyword">self</span>.textLabel.textAlignment = .center</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Interface Builder is not supported!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Interface Builder is not supported!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel.text = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们必须实现负责管理集合视图的视图控制器，因为我们没有使用 <code>IB</code> ，所以必须在 <code>loadView</code> 方法内部使用自动布局锚点（如单元格中的 <code>textLabel</code> ）手动创建它。 在视图层次结构准备就绪后，我们还设置了数据源并委托并注册了我们的单元格类以供进一步重用。 请注意，如果你使用 <code>IB</code> ，则此操作由系统自动完成，但是如果你喜欢代码，则必须通过调用适当的注册方法来完成。 你可以注册 <code>nibs</code> 和 <code>classes</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> collectionView = <span class="type">UICollectionView</span>(frame: .zero, collectionViewLayout: <span class="type">UICollectionViewFlowLayout</span>())</span><br><span class="line">        collectionView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(collectionView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            collectionView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.topAnchor),</span><br><span class="line">            collectionView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.bottomAnchor),</span><br><span class="line">            collectionView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.leadingAnchor),</span><br><span class="line">            collectionView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView = collectionView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView.backgroundColor = .white</span><br><span class="line">        <span class="keyword">self</span>.collectionView.dataSource = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView.register(<span class="type">MyCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"MyCell"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> collectionView: UICollectionView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">"MyCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">MyCell</span></span><br><span class="line">        cell.textLabel.text = <span class="type">String</span>(indexPath.row + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(indexPath.row + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegateFlowLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        sizeForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.bounds.size.width - <span class="number">16</span>, height: <span class="number">120</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumLineSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumInteritemSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        insetForSectionAt section: Int)</span></span> -&gt; <span class="type">UIEdgeInsets</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIEdgeInsets</span>.<span class="keyword">init</span>(top: <span class="number">8</span>, <span class="keyword">left</span>: <span class="number">8</span>, bottom: <span class="number">8</span>, <span class="keyword">right</span>: <span class="number">8</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，你应该注意流布局委托方法。 你可以使用这些方法为布局系统提供支持。 流布局将基于这些数字和大小显示所有单元格。  <code>sizeForItemAt</code> 负责单元格的大小，<code>minimumInteritemSpacingForSectionAt</code> 是水平填充，<code>minimumLineSpacingForSectionAt</code> 是垂直填充，<code>insetForSectionAt</code> 是集合视图部分的边距。</p></br><h1 id="section-headers-and-footers"><a href="#section-headers-and-footers" class="headerlink" title="section headers and footers"></a><strong>section headers and footers</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在本节中，我将同时使用 <code>storyboards</code>，<code>nibs</code> 和一些 <code>Swift</code> 代码。 由于某些原因，这是我通常的方法。 虽然我很喜欢用代码进行约束，但大多数人更喜欢视觉编辑器，因此所有单元格都在笔尖内部创建。 为什么是笔尖？ 因为如果你有多个集合视图，这几乎是在它们之间共享单元格的唯一好方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以像创建 <code>section headers</code> 一样完全地创建 <code>section footers</code> ，因此这就是我这次只关注 <code>section headers</code> 的原因，因为从字面上看，你只需要更改一个字即可使用 <code>section footers</code> 。 ⚽️</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp3.png" alt="footers"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你只需要创建两个 <code>xib</code> 文件，一个用于单元格，一个用于头文件。 请注意，你可以使用完全相同的集合视图单元格来在 <code>section</code> 标题中显示内容，但这是一个演示，因此让我们处理两个不同的项目。 你甚至不必从 <code>IB</code> 设置重用标识符，因为我们必须在源代码中注册我们的可重用视图，因此只需设置单元类并连接你的 <code>outlets</code> 即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单元格的注册和 <code>section headers and footers</code> 的注册略有不同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cellNib = <span class="type">UINib</span>(nibName: <span class="string">"Cell"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.collectionView.register(cellNib, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sectionNib = <span class="type">UINib</span>(nibName: <span class="string">"Section"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.collectionView.register(sectionNib, forSupplementaryViewOfKind: <span class="type">UICollectionView</span>.elementKindSectionHeader, withReuseIdentifier: <span class="string">"Section"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现 <code>section header</code> 的数据源如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        viewForSupplementaryElementOfKind kind: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                        at indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionReusableView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> kind == <span class="type">UICollectionView</span>.elementKindSectionHeader <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UICollectionReusableView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> view = collectionView.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: <span class="string">"Section"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">Section</span></span><br><span class="line"></span><br><span class="line">    view.textLabel.text = <span class="type">String</span>(indexPath.section + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供流布局委托的大小也非常简单，但是有时我并没有得到 <code>Apple</code> 的命名约定。 一旦必须切换一种类型，而其他时候则有针对特定类型的确切方法。 🤷‍♂️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                    layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                    referenceSizeForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.bounds.size.width, height: <span class="number">64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 <code>iOS9</code> 开始，可以将 <code>section headers and footers</code> 固定在集合视图可见范围的顶部或底部。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">    flowLayout.sectionHeadersPinToVisibleBounds = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，现在你知道了如何使用集合视图构建基本布局。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复杂的情况怎么样，例如在同一集合视图中使用多种单元格呢？ 索引路径会使事情变得很混乱，所以这就是为什么我基于一种技术来重新发明更好的方法，该技术如何使用 <code>Apple</code> 在 <code>WWDC 2014</code> 上展示的 <a href="https://developer.apple.com/videos/wwdc2014" target="_blank" rel="noopener"><strong><code>集合视图来构建高级用户界面</code></strong></a> 。</p></br><h1 id="基于-CollectionView-的-UI-Framework"><a href="#基于-CollectionView-的-UI-Framework" class="headerlink" title="基于 CollectionView 的 UI Framework"></a><strong>基于 <code>CollectionView</code> 的 <code>UI Framework</code></strong></h1><blockquote><p>CollectionView + ViewModel pattern = ❤️ .</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将快速解释这些组件，然后，你将学习如何使用它们来构建起初我所谈论的 <code>Apple</code> 音乐风格的布局。 🎶</p><h2 id="网格系统"><a href="#网格系统" class="headerlink" title="网格系统"></a><strong><em>网格系统</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集合视图的第一个问题是大小计算。你必须提供集合视图中每个单元的大小（宽度和高度）。</p><ul><li>如果在集合视图中所有内容都具有固定的大小，则只需在流布局本身上设置大小属性</li><li>如果你需要每个项目的动态尺寸，则可以实施流布局委托。 <code>UICollectionViewDelegateFlowLayout</code>（为什么在名称中间使用委托词？？？）并返回布局系统的确切大小</li><li>如果你需要更多控制权，则可以创建一个从 <code>CollectionView（Flow）Layout</code> 派生的新布局子类，并在那里进行所有尺寸计算</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很好，但是你仍然必须弄乱索引路径，特征集合，框架等，以使简单的2、4，n列布局适用于所有设备。这就是为什么我创建了一个非常基本的网格系统进行尺寸计算的原因。使用我的网格类，你可以设置列数并获取x列数的大小，就像在基于 <code>Web</code> 的 <code>CSS</code> 网格系统中一样。 🕸</p><h2 id="单元格重用"><a href="#单元格重用" class="headerlink" title="单元格重用"></a><strong><em>单元格重用</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单元格的注册和重用应该并且可以以类型安全的方式自动化。 你只想使用单元，而根本不关心重用标识符和单元注册。 我做了一些辅助方法，以使进步更加愉快。 重用标识符是从单元格类的名称派生的，因此你不必担心。 大多数开发人员都使用这种做法。</p><h2 id="View-model"><a href="#View-model" class="headerlink" title="View model"></a><strong><em>View model</em></strong></h2><blockquote><p><strong><code>view model = cell (view) + data (model)</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用实际数据填充“模板”单元应该是视图模型的任务。 这就是 <code>MVVM</code> 发挥作用的地方。 我做了一个通用的基本视图模型类，应该将其子类化。 借助协议，你可以在单个集合视图中使用各种单元，而不必担心行和节的计算，并且你可以专注于一项简单的任务：将视图与模型联系起来。 😛</p><h2 id="Section"><a href="#Section" class="headerlink" title="Section"></a><strong><em>Section</em></strong></h2><blockquote><p><strong><code>section = header + footer + cells</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要强调的是，你不想弄乱索引路径，只想将数据放在一起就可以了。 过去，我对“不必要的索引路径计算”进行了充分的努力，因此，我将 <code>section</code> 对象作为一个简单的容器来包装标题，页脚和该部分中的所有项目。 结果？ 通用数据源类，可以与多个单元格一起使用，而无需任何行或节索引计算。 👏👏👏</p><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a><strong><em>数据源</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，为了使我上面提到的所有事情都能起作用，我需要实现集合视图委托，数据源和流布局委托方法。 这就是我的源代码类的诞生。 一切都在这里实现，我正在使用各部分，通过视图模型对网格系统进行建模以建立集合视图。 但是，从理论上讲，足够了，让我们在实践中进行观察。 👓</p></br><h1 id="CollectionView-框架创建示例"><a href="#CollectionView-框架创建示例" class="headerlink" title="CollectionView 框架创建示例"></a><strong>CollectionView 框架创建示例</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何使任何列表或网格布局轻松自如？ 好吧，作为第一步，只需将我的 <code>CollectionView</code> 框架添加为依赖项。 它已经支持<code>Xcode 11</code> ，因此你可以直接从文件菜单使用 <code>Swift</code> 软件包管理器来集成此软件包。</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需在 <code>AppDelegate</code> 文件中添加 <code>@_exported import CollectionView</code> 行，那么你不必担心逐个文件导入框架。</p></blockquote><h2 id="创建-Cell"><a href="#创建-Cell" class="headerlink" title="创建 Cell"></a><strong><em>创建 Cell</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此步骤与常规设置相同，除了你的单元必须是我的 <code>Cell</code> 类的子类。 添加你自己的单元并像往常一样执行所有操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumCell</span>: <span class="title">Cell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> detailTextLabel: <span class="type">UILabel!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">self</span>.textLabel.textColor = .black</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel.textColor = .darkGray</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="number">8</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.reset()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.image = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-Model"><a href="#创建-Model" class="headerlink" title="创建 Model"></a><strong><em>创建 Model</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需选择一个模型对象。 可以是任何东西，但是我的方法是使用 <code>Model</code> 后缀创建新的结构或类。 这样，我知道模型正在引用可重用组件文件夹中的集合视图模型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlbumModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> artist: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> image: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-ViewModel"><a href="#创建-ViewModel" class="headerlink" title="创建 ViewModel"></a><strong><em>创建 ViewModel</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，不用在委托内部或在某些地方的 <code>configure</code> 方法中配置单元格，而是为单元格和将通过视图表示的数据模型创建一个真实的视图模型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumViewModel</span>: <span class="title">ViewModel</span>&lt;<span class="title">AlbumCell</span>, <span class="title">AlbumModel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">updateView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view?.textLabel.text = <span class="keyword">self</span>.model.artist</span><br><span class="line">        <span class="keyword">self</span>.view?.detailTextLabel.text = <span class="keyword">self</span>.model.name</span><br><span class="line">        <span class="keyword">self</span>.view?.imageView.image = <span class="type">UIImage</span>(named: <span class="keyword">self</span>.model.image)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">(grid: Grid)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">            (<span class="keyword">self</span>.collectionView.traitCollection.userInterfaceIdiom == .phone &amp;&amp;</span><br><span class="line">             <span class="keyword">self</span>.collectionView.traitCollection.verticalSizeClass == .compact) ||</span><br><span class="line">            <span class="keyword">self</span>.collectionView?.traitCollection.userInterfaceIdiom == .pad</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> grid.size(<span class="keyword">for</span>: <span class="keyword">self</span>.collectionView, ratio: <span class="number">1.2</span>, items: grid.columns / <span class="number">4</span>, gaps: grid.columns - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> grid.columns == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> grid.size(<span class="keyword">for</span>: <span class="keyword">self</span>.collectionView, ratio: <span class="number">1.1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid.size(<span class="keyword">for</span>: <span class="keyword">self</span>.collectionView, ratio: <span class="number">1.2</span>, items: grid.columns / <span class="number">2</span>, gaps: grid.columns - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置数据源"><a href="#设置数据源" class="headerlink" title="设置数据源"></a><strong><em>设置数据源</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，使用你的真实数据并使用视图模型填充你的集合视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> grid = <span class="type">Grid</span>(columns: <span class="number">1</span>, margin: <span class="type">UIEdgeInsets</span>(all: <span class="number">8</span>))</span><br><span class="line"><span class="keyword">self</span>.collectionView.source = .<span class="keyword">init</span>(grid: grid, [</span><br><span class="line">    [</span><br><span class="line">        <span class="type">HeaderViewModel</span>(.<span class="keyword">init</span>(title: <span class="string">"Albums"</span>))</span><br><span class="line">        <span class="type">AlbumViewModel</span>(<span class="keyword">self</span>.album)</span><br><span class="line">    ],</span><br><span class="line">])</span><br><span class="line"><span class="keyword">self</span>.collectionView.reloadData()</span><br></pre></td></tr></table></figure><h2 id="🍺🤘🏻🎸"><a href="#🍺🤘🏻🎸" class="headerlink" title="🍺🤘🏻🎸"></a>🍺🤘🏻🎸</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恭喜，你已完成第一个 <code>collection</code> 视图。 仅需几行代码，你便拥有了 <code>ROCK SOLID</code>代码，可在大多数情况下为你提供帮助！ 😎</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp4.png" alt="collection"></p></br><h1 id="垂直滚动内的水平滚动"><a href="#垂直滚动内的水平滚动" class="headerlink" title="垂直滚动内的水平滚动"></a><strong>垂直滚动内的水平滚动</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们制作一个包含集合视图的单元格并使用与上述相同的方法怎么办？ 包含 <code>collectionview</code> 的 <code>collection</code> 视图… <code>UICollectionViewception</code> !!! 😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全有可能并且确实很容易做到，为视图模型提供数据的将是一个集合视图源对象，你已经完成了。 示例应用程序中还包括轻松，神奇和超好实现的内容。</p></br><h1 id="带有圆角图片的-Section"><a href="#带有圆角图片的-Section" class="headerlink" title="带有圆角图片的 Section"></a><strong>带有圆角图片的 Section</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多个部分？这也是小菜一碟，如果你阅读了我先前有关 <a href="http://www.xuebaonline.com/UICollectionView%20Cells%EF%BC%9A%E5%9C%86%E5%BD%A2%E5%9B%BE%E5%83%8F%E3%80%81%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC/"><strong><code>设置圆形Collection视图单元</code></strong></a> 的文章，你将知道该如何做，但是请从gitlab中查看源代码，并亲自进行操作。</p></br><h1 id="Callbacks-amp-amp-Actions"><a href="#Callbacks-amp-amp-Actions" class="headerlink" title="Callbacks &amp;&amp; Actions"></a><strong>Callbacks &amp;&amp; Actions</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户事件可以非常容易地处理，因为视图模型可以具有委托或回调块，这仅取决于你喜欢哪一个。 该示例包含一个 <code>onSelect</code> 处理程序，该处理程序超级好并且内置于框架中。 😎</p></br><h1 id="重新计算动态单元大小"><a href="#重新计算动态单元大小" class="headerlink" title="重新计算动态单元大小"></a><strong>重新计算动态单元大小</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我也有一个关于<a href="http://www.xuebaonline.com/Swift%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%85%83%E6%A0%BC/"><strong><code>UICollection视图自动调整大小单元格</code></strong></a> 的文章。 在制作完网格系统并开始使用视图模型之后，我自己可以轻松计算出单元格的高度，大约需要两行额外的代码。 我相信这是值得的，因为就自动旋转而言，自定尺寸的单元格有点麻烦。</p></br><h1 id="支持旋转，自适应"><a href="#支持旋转，自适应" class="headerlink" title="支持旋转，自适应"></a><strong>支持旋转，自适应</strong></h1><p>不必担心太多，你可以根据需要简单地更改网格或检查视图模型中的特征集合。 我想说几乎所有事情都可以立即完成。 那就是它的美，可以随意做任何你想做的事情，并以自己喜欢的方式使用它。 📦</p></br><h1 id="如果我告诉你…又一件事：SwiftUI"><a href="#如果我告诉你…又一件事：SwiftUI" class="headerlink" title="如果我告诉你…又一件事：SwiftUI"></a><strong>如果我告诉你…又一件事：SwiftUI</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你喜欢这种方法很酷，但是如果我告诉你还有更多方法呢？ 你是否想在所有地方都使用相同的模式？ 我的意思是在 <code>iOS</code> ，<code>tvOS</code>，<code>macOS</code>甚至 <code>watchOS</code> 上。  我已经在 <code>CoreKit</code> 框架中创建了所有内容。 还支持 <code>UITableViews</code> ， <code>WKInterfaceTables</code> 。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我真的相信苹果今年会采用类似的方式处理下一代<code>UIKit / AppKit / UXKit</code>框架（当然是用<code>Swift</code>编写的）。 我不是在谈论视图模型模式，而是在每个平台上思考相同的<code>API</code>。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自适应布局 </tag>
            
            <tag> UICollectionView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UICollectionView Cells：圆形图像、支持旋转</title>
      <link href="/UICollectionView%20Cells%EF%BC%9A%E5%9C%86%E5%BD%A2%E5%9B%BE%E5%83%8F%E3%80%81%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC/"/>
      <url>/UICollectionView%20Cells%EF%BC%9A%E5%9C%86%E5%BD%A2%E5%9B%BE%E5%83%8F%E3%80%81%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何通过旋转支持为包装在 <code>UICollectionView</code> 单元格内的 <code>UIImageView</code> 项制作圆角。</p></br><h1 id="UICollectionView-中的圆形单元格"><a href="#UICollectionView-中的圆形单元格" class="headerlink" title="UICollectionView 中的圆形单元格"></a><strong>UICollectionView 中的圆形单元格</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现目标相对容易，但是如果你不知道后台发生了什么，那可能会比你最初想的要难。 因此，让我们创建一个新项目，添加带有 <code>UICollectionViewController</code> 的情节提要，将 <code>UIImageView</code> 拖动到单元格内，调整其大小，添加一些约束，设置单元格标识符。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp1.png" alt="UICollectionViewController"></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它看起来应该像上面的图像。 对于我们的示例应用程序而言，没有什么特别的简单的 <code>UI</code> 。 现在搜索一些随机图像，将其添加到项目中，让我们进行一些实际的编码。 首先，我将向你展示单元子类内部的小技巧。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.layoutIfNeeded()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.setCircularImageView()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setCircularImageView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="type">CGFloat</span>(roundf(<span class="type">Float</span>(<span class="keyword">self</span>.imageView.frame.size.width / <span class="number">2.0</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你能看见它吗？ 是的，你应该重写 <code>bounds</code> 属性。 下一步，我们必须为控制器类编写一些用于收集视图的基本数据源，并为旋转方法提供适当的支持。 🤓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">"Cell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></span><br><span class="line"></span><br><span class="line">        cell.imageView.image = <span class="type">UIImage</span>(named: <span class="string">"Example.jpg"</span>)</span><br><span class="line">        cell.imageView.backgroundColor = .lightGray</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">traitCollectionDidChange</span><span class="params">(<span class="number">_</span> previousTraitCollection: UITraitCollection?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> previousTraitCollection = previousTraitCollection,</span><br><span class="line">            <span class="keyword">self</span>.traitCollection.verticalSizeClass != previousTraitCollection.verticalSizeClass ||</span><br><span class="line">            <span class="keyword">self</span>.traitCollection.horizontalSizeClass != previousTraitCollection.horizontalSizeClass</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">        <span class="keyword">self</span>.collectionView?.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillTransition</span><span class="params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillTransition(to: size, with: coordinator)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line"></span><br><span class="line">        coordinator.animate(alongsideTransition: &#123; context <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">        &#125;, completion: &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.collectionView?.visibleCells.forEach &#123; cell <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> cell = cell <span class="keyword">as</span>? <span class="type">Cell</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                cell.setCircularImageView()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegateFlowLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        sizeForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.frame.size.width/<span class="number">3.0</span> - <span class="number">8</span>,</span><br><span class="line">                      height: collectionView.frame.size.width/<span class="number">3.0</span> - <span class="number">8</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，如果没有重写的 <code>bounds</code> 属性，则该示例在左侧看起来像这样。 😢</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp2.jpg" alt="UICollectionViewController2"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好笑吧？ 右侧的图像是带有超出范围的实际结果，这是预期的行为。 如果你不覆盖边界并且不为可见视图重设 <code>cornerRadius</code> 属性，那么滚动和旋转将真的很奇怪。 你可能会问：但是为什么呢？ 🤔</p></br><h1 id="Layers-springs-amp-struts-说明"><a href="#Layers-springs-amp-struts-说明" class="headerlink" title="Layers, springs &amp; struts 说明"></a><strong>Layers, springs &amp; struts</strong> 说明</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Apple</code> 在 <code>UIKit</code> 中仍然具有基于 <code>“ Springs＆Struts”</code> 的代码。 这意味着框架和边界计算正在底层系统中进行，并且约束系统也在努力工作以找出适当的措施。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当有一个 <code>init（frame :)</code> 方法或一个必需的 <code>init（coder :)</code> 方法时，这些布局会糟透了。 我真的很喜欢 <code>Interface Builder</code> ，但是直到我们没有一个好的工具来创建出色的用户界面， <code>IB</code> 才可能是潜在错误的另一层。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果仅使用自动布局约束或布局锚从代码创建单元，则甚至不会出现此问题！ 这是因为IB根据你在设计原型时提供的框架来创建单元。 但是，如果你忘记了 <code>init（frame :)</code> ，而只是创建了一个新的 <code>UIImageView</code> 实例并让自动布局完成了艰苦的工作，则布局系统将解决所有其他问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> imageView = <span class="type">UIImageView</span>()</span><br><span class="line">        imageView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.addSubview(imageView)</span><br><span class="line">        <span class="keyword">self</span>.imageView = imageView</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.topAnchor)</span><br><span class="line">        <span class="keyword">self</span>.imageView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.bottomAnchor)</span><br><span class="line">        <span class="keyword">self</span>.imageView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.leadingAnchor)</span><br><span class="line">        <span class="keyword">self</span>.imageView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.trailingAnchor)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="type">CGFloat</span>(roundf(<span class="type">Float</span>(<span class="keyword">self</span>.imageView.frame.size.width/<span class="number">2.0</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，你必须编写更多代码，在控制器类中手动注册单元格类，并且还必须重写单元格中的 <code>layoutSubviews</code> 方法，但是它将按预期执行。 🙄</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.collectionView?.register(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，在注册以编程方式创建的单元格之后，你将有一种很好的方式来显示圆形图像。 使用这种技术非常棘手，但是在每种情况下它肯定都有效。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自适应布局 </tag>
            
            <tag> UICollectionView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift支持旋转的自适应单元格</title>
      <link href="/Swift%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%85%83%E6%A0%BC/"/>
      <url>/Swift%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%85%83%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何在Swift中为表格视图和集合视图制作自定义大小的单元格，以支持方向更改和动态字体类型。</p></br><h1 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a><strong>UITableView</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们从 <code>iOS</code> 的标准单视图模板开始。 命名项目，然后直接转到 <code>Main.storyboard</code> 文件。 选择你的 <code>ViewController</code> ，将其删除并创建一个新的 <code>UITableViewController</code> <code>scene</code> 。</p><a id="more"></a><p><img src="http://q8wtfza4q.bkt.clouddn.com/sc-stp1.jpg" alt="Main.storyboard"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将表视图控制器场景设置为初始视图控制器，并使用相应的类创建 <code>TableViewController.swift</code> 文件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dataSource: [<span class="type">String</span>] = [</span><br><span class="line">        <span class="string">"Donec id elit non mi porta gravida at eget metus."</span>,</span><br><span class="line">        <span class="string">"Integer posuere erat a ante venenatis dapibus posuere velit aliquet. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus."</span>,</span><br><span class="line">        <span class="string">"Duis mollis, est non commodo luctus, nisi erat porttitor ligula, eget lacinia odio sem nec elit. Vestibulum id ligula porta felis euismod semper. Nullam id dolor id nibh ultricies vehicula ut id elit. Nullam quis risus eget urna mollis ornare vel eu leo."</span>,</span><br><span class="line">        <span class="string">"Maecenas faucibus mollis interdum."</span>,</span><br><span class="line">        <span class="string">"Donec ullamcorper nulla non metus auctor fringilla. Aenean lacinia bibendum nulla sed consectetur. Cras mattis consectetur purus sit amet fermentum."</span>,</span><br><span class="line">        <span class="string">"Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Maecenas faucibus mollis interdum."</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TableViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dataSource.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"Cell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">TableViewCell</span></span><br><span class="line"></span><br><span class="line">        cell.dynamicLabel?.text = <span class="keyword">self</span>.dataSource[indexPath.row]</span><br><span class="line">        cell.dynamicLabel.font  = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该设置实际上是自我描述的。 你已经有了一个字符串数组作为数据源，以及 <code>UITableViewDataSource</code> 协议的必需实现。</p><p>唯一缺少的是 <code>TableViewCell</code> 类:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> dynamicLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，创建类本身，然后使用界面构建器选择表视图控制器场景并将标签拖到原型单元中。 将原型单元格的类设置为 <code>TableViewCell</code> 。 可重复使用的标识符可以简单地是 <code>“ Cell”</code>。 将 <code>dynamicLabel</code> 插座连接到视图。 将标签的上，下，前，尾约束赋予父视图，默认值为8。选择标签，将字体设置为主体样式，并将 <code>lines</code> 属性设置为零。 就是这么简单。 😂</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sc-stp2.jpg" alt="TableViewCell"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在你已经准备好了。 你只需要在表格视图上设置估计的行高。 在 <code>TableViewController</code> 类内部，更改 <code>viewDidLoad</code> 方法，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">44</span></span><br><span class="line">    <span class="keyword">self</span>.tableView.rowHeight = <span class="type">UITableView</span>.automaticDimension</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>EstimateRowHeight</code> 属性将告诉系统 <code>tableview</code> 应该尝试动态计算每个单元格的高度。 你还应该将 <code>rowHeight</code> 属性更改为自动尺寸，如果不这样做，则系统将使用静态单元格高度-你可以在单元格上设置的界面生成器高度。 现在构建并运行。 你将拥有一个带有自定义尺寸单元格的绝佳表格视图。 你甚至可以旋转设备，它将在两个方向上都能正常工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你在 <code>iOS</code> 辅助功能设置下更改了文字大小，表格视图将反映这些更改，因此它将使布局适应新值。 表格视图的字体大小将使 <code>comcorint</code> 更改为滑块值。 你可能想要订阅 <code>UIContentSizeCategory.didChangeNotification</code> 以便检测大小更改并重新加载 <code>UI</code> 。 此功能称为动态类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>.tableView, selector: #selector(<span class="type">UITableView</span>.reloadData), name: <span class="type">UIContentSizeCategory</span>.didChangeNotification,, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></br><h1 id="UICollectionView"><a href="#UICollectionView" class="headerlink" title="UICollectionView"></a><strong>UICollectionView</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，我们完成了简单的部分。 现在，让我们尝试通过集合视图实现相同的功能。 <code>UICollectionView</code> 是一个通用类，旨在创建自定义布局，因为这种通用行为，你将无法从界面生成器创建自定义单元格。 你必须通过代码来完成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开始之前，我们仍然可以使用 <code>IB</code> 。 创建一个新的集合视图控制器场景，然后将一个推键从上一个表视图单元格拖到这个新的控制器上。 最后，将整个内容嵌入导航控制器中。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sc-stp3.jpg" alt="UICollectionView"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该单元将与我们用于表视图的单元完全相同，但是它是 <code>UICollectionViewCell</code> 的子类，并且我们将直接从代码构造布局。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionViewCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> dynamicLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="keyword">self</span>.bounds)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line">        label.backgroundColor = <span class="type">UIColor</span>.darkGray</span><br><span class="line">        label.numberOfLines = <span class="number">0</span></span><br><span class="line">        label.preferredMaxLayoutWidth = frame.size.width</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(label)</span><br><span class="line">        <span class="keyword">self</span>.dynamicLabel = label</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.dynamicLabel.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setPreferred</span><span class="params">(width: CGFloat)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.dynamicLabel.preferredMaxLayoutWidth = width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们为单元格提供了一个子类，现在让我们创建视图控制器类。 在 <code>viewDidLoad</code> 方法内部，你必须在集合视图上设置 <code>EstimatedItemSize</code> 属性。 如果输入的尺寸错误，自动旋转将无法正常工作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.navigationItem.rightBarButtonItem = <span class="type">UIBarButtonItem</span>(barButtonSystemItem: .refresh, target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.toggleColumns))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.register(<span class="type">CollectionViewCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView?.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">        flowLayout.itemSize = <span class="type">CGSize</span>(width: <span class="number">64</span>, height: <span class="number">64</span>)</span><br><span class="line">        flowLayout.minimumInteritemSpacing = <span class="number">10</span></span><br><span class="line">        flowLayout.minimumLineSpacing = <span class="number">20</span></span><br><span class="line">        flowLayout.sectionInset = <span class="type">UIEdgeInsets</span>(top: <span class="number">10</span>, <span class="keyword">left</span>: <span class="number">10</span>, bottom: <span class="number">10</span>, <span class="keyword">right</span>: <span class="number">10</span>)</span><br><span class="line">        flowLayout.estimatedItemSize = <span class="type">CGSize</span>(width: <span class="keyword">self</span>.preferredWith(forSize: <span class="keyword">self</span>.view.bounds.size), height: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.reloadData()</span><br><span class="line"></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>.collectionView!, selector: #selector(<span class="type">UICollectionView</span>.reloadData), name: <span class="type">UIContentSizeCategory</span>.didChangeNotification, object: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在旋转方法内部，必须使集合视图布局无效，并在发生过渡时重新计算可见的单元格大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">traitCollectionDidChange</span><span class="params">(<span class="number">_</span> previousTraitCollection: UITraitCollection?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span></span><br><span class="line">        <span class="keyword">let</span> previousTraitCollection = previousTraitCollection,</span><br><span class="line">        <span class="keyword">self</span>.traitCollection.verticalSizeClass != previousTraitCollection.verticalSizeClass ||</span><br><span class="line">        <span class="keyword">self</span>.traitCollection.horizontalSizeClass != previousTraitCollection.horizontalSizeClass</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">    <span class="keyword">self</span>.collectionView?.reloadData()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillTransition</span><span class="params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewWillTransition(to: size, with: coordinator)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">    <span class="keyword">self</span>.estimateVisibleCellSizes(to: size)</span><br><span class="line"></span><br><span class="line">    coordinator.animate(alongsideTransition: &#123; context <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    &#125;, completion: &#123; context <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有两种辅助方法可以计算估计的项目大小的首选宽度并重新计算可见的单元格大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preferredWith</span><span class="params">(forSize size: CGSize)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> columnFactor: <span class="type">CGFloat</span> = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.twoColumns &#123;</span><br><span class="line">        columnFactor = <span class="number">2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (size.width - <span class="number">30</span>) / columnFactor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">estimateVisibleCellSizes</span><span class="params">(to size: CGSize)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> collectionView = <span class="keyword">self</span>.collectionView <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView?.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">        flowLayout.estimatedItemSize = <span class="type">CGSize</span>(width: <span class="keyword">self</span>.preferredWith(forSize: size), height: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    collectionView.visibleCells.forEach(&#123; cell <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cell = cell <span class="keyword">as</span>? <span class="type">CollectionViewCell</span> &#123;</span><br><span class="line">            cell.setPreferred(width: <span class="keyword">self</span>.preferredWith(forSize: size))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果进行适当的计算，甚至可以包含多列。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我只有一件事无法解决，但这只是一条日志消息。 如果向后旋转设备，则某些单元格将不可见，布局引擎将无法对这些单元格进行快照。</p><p><strong><em>快照尚未渲染的视图将导致快照为空。 确保在快照之前或屏幕更新后快照至少已渲染一次视图。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你可以通过某种方式使此消息消失 <code>OS_ACTIVITY_MODE = disable</code> 。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自适应布局 </tag>
            
            <tag> UITableView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift使用布局锚点添加约束</title>
      <link href="/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/"/>
      <url>/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Auto Layout</code> 经常引起抱怨的是，语法以编程方式创建约束的方式多么繁琐和难以理解。 幸运的是，<code>iOS 9</code> 做了很多改进。 <code>堆栈视图</code> 消除了我们在典型布局中创建许多约束的需要。 相比较而言，布局锚点和布局指南的引入却被忽略了，但同样有用。 从《 Apple自动版面指南》中：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以编程方式创建约束时，你有三个选择：可以使用 <code>layout anchors</code> ，可以使用 <code>NSLayoutConstraint</code> 类，或者可以使用可视格式语言。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将再次看一下布局指南，但是现在这里是我关于使用布局锚点在代码中轻松创建约束的说明：</p><a id="more"></a></br><h1 id="创建约束"><a href="#创建约束" class="headerlink" title="创建约束"></a><strong>创建约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先提醒一下使用 <code>NSLayoutConstraint</code> 类方法创建约束的方式。 假设我们有一个堆栈视图，我们想要固定到视图控制器顶级视图的左右边距：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLayoutConstraint</span>(item: stackView,</span><br><span class="line">  attribute: .leading,</span><br><span class="line">  relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">  toItem: view,</span><br><span class="line">  attribute: .leadingMargin,</span><br><span class="line">  multiplier: <span class="number">1</span>,</span><br><span class="line">  constant: <span class="number">0</span>).isActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="type">NSLayoutConstraint</span>(item: stackView,</span><br><span class="line">  attribute: .trailing,</span><br><span class="line">  relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">  toItem: view,</span><br><span class="line">  attribute: .trailingMargin,</span><br><span class="line">  multiplier: <span class="number">1</span>,</span><br><span class="line">  constant: <span class="number">0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以将堆栈视图固定在顶部布局指南下方，以免被导航栏隐藏：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLayoutConstraint</span>(item: stackView,</span><br><span class="line">attribute: .top,</span><br><span class="line">relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">toItem: topLayoutGuide,</span><br><span class="line">attribute: .bottom,</span><br><span class="line">multiplier: <span class="number">1</span>,</span><br><span class="line">constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为我们可以同意，这既不美观也不容易理解（ <code>Objective-C</code> 版本更糟）。 在我看来，使用 <strong><em>Visual Format Language</em></strong> 并不是更好：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> views: [<span class="type">String</span>: <span class="type">AnyObject</span>] =</span><br><span class="line">  [<span class="string">"stackView"</span> : stackView,</span><br><span class="line">   <span class="string">"topLayoutGuide"</span> : topLayoutGuide]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="type">NSLayoutConstraint</span>.constraints(</span><br><span class="line">  withVisualFormat: <span class="string">"|-[stackView]-|"</span>,</span><br><span class="line">  options: [],</span><br><span class="line">  metrics: <span class="literal">nil</span>,</span><br><span class="line">  views: views)</span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate(h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="type">NSLayoutConstraint</span>.constraints(</span><br><span class="line">  withVisualFormat: <span class="string">"V:|[topLayoutGuide]-[stackView]"</span>,</span><br><span class="line">  options: [],</span><br><span class="line">  metrics: <span class="literal">nil</span>,</span><br><span class="line">  views: views)</span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate(v)</span><br></pre></td></tr></table></figure></br><h1 id="使用-Layout-Anchors-创建约束"><a href="#使用-Layout-Anchors-创建约束" class="headerlink" title="使用 Layout Anchors 创建约束"></a><strong>使用 <code>Layout Anchors</code> 创建约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布局锚点使创建约束更加容易。 从文档中：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>NSLayoutAnchor</code> 类是用于使用流畅的 <code>API</code> 创建 <code>NSLayoutConstraint</code> 对象的工厂类。 使用这些约束可以使用“自动布局”以编程方式定义你的布局。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布局锚点是 <code>UIView</code>（或<code>UILayoutGuide</code> ）上的属性。 每个属性都是 <code>NSLayoutAnchor</code> 的子类，其方法可直接为其他相同类型的布局锚创建约束。 <code>UIView</code> 具有十二种不同的布局锚点属性，可用于创建水平，垂直或基于大小的约束：</p><h2 id="水平约束"><a href="#水平约束" class="headerlink" title="水平约束"></a><strong><em>水平约束</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于创建水平约束的  <code>NSLayoutXAxisAnchor</code> 类型的布局锚点：</p><ul><li><code>centerXAnchor</code></li><li><code>leadingAnchor</code> 和 <code>trailingAnchor</code></li><li><code>leftAnchor</code> 和 <code>rightAnchor</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，创建约束以使两个视图居中对齐：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">myView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.centerXAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.centerXAnchor].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><p><strong><em>请注意如何从一个视图上的锚点开始并为另一个视图上的锚点创建约束。</em></strong></p><h2 id="垂直约束"><a href="#垂直约束" class="headerlink" title="垂直约束"></a><strong><em>垂直约束</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于创建垂直约束的 <code>NSLayoutYAxisAnchor</code> 类型的布局锚点：</p><ul><li><code>centerYAnchor</code></li><li><code>bottomAnchor</code> 和 <code>topAnchor</code></li><li><code>firstBaselineAnchor</code> 和 <code>lastBaselineAnchor</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，要在间距恒定的两个视图的顶部和底部锚点之间创建约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swift</span><br><span class="line">myView.bottomAnchor.constraint(equalTo: view.topAnchor,</span><br><span class="line">       constant: 8).isActive&#x3D;true</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.bottomAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.topAnchor</span><br><span class="line">      constant:<span class="number">8.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="基于-Size-的约束"><a href="#基于-Size-的约束" class="headerlink" title="基于 Size 的约束"></a><strong><em>基于 Size 的约束</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>NSLayoutDimension</code> 类型的布局锚，用于创建基于 <code>Size</code> 的约束：</p><ul><li><code>heightAnchor</code> 和 <code>widthAnchor</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，为视图创建宽度约束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">myView.widthAnchor.constraint(equalToConstant: <span class="number">50.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.widthAnchor constraintEqualToConstant:<span class="number">50.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个示例，使用 <code>multiplier</code> 使一个视图的高度是另一个视图的高度的两倍：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">myView.heightAnchor.constraint(equalTo: otherView.heightAnchor,</span><br><span class="line">       multiplier: <span class="number">2.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.heightAnchor constraintEqualToAnchor:<span class="keyword">self</span>.otherView.heightAnchor </span><br><span class="line">      multiplier:<span class="number">2.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="视图边距"><a href="#视图边距" class="headerlink" title="视图边距"></a><strong><em>视图边距</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIView</code> 没有用于创建堆栈视图约束时使用的前，后边距的布局锚。 相反，<code>iOS 9</code> 添加了两个新属性， <code>layoutMarginGuide</code> 和可读 <code>readableContentGuide</code> ，它们又具有布局锚点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，要将子视图的前沿约束到父视图的前面：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="keyword">let</span> margins = view.layoutMarginsGuide    </span><br><span class="line">myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line"><span class="type">UILayoutGuide</span> *margins = <span class="keyword">self</span>.view.layoutMarginsGuide;</span><br><span class="line">[<span class="keyword">self</span>.myView.leadingAnchor constraintEqualToAnchor:</span><br><span class="line">      margins.leadingAnchor].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="顶部和底部布局"><a href="#顶部和底部布局" class="headerlink" title="顶部和底部布局"></a><strong><em>顶部和底部布局</em></strong></h2><blockquote><p><strong><code>提示:</code></strong> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顶部和底部布局指南已由 <code>iOS 11</code> 中的 <code>“Safe Area Layout Guide ”</code> 代替。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你要相对于顶部或底部 <code>UIKit</code> 工具栏定位内容时，视图控制器具有 <code>topLayoutGuide</code> 和 <code>bottomLayoutGuide</code> 属性。 从 <code>iOS 9</code> 开始，这两个属性均符合 <code>UILayoutSupport</code>  协议，该协议为 <code>bar</code> 提供了 <code>bottomAnchor</code> ， <code>topAnchor</code> 和 <code>heightAnchor</code> 属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，要将视图放置在顶部布局指南底部下方8个点处：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">    myView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor,</span><br><span class="line">       constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">    [<span class="keyword">self</span>.stackView.topAnchor constraintEqualToAnchor:<span class="keyword">self</span>.topLayoutGuide.bottomAnchor</span><br><span class="line">       constant:<span class="number">8.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="控件组合布局"><a href="#控件组合布局" class="headerlink" title="控件组合布局"></a><strong><em>控件组合布局</em></strong></h2><p><strong>那么我们如何使用布局锚创建堆栈视图约束？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们获得父视图的 <code>leading</code> 和 <code>trailing</code> 边距：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> margins = view.layoutMarginsGuide</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建 <code>leading</code> 和 <code>trailing</code>  水平约束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = <span class="literal">true</span></span><br><span class="line">stackView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我们使用视图控制器的 <code>topLayoutGuide</code> 属性将堆栈视图固定在导航栏下方的8点处：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor,</span><br><span class="line">          constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Objective-C</code> 版本稍微冗长一些，但仍有很大改进：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UILayoutGuide</span> *margins = <span class="keyword">self</span>.view.layoutMarginsGuide;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.stackView.leadingAnchor</span><br><span class="line">      constraintEqualToAnchor:margins.leadingAnchor].active = <span class="type">YES</span>;</span><br><span class="line">[<span class="keyword">self</span>.stackView.trailingAnchor</span><br><span class="line">      constraintEqualToAnchor:margins.trailingAnchor].active = <span class="type">YES</span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.stackView.topAnchor</span><br><span class="line">      constraintEqualToAnchor:<span class="keyword">self</span>.topLayoutGuide.bottomAnchor</span><br><span class="line">      constant:<span class="number">8.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与以前的代码相比，我发现更容易理解这些约束的意图。</p></br><h1 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a><strong>了解更多</strong></h1><ul><li><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ProgrammaticallyCreatingConstraints.html" target="_blank" rel="noopener"><strong><code>Programmatically Creating Constraints (Apple Auto Layout Guide)</code></strong></a></li><li><a href="https://developer.apple.com/videos/play/wwdc2015/219/" target="_blank" rel="noopener"><strong><code>WWDC 2015 Session 219 Mysteries of Auto Layout, Part 2</code></strong></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自动化布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift掌握iOS自动布局锚点</title>
      <link href="/Swift%E6%8E%8C%E6%8F%A1iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9/"/>
      <url>/Swift%E6%8E%8C%E6%8F%A1iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;寻找使用布局锚点的最佳实践吗？ 让我们学习如何使用 <code>Swift</code> 以正确的方式使用 <code>iOS</code> 自动布局系统。</p><h1 id="以代码方式创建视图和约束"><a href="#以代码方式创建视图和约束" class="headerlink" title="以代码方式创建视图和约束"></a><strong>以代码方式创建视图和约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我想回顾一下 <code>UIViewController</code> 生命周期方法，你可能对其中一些方法很熟悉。 它们按以下顺序被调用：</p><ul><li><code>loadView</code></li><li><code>viewDidLoad</code></li><li><code>viewWillAppear</code></li><li><code>viewWillLayoutSubviews</code></li><li><code>viewDidLayoutSubviews</code></li><li><code>viewDidAppear</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在自动布局之前，你必须在 <code>viewDidLayoutSubviews</code> 方法内进行布局计算，但是由于这是专业的自动布局教程，因此我们仅关注 <code>loadView</code> 和 <code>viewDidLoad</code> 方法。 🤓</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些是使用自动布局创建视图层次结构的基本规则：</p><ul><li>永远不要自己手动计算帧！</li><li>使用 <code>.zero</code> 初始化视图 <code>frame</code></li><li>将 <code>translatesAutoresizing</code>, <code>MaskIntoConstraints</code> 设置为 <code>false</code></li><li>使用 <code>addSubview</code> 将视图添加到视图层次结构</li><li>创建并激活你的布局约束 <code>NSLayoutConstraint.activate</code></li><li>使用 <code>loadView</code> 代替 <code>viewDidLoad</code> 创建具有约束的视图</li><li>通过使用弱引用来管理内存管理</li><li>在 <code>viewDidLoad</code> 中设置所有其他属性，例如背景色等。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理论足够，下面是一个简短的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> testView: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">        testView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(testView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            testView.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            testView.widthAnchor.constraint(equalTo: testView.heightAnchor),</span><br><span class="line">            testView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">            testView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.testView = testView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView.backgroundColor = .red</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很简单吧？ 只需几行代码，你就可以得到一个大小固定的中心对齐视图，并带有专用的类属性引用。 如果通过接口构建器创建完全相同的对象，则调用 <code>loadView</code> 方法，但是你必须设置对该视图的 <code>@IBOutlet</code> 引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没关系，请随意选择。 有时我喜欢和 <code>IB</code> 一起玩，但是在大多数情况下，我更喜欢编程的做事方式。 😛</p></br><h1 id="常见的UIKit自动布局约束用例"><a href="#常见的UIKit自动布局约束用例" class="headerlink" title="常见的UIKit自动布局约束用例"></a><strong>常见的UIKit自动布局约束用例</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我只使用布局锚。 你可能会浪费时间使用 <code>visual format language</code> ，但这绝对是死胡同。 因此，请记住我的话：仅使用锚点或堆栈视图，请勿使用其他任何视图！ 😇</p><p>这是我用来创建漂亮布局的最常见模式。 😉</p><h2 id="设置固定宽度或高度"><a href="#设置固定宽度或高度" class="headerlink" title="设置固定宽度或高度"></a><strong><em>设置固定宽度或高度</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个是最简单的一个：将视图的高度或宽度设置为固定点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.widthAnchor.constraint(equalToConstant: <span class="number">320</span>),</span><br><span class="line">testView.heightAnchor.constraint(equalToConstant: <span class="number">240</span>),</span><br></pre></td></tr></table></figure><h2 id="设定长宽比"><a href="#设定长宽比" class="headerlink" title="设定长宽比"></a><strong><em>设定长宽比</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置视图的纵横比只是将宽度限制为高度，反之亦然，你可以通过 <code>multiplier</code> 简单地定义倍数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">testView.widthAnchor.constraint(equalTo: testView.heightAnchor, multiplier: <span class="number">16</span>/<span class="number">9</span>),</span><br></pre></td></tr></table></figure><h2 id="水平和垂直居中"><a href="#水平和垂直居中" class="headerlink" title="水平和垂直居中"></a><strong><em>水平和垂直居中</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将视图居中放置在另一个视图中是一件很简单的事情，为此需要特定的锚点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">testView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br></pre></td></tr></table></figure><h2 id="伸展-用边距填充内部视图"><a href="#伸展-用边距填充内部视图" class="headerlink" title="伸展 | 用边距填充内部视图"></a><strong><em>伸展 | 用边距填充内部视图</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里唯一棘手的部分是，对于常量，尾部约束和底部约束的行为与顶部和前部约束略有不同。 通常，你必须使用负值，但经过几次尝试，你将在这里理解逻辑。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.topAnchor, constant: <span class="number">32</span>),</span><br><span class="line">testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.leadingAnchor, constant: <span class="number">32</span>),</span><br><span class="line">testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.trailingAnchor, constant: -<span class="number">32</span>),</span><br><span class="line">testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.bottomAnchor, constant: -<span class="number">32</span>),</span><br></pre></td></tr></table></figure><h2 id="比例宽度或高度"><a href="#比例宽度或高度" class="headerlink" title="比例宽度或高度"></a><strong><em>比例宽度或高度</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不想使用常量值，可以使用 <code>multiplier</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.widthAnchor.constraint(equalTo: <span class="keyword">self</span>.view.widthAnchor, multiplier: <span class="number">1</span>/<span class="number">3</span>),</span><br><span class="line">testView.heightAnchor.constraint(equalTo: <span class="keyword">self</span>.view.heightAnchor, multiplier: <span class="number">2</span>/<span class="number">3</span>),</span><br></pre></td></tr></table></figure><h2 id="使用-safe-area-layout"><a href="#使用-safe-area-layout" class="headerlink" title="使用 safe area layout"></a><strong><em>使用 safe area layout</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用最新的 <code>iPhone</code> ，你将需要一些指南，以确保你安全无虞。 这就是视图具有 <code>safeAreaLayoutGuide</code> 属性的原因。 调出安全区域指南后，即可获得所有常用锚。 💪</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor),</span><br><span class="line">testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.leadingAnchor),</span><br><span class="line">testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.trailingAnchor),</span><br><span class="line">testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor),</span><br></pre></td></tr></table></figure></br><h1 id="带有动画的布局约束"><a href="#带有动画的布局约束" class="headerlink" title="带有动画的布局约束"></a><strong>带有动画的布局约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有约束的动画很容易，你不应该相信别人会说什么。 我制定了一些规则和示例，可以帮助你理解为约束的常量值设置动画效果以及切换各种约束的基本原理。 👍</p><p><strong>规则</strong>：</p><ul><li>将标准 <code>UIView</code> 动画与 <code>layoutIfNeeded</code> 一起使用</li><li>始终先停用约束</li><li>遵守停用的约束</li><li>玩得开心！ 😛</li></ul><p>约束动画示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> testView: <span class="type">UIView!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> topConstraint: <span class="type">NSLayoutConstraint!</span></span><br><span class="line">    <span class="keyword">var</span> bottomConstraint: <span class="type">NSLayoutConstraint!</span></span><br><span class="line">    <span class="keyword">var</span> heightConstraint: <span class="type">NSLayoutConstraint!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">        testView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(testView)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> topConstraint = testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor)</span><br><span class="line">        <span class="keyword">let</span> bottomConstraint = testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor)</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            topConstraint,</span><br><span class="line">            testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.leadingAnchor),</span><br><span class="line">            testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.trailingAnchor),</span><br><span class="line">            bottomConstraint,</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> heightConstraint = testView.heightAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.heightAnchor, multiplier: <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView = testView</span><br><span class="line">        <span class="keyword">self</span>.topConstraint = topConstraint</span><br><span class="line">        <span class="keyword">self</span>.bottomConstraint = bottomConstraint</span><br><span class="line">        <span class="keyword">self</span>.heightConstraint = heightConstraint</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView.backgroundColor = .red</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> tap = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.tapped))</span><br><span class="line">        <span class="keyword">self</span>.view.addGestureRecognizer(tap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">tapped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.topConstraint.constant != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.topConstraint.constant = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.topConstraint.constant = <span class="number">64</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.bottomConstraint.isActive &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.deactivate([<span class="keyword">self</span>.bottomConstraint])</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate([<span class="keyword">self</span>.heightConstraint])</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.deactivate([<span class="keyword">self</span>.heightConstraint])</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate([<span class="keyword">self</span>.bottomConstraint])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: <span class="number">0.25</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.view.layoutIfNeeded()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，还算不错：适应性强并且支持多种设备屏幕尺寸。 🤔</p></br><h1 id="如何为iOS创建自适应布局？"><a href="#如何为iOS创建自适应布局？" class="headerlink" title="如何为iOS创建自适应布局？"></a><strong>如何为iOS创建自适应布局？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果公司内置的 <code>iOS</code> 应用程序中都难以适应自适应布局。 如果你查看使用收藏夹视图制作的应用程序（例如照片），则在每个设备上的布局都可以。 但是，还有其他一些-我认为-在更大的屏幕上是可怕的经历。 <code>#just use collectionview</code> 所有内容。 🤐</p><h2 id="支持旋转"><a href="#支持旋转" class="headerlink" title="支持旋转"></a><strong><em>支持旋转</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自适应布局的第一步是支持多种设备方向。 你可以查看我以前有关iOS自动布局的文章，其中有很多关于旋转支持，在自动布局区域内使用图层等方面的好文章。</p><h2 id="特征集合"><a href="#特征集合" class="headerlink" title="特征集合"></a><strong><em>特征集合</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步是调整特征集合。  <code>UITraitCollection</code> 可以为你分组所有特定于环境的特征，例如尺寸类别，显示比例，用户界面 <code>idom</code> 等。 大多数时候，你将不得不检查垂直和水平尺寸类别。 有设备尺寸类别的参考以及 <code>Apple</code> 所做的所有可能的变化，请参阅下面的外部资源部分。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的这个小段 <code>Swift</code> 代码示例演示了如何检查尺寸类别，以便为紧凑型和常规屏幕设置不同的布局。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> testView: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> regularConstraints: [<span class="type">NSLayoutConstraint</span>] = []</span><br><span class="line">    <span class="keyword">var</span> compactConstraints: [<span class="type">NSLayoutConstraint</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">        testView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(testView)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.regularConstraints = [</span><br><span class="line">            testView.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            testView.widthAnchor.constraint(equalTo: testView.heightAnchor),</span><br><span class="line">            testView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">            testView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.compactConstraints = [</span><br><span class="line">            testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor),</span><br><span class="line">            testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.leadingAnchor),</span><br><span class="line">            testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.trailingAnchor),</span><br><span class="line">            testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.activateCurrentConstraints()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView = testView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">activateCurrentConstraints</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.deactivate(<span class="keyword">self</span>.compactConstraints + <span class="keyword">self</span>.regularConstraints)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.traitCollection.verticalSizeClass == .regular &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate(<span class="keyword">self</span>.regularConstraints)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate(<span class="keyword">self</span>.compactConstraints)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView.backgroundColor = .red</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - rotation support</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .allButUpsideDown</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .portrait</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - trait collections</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">traitCollectionDidChange</span><span class="params">(<span class="number">_</span> previousTraitCollection: UITraitCollection?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.activateCurrentConstraints()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设备检测"><a href="#设备检测" class="headerlink" title="设备检测"></a><strong><em>设备检测</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以通过 <code>UIDevice</code> 类检查用户界面 <code>idom</code> （是 <code>iPhone</code> 还是 <code>iPad</code> ？），以基于该设备设置例如字体大小。 📱</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIDevice</span>.current.userInterfaceIdiom == .pad</span><br></pre></td></tr></table></figure><h2 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a><strong><em>屏幕尺寸</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定你的环境的另一个选项是检查屏幕的大小。 你可以检查原始像素数或以 <code>points</code> 为单位的相对大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iPhone X</span></span><br><span class="line"><span class="type">UIScreen</span>.main.nativeBounds   <span class="comment">// 1125x2436</span></span><br><span class="line"><span class="type">UIScreen</span>.main.bounds         <span class="comment">// 375x812</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常我会尽力遵守这些规则。 我真的不记得一个场景，在这种情况下，我需要的不只是上面列出的所有内容。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自动化布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS自动化布局编程</title>
      <link href="/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80%E7%BC%96%E7%A8%8B/"/>
      <url>/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个出色的 <code>iOS Auto Layout</code> 教程中，我将教你如何支持旋转，使用约束，使用图层以及设置拐角半径的动画。</p><br><h1 id="支持旋转"><a href="#支持旋转" class="headerlink" title="支持旋转"></a><strong>支持旋转</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你的应用程序要支持多种设备方向，则应在视图控制器内部实现以下方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .portrait</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .portrait</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，你可以更改返回值以不仅支持纵向，还支持横向模式。 这很容易，但是，如果你的控制器嵌入在导航或选项卡栏控制器内部，则旋转将停止工作。 在这种情况下，你必须继承 <code>UINavigationController</code> 的子类，并且必须从顶视图控制器返回正确的值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NavigationController</span>: <span class="title">UINavigationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> shouldRotate = <span class="keyword">self</span>.topViewController?.shouldAutorotate &#123;</span><br><span class="line">            <span class="keyword">return</span> shouldRotate</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldAutorotate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> orientation = <span class="keyword">self</span>.topViewController?.supportedInterfaceOrientations &#123;</span><br><span class="line">            <span class="keyword">return</span> orientation</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.supportedInterfaceOrientations</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> orientation = <span class="keyword">self</span>.topViewController?.preferredInterfaceOrientationForPresentation &#123;</span><br><span class="line">            <span class="keyword">return</span> orientation</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preferredInterfaceOrientationForPresentation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果具有 <code>UITabBarController</code> ，则适用相同的逻辑，但必须使用 <code>selectedIndex</code> 并基于所选视图控制器返回属性，而不是顶视图控制器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabBarController</span>: <span class="title">UITabBarController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewController = <span class="keyword">self</span>.viewControllers?[<span class="keyword">self</span>.selectedIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> viewController.shouldAutorotate</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldAutorotate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewController = <span class="keyword">self</span>.viewControllers?[<span class="keyword">self</span>.selectedIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> viewController.supportedInterfaceOrientations</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.supportedInterfaceOrientations</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewController = <span class="keyword">self</span>.viewControllers?[<span class="keyword">self</span>.selectedIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> viewController.preferredInterfaceOrientationForPresentation</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preferredInterfaceOrientationForPresentation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，你的嵌入式控制器就可以控制支持的方向。 哦，顺便说一句，你可以使用此方法更改状态栏样式。</p></br><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a><strong>约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了 <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/" target="_blank" rel="noopener"><code>了解约束</code></a> 和 <a href="https://www.raywenderlich.com/160527/auto-layout-tutorial-ios-11-getting-started" target="_blank" rel="noopener"><code>Auto Layout engine</code></a> 的当前状态，我们应该回到过去并从头开始。</p><h2 id="Springs-and-struts"><a href="#Springs-and-struts" class="headerlink" title="Springs and struts"></a><strong><em>Springs and struts</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还记得第一部 <code>iPhone</code> 吗？ 一屏统治一切！ <code>320x480</code>，没有限制，没有适应性，只有帧和边界。 在固定大小的画布上放置视图绝对是理所当然的，这是一个示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> squareFrame: <span class="type">CGRect</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> midX = <span class="keyword">self</span>.view.bounds.midX</span><br><span class="line">        <span class="keyword">let</span> midY = <span class="keyword">self</span>.view.bounds.midY</span><br><span class="line">        <span class="keyword">let</span> size: <span class="type">CGFloat</span> = <span class="number">64</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGRect</span>(x: midX-size/<span class="number">2</span>, y: midY-size/<span class="number">2</span>, width: size, height: size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.frame = <span class="keyword">self</span>.squareFrame</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>viewDidLayoutSubviews</code> 方法可以非常方便地支持旋转，如果边界矩形发生变化，我每次都必须重新计算视图的框架。 你可能会想，这很容易，但是如果你必须支持许多设备尺寸会怎样？</p><blockquote><p><strong><em>算一算！</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于单个对象，进行计算非常容易，但是通常你在屏幕上有多个视图。 这些视图可以相互联系，简单的数学技巧可以使你完全陷入帧计算的混乱之中，你还会喜欢数学吗？ 肯定有更好的办法！</p></br><h1 id="Auto-Layout"><a href="#Auto-Layout" class="headerlink" title="Auto Layout"></a><strong>Auto Layout</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果通过<code>iOS6</code>为我们带来了布局技术的圣杯。 它是先前系统的完美继承者。 每个人都很快采用了它，这就是为什么苹果工程师在下一版本中完全删除了基于框架的布局<code>API</code>的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了开玩笑之外，这是一个新时代的开始，越来越多的设备诞生了，并且由于自动版式的限制，维护视图非常容易。 现在，我们应该使用布局约束来重构前面的示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        square.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addConstraints([</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .width, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="literal">nil</span>, attribute: .width, multiplier: <span class="number">1.0</span>, constant: <span class="number">64</span>),</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .height, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="literal">nil</span>, attribute: .height, multiplier: <span class="number">1.0</span>, constant: <span class="number">64</span>),</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .centerX, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="keyword">self</span>.view, attribute: .centerX, multiplier: <span class="number">1.0</span>, constant: <span class="number">0</span>),</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .centerY, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="keyword">self</span>.view, attribute: .centerY, multiplier: <span class="number">1.0</span>, constant: <span class="number">0</span>),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我们不需要手动计算视图的框架，但是以编程方式创建约束并不是那么方便。 这就是为什么 <code>Apple</code> 制定了限制格式 <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html" target="_blank" rel="noopener"><code>Visual Format Language</code></a>。</p><blockquote><p><strong><code>VFL = WTF?</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，这个<code>VFL</code>非常糟糕，我什至不想演示它，但是无论如何…</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        square.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> views: [<span class="type">String</span>:<span class="type">Any</span>] = [<span class="string">"view"</span>: <span class="keyword">self</span>.view, <span class="string">"subview"</span>: square]</span><br><span class="line">        <span class="keyword">let</span> vertical = <span class="type">NSLayoutConstraint</span>.constraints(withVisualFormat: <span class="string">"V:[view]-(&lt;=1)-[subview(==64)]"</span>, options: .alignAllCenterX, metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> horizontal = <span class="type">NSLayoutConstraint</span>.constraints(withVisualFormat: <span class="string">"H:[view]-(&lt;=1)-[subview(==64)]"</span>, options: .alignAllCenterY, metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line">        <span class="keyword">self</span>.view.addConstraints(vertical)</span><br><span class="line">        <span class="keyword">self</span>.view.addConstraints(horizontal)</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>God forbid the engineer who invented this black magic. :)</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如你所见，我们肯定存在约束方面的问题。 创建所有约束很糟糕，至少要花很多行代码。 当然，你可以使用神奇的界面生成器，但是如果只是拖动线，那么有趣的地方在哪里呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以编程方式创建约束并不比计算框架好，它会导致你达到相同的复杂度甚至更糟，这就是为什么这么多第三方框架活跃起来并最终由<code>Apple</code>发出问题的原因。</p><blockquote><p><strong><code>提示:</code></strong><br>我有一篇<a href="http://www.xuebaonline.com/Swift%E6%8E%8C%E6%8F%A1iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9/"><code>关于掌握自动布局锚点</code></a>的出色文章，如果你想熟悉锚点，强烈建议阅读。 📖</p></blockquote></br><h1 id="锚点-Anchors"><a href="#锚点-Anchors" class="headerlink" title="锚点(Anchors)"></a><strong>锚点(Anchors)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.xuebaonline.com/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/"><code>锚点(Anchors)</code></a>的诞生是因为“自动布局”存在一些构造缺陷。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>NSLayoutAnchor</code> 类是用于使用流畅的 <code>API</code> 创建 <code>NSLayoutConstraint</code> 对象的工厂类。 使用这些约束可以使用“自动布局”以编程方式定义你的布局。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        square.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            square.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            square.heightAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            square.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">            square.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>锚点是用于自动布局约束的最佳方法。</em></strong></p></br><h1 id="自适应布局-Adaptive-layout"><a href="#自适应布局-Adaptive-layout" class="headerlink" title="自适应布局(Adaptive layout)"></a><strong>自适应布局(Adaptive layout)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果查看 <code>Apple</code> 提供的内置应用程序的当前状态，你会发现只有其中一些是响应式/自适应的。 通常，使用集合视图的应用更容易适应更大的屏幕或不同的设备方向。</p><p><strong><em>始终使用 <code>collection views</code>。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了只是屏幕中心的一个视图之外，你都应该使用集合视图来构建用户界面。 它将为你提供可重用性，更低的内存开销，滚动以及更多好处。 如果你使用的是我的 <code>CollectionView</code> 微型框架，则甚至不必计算愚蠢的索引位置。</p></br><h1 id="基于图层的自动化布局"><a href="#基于图层的自动化布局" class="headerlink" title="基于图层的自动化布局"></a><strong>基于图层的自动化布局</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动布局很棒，但有时你必须直接处理图层。 现在在这种情况下，你仍然必须进行一些计算。 如果要处理视图子类，则可以轻松覆盖 <code>bounds</code> 属性并更新 <code>didSet</code> 块中的框架。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.gradientLayer.frame = <span class="keyword">self</span>.bounds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个选项是在视图控制器中重写 <code>viewDidLayoutSubviews</code> 方法，并根据新边界设置图层的框架。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.gradientView.gradientLayer.frame = <span class="keyword">self</span>.gradientView.bounds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以使用普通的键值监听来观察对象的 <code>bounds</code> 属性，并根据该属性来更新图层的框架。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// somewhere in the init method</span></span><br><span class="line"><span class="keyword">self</span>.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"bounds"</span>, options: .new, context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: <span class="keyword">Any</span>?, change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> keyPath == <span class="string">"bounds"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.gradientLayer.frame = <span class="keyword">self</span>.bounds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"bounds"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="带有动画的圆角设置"><a href="#带有动画的圆角设置" class="headerlink" title="带有动画的圆角设置"></a><strong>带有动画的圆角设置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，如果要在使用基于约束的布局时为视图设置动画，则必须执行类似的操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.widthConstraint.constant = <span class="number">64</span></span><br><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.view.layoutIfNeeded()</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，如果要为视图的拐角半径设置动画，则可以始终使用传统方式，并在边界更改上设置图层的 <code>cornerRadius</code> 属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，自<code>iOS 10</code>以来，我们有了这个精美的新 <code>UIViewPropertyAnimator API</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="number">16</span></span><br><span class="line"><span class="type">UIViewPropertyAnimator</span>(duration: <span class="number">2.5</span>, curve: .easeInOut) &#123;</span><br><span class="line">    <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="number">32</span></span><br><span class="line">&#125;.startAnimation()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这非常简单，你甚至可以应用 <code>cornerMask</code> 来仅对某些角进行倒圆。 基于图层的布局示例位于本文提供的源代码中，以及每种自动布局技术的完整示例。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>产品开发的幕后花絮</title>
      <link href="/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E7%9A%84%E5%B9%95%E5%90%8E%E8%8A%B1%E7%B5%AE/"/>
      <url>/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E7%9A%84%E5%B9%95%E5%90%8E%E8%8A%B1%E7%B5%AE/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍产品专业人员用来定义问题，创建概念和选择最佳解决方案的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与关于设计师职务的争论类似，对于设计师是否应该编码，这是一个永无止境的讨论。 首先，我们谈论的是根本不同的心态。 尽管开发人员对技术流程的思考更多，但设计人员专注于用户执行的一系列操作，因为他们的目的是提出解决客户问题的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，产品设计师（或UX设计师，但正如我之前提到的那样，我不喜欢该职位）通常不做任何编码，仅因为我们从事的活动是专职职责。 设计师的大部分工作实际上甚至没有建立图形用户界面，而是进行了大量的交流和研究。 🔍</p><a id="more"></a></br><h1 id="我们有一个问题"><a href="#我们有一个问题" class="headerlink" title="我们有一个问题"></a><strong>我们有一个问题</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，当我拿到设计图时，该过程已经开始。 我们的产品经理来找我解决问题。 有几种定义问题的方法，例如根据数据分析或竞争对手的活动做出的假设； 技术改进为我们提供了更多空间； 或客户的直接要求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步（也是最重要的一步）是了解问题。 假设我们盯着分析，看到用户在流程的某个特定点下降，放弃它而没有完成任务。 问题是：为什么？ 提供解决方案之前，你需要确定要解决的问题。 你需要了解动机，目标，需求以及用户当前解决问题的方式。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接来自客户的想法可以对你的系统进行非常好的改进，但是你需要谨慎。 系统越大，用户对系统一无所知的机会就越大，这可能导致错误的假设。 他们可能不知道某些“隐藏”的细节，但是如果知道的话，他们会问一个完全不同的问题。 用户对现有系统的信念称为心理模型。 这仅表示他们基于对当前工具的了解，相信他们可以或不能使用你的工具。 心理模型可能会因教育或经验而改变，因此在你开始编写代码之前，你可能需要了解他们为什么想要特定的东西。 也许解决方案不是他们想要的，但是你可以给他们更好的解决方案。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有几种方法可以收集有关原因的信息，而我最喜欢的两个是调查和访谈。 你可以收集所有听众提出的一些高级问题，然后发送表格。 找到适合你的问卷调查的最佳平台并不总是容易的：虽然一个渠道可以为你提供大量的答案，但另一个渠道将是死路一条。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间安排也很重要：你应该注意听众的时间表。 当他们太忙甚至不工作时，他们将没有时间或精力来帮助你。 进行良好调查的秘诀还有很多，但重点是你需要耐心，尝试几种方法来吸引受众，直到找到最适合你的案例。</p></br><h1 id="与用户的真正联系：用户访谈"><a href="#与用户的真正联系：用户访谈" class="headerlink" title="与用户的真正联系：用户访谈"></a><strong>与用户的真正联系：用户访谈</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我喜欢的另一种做法是进行用户访谈。 听起来就是这样：你与用户（最好是一对一）坐下并与他们交谈。 你需要再次准备问题，但是调查虽然可以帮助你了解很多事情，但是面试仅可以帮助你解决一些问题，但范围更广。 重要的是进行实际对话而不是询问客户：你收集的问题是面试的基础，但是当客户回答时，你可以侧身甚至完全劫持讨论（只要你谈论的是你所遇到的问题） 都想解决）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你随身携带一个记事本，这将很有帮助，这样你就可以在伴侣写下最重要的要点时全神贯注于对话。 如果你的客户同意，你可以记录下采访，以便稍后再听并写下你自己的笔记。 🗒</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重要的是要观察到广泛的用户，尤其是在组中有多种用户的情况下。 如果你只关注一个小组，那么你可能会满足这对夫妇的需求，而拒绝其他人。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我对问题有满意的答案时，我可以通过创建草图或基本模型来开始实际的“设计”工作。在这一点上，我并没有将重点放在外观或精度上，我只是尝试为我的想法建立一些视觉支持。有时，我什至没有构建整个功能或页面，而只是构建一个特定的部分，例如复杂的控制器，模式，表单等等。我还尝试至少提出2-3个概念。这将帮助我与团队交流思想：那是我参与开发人员的地方，因为下一步是了解技术限制。当然，如果我们无法为用户找出有史以来最好的UI元素，那也没关系。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在收集了我们需要的所有信息之后（包括用户的必备信息，开发人员的约束以及可能的其他因素，例如设计，完整性和一致性准则等），我们的工作重点变得更加狭窄。这是我开始在像素完美的UI上工作的地方。我创建了可点击的原型，因此可以为团队提供一个快照，以显示实际软件的外观和工作方式，更重要的是，它们将成为可用性测试的核心：是的，我们将回头再回头。</p></br><h1 id="可用性测试简介"><a href="#可用性测试简介" class="headerlink" title="可用性测试简介"></a><strong>可用性测试简介</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户测试类似于访谈，你一次要与1位用户交谈，但是你可以提出任务而不是提问。你应该准备要执行的3-4个任务，就像它们已经存在时在系统中通常会执行的操作一样。这是验证你的工作，查看用户是否真的能够通过你的特定概念解决他们的问题的好方法。你如何进行这些会议的方式可能会因项目，概念因人员而异，但是以下一些重点可以派上用场：</p><ul><li>你测试用户界面而不是用户。无论他们做错了什么，不是他们的错，这是你的界面的缺陷。他们应该知道，你也知道。</li><li>不要给出详细的说明，而要编写高级任务，类似于现实生活中的任务。即使他们受过使用你的软件的教育，也不会一直有人陪他们走走。为了模拟这一点，你也不能通过原型指导他们。</li><li>包括与任务不直接相关的选项。如果你使用一些原型制作工具，它可能会以某种方式突出显示可点击元素。如果唯一可点击的东西是测试的控制器，他们将很容易找到解决方法。但是，如果有几个不同的可操作项目，它们将能够环顾四周，打开和关闭物品，并且一旦达成交易便会迷失方向。即使你感觉“来吧，就在那里，为什么不找到它”，也应该抵制胆量并保持沉默。对你来说也许很清楚，但对他们来说却是一个谜。这些测试的目的是发现谜语，而不是证明你的想法合理。</li><li>提醒参与者在整个会议过程中大声思考，以便你了解他们为什么做自己的事情。与面试期间一样，你应该创建笔记并可能记录会话。会议结束后，你还可以与用户聊天。你可以回去问一下，如果他们在会议期间没有解释，为什么他们要做特定的事情。你甚至可以在这一点上询问他们的意见，但绝不能在会议期间提出。放弃有关UI的想法可能会使你偏离测试目标，因此请保持专注并保持参与者的专注。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些会议的结果将帮助你了解概念的弱点，或者只是帮助你选择最佳的概念。 你可以重新考虑一些事情，然后再进行测试，然后再继续。 测试和迭代的次数取决于你的时间和预算：根据 <code>Jacob Nielsen</code> 的说法，如果与5个用户一起测试，最好的方法是考虑未发现的问题的数量和会话的成本，因为一段时间后，用户会反复发现其他已经存在的问题 裸露。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适当招募参与者也很重要。 如果你要为会计师构建应用程序，则可能不会获得机械师的宝贵反馈。 同样，如果你要改善现有服务，则最好与已经使用该服务的人联系，而不是与新员工交谈（除非你尝试弄清楚新手将如何与新功能交互）。</p><br><h1 id="要避免的常见错误"><a href="#要避免的常见错误" class="headerlink" title="要避免的常见错误"></a><strong>要避免的常见错误</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一种称为设计批判的做法，在这种做法中，大量的团队成员（设计师，开发人员，质量保证人员，产品经理等）坐在一起讨论设计。 你提出自己的想法，其他人则可以基于对一致性，技术约束，所有问题或简单的可用性假设的关注而提出问题并提出更改建议。 这可能真的很有帮助：当你花很长时间尝试解决问题时，可能会遇到困难。 睁开眼睛和其他角度可以帮助你摆脱困境，无论如何都要进行一些头脑风暴总是好的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，团队经常将<code>DC</code>会话与适当的可用性验证混淆。 为什么不能仅用它们代替<code>UX</code>研究有以下几个原因：</p><ul><li><strong><em>详细说明</em></strong> &nbsp;&nbsp;&nbsp;&nbsp;在可用性测试期间，你将执行任务并查看其他人如何与你的原型进行交互，而设计评论则是关于你自己讲述整个故事。你按照流程进行操作，并告诉团队正在发生什么以及为什么。这样很容易理解，但是如果仅<code>UI</code>没有解释，则可能会失败。</li><li><strong><em>领域知识</em></strong> &nbsp;&nbsp;&nbsp;&nbsp;即使你只是在从事合同项目，与你一起工作的团队也具有丰富的领域知识。你知道系统的工作原理，知道后台发生了什么，如何传输数据，调用了什么<code>API</code>……用户不知道这种事情，你也不是你的用户。</li><li><strong><em>主观性</em></strong> &nbsp;&nbsp;&nbsp;&nbsp;虽然你可能喜欢某些东西，但其他人可能不喜欢。另外，尽管你认为某些事情很清楚，但其他人可能不理解。当你说“我认为这可行”时，这只是你的观点，其他人可能会基于他们的观点对此进行争论。意见分歧可以帮助你取得进展，但是，如果保持不变，这是一个标志，你应该查看用户的反应方式，而不是争夺你的意见。</li><li><strong><em>自我</em></strong>  &nbsp;&nbsp;&nbsp;&nbsp;我并不是说它总是存在，但是这些讨论很容易变成有争议的论据，每个人都试图说服他人。我对此不够强调：你没有为自己设计（或编写代码），而是为用户设计。如果团队中的某个人有一个更好的主意，或者只是发现了一个错误，请高兴地为你提供改善产品的机会。这不是单人表演，而是团队失败或胜利。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，要在没有任何实际数据的情况下通过一次演示来证明自己要困难得多。当你的设计基于推测时，可能很难捍卫一个想法，因为你无法用事实来支持它。其他人可能有不同的假设，从这一点出发，论点立足或落在参与者的说服力上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这并不意味着这些会议根本没有用，它们无法替代研究，因为它们以不同的方式帮助你。我也认为争论通常是好的，因为我们可以了解很多彼此的观点。我要说的是不确定性使事情变得困难，因为你只有在发表作品后才能看到结果。最好的办法是定期与团队进行研究并进行同步，以便在技术上仍可行的情况下，确保要构建的内容能够很好地为用户服务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你创建的所有内容都会带来用户体验。 UX不是你设计的，而是工作的必然结果。请记住这一点。 🙏</p></br><h1 id="设计师应该编码吗？-开发人员应该设计吗？"><a href="#设计师应该编码吗？-开发人员应该设计吗？" class="headerlink" title="设计师应该编码吗？ 开发人员应该设计吗？"></a><strong>设计师应该编码吗？ 开发人员应该设计吗？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为存在这个永恒的问题是因为图形<code>UI</code>设计本身通常并不困难。 <code>UI</code>设计工具（例如<code>Sketch</code>或<code>Figma</code>）非常简单，即使没有经验也很容易使用，而无需谈论网络上成千上万的优质教程和资源。图形用户界面设计是一项技能，而成为专家意味着你还拥有许多其他有价值的技能，这些技能最终将定义你。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于设计师和开发人员的思维方式之间存在核心差异，因此我更喜欢将研究与设计结合起来，而不是将设计与编码结合起来。如果你对自己的系统技术知识有偏见，可能很难找到问题的抽象解决方案。这就是为什么我在多个学科的协作以及不同观点的结合中看到真正价值的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，以视觉方式呈现你的作品仍然是有益的，因为它可以帮助你发现潜在的盲点和缺失的边缘情况，还可以帮助连接点并查看整体图片，最后但并非最不重要的一点：它要快得多在设计工具中进行修复而不是在实际代码中进行修复。因此，虽然我不说开发人员应该设计，但某些设计技能可以很好地补充你的工作流程。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 用户体验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 用户体验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作为Swift开发人员，如何提供更好的用户体验？</title>
      <link href="/%E4%BD%9C%E4%B8%BASwift%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%9F/"/>
      <url>/%E4%BD%9C%E4%B8%BASwift%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过一些可访问性提示来学习用户体验设计的基础知识，你可以立即使用这些提示为每个人构建更好的移动应用程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 很有趣，但是你曾经尝试过 <code>UX</code> 吗？ 当然有 你使用的所有内容都会带来用户体验。 遵循这样的逻辑：你创建并将要由他人使用的所有内容也将导致 <code>UX</code> 。 但是到底是什么，设计师和开发人员在哪里适合呢？ 让我们找出答案。</p><a id="more"></a></br><h1 id="用户体验设计"><a href="#用户体验设计" class="headerlink" title="用户体验设计"></a><strong>用户体验设计</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于所有不同类型的设计师，都有大量的文章，我也可以编写自己的文章，但现在暂时跳过。 我唯一要提及的是，我个人不喜欢 <code>“用户体验设计师”</code> 这个称呼，因为它可能会引起误解。 几乎没有设计专业人员经验的公司都希望你神奇地找出最好的 <code>UX</code> ：“因为那是你的工作，对吧？ 错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><em>用户体验是任何使用工具的人都在发生的现象。</em></strong> 任何工具。你是否在Twitter上发帖？它是 <code>UX</code> 。你是否在 <code>iPad</code> 上阅读邮件？它是 <code>UX</code> 。你是否喝用旧金属咖啡机制作的咖啡？用户体验。你是否刚刚从宜家购买了新椅子，并且必须将其放在一起？相同。你是否只是坐在崭新的椅子上享受一杯咖啡？仍然是 <code>UX</code> 。 ☕️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我可以设计这些东西吗？我可以说你会从头到尾按照此特定顺序进行所有这些操作，并且你会喜欢吗？不。我可以映射这种情况的可能方式吗？是的开始了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户体验“设计”是了解需求（你想每天早上在舒适的椅子上上班前喝咖啡），然后提供满足需求的工具。当然，我希望你尽可能轻松地实现自己的目标，因此，我将尝试了解你现在的处事方式以及如何更改这些处境以改善你的处境。然后，我将找出一种方法并定义“预期的用户体验”，并为你进行设置。到达那里后，你将获得真实的用户体验，这可能与我们期望的有很大不同。<strong><em>用户体验设计的目标是使期望的用户体验尽可能接近实际用户体验。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，舒适性不是 <code>UX</code> 的唯一方面。无论你创建什么内容，都希望使其易于理解，可学习，令人难忘，一致，可访问且安全。</p><p><strong>如果看起来也不错，那很好。</strong></p></br><h1 id="UX-舒适：辅助功能简介"><a href="#UX-舒适：辅助功能简介" class="headerlink" title="UX != 舒适：辅助功能简介"></a><strong>UX != 舒适：辅助功能简介</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如前所述，构建良好的用户界面具有挑战性。假设你正在开发应用程序，网站，服务或其他任何东西，并且希望使用框架的帮助。网路上有许多使用者介面框架和范本，因此你会很容易找到适合你的介面。可能要格外小心，为你的用户找到合适的产品。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可访问性（简称<code>a11y</code>）是 <code>UX</code> 最重要的方面之一。世界人口的10-20％患有一种或多种残疾。根据此摘要，英国，美国和加拿大的网络用户中有 <code>7％</code> 有灵活性问题；其中<code>8％</code>有某种色盲；并且其中<code>3-4％</code>的人看不清自己的阅读能力，而且随着时间的流逝越来越多。人们经常说a11y是有特殊需求的用户，但是我们不是都有我们自己的“特殊”自定义偏好吗？我们整理工作表以轻松实现所有功能，将应用程序按特定顺序分组在<code>iPhone</code>上，我们打开黑暗模式以获得更好的阅读体验和爱侣般的功耗… <code>A11y</code>并没有太大不同，并且移动设备很多辅助功能注意事项实际上非常简单：将信息最小化以适合小屏幕；使用明确的措辞，尤其是在可诉诸事项上；提供合理的触摸目标尺寸和间距；将控制器放置在易于访问的位置；使用正确的背景-前景对比（有类似的工具可以帮助你）；不仅依赖颜色：使用绿色，黄色和红色点进行状态反馈对你来说可能是一个简单明了的主意，但是对于某些人来说，它们只是灰色阴影（这是一个很酷的浏览器扩展程序，可以帮助你了解其他人看到）；手势应尽可能简单，如果你可以添加变通功能以通过屏幕菜单甚至键盘操作来模拟手势，则效果会更好，因为越来越多的移动设备也支持键盘。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，<code>iOS</code>具有强大的<code>a11y</code>支持，我也非常推荐这篇关于<code>SwiftUI</code>可访问性的文章。长话短说：通过采用<code>SwiftUI</code>，你将在正确的道路上为所有<code>iOS</code>用户提供可访问的<code>UI</code>（当然，与设计无关）。 <code>UIKit</code>也并非没有选项，但我将保留<code>Tib</code>的技术部分。 🙂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有更多的原则，但是下面列出的是一个好的开始。你可以将它们应用到<code>Web</code>应用程序中，因为无论如何都需要使其可移动。但是，即使你已做好一切准备，你仍然可能会出错。让我给你看一个例子。</p></br><h1 id="视觉设计的力量"><a href="#视觉设计的力量" class="headerlink" title="视觉设计的力量"></a><strong>视觉设计的力量</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设你在一个网页上，其中加载了“无限”元素列表以进行滚动（例如新闻源）。页面底部有一个固定的页脚，其中包含一些持久性和动态（隐藏）操作。你可以从页面中选择项目，然后在页脚中通过批量操作按钮“全部删除”。容易吧？ 👌</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在假设你不能使用触摸或鼠标，只能使用物理键盘。你可以按<code>Tab</code>键进行导航，从一个<code>UI</code>元素跳到另一个<code>UI</code>元素，但是列表仅加载越来越多的数据，因此你无法到达页脚，这意味着你无法进行操作。当然，修复起来很容易，只需将“加载滚动”选项替换为“加载更多”按钮，即可集中精力跳转到页脚，而无需加载更多项目。但是，如果你错过了它，则可能会阻止某些用户执行操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从另一个角度来看这个例子。选择要删除的项目，然后出现“全部删除”按钮，取消选择它们后它消失，因此可以连接各个点。但是，如果你没有看到此视觉反馈，该怎么办？如果只有屏幕阅读器告诉你“全部删除”按钮处于焦点，该怎么办？你是否知道仅适用于所选项目，还是希望它清除所有数据？如你所见，你使用的副本也很重要。当你看到“全部删除”已连接到所选项目时，“仅删除所选内容”对于那些只能依靠耳朵听的人也很清楚。虽然基本的UI对大多数用户都适用，但可访问的UI对所有人都更好。因此，别忘了照顾它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编码前设计UI可以帮助你解决这些情况，因此你不必浪费时间实施有缺陷的UI的多个版本。最受欢迎的框架都具有用于设计工具（例如<code>Sketch</code>或<code>Figma</code>）的组件库，因此你不会费劲将代码与设计进行匹配。大型公司非常注重维护和记录自己的自定义框架和<code>UI</code>库（共称为设计系统），以实现更快的工作流和更一致的<code>UI</code>，从而满足所有<code>UX</code>要求。但我会保留此内容以备将来之用。 😉</p></br><h1 id="用户界面之外的用户体验"><a href="#用户界面之外的用户体验" class="headerlink" title="用户界面之外的用户体验"></a><strong>用户界面之外的用户体验</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经讨论了工具的“触感”，现在让我们来看看幕后。他们说，最好的UX是看不见的，我敢说，至少在我们要执行任务时，我们都更喜欢简单而不是美观或娱乐。你的用户界面有多酷，服务是否不好，或者没有给用户他们想要的东西都没有关系。但是，如果你提供的工具运行良好，并且可以帮助用户有效地完成工作，则他们可能不太在乎界面的外观（请记住将 <code>iOS6</code> 换成 <code>iOS7</code> 😏）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，<code>UI</code>的简单性意味着后台的复杂性。只需考虑一下搜索引擎：这是一个非常简单的用户体验，你只需在搜索字段（甚至是浏览器的网址栏）中输入内容，然后魔术般地出现在屏幕上。在这里，你无需关心美观，有趣的动画或其他任何内容，而只关心速度和准确性：你想找到东西，现在就想要。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道看到加载动画超过3秒钟是多么令人沮丧。实际上，有研究表明，如果加载时间超过3秒，用户将放弃你的网站，这可能会令人震惊。毋庸置疑，视觉设计师对此无能为力。这是<code>UX</code>高度依赖开发人员的工作的众多情况之一，这是巨大的责任！我们所有人都希望轻松完成工作，但是有时候选择短路径意味着我们的用户将不得不走更长的路。我知道在项目束缚我们的过程中有很多因素（期限，遗留代码，依赖项等），但是如果你有机会提出问题的解决方案，请不要犹豫，因为这样做更容易。你的用户稍后会感谢你。 😊</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 用户体验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 用户体验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭秘 WordPress Hook 系统</title>
      <link href="/%E6%8F%AD%E7%A7%98%20WordPress%20Hook%20%E7%B3%BB%E7%BB%9F/"/>
      <url>/%E6%8F%AD%E7%A7%98%20WordPress%20Hook%20%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你一直在使用 <code>WordPress</code> 开发网站（包括插件和主题开发），那么你可能已经听说过以下术语：<code>挂钩</code>，<code>操作</code>和<code>过滤器</code>。 这些是 <code>WordPress</code> 使用的 <a href="https://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="noopener"><code>事件驱动架构模式(英文：Event-driven architecture)</code></a> 的一部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是 <code>WordPress</code> 开发的新手还是发现难以理解基本概念？ 我不能推荐足够高的 <a href="https://www.sitepoint.com/author/scodrington/" target="_blank" rel="noopener"><code>Simon Codrington</code></a> 的 <code>WordPress</code> 插件开发简介教程。 他在解释 <code>动作</code> 和 <code>过滤器</code> 方面做得很出色。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本教程中，我将揭开 <code>WordPress</code> 钩子系统的神秘面纱，不遗余力。 事不宜迟，让我们开始吧。</p><a id="more"></a></br><h1 id="挂钩，动作，过滤器。-这些是什么？"><a href="#挂钩，动作，过滤器。-这些是什么？" class="headerlink" title="挂钩，动作，过滤器。 这些是什么？"></a><strong>挂钩，动作，过滤器。 这些是什么？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>“挂钩”</code>基本上是由 <code>WordPress</code> 核心，主题和插件在 <code>PHP</code> 执行或解释的各个阶段触发的事件。 当这些事件被触发时，挂钩或附加到它们的所有函数和/或类方法均以其正确顺序执行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>挂钩</code>有两种形式，<code>动作</code>和<code>过滤器</code>。 前者用于在流程执行的各个阶段添加和删除功能部件，而后者则用于修改各种功能部件和实现的行为。 如果你仍然不了解，请不要担心。 当我们开始在下面看到一些代码示例时，你将看到。</p></br><h1 id="WordPress中Hook系统的重要性"><a href="#WordPress中Hook系统的重要性" class="headerlink" title="WordPress中Hook系统的重要性"></a><strong>WordPress中Hook系统的重要性</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>钩子系统</code> 在 <code>WordPress</code> 中的重要性仅仅是可扩展性。 它使添加和删除功能以及调整/修改 <code>WordPress</code> 核心，插件和主题中功能的实现成为可能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你编写可扩展的插件和主题时，其他开发人员无需编辑核心源代码就可以改进和扩展它们。</p></br><h1 id="深入研究WordPress挂钩系统"><a href="#深入研究WordPress挂钩系统" class="headerlink" title="深入研究WordPress挂钩系统"></a><strong>深入研究WordPress挂钩系统</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>WordPress</code> 执行的各个阶段，通常会使用 <code>do_actions（）</code>和<code>a pply_filters（）</code> <code>PHP</code> 函数来触发大量事件。 这些事件可以通过 <code>add_action（）</code>和 <code>add_filter（）</code>进行订阅或挂接。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意使用“普通”一词。 还有其他触发事件的方法。 我们将在本教程的第二部分中对此进行探讨。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是插件中操作的示例。 在我的 <code>ProfilePress</code> 用户注册插件中成功注册用户后，将触发此操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fires after a user registration is completed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param int $form_id ID of the registration form.</span></span><br><span class="line"><span class="comment"> * @param mixed $user_data array of registered user info.</span></span><br><span class="line"><span class="comment"> * @param int $user_id ID of the registered user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">do_action( 'pp_after_registration', $form_id, $user_data, $user_id );</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>WordPress</code> 执行期间，将处理与该操作关联的所有功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过滤器挂钩的一个示例是 <code>WordPress</code> 核心中的 <code>the_content</code> ，它过滤每个帖子内容。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Filter the post content.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 0.71</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> string $content Content of the current post.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   $content = apply_filters( <span class="string">'the_content'</span>, $content );</span><br></pre></td></tr></table></figure></br><h1 id="做个笔记"><a href="#做个笔记" class="headerlink" title="做个笔记"></a><strong>做个笔记</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>do_action（）</code>中，第一个参数是动作挂钩的名称，后续参数是可供挂钩到动作的函数使用的变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>apply_filters（）</code>中，第一个参数是过滤器挂钩的名称，第二个参数是修改或应用连接到过滤器的函数的数据或值。 后面的参数是挂钩到过滤器的函数可用的变量/值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不用担心，当我们检查代码示例时，所有这些将更有意义。</p><br><h1 id="动作挂钩示例"><a href="#动作挂钩示例" class="headerlink" title="动作挂钩示例"></a><strong>动作挂钩示例</strong></h1><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a><strong><em>实例1</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;试一下我的 <code>ProfilePress</code> 插件的 <code>pp_after_registration</code> 操作； 假设我们要实现一项功能，使用户在注册后会立即收到一条 <code>SMS</code>（通过称为 <code>Dolio</code> 的消息传递服务），欢迎他们访问你的网站。 我们的函数挂钩可以采用以下形式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'pp_after_registration'</span>, <span class="string">'send_users_welcome_sms'</span>, <span class="number">20</span>, <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send_users_welcome_sms</span><span class="params">( $form_id, $user_data, $user_id )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $service_locator;</span><br><span class="line"></span><br><span class="line">    $username    = $user_data[<span class="string">'username'</span>];</span><br><span class="line">    $firstName   = $user_data[<span class="string">'first_name'</span>];</span><br><span class="line">    $lastName    = $user_data[<span class="string">'last_name'</span>];</span><br><span class="line">    $phoneNumber = $user_data[<span class="string">'phone_number'</span>];</span><br><span class="line"></span><br><span class="line">    $text = <span class="string">&lt;&lt;&lt;SMS_CONTENT</span></span><br><span class="line"><span class="string">Hello <span class="subst">$firstName</span> <span class="subst">$lastName</span>, Welcome to SitePoint. "\r\n"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">User ID: <span class="subst">$user_id</span> "\r\n"</span></span><br><span class="line"><span class="string">Username: <span class="subst">$username</span> "\r\n"</span></span><br><span class="line"><span class="string">Password: The password you sign up with "\r\n"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SMS_CONTENT;</span></span><br><span class="line"></span><br><span class="line">    $dolio = $service_locator-&gt;get( <span class="string">'dolio_sdk'</span> );</span><br><span class="line">    $dolio-&gt;phone_number( $phoneNumber );</span><br><span class="line">    $dolio-&gt;sms_content( $text );</span><br><span class="line">    $dolio-&gt;send();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中 <code>add_action</code> 的第三个参数是挂钩优先级，该挂钩优先级指定了挂钩到 <code>pp_after_registration</code> 动作的函数的执行顺序。 将其保留为空将默认为10。而第四个参数指定函数挂钩将接受的参数数量。 如果为空，则默认为1。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我省略了第四个参数，因此默认为1，则<code>$ user_data</code>和<code>$ user_id</code>变量将为<code>null</code>，因为我们只告诉函数仅接受一个参数。</p><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a><strong><em>实例2</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WordPress</code> 包含以下动作挂钩- <code>wp_head</code> 和 <code>wp_footer</code> ，它们分别在<code>head</code>标签和前端的<code>body</code>标签之前触发。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些挂钩可用于在那些关键位置显示脚本和数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看看一些代码示例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下代码使用 <code>wp_head</code> 将 <code>Google</code> 的站点验证元标记添加到 <code>WordPress</code> 前端的标头中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'wp_head'</span>, <span class="string">'google_site_verification'</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">google_site_verification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;meta name="google-site-verification" content="ytl89rlFsAzH7dWLs_U2mdlivbrr_jgV4Gq7wClHDUJ8" /&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有挂钩函数都将是匿名的，而不是命名函数，以避免不必要的函数名称重复。 例如，上面的 <code>Google</code> 网站验证元标记的代码将变为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'wp_head'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;meta name="google-site-verification" content="ytl89rlFsAzH7dWLs_U2mdlivbrr_jgV4Gq7wClHDUJ8" /&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的代码使用 <code>wp_footer</code> 在 <code>WordPress</code> 前端的页脚区域中添加 <code>JavaScript</code> 。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'wp_footer'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;script type="text/javascript" src="http://example.com/wp-content/plugins/site-specific-plugin/hello-bar.js"&gt;&lt;/script&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><em>动作钩子代码示例足够多，让我们看看过滤器。</em></strong></p></br><h1 id="滤钩示例"><a href="#滤钩示例" class="headerlink" title="滤钩示例"></a><strong>滤钩示例</strong></h1><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a><strong><em>示例1</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们正在开发一个广告插入器插件，该插件将以编程方式在每个帖子内容前后插入广告，因此我们需要 <code>the_content</code> 过滤器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下代码在每个帖子内容前后都包含“我们喜欢 <code>SitePoint</code> ”文字。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_filter( <span class="string">'the_content'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">( $content )</span> </span>&#123;</span><br><span class="line">        $text = sprintf( <span class="string">'&lt;div class="notice alert"&gt;%s&lt;/div&gt;'</span>, __( <span class="string">'We love SitePoint'</span>, <span class="string">'sp'</span> ) );</span><br><span class="line">        $content = $text . $content . $text;</span><br><span class="line">        <span class="keyword">return</span> $content;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：<code>$text</code> 变量的内容与&lt;div class =“ notice alert”&gt;我们喜欢SitePoint &lt;/ div&gt;一样，尽管它已经国际化，所以可以本地化。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，函数参数 <code>$content</code> 是提供帖子内容的变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们在帖子内容前后添加自定义文本，将结果数据保存到 <code>$content</code> 中，然后返回。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：所有滤镜挂钩函数都必须在操作或修改后返回变量参数。</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a><strong><em>示例2</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将看到的另一个过滤器示例是 <code>the_title</code> 。 以下是 <code>wp-includes/post-template.php</code> 的158行中的定义方式。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Filter the post title.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 0.71</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> string $title The post title.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> int    $id    The post ID.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">return</span> apply_filters( <span class="string">'the_title'</span>, $title, $id );</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的代码通过在其后面附加 <code>-WeLoveSitePoint</code> 来仅修改 ID 为 5978的帖子的标题。 这要归功于 <code>$id</code> 参数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_filter( <span class="string">'the_title'</span>, <span class="function"><span class="keyword">function</span> <span class="params">( $title, $id )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( $id == <span class="string">'5978'</span> ) &#123;</span><br><span class="line">            $title .= <span class="string">' - WeLoveSitePoint'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $title;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">10</span>, <span class="number">2</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WordPress</code> 之所以继续成为领先的内容管理系统的原因是其可扩展性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>WordPress Hook</code> 系统使 <code>WordPress</code> 可以转换为功能强大的 <code>Web</code> 应用程序，无论是 <code>WooCommerce</code> 的电子商务商店，<code>bbPress</code> 的论坛还是 <code>BuddyPress</code> 的社交网站。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> Modules And Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中的模块和挂钩</title>
      <link href="/Swift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E6%8C%82%E9%92%A9/"/>
      <url>/Swift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E6%8C%82%E9%92%A9/</url>
      
        <content type="html"><![CDATA[<p>了解如何使用以 <code>Swift</code> 编写的松耦合模块插件系统通过新功能扩展应用程序。</p><h1 id="模块（插件）如何工作？"><a href="#模块（插件）如何工作？" class="headerlink" title="模块（插件）如何工作？"></a><strong>模块（插件）如何工作？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你可以创建可以在不知彼此的情况下一起工作的对象，那会很酷吗？ 想象一下，你正在构建一个动态表单。 根据一些内部条件，将使用来自启用模块的数据来构成字段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，你拥有模块 <code>A</code> ，<code>B</code> ，<code>C</code> ，其中 <code>A</code> 为您提供字段 <code>1、2、3</code>，<code>B</code> 模块负责字段4、5，而 <code>C</code> 是字段6的提供者。现在，如果您关闭 <code>B</code>， 您应该只能看到字段1、2、3和6。如果已打开所有内容，则应该看到从1到6的所有字段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以将完全相同的模式应用于许多事物。 试想一下最大的插件生态系统之一。 <code>WordPress</code> 使用 <a href="https://www.sitepoint.com/wordpress-hook-system/" target="_blank" rel="noopener"><code>钩子(英文：hooks)</code></a> 来扩展核心功能。 这些都是基于我上面刚刚提到的概念。 这是 <a href="https://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="noopener"><code>事件驱动的体系结构设计模式(英文：Event-driven architecture)</code></a> 的一部分。 现在的问题是，我们如何使用 <code>Swift</code> 实现类似的东西？ 🤔</p><a id="more"></a></br><h1 id="钩子系统的实现"><a href="#钩子系统的实现" class="headerlink" title="钩子系统的实现"></a><strong>钩子系统的实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们从带有调用点的协议开始。 模块管理器将调用此方法，以按名称调用正确的钩子函数。 我们将传递参数字典，因此我们的钩子可以有参数。 我们在这里使用 <code>Any</code> 类型作为值，因此你可以在给定键下将任何内容作为参数发送。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123; <span class="literal">nil</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们使用基于表单示例的简化版本来实现我们的模块。 🤓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 1"</span>, <span class="string">"Field 2"</span>, <span class="string">"Field 3"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 4"</span>, <span class="string">"Field 5"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 6"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们需要一个模块管理器，可以使用模块数组对其进行初始化。 该管理器将负责在每个模块上调用正确的调用方法，并将以类型安全的方式处理返回的响应。 我们将立即实现两个 <code>invoke</code> 方法版本。 一个用于合并结果，另一个用于返回挂钩的第一个结果。</p><p><strong>你可以尝试实现一个可以使用 <code>&amp;&amp;</code> 运算符合并 <code>Bool</code> 值的版本。</strong></p><p>这是我们使用两种通用方法的模块管理器实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ModuleManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span>  modules: [<span class="type">Module</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invokeAllHooks</span>&lt;T&gt;<span class="params">(<span class="number">_</span> name: String, type: T.<span class="keyword">Type</span>, params: [String: <span class="keyword">Any</span>] = [:])</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">self</span>.modules.<span class="built_in">map</span> &#123; module <span class="keyword">in</span></span><br><span class="line">            module.invoke(name: name, params: params)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? [<span class="type">T</span>] &#125;.flatMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invokeHook</span>&lt;T&gt;<span class="params">(<span class="number">_</span> name: String, type: T.<span class="keyword">Type</span>, params: [String: <span class="keyword">Any</span>] = [:])</span></span> -&gt; <span class="type">T?</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> module <span class="keyword">in</span> <span class="keyword">self</span>.modules &#123;</span><br><span class="line">            <span class="keyword">let</span> result = module.invoke(name: name, params: params)</span><br><span class="line">            <span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result <span class="keyword">as</span>? <span class="type">T</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <code>invokeAllHooks</code> 方法将通用类型的数组合并在一起。 这是我们可以使用基础钩子方法收集他所有表单字段的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manager1 = <span class="type">ModuleManager</span>(modules: [<span class="type">A</span>(), <span class="type">B</span>(), <span class="type">C</span>()])</span><br><span class="line"><span class="keyword">let</span> form1 = manager1.invokeAllHooks(<span class="string">"example_form"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(form1) <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager2 = <span class="type">ModuleManager</span>(modules: [<span class="type">A</span>(), <span class="type">C</span>()])</span><br><span class="line"><span class="keyword">let</span> form2 = manager2.invokeAllHooks(<span class="string">"example_form"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(form2) <span class="comment">// 1, 2, 3, 6</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>invokeHook</code> 方法，你可以实现类似的行为，例如责任链设计模式。 响应程序链的工作方式非常相似，<code>Apple</code> 几乎在每个平台上都使用响应程序来处理 <code>UI</code> 事件。 让我通过更新模块 <code>B</code> 向你展示它的工作方式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_responder"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleResponderHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 4"</span>, <span class="string">"Field 5"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleResponderHook</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">"Hello, this is module B."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们在两个管理器上使用 <code>invokeHook</code> 方法触发新的 <code>example_responder</code> 挂钩，我们将看到结果完全不同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = manager1.invokeHook(<span class="string">"example_responder"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value) <span class="comment">// Hello, this is module B.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = manager2.invokeHook(<span class="string">"example_responder"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value) <span class="comment">// this won't be called at all...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第一种情况下，由于我们在其中一个模块中为此钩子实现了一个实现，因此将显示返回值，因此可以进行打印。 在第二种情况下，没有模块可以处理该事件，因此不会执行条件内的块。 告诉你，就像一个响应链。 😜</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用模块或插件是将代码的某些部分解耦的有效方法。 我真的很喜欢钩子函数，因为它们可以为应用程序中的几乎所有内容提供扩展点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将其与动态模块加载器混合使用，你将在 <code>Vapor</code> 之上拥有一个完全可扩展的下一代后端解决方案。 你可以独立于模块使用已编译的核心系统，以后可以仅升级整个组件的某些部分而无需接触其他部分。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> Modules And Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift初始化模式</title>
      <link href="/Swift%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终指南，如何在指定的，方便的，可使用的初始化工具等帮助下初始化你的 <code>Swift</code> 数据类型。</p><h1 id="什么是初始化？"><a href="#什么是初始化？" class="headerlink" title="什么是初始化？"></a><strong>什么是初始化？</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" target="_blank" rel="noopener"><code>初始化(英文: Initialization)</code></a> 是准备使用的类，结构或枚举实例的过程。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个过程是通过初始化程序来处理的，初始化程序只是一种特殊的函数，通常为它们保留 <code>init</code> 关键字-因此您不必使用 <code>func</code> 关键字-通常您不会从初始化程序中返回任何值 。</p><a id="more"></a></br><h1 id="初始化属性"><a href="#初始化属性" class="headerlink" title="初始化属性"></a><strong>初始化属性</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类和结构必须在创建该类或结构的实例时将其所有存储的属性设置为适当的初始值。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先想象一个非常简单的结构，它只有两个属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，上面的规则说我们必须初始化所有属性，因此让我们通过创建第一个 <code>init</code> 方法来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像其他所有 <code>Swift</code> 函数一样。 现在我们可以创建我们的第一点了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，如果它们是变量而不是常量，则不必初始化隐式解包的可选属性和可选属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相同的逻辑适用于类，你可以通过将 <code>struct</code> 关键字更改为 <code>class</code> 来尝试。 但是结构是值类型，类是引用类型，这种差异将为我们提供两种类型的独特功能。</p></br><h1 id="成员初始化（仅适用于结构）"><a href="#成员初始化（仅适用于结构）" class="headerlink" title="成员初始化（仅适用于结构）"></a><strong>成员初始化（仅适用于结构）</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于 <code>struct</code> 的好处是，如果你不提供自己的 <code>init</code> 方法，则编译器将免费生成一个逐成员的 <code>init</code> 。 但是有很多问题。 生成的方法将包含除具有默认值的常量以外的所有属性（也为可选属性），并且它将具有内部访问类型，因此在其他模块中将不可见。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果任何结构的存储属性都是私有的，则该结构类型的默认成员初始化器被视为私有的。 同样，如果结构的任何存储属性是文件专用的，则初始化程序是文件专用的。 否则，初始化程序的访问级别为 <code>internal</code> 。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> key: <span class="type">Int!</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span> = <span class="string">"zero"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, key: <span class="number">0</span>) <span class="comment">// provided by the memberwise init</span></span><br></pre></td></tr></table></figure></br><h1 id="初始化失败"><a href="#初始化失败" class="headerlink" title="初始化失败"></a><strong>初始化失败</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时情况可能会出错，并且你不想创建坏的或无效的对象，例如，你想从有效点列表中过滤掉 <code>origo</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>?(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123; <span class="comment">// ? marks that this could fail</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>) <span class="comment">// nil</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>) <span class="comment">// valid point</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过 <code>rawValues</code> 初始化从 <code>RawRepresentable</code> 协议传递的枚举，这也是一个失败的初始化模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> red</span><br><span class="line">    <span class="keyword">case</span> blue</span><br><span class="line">    <span class="keyword">case</span> yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c1 = <span class="type">Color</span>(rawValue: <span class="string">"orange"</span>) <span class="comment">// nil, no such case</span></span><br><span class="line"><span class="keyword">let</span> c2 = <span class="type">Color</span>(rawValue: <span class="string">"red"</span>) <span class="comment">// .red</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以使用 <code>init！</code> 而不是<code>init ?</code> ，这将创建实例的隐式展开的可选类型。 请注意，类也可以具有失败的初始化器。</p></br><h1 id="初始化纯Swift类"><a href="#初始化纯Swift类" class="headerlink" title="初始化纯Swift类"></a><strong>初始化纯Swift类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你知道类是 <code>Swift</code> 编程语言中的本机类型。 你甚至不必导入 <code>Foundation</code> 框架即可创建全新的类。 这是由纯 <code>Swift</code> 类表示的完全相同的 <code>Point</code> 对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次我们不得不自己提供 <code>init</code> 方法，因为类没有成员初始化器。 它们是引用类型和继承逻辑，因此为它们生成成员初始化方法会更加复杂。</p></br><h1 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a><strong>默认初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 <code>Swift</code> 类，如果为所有存储的属性提供默认值，即使是可选属性，也将免费获得内部默认初始化程序。 实际上，它看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>()</span><br></pre></td></tr></table></figure><p>或者，如果我们遵循前面的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> key: <span class="type">Int!</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span> = <span class="string">"zero"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这感觉太不对了。 为什么一个点具有键和标签属性？ 拥有一个可能具有额外属性的子对象会很好。 现在该通过类继承来重构此代码了。</p></br><h1 id="指定的初始值设定项-Designated-initializer"><a href="#指定的初始值设定项-Designated-initializer" class="headerlink" title="指定的初始值设定项(Designated initializer)"></a><strong>指定的初始值设定项(Designated initializer)</strong></h1><blockquote><p><strong><em>提示：</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.codingexplorer.com/designated-initializers-convenience-initializers-swift/" target="_blank" rel="noopener"><code>指定的初始化器(Designated initializer)</code></a> 是类的主要初始化器。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换句话说，它没有用便捷关键字标记。 一个类也可以具有多个指定的初始化器。 因此，让我们继续我们的 <code>Point</code> 类，它将成为 <code>NamedPoint</code> 类的超类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123; <span class="comment">// this is the designated initializer</span></span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedPoint</span>: <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>, label: <span class="type">String?</span>) &#123; <span class="comment">// designated</span></span><br><span class="line">        <span class="keyword">self</span>.label = label</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(point: <span class="type">Point</span>, label: <span class="type">String?</span>) &#123; <span class="comment">// also designated</span></span><br><span class="line">        <span class="keyword">self</span>.label = label</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: point.x, y: point.y) <span class="comment">// delegating up</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">NamedPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>, label: <span class="string">"first"</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="type">NamedPoint</span>(point: <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>), label: <span class="string">"second"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定的初始值设定项必须始终从其直接超类调用指定的初始值设定项，因此你必须委托链。 但是首先，我们必须按照初始化的第一条规则来初始化所有属性。 因此，这意味着 <code>Swift</code> 语言具有两个阶段的初始化过程。</p><p><strong><em>两阶段初始化</em></strong></p><ul><li>每个存储的属性由引入它的类分配一个初始值。</li><li>每个类都有机会自定义其存储的属性。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，根据这些规则，首先我们必须初始化 <code>label</code> 属性，然后进行委托，然后才有机会做其他事情。</p></br><h1 id="便捷初始化"><a href="#便捷初始化" class="headerlink" title="便捷初始化"></a><strong>便捷初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它们是用于简化初始化的初始化程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，例如在前面的例子中，如果我们可以为 <code>x</code> 和 <code>y</code> 等于数字的点设置一个初始化器。 在某些情况下，这将非常方便。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(z: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(x: z, y: z) <span class="comment">// we're calling the designated init</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(z: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;便捷初始化程序必须调用同一类中另一个 <code>&quot;convenience&quot;</code> 初始化程序，但是您不必写出关键字，实际上，这些 <code>init</code> 方法略有不同，你可以从一个到另一个进行调出，这就是为什么它看起来一样的原因。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(z: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(x: z, y: z)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="type">Point</span>(z: <span class="number">1</span>)</span><br></pre></td></tr></table></figure></br><h1 id="必需的初始值设定项-Required-initializer"><a href="#必需的初始值设定项-Required-initializer" class="headerlink" title="必需的初始值设定项(Required initializer)"></a><strong>必需的初始值设定项(Required initializer)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你在类中标记了一个必需的初始化器，则所有直接类（必须在每个级别中都标记为必需）也必须实现该类的子类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedPoint</span>: <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.label = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">NamedPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure></br><h1 id="覆盖初始化器"><a href="#覆盖初始化器" class="headerlink" title="覆盖初始化器"></a><strong>覆盖初始化器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中，默认情况下不会为子类继承初始化器。 如果要为父类已经具有的子类提供相同的初始化程序，则必须使用 <code>override</code> 关键字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedPoint</span>: <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.label = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">NamedPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong><em>初始化继承有两个规则，这是第一个…</em></strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你的子类没有定义任何指定的初始值设定项，它将自动继承其所有超类指定的初始值设定项。</span><br><span class="line"></span><br><span class="line">***...还有第二个：***</span><br><span class="line">&#96;&#96;&#96;提示:&#96;&#96;&#96;\</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你的子类提供了其所有超类指定的初始值设定项的实现（通过按规则1继承它们，或通过提供自定义实现作为其定义的一部分），则它会自动继承所有超类便利的初始值设定项。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;br&gt;</span><br><span class="line"></span><br><span class="line"># **取消初始化**</span><br><span class="line"></span><br><span class="line">&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在取消分配类实例之前，将立即调用反初始化程序。</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此，如果你想在类终止时进行一些手动清理，这就是你要寻找的方法。 在大多数情况下，你不必担心内存管理，因为 &#96;&#96;&#96;ARC&#96;&#96;&#96; 会为你完成。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; Swift</span><br><span class="line">class Point &#123;</span><br><span class="line">   let x: Int</span><br><span class="line">   let y: Int</span><br><span class="line"></span><br><span class="line">   init(x: Int, y: Int) &#123;</span><br><span class="line">       self.x &#x3D; x</span><br><span class="line">       self.y &#x3D; y</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   deinit &#123;</span><br><span class="line">       print(&quot;Point is clenaed up.&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1: Point? &#x3D; Point(x: 1, y: 1)</span><br><span class="line">p1 &#x3D; nil &#x2F;&#x2F;deinit is being called </span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 初始化模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift带闭包的懒惰初始化</title>
      <link href="/Swift%E5%B8%A6%E9%97%AD%E5%8C%85%E7%9A%84%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/Swift%E5%B8%A6%E9%97%AD%E5%8C%85%E7%9A%84%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何创建具有模块化和可读性的对象。</p><h1 id="使用初衷"><a href="#使用初衷" class="headerlink" title="使用初衷"></a><strong>使用初衷</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>iOS</code> 之旅的开始，我遵循了 <code>YouTube</code> 上的教程。 我看到一些使用如下所示的方法来创建 <code>UI</code> 对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> makeBox: <span class="type">UIView</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> view = <span class="type">UIView</span>()</span><br><span class="line"> <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为学习者，我复制了练习并使用了它。 但是，有一天，有人问我：“为什么要添加 <code>{}</code> ，为什么 <code>（）</code> 末尾存在？ 它是计算属性吗？” 我无法回答。</p><a id="more"></a></br><h1 id="学习的目标"><a href="#学习的目标" class="headerlink" title="学习的目标"></a><strong>学习的目标</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有三个目标。 首先，了解如何使用上述非常规方式初始化对象。 其次，了解何时在 <code>Swift</code> 中使用惰性 <code>var</code> 。 最后，如何最终正确使用它。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a><strong><em>先决条件</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了充分理解文章中的内容，我强烈建议您熟悉以下主题。</p><ul><li><a href="https://blog.bobthedeveloper.io/no-fear-closure-in-swift-3-with-bob-72a10577c564?gi=bfa929c89fa9" target="_blank" rel="noopener"><code>Closures</code></a></li><li><a href="https://blog.bobthedeveloper.io/swift-retention-cycle-in-closures-and-delegate-836c469ef128" target="_blank" rel="noopener"><code>Capture List and retention cycle [weak self]</code></a></li><li>Descent Object Oriented Programming</li></ul></br><h1 id="创建UI组件"><a href="#创建UI组件" class="headerlink" title="创建UI组件"></a><strong>创建UI组件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我解释上述非常规方法之前，让我们先回顾一下你的过去。 为了在 <code>Swift</code> 中创建一个按钮，你可能已经做了类似的事情。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine Size</span></span><br><span class="line"><span class="keyword">let</span> buttonSize = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="comment">// Create Instance</span></span><br><span class="line"><span class="keyword">let</span> bobButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">bobButton.backgroundColor = .black</span><br><span class="line">bobButton.titleLabel?.text = <span class="string">"Bob"</span></span><br><span class="line">bobButton.titleLabel?.textColor = .white</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设你必须创建其他三个按钮，你可能必须复制上面的代码，然后将名称从 <code>bobButton</code> 更改为 <code>bobbyButton</code> 。这非常繁琐。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New Button</span></span><br><span class="line"><span class="keyword">let</span> bobbyButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">bobbyButton.backgroundColor = .black</span><br><span class="line">bobbyButton.titleLabel?.text = <span class="string">"Bob"</span></span><br><span class="line">bobbyButton.titleLabel?.textColor = .white</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使事情变得容易一些，你可以：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xcode-edit-all.gif" alt="带闭包的懒惰初始化" title="这也适用于键盘快捷键：ctrl-cmd-e"></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用快捷键：ctrl-cmd-e，完成上述操作。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不想重复这样创建，则可以创建一个函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createButton</span><span class="params">(enterTitle: String)</span></span> -&gt; <span class="type">UIButton</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = enterTitle</span><br><span class="line"> <span class="keyword">return</span> button</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createButton(enterTitle: <span class="string">"Yoyo"</span>) <span class="comment">//  👍</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，在 <code>iOS</code> 开发中，很少有自定义按钮看起来相似的情况。 因此，一个函数可能需要更多的参数，包括背景颜色，标题，边框半径，阴影等。 你的功能可能最终看起来像：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createButton</span><span class="params">(title: String, borderWidth: Double, backgrounColor, ...)</span></span> -&gt; <span class="type">Button</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使你向函数添加默认参数，上面的代码也不是理想的选择。 它降低了可读性。 因此，最好还是保留上面乏味的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有什么方法可以使它减少乏味和更有条理？ 当然。 我们已经调查了你的过去—现在该加紧步伐，展望你的未来。</p></br><h1 id="引入非常规方式"><a href="#引入非常规方式" class="headerlink" title="引入非常规方式"></a><strong>引入非常规方式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以非常规的方式创建UI组件之前，让我们首先回答最初问题: <code>{}</code> 是什么意思，它是计算属性吗？</p><p><strong><em>不，这只是一个封闭块。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，让我们演示如何使用闭包创建对象。 我们将设计一个名为 <code>Human</code> 的结构。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"> <span class="keyword">init</span>() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Born 1996"</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，这就是创建带闭包的对象的方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createBob = &#123; () -&gt; <span class="type">Human</span> <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">let</span> human = <span class="type">Human</span>()</span><br><span class="line"> <span class="keyword">return</span> human</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> babyBob = createBob() <span class="comment">// "Born 1996"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>仅说明一下，createBob</code> 是一个类型为 <code>（）-&gt; Human</code> 的闭包。 您已经通过调用 <code>createBob（）</code> 创建了一个名为 <code>babyBob</code> 的实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，你必须创建两个常量： <code>createBob</code> 和 <code>babyBob</code> 。 如果你想在一个语句中做所有事情怎么办？ </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bobby = &#123; () -&gt; <span class="type">Human</span> <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">let</span> human = <span class="type">Human</span>()</span><br><span class="line"> <span class="keyword">return</span> human</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，闭包块通过在末尾添加 <code>（）</code> 来执行自身，而 <code>bobby</code> 现在附加了一个 <code>Human</code> 对象。 很好的东西。</p><p><strong><em>你已经了解了如何使用闭包块初始化对象。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们来创建一个 <code>UI</code> 对象，该对象应该与上面的示例相似。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bobView = &#123; () -&gt; <span class="type">UIView</span> <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">let</span> view = <span class="type">UIView</span>()</span><br><span class="line"> view.backgroundColor = .black</span><br><span class="line"> <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;太好了，我们可以缩短它的时间。 实际上，我们不需要指定封闭块的类型。 相反，我们要做的就是指定实例的类型，例如 <code>bobView</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bobbyView: <span class="type">UIView</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> view = <span class="type">UIView</span>()</span><br><span class="line"> view.backgroundColor = .black</span><br><span class="line"> <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 能够基于关键字 <code>return</code> 推断出闭包块是 <code>（）-&gt; UIView</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，看看。 上面的示例应该看起来与我担心的“非常规方式”相同。</p></br><h1 id="闭包初始化的好处"><a href="#闭包初始化的好处" class="headerlink" title="闭包初始化的好处"></a><strong>闭包初始化的好处</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们讨论了创建对象的乏味以及使用函数引起的问题。 在你的脑海中，你肯定在想：“为什么我应该改用闭包？”</p><h2 id="容易复制"><a href="#容易复制" class="headerlink" title="容易复制"></a><strong><em>容易复制</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我不喜欢使用 <code>Storyboard</code> ，我喜欢复制和粘贴 <code>UI</code> 对象。 实际上，我的计算机中有一个“库”。 让我们假设库中有一个如下所示的按钮。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = <span class="number">1</span></span><br><span class="line"> button.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要做的就是复制整行，然后将 <code>myButton</code> 的名称更改为 <code>newButton</code> 以供使用。 如果不使用闭包方法，则可能不得不将 <code>button</code> 的名称更改为 <code>newButton</code> 7–8次。 我们可以使用上面的 <code>Xcode</code> 快捷方式，但为什么不使其更简单。</p><h2 id="代码更整洁"><a href="#代码更整洁" class="headerlink" title="代码更整洁"></a><strong><em>代码更整洁</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于将对象组合在一起，看代码更加直观。 比较一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init with Closure</span></span><br><span class="line"><span class="keyword">let</span> leftCornerButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = <span class="number">1</span></span><br><span class="line"> button.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">let</span> rightCornerButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = <span class="number">1</span></span><br><span class="line"> button.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p><em><code>比较</code></em></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init With Fingers</span></span><br><span class="line"><span class="keyword">let</span> leftCornerButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">leftCornerButton.backgroundColor = .black</span><br><span class="line">leftCornerButton.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line">leftCornerButton.titleLabel?.textColor = .white</span><br><span class="line">leftCornerButton.layer.cornerRadius = <span class="number">1</span></span><br><span class="line">leftCornerButton.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rightCornerButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">rightCornerButton.backgroundColor = .black</span><br><span class="line">rightCornerButton.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line">rightCornerButton.titleLabel?.textColor = .white</span><br><span class="line">rightCornerButton.layer.cornerRadius = <span class="number">1</span></span><br><span class="line">rightCornerButton.layer.masksToBounds = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管使用闭包创建对象要多加几行，但我感到有点不知所措，因为我只需要向按钮添加属性，而不必向 <code>rightCornerButton</code> 或 <code>leftCornerButton</code> 添加属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，如果按钮的名称更具描述性，那么创建带有闭包块的对象通常需要较少的行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你已经实现了第一个目标。 恭喜你</p><h2 id="延迟初始化应用"><a href="#延迟初始化应用" class="headerlink" title="延迟初始化应用"></a><strong><em>延迟初始化应用</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你已经走了很长一段路。 现在该实现本教程的第二个目标。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能在下面看到了类似的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntenseMathProblem</span> </span>&#123;</span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> complexNumber: <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="comment">// imagine it requires a lot of CPU</span></span><br><span class="line">  <span class="number">1</span> * <span class="number">1</span></span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性允许您执行的操作是，仅当你尝试访问 <code>complexNumber</code> 属性时，才会计算 <code>complexNumber</code> 属性。 例如:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> problem = <span class="type">IntenseMathProblem</span></span><br><span class="line">problem()  <span class="comment">// No value for complexNumber</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前， <code>complexNumber</code> 没有值。 但是，一旦你访问该媒体资源，</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">problem().complexNumber <span class="comment">// Now returns 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性变量经常用于对数据库进行排序并从任何后端服务中获取数据，因为你绝对不想在创建对象时对所有内容进行计算和排序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，你的手机会崩溃，因为该物体过大且RAM无法处理。</p></br><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面只是 <code>lazy var</code> 的一个应用。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong><em>排序</em></strong></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortManager</span> </span>&#123;</span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> sortNumberFromDatabase: [<span class="type">Int</span>] = &#123;</span><br><span class="line">  <span class="comment">// Sorting logic</span></span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a><strong><em>图像压缩</em></strong></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompressionManager</span> </span>&#123;</span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> compressedImage: <span class="type">UIImage</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> image = <span class="type">UIImage</span>()</span><br><span class="line">  <span class="comment">// Compress the image</span></span><br><span class="line">  <span class="comment">// Logic</span></span><br><span class="line">  <span class="keyword">return</span> image</span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="懒加载规则"><a href="#懒加载规则" class="headerlink" title="懒加载规则"></a><strong>懒加载规则</strong></h1><ul><li>你不能将lazy与let一起使用，因为它没有初始值，并且在以后访问它时才可以达到。</li><li>你不能将其与计算属性一起使用，因为当你修改与惰性属性有关系的任何变量时，总是会重新计算计算属性（需要CPU）。</li><li>惰性仅对结构或类的成员有效</li></ul></br><h1 id="懒加载能捕获"><a href="#懒加载能捕获" class="headerlink" title="懒加载能捕获"></a><strong>懒加载能捕获</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如果你已阅读上一篇有关<a href="https://blog.bobthedeveloper.io/swift-retention-cycle-in-closures-and-delegate-836c469ef128" target="_blank" rel="noopener"><code>“封闭和委托中的循环引用”</code></a>的文章，您可能会感到奇怪。 让我们测试一下。 创建一个名为 <code>BobGreet</code> 的类。 它具有两个属性：名称为 <code>String</code> 的名称和问候语也为 <code>String</code> 的问候语，但使用闭包块进行了初始化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BobGreet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Bob the Developer"</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> greeting: <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, \(self.name)"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I'm gone, bruh 🙆‍"</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;封闭块可能对 <code>BobGuest</code> 强引用，但让我们尝试取消分配。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bobGreet: <span class="type">BobGreet?</span> = <span class="type">BobGreet</span>()</span><br><span class="line">bobGreet?.greeting</span><br><span class="line">bobGreet = <span class="literal">nil</span> <span class="comment">// I'm gone, bruh 🙆‍</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无需担心 <code>[unown self]</code> 闭包块没有对该对象的引用。 取而代之的是，它只是在封闭块内复制自身。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 懒加载模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift Lazy属性初始化</title>
      <link href="/Swift%20Lazy%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/Swift%20Lazy%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Swift中什么是惰性存储属性？ 你应该如何以及何时使用它？ 快速入门指南，需要记住的一些关键点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先回顾一下在 <code>Swift</code> 中声明和初始化存储属性的最常用方法：</p><h1 id="直接分配"><a href="#直接分配" class="headerlink" title="直接分配"></a><strong>直接分配</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过直接分配初始值来对常量和变量存储的属性进行初始化的最简单形式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constant</span></span><br><span class="line"><span class="keyword">let</span> fontSize: <span class="type">CGFloat</span> = <span class="number">24.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// variable</span></span><br><span class="line"><span class="keyword">var</span> spacing: <span class="type">CGFloat</span> = <span class="number">16.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Optional</span></span><br><span class="line"><span class="keyword">var</span> title: <span class="type">String?</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，默认情况下，可选参数初始化为 <code>nil</code> 。 我喜欢将恒定的魔术数字（如 <code>fontSize</code> ）收集到一个结构中，使它们成为静态的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">ViewMetrics</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> fontSize: <span class="type">CGFloat</span> = <span class="number">24.0</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">titleLabel.font = <span class="type">ViewMetrics</span>.fontSize</span><br></pre></td></tr></table></figure></br><h1 id="使用初始化器"><a href="#使用初始化器" class="headerlink" title="使用初始化器"></a><strong>使用初始化器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你没有将初始值分配给存储属性作为其定义的一部分，则必须在初始化程序中进行设置。 引用《 Swift编程语言》指南：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类和结构必须在创建该类或结构的实例时将其所有存储的属性设置为适当的初始值。 存储的属性不能处于不确定状态。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(title: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.title = title</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当属性始终采用相同的初始值时，最好在声明属性时进行设置，而不要在初始化程序中进行设置。</p></br><h1 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a><strong>使用闭包</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当初始值需要更多设置时，闭包是一个不错的选择。 我发现闭包样式比许多初始化程序代码更可取，因为它使设置接近属性声明。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button: <span class="type">UIButton</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> button = <span class="type">UIButton</span>(type: .system)</span><br><span class="line">  button.titleLabel?.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="type">ViewMetrics</span>.fontSize)</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化包含属性的类型时，将调用一次闭包。 闭包的返回值分配给该属性。 不要忘记尾随（）来执行关闭。</p></br><h1 id="懒加载方式"><a href="#懒加载方式" class="headerlink" title="懒加载方式"></a><strong>懒加载方式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当初始值创建起来开销相对较大时时，通常会使用惰性初始化。 仅在确定需要时才创建值。 如果你是从 <code>Objective-C</code> 转到 <code>Swift</code> 的，那么您可能会熟悉使用 <code>getter</code> 仅在首次使用属性时才对其进行延迟初始化的技术：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">NSNumberFormatter</span> *)decimalFormatter &#123;</span><br><span class="line">  <span class="keyword">if</span> (_decimalFormatter == <span class="literal">nil</span>) &#123;</span><br><span class="line">    _decimalFormatter = [[<span class="type">NSNumberFormatter</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [_decimalFormatter setNumberStyle:<span class="type">NSNumberFormatterDecimalStyle</span>];        </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _decimalFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么 <code>Swift</code> 中的惰性属性呢？ <code>Swift</code> 属性没有后备实例变量（如 <code>_decimalFormatter</code> ）。 要在 <code>Swift</code> 中延迟初始化属性，请添加 <code>lazy</code> 关键字：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> decimalFormatter: <span class="type">NumberFormatter</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> formatter = <span class="type">NumberFormatter</span>()</span><br><span class="line">  formatter.numberStyle = .decimal</span><br><span class="line">  <span class="keyword">return</span> formatter</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，惰性属性始终为 <code>var</code> 。 当访问属性时，可以在初始化完成后调用该闭包。</p></br><h1 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a><strong>访问属性</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性属性初始化的另一个常见用法是，当初始值取决于初始化实例的属性或方法时。 例如，使用闭包设置对象，此堆栈视图可以作为 <code>let constant</code> 属性使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stackView: <span class="type">UIStackView</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> stackView = <span class="type">UIStackView</span>()</span><br><span class="line">  stackView.spacing = <span class="type">ViewMetrics</span>.spacing</span><br><span class="line">  <span class="keyword">return</span> stackView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请记住，在初始化期间调用了闭包，因此你尚不能使用 <code>self</code> 来访问实例的任何属性或方法。 如果你需要访问 <code>self</code> ，则必须将 <code>let</code> 替换为 <code>lazy var</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spacing: <span class="type">CGFloat</span> = <span class="number">16.0</span>  &#123;</span><br><span class="line">  <span class="keyword">didSet</span> &#123;</span><br><span class="line">    stackView.spacing = spacing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> stackView: <span class="type">UIStackView</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> stackView = <span class="type">UIStackView</span>()</span><br><span class="line">  stackView.spacing = spacing</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> stackView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，在对象初始化之后执行关闭操作，因此你可以通过 <code>self</code> 完全访问实例属性和方法。 这是声明诸如用户界面组件之类的便捷方式。 将任何常见配置移至单独的方法或类扩展：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buttonFontSize: <span class="type">CGFloat</span> = <span class="number">18.0</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> redButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">UILabel</span>.colorButton(title: <span class="string">"Red"</span>, color: .red, fontSize: buttonFontSize)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> blueButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">UILabel</span>.colorButton(title: <span class="string">"Blue"</span>, color: .blue, fontSize: buttonFontSize)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></br><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a><strong>要点</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要记住的一些关键点并不明显，并且经常引起混乱（至少对我而言）：</p><ul><li>引用闭包内的其他实例属性或方法时，无需编写self。</li><li>闭包不会逃逸，因此你无需使用 <code>weak self</code> 避免形成循环引用。</li><li>初始化之前，如果属性可以被多个线程访问，请小心。 无法保证只有在设置初始值之前有多个线程同时访问该属性时才将其初始化一次。</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 懒加载模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中的懒加载模式</title>
      <link href="/Swift%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何在 <code>Swift</code> 中使用惰性属性来提高性能，避免使用可选参数或只是为了使初始化过程更加简洁。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在程式设计中, 惰性初始是一种拖延战术。在第一次需求出现以前，先延迟创建物件、计算值或其它昂贵程序。这通常是以一个旗号来实现，用旗号来标示是否完成其程式。每次请求对象时，会先测试此旗号。如果已完成，直接传回，否则当场执行。<br>对于此想法更一般的论述，可见惰性求值。对指令式语言，这个模式可能潜藏着危险，尤其是使用共享状态的程式习惯。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以设计模式的观点来说，惰性初始通常会和工厂方法模式合作，这结合了三种构想：</p><ul><li>使用一个工厂去得到一个类别的实例（工厂方法模式）。</li><li>将实例存在一个集合中，所以下次要求一个实例却有相同参数时，可以得到同一个实例（可和单例模式来做比较）。</li><li>在第一次时，使用惰性初始来实例化物件（惰性初始模式）。</li></ul><a id="more"></a></br><h1 id="懒惰的终极指南"><a href="#懒惰的终极指南" class="headerlink" title="懒惰的终极指南"></a><strong>懒惰的终极指南</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果仅在某个时间点需要某个属性，则可以在其前面加上 <code>lazy</code> 关键字，以便在初始化过程中将其 <code>“excluded”</code> ，并且将按需分配其默认值。 这对于创建成本高昂或需要更多时间创建的类型很有用。 这是一个懒惰公主的小故事。 👸💤</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepingBeauty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zzz...sleeping..."</span>)</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"sleeping beauty is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Castle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> princess = <span class="type">SleepingBeauty</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"castle is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a new castle..."</span>)</span><br><span class="line"><span class="keyword">let</span> castle = <span class="type">Castle</span>()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此代码段的输出如下所示，但是你可以看到公主睡了很长时间，她也“堵住了”城堡。 🏰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a new castle...</span><br><span class="line">zzz...sleeping...</span><br><span class="line">sleeping beauty is ready!</span><br><span class="line">castle is ready!</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以通过添加 <code>lazy</code> 关键字来加快处理速度，因此你的英雄将有时间杀死龙，我们的公主可以睡在她的床上直到需要她为止。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepingBeauty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zzz...sleeping..."</span>)</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"sleeping beauty is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Castle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> princess = <span class="type">SleepingBeauty</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"castle is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a new castle..."</span>)</span><br><span class="line"><span class="keyword">let</span> castle = <span class="type">Castle</span>()</span><br><span class="line">castle.princess</span><br></pre></td></tr></table></figure><p>好多了！ 现在城堡立即为战斗做好了准备，因此王子可以唤醒他所爱的人，并且……他们从此过着幸福的生活。 故事结局。👸 ❤️ 🤴</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a new castle...</span><br><span class="line">castle is ready!</span><br><span class="line">zzz...sleeping...</span><br><span class="line">sleeping beauty is ready!</span><br></pre></td></tr></table></figure><p>希望你喜欢童话故事，但让我们做一些真正的编码吧！ 🤓</p></br><h1 id="避免懒加载可选属性"><a href="#避免懒加载可选属性" class="headerlink" title="避免懒加载可选属性"></a><strong>避免懒加载可选属性</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你在前面的示例中所看到的，可以使用惰性属性来提高 <code>Swift</code> 代码的性能。 您也可以消除对象中的可选项。 如果你要处理 <code>UIView</code> 派生类，这将很有用。 例如，如果你的视图层次结构需要 <code>UILabel</code> ，则通常必须将该属性声明为可选属性或隐式展开的可选存储属性。 让我们通过使用惰性和消除邪恶的可选要求的方式来重新制作此示例。 😈</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.label)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.label.textColor = .black</span><br><span class="line">        <span class="keyword">self</span>.label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况还不错，但是我仍然更喜欢将我的视图声明为隐式展开的可选对象。 💀</p></br><h1 id="使用懒加载闭包"><a href="#使用懒加载闭包" class="headerlink" title="使用懒加载闭包"></a>使用懒加载闭包</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <a href="http://www.xuebaonline.com/Swift%E5%B8%A6%E9%97%AD%E5%8C%85%E7%9A%84%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96/"><code>懒加载闭包(lazy closure)</code></a> 将一些代码包装在其中。 与存储的属性相比，懒惰的主要优点是，只有对该变量执行读取操作时，才执行块。 您还可以使用常规存储属性填充 <a href="http://www.xuebaonline.com/Swift%20Lazy%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/"><code>惰性属性(lazy property)</code></a> 的值。 让我们在实践中看一下。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.textColor = .black</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想整理一下init方法，这是一个不错的做法。 你可以将所有对象自定义逻辑放在闭包内。 闭包在读取时自动执行（自我执行的闭包），因此当你调用self.label时，你的代码块将被执行并贴紧：视图将准备就绪。</p><blockquote><p><strong><em>提示：</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你不能在存储的属性中使用 <code>self</code> ，但是可以使用 <code>lazy closure</code> 来使用 <code>self</code> 。 注意：如果你不想造成引用循环和内存泄漏，则应始终使用 <code>[unown self]</code> 。 ♻️</p></blockquote></br><h1 id="使用工厂模式进行-Lazy-initialization"><a href="#使用工厂模式进行-Lazy-initialization" class="headerlink" title="使用工厂模式进行 Lazy initialization"></a><strong><em>使用工厂模式进行 Lazy initialization</em></strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我已经有几篇关于 <code>Swift</code> 中 <a href="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><code>工厂设计模式</code></a> 的文章，所以现在我只想向你展示如何使用工厂方法和结合了 <code>lazy property</code> 的静态工厂。</p></br><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong><em>工厂方法</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不喜欢自动执行的闭包，则可以将代码移出工厂方法，并将其与惰性变量一起使用。 像这样简单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = <span class="keyword">self</span>.createCustomLabel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">createCustomLabel</span><span class="params">()</span></span> -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"called"</span>)</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.textColor = .black</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，工厂方法的工作方式类似于你的惰性属性的私有初始化程序。 让我们更进一步，以便可以稍微提高可重用性…</p><h2 id="静态工厂方式"><a href="#静态工厂方式" class="headerlink" title="静态工厂方式"></a><strong><em>静态工厂方式</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想在应用程序的多个部分中重复使用这些初始化代码，则将它们初始化为 <a href="http://www.xuebaonline.com/tags/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"><code>静态工厂(static factory)</code></a> 可能是一个好习惯。 例如，这非常适合初始化自定义视图。 另外，创建自定义视图实际上并不是视图控制器任务，因此本示例中的职责更加分离。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = <span class="type">UILabel</span>.createCustomLabel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">createCustomLabel</span><span class="params">()</span></span> -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.textColor = .black</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;免费获得你可以享受静态工厂属性/方法的优点，例如缓存或返回特定的子类型。 挺整洁的！ 👍</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性变量是优化代码的一种非常方便的方法，但是它们只能在结构和类上使用。 n你不能将它们用作计算属性，这意味着它们在你每次尝试访问它们时都不会返回闭包块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个重要的事情是，惰性属性不是线程安全的，因此你必须谨慎使用它们。 另外，你并不总是希望消除隐式解包的可选值，有时候崩溃只是更好的选择！ 🐛</p><blockquote><p><strong><em>提示：</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;别偷懒！</p></blockquote><p>…但是请随时使用惰性属性！ 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 懒加载模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift对象池设计模式</title>
      <link href="/Swift%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本快速教程中，我将解释并向你展示如何使用 <code>Swift</code> 编程语言实现对象池设计模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="对象池"><code>对象池（英语：object pool pattern）</code></a>是一种设计模式。一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的效能提升。从池子中取得对象的时间是可预测的，但新建一个实例所需的时间是不确定。</p><a id="more"></a></br><h1 id="Swift-中的通用对象池"><a href="#Swift-中的通用对象池" class="headerlink" title="Swift 中的通用对象池"></a><strong>Swift 中的通用对象池</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象池模式是一种创新的设计模式。其背后的主要思想是，首先创建一组对象（一个池），然后从该池中获取和释放对象，而不是不断创建和释放它们。 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么？性能改进。例如， <code>Dispatch</code> 框架使用对象池模式为开发人员提供预先创建的队列，因为创建队列（带有关联线程）是相对昂贵的操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象池模式的另一个用例是 <code>worker</code> 。例如，您必须从Web上下载数百个图像，但是您只想同时下载5个图像，则可以使用5个工作对象池来完成。分配少量的工作程序（实际上将完成下载任务）可能要比为每个图像下载请求创建一个新的工作程序便宜得多。 🖼</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么这种模式的缺点呢？有一些。例如，如果池中有工作程序，则它们可能包含状态或敏感的用户数据。你也必须非常小心。重设所有内容。同样，如果你在多线程环境中运行，则还必须使池成为线程安全的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个简单的通用线程安全对象池类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> lockQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"pool.lock.queue"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> semaphore: <span class="type">DispatchSemaphore</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> items = [<span class="type">T</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> items: [<span class="type">T</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.semaphore = <span class="type">DispatchSemaphore</span>(value: items.<span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">self</span>.items.reserveCapacity(items.<span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">self</span>.items.append(contentsOf: items)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">acquire</span><span class="params">()</span></span> -&gt; <span class="type">T?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.semaphore.wait(timeout: .distantFuture) == .success, !<span class="keyword">self</span>.items.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.lockQueue.sync &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>.items.remove(at: <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">release</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.lockQueue.sync &#123;</span><br><span class="line">            <span class="keyword">self</span>.items.append(item)</span><br><span class="line">            <span class="keyword">self</span>.semaphore.signal()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pool = <span class="type">Pool</span>&lt;<span class="type">String</span>&gt;([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(a ?? "</span>n/a<span class="string">") acquired"</span>)</span><br><span class="line"><span class="keyword">let</span> b = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(b ?? "</span>n/a<span class="string">") acquired"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(c ?? "</span>n/a<span class="string">") acquired"</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .<span class="keyword">default</span>).asyncAfter(deadline: .now() + .seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> item = b &#123;</span><br><span class="line">        pool.release(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"No more resource in the pool, blocking thread until..."</span>)</span><br><span class="line"><span class="keyword">let</span> x = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(x ?? "</span>n/a<span class="string">") acquired again"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在示例中，实现仅几行。 你具有通用池项的线程安全数组，一个调度信号量（如果池中没有可用对象将阻塞该信号量）以及两个方法以实际使用对象池。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在示例中，你可以看到，如果池中没有剩余的对象，则当前队列将被阻塞，直到资源被释放并可以使用为止。 所以要当心，不要意外阻塞主线程！ 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 对象池设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift外观设计模式</title>
      <link href="/Swift%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观设计模式是复杂子系统上的简化界面。 展示一个使用 <code>Swift</code> 的快速实例。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="外观模式"><code>外观模式（Facade pattern）</code></a> ，是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。</p><a id="more"></a><p><img src="http://q8wtfza4q.bkt.clouddn.com/fp-stp1.png" alt="外观设计模式"></p><ul><li><p>结构</p><ul><li><p>Facade</p><p>  这个外观类为子系统中Packages 1、2、3提供一个共同的对外接口</p></li><li><p>Clients</p><p>  客户对象通过一个外观接口读写子系统中各接口的数据资源。</p></li><li><p>Packages</p><p>  客户可以通过外观接口读取的内部库。</p></li></ul></li></ul></br><h1 id="什么是外观设计模式"><a href="#什么是外观设计模式" class="headerlink" title="什么是外观设计模式"></a><strong>什么是外观设计模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观设计模式名字的由来是源于建筑结构的术语。</p><blockquote><p>one exterior side of a building, usually the front</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件开发中，此定义可以转换为外部所有内容，隐藏所有内部部分。 因此，外观的主要目的是在一些更复杂的丑陋外观上提供漂亮的API。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，如果你有两个或多个单独的子系统需要一起工作以完成某种任务，则外观设计模式会很方便。 它可以隐藏底层的复杂性，再加上如果隐藏方法内部发生任何更改，则外观的界面仍然可以保持不变。 👍</p></br><h1 id="外观设计模式实例"><a href="#外观设计模式实例" class="headerlink" title="外观设计模式实例"></a><strong>外观设计模式实例</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我让我们想象一个带有切换按钮的应用程序，该按钮可以打开或关闭特定设置。 如果用户点击它，我们将更改默认存储中的基础设置值，此外，我们还希望播放声音作为给定输入的额外反馈。 这是三个不同的东西组合在一起。 🎶</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toggleSettings</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// change underlying settings value</span></span><br><span class="line">    <span class="keyword">let</span> settingsKey = <span class="string">"my-settings"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> originalValue = <span class="type">UserDefaults</span>.standard.bool(forKey: settingsKey)</span><br><span class="line">    <span class="keyword">let</span> newValue = !originalValue</span><br><span class="line"></span><br><span class="line">    <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(newValue, forKey: settingsKey)</span><br><span class="line">    <span class="type">UserDefaults</span>.standard.synchronize()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// positive feedback sound</span></span><br><span class="line">    <span class="type">AudioServicesPlaySystemSound</span>(<span class="number">1054</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update UI</span></span><br><span class="line">    <span class="keyword">self</span>.switchButton.setOn(newValue, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恭喜，我们已经创建了最简单的外观！ 如果你对这段代码熟悉，则意味着您过去已经使用了 <code>Facade</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，事情可能会更加复杂，例如，如果你有一个 <code>Web</code> 服务，并且需要上传一些数据和附件文件，那么你还可以编写一个 <code>Facade</code> 来隐藏子系统的底层复杂性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观设计模式确实很容易创建，有时你甚至不会注意到正在使用外观模式，但是它们对于隐藏，解耦或简化事物非常有用。 😉</p></br><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><br><ul><li><p><a href="https://www.appcoda.com/design-pattern-structural/" target="_blank" rel="noopener"><code>Design Patterns in Swift #3: Facade and Adapter</code></a></p></li><li><p><a href="https://rubygarage.org/blog/swift-design-patterns" target="_blank" rel="noopener"><code>Top 5 Design Patterns in Swift for iOS App Development</code></a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 外观设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Swift中处理非可选选项</title>
      <link href="/%E5%9C%A8Swift%E4%B8%AD%E5%A4%84%E7%90%86%E9%9D%9E%E5%8F%AF%E9%80%89%E9%80%89%E9%A1%B9/"/>
      <url>/%E5%9C%A8Swift%E4%B8%AD%E5%A4%84%E7%90%86%E9%9D%9E%E5%8F%AF%E9%80%89%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可选参数可以说是 <code>Swift</code> 最重要的功能之一，也是将其与 <code>Objective-C</code> 之类的语言区分开来的关键。 通过被迫处理可能为 <code>nil</code> 的情况，我们倾向于编写更具可预测性和较少错误的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有时可选参数可能会使你处于一个很难处理的局面，在程序员看来，你知道（或至少在假设之下）某个变量在使用时始终为 <code>non-nil</code> ，即使它是 可选类型。 就像在视图控制器中处理视图时一样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tableView: <span class="type">UITableView?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        tableView = <span class="type">UITableView</span>(frame: view.bounds)</span><br><span class="line">        view.addSubview(tableView!)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewModelDidUpdate</span><span class="params">(<span class="number">_</span> viewModel: ViewModel)</span></span> &#123;</span><br><span class="line">        tableView?.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下， <code>Swift</code> 程序员会在与制表符和空格几乎相同的程度上存在分歧。 有人说：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“由于它是可选的，因此你应该始终正确地解开它，使用 <code>let</code> 或 <code>guard let</code> 。”</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而其他人会朝完全不同的方向说：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“由于你知道变量将不会为 <code>nil</code> ，请强制将其解包（使用！）。 崩溃比处于不确定状态要好。”</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本上，我们在这里谈论的是是否进行 <a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener" title="防御性编程"><code>防御性编程(英文：defensive programming)</code></a>。 我们是否试图从不确定的状态中恢复，还是仅仅放弃并崩溃？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我必须对这个问题给出一个二元的答案，那么我肯定会选择后者。 未定义状态会导致很难发现错误，可能会导致不必要的代码执行，而采用防御性编程只会导致难以推理的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，我宁愿不必给出二进制答案，而是研究一些可用于以更细微的方式解决此问题的技术。 </p></br><h1 id="真的可选吗？"><a href="#真的可选吗？" class="headerlink" title="真的可选吗？"></a><strong>真的可选吗？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变量和属性是可选的，但实际上是程序逻辑所必需的，实际上是体系结构缺陷的征兆。 如果需要某些东西，到没有它会使你处于不确定状态-它不是可选的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管在某些情况下（例如与某些系统 <code>API</code> 进行交互时），确实很难避免使用可选项–在许多情况下，我们可以使用某些技术来摆脱可选项。</p></br><h1 id="懒加载-lazy-比非可选的-non-optionally-optional-要好"><a href="#懒加载-lazy-比非可选的-non-optionally-optional-要好" class="headerlink" title="懒加载(lazy)比非可选的(non-optionally optional)要好"></a><strong>懒加载(lazy)比非可选的(non-optionally optional)要好</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种避免使用属性的可选选项的方法，即通过使用惰性属性来避免在创建父对象之后需要创建值的属性（例如，视图控制器中的视图-应该在 <code>loadView()</code> 或 <code>viewDidLoad()</code> 中创建）。 惰性属性可以是非可选的，但仍不需要在其父级的初始值设定项中创建。 它将在首次访问时创建。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从之前更新 <code>TableViewController</code> ，以对其表视图使用对属性进行懒加载：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> tableView = <span class="type">UITableView</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        tableView.frame = view.bounds</span><br><span class="line">        view.addSubview(tableView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewModelDidUpdate</span><span class="params">(<span class="number">_</span> viewModel: ViewModel)</span></span> &#123;</span><br><span class="line">        tableView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有可选项，没有不确定的状态！ 🎉</p></br><h1 id="适当的依赖项管理要比非可选的可选项好"><a href="#适当的依赖项管理要比非可选的可选项好" class="headerlink" title="适当的依赖项管理要比非可选的可选项好"></a><strong>适当的依赖项管理要比非可选的可选项好</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可选项的另一个常见用法是打破 <a href="https://en.wikipedia.org/wiki/Circular_dependency" target="_blank" rel="noopener" title="循环依赖关系"><code>循环依赖关系(circular dependencies)</code></a> 。 有时您可能会遇到 <code>A</code> 依赖于 <code>B</code> ，但 <code>B</code> 也依赖于 <code>A</code> 的情况。类似于此设置：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> commentManager: <span class="type">CommentManager?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userDidPostComment</span><span class="params">(<span class="number">_</span> comment: Comment)</span></span> &#123;</span><br><span class="line">        user.totalNumberOfComments += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">logOutCurrentUser</span><span class="params">()</span></span> &#123;</span><br><span class="line">        user.logOut()</span><br><span class="line">        commentManager?.clearCache()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> userManager: <span class="type">UserManager?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">composer</span><span class="params">(<span class="number">_</span> composer: CommentComposer</span></span></span><br><span class="line"><span class="function"><span class="params">                  didPostComment comment: Comment)</span></span> &#123;</span><br><span class="line">        userManager?.userDidPostComment(comment)</span><br><span class="line">        handle(comment)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clearCache</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cache.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们在上面看到的，我们在 <code>UserManager</code> 和 <code>CommentManager</code> 之间具有循环依赖关系，其中它们都不假定彼此拥有所有权，但是它们在逻辑上仍然相互依赖。 那只是等待发生的错误！ 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决上述问题，我们改为让 <code>CommentComposer</code> 充当中间人，并负责通知 <code>UserManager</code> 和 <code>CommentManager</code> 已做出评论：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentComposer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> commentManager: <span class="type">CommentManager</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> userManager: <span class="type">UserManager</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> textView = <span class="type">UITextView</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(commentManager: <span class="type">CommentManager</span>,</span><br><span class="line">         userManager: <span class="type">UserManager</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.commentManager = commentManager</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">postComment</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> comment = <span class="type">Comment</span>(text: textView.text)</span><br><span class="line">        commentManager.handle(comment)</span><br><span class="line">        userManager.userDidPostComment(comment)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，<code>UserManager</code> 可以拥有对 <code>CommentManager</code> 的强引用，而没有循环引用（或依赖)：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> commentManager: <span class="type">CommentManager</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(commentManager: <span class="type">CommentManager</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.commentManager = commentManager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userDidPostComment</span><span class="params">(<span class="number">_</span> comment: Comment)</span></span> &#123;</span><br><span class="line">        user.totalNumberOfComments += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再次删除了所有可选内容，并提供了可预测的代码！ 🎉</p></br><h1 id="崩溃"><a href="#崩溃" class="headerlink" title="崩溃"></a><strong>崩溃</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的示例中，我们看到了一些示例，在这些示例中我们可以调整代码以通过删除可选选项来消除不确定性。 但是，有时候这是不可能的。 假设你正在加载包含应用程序配置的本地 <code>JSON</code> 文件。 这本质上是一项可能会失败的操作，因此我们将需要添加一些错误处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果配置无法加载，则继续执行程序会使应用程序处于未定义状态，因此在这种情况下可能会引发崩溃。 这样，我们可以获得崩溃报告，并希望我们的 <code>tests &amp; QA</code> 检查流程能够早于解决此问题并将其传递给用户。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，我们如何崩溃？ 最简单的解决方案是简单地使用 <code>! operator</code> ，强制解开可选选项，如果它包含 <code>nil</code> 则导致崩溃：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = loadConfiguration()!</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管这种方法很简单，但缺点是很大。 如果此代码开始崩溃，我们将得到的错误消息是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: unexpectedly found <span class="literal">nil</span> <span class="keyword">while</span> unwrapping an <span class="type">Optional</span> value</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;错误消息不会告诉我们错误的原因和发生位置，也没有提供解决方法的线索。 相反，让我们结合使用 <code>guard</code> 语句和 <code>preconditionFailure()</code> 函数，以自定义消息退出。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> configuration = loadConfiguration() <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">preconditionFailure</span>(<span class="string">"Configuration couldn't be loaded. "</span> +</span><br><span class="line">                        <span class="string">"Verify that Config.JSON is valid."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用以上方法崩溃时，我们将获得更多有用的错误消息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: <span class="type">Configuration</span> couldn’t be loaded. <span class="type">Verify</span> that <span class="type">Config1</span>.<span class="type">JSON</span> <span class="keyword">is</span> valid.: file ~/<span class="type">DemoApp</span>/<span class="type">Sources</span>/<span class="type">AppDelegate</span>.swift, line <span class="number">17</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以采取明确的措施来解决该问题，并且我们确切知道它在代码库中的位置！ 🚀</p></br><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a><strong>更多</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进行上面的 <code>guard-let-preconditionFailure</code> 操作可能会有些乏味，并且确实会使代码难于遵循。 我们真的不想在代码中留出如此大的空间，这样的特殊情况-我们要专注于我们的逻辑。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的解决方案是 <code>Require</code> 。 它在 <code>Optional</code> 上添加了一个简单的 <code>require()</code> 方法，可以完成上述操作，但是使调用站点更加整洁。 使用 <code>Require</code> 时，上述配置加载代码如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = loadConfiguration().require(hint: <span class="string">"Verify that Config.JSON is valid"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果失败，它将给我们以下错误消息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: <span class="type">Required</span> value was <span class="literal">nil</span>. <span class="type">Debugging</span> hint: <span class="type">Verify</span> that <span class="type">Config1</span>.<span class="type">JSON</span> <span class="keyword">is</span> valid: file ~/<span class="type">DemoApp</span>/<span class="type">Sources</span>/<span class="type">AppDelegate</span>.swift, line <span class="number">17</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Require</code> 的另一个优点是，它还将引发 <code>NSException</code> 以及调用 <code>preconditionFailure</code> ，这将使崩溃报告工具（如 <code>Crashlytics</code> ）能够提取崩溃的所有元数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想在代码中使用  <a href="https://github.com/JohnSundell/Require" target="_blank" rel="noopener" title="Require"><code>Require</code></a> ，它是 <a href="https://github.com/JohnSundell/Require" target="_blank" rel="noopener" title="Require"><code>GitHub</code></a> 上的开源代码。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，这些是我在 <code>Swift</code> 中处理非可选可选内容的技巧：</p><ul><li>懒加载(lazy)比非可选的(non-optionally optional)要好</li><li>适当的依赖项管理要比非可选的可选项好</li><li>当您需要使用非可选的可选选项时，正常崩溃</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 迭代器设计模式 </tag>
            
            <tag> optionals </tag>
            
            <tag> non-optional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Swift中创建自定义集合</title>
      <link href="/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/"/>
      <url>/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建对象或值的集合时，我们通常使用标准库提供的数据结构-例如 <code>Array</code> ，<code>Dictionary</code> 和 <code>Set</code> 。 尽管这三个案例涵盖了大多数用例，但有时创建自定义包装器集合可以使你使代码更可预测，并且更不易出错。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此次，让我们看看作为应用程序开发人员的我们如何在 <code>Swift</code> 中定义此类自定义集合，以及结合枚举的强大功能，如何让我们为自己创建一些非常漂亮的 <code>API</code> 。</p><a id="more"></a></br><h1 id="删除可选"><a href="#删除可选" class="headerlink" title="删除可选"></a><strong>删除可选</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像我们在 <a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%A4%84%E7%90%86%E9%9D%9E%E5%8F%AF%E9%80%89%E9%80%89%E9%A1%B9/" title="在Swift中处理非可选的可选内容"><code>“在Swift中处理非可选的可选内容”</code></a> 中介绍的那样，减少了在实际需要的值真正需要时使用可选的需求，这确实可以帮助我们避免错误并简化我们的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，集合的问题在于，你通常无法保证它们是否包含一定的值，因此，你往往会遇到很多可选内容和逻辑，这些可选内容和逻辑要求以一种或另一种方式将它们拆开。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们正在为一家杂货店构建应用程序，并且我们希望拥有一个用户界面，该界面可让用户按类别显示所有产品。 要为此类UI创建模型，我们可以使用 <code>Dictionary</code> ，其使用 <code>Category</code> 作为其键类型，并使用 <code>[Product]</code> 作为其值类型，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> products: [<span class="type">Category</span> : [<span class="type">Product</span>]] = [</span><br><span class="line">    .dairy: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Milk"</span>, category: .dairy),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Butter"</span>, category: .dairy)</span><br><span class="line">    ],</span><br><span class="line">    .vegetables: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Cucumber"</span>, category: .vegetables),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Lettuce"</span>, category: .vegetables)</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管上述方法有效，但要求我们编写这样的代码，以便例如仅显示所有 <code>Product</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> dairyProducts = products[.dairy] &#123;</span><br><span class="line">    <span class="keyword">guard</span> !dairyProducts.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        renderEmptyView()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render(dairyProducts)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    renderEmptyView()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很好，但是可能会更好。 但是，插入新产品变得更加麻烦：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> products = [<span class="type">Category</span> : [<span class="type">Product</span>]]()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> product: Product)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> productsInCategory = products[product.category] &#123;</span><br><span class="line">            productsInCategory.append(product)</span><br><span class="line">            products[product.category] = productsInCategory</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            products[product.category] = [product]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好消息是，通过创建我们自己的自定义集合，我们可以使上述两个示例变得更好更清晰。 而且，更好的消息是-借助 <code>Swift</code> 的面向协议的设计-创建这样的集合实际上非常容易！</p></br><h1 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a><strong>创建集合</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 标准库中的所有集合都遵循 <code>Collection</code> 协议，而 <code>Collection</code> 协议又继承自 <code>Sequence</code> 协议。 通过使自定义集合符合这两个协议，它可以完全免费地利用所有标准集合操作（例如，迭代和过滤）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从定义自定义 <code>ProductCollection</code> 的基础开始，这将使我们能够以更好的方式处理产品和类别。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProductCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">DictionaryType</span> = [<span class="type">Category</span> : [<span class="type">Product</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Underlying, private storage, that is the same type of dictionary</span></span><br><span class="line">    <span class="comment">// that we previously was using at the call site</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> products = <span class="type">DictionaryType</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable our collection to be initialized with a dictionary</span></span><br><span class="line">    <span class="keyword">init</span>(products: <span class="type">DictionaryType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.products = products</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们将通过实现协议要求使其符合 <code>Collection</code> 。 我们要做的大多数事情就是简单地将调用转发到基础 <code>products</code> 字典，然后让它进行“繁重的工作”：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span>: <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Required nested types, that tell Swift what our collection contains</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">DictionaryType</span>.<span class="type">Index</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">DictionaryType</span>.<span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The upper and lower bounds of the collection, used in iterations</span></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123; <span class="keyword">return</span> products.startIndex &#125;</span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123; <span class="keyword">return</span> products.endIndex &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Required subscript, based on a dictionary index</span></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Index</span>) -&gt; <span class="type">Iterator</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> products[index] &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method that returns the next index when iterating</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Index)</span></span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> products.index(after: i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码使用的是 <code>Swift 4</code> ，这归功于对通用约束的改进（使我们可以更仔细地研究这些改进以及如何在以后的文章中使用类型约束），从而使自定义集合的定义变得更加简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们有了一个自定义集合，可以将其用作内置集合之一。 例如，我们可以遍历它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (category, productsInCategory) <span class="keyword">in</span> products &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者在其上使用诸如 <code>map</code> 的操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> categories = productCollection.<span class="built_in">map</span> &#123; $<span class="number">0</span>.key &#125;</span><br></pre></td></tr></table></figure></br><h1 id="自定义集合-API"><a href="#自定义集合-API" class="headerlink" title="自定义集合 API"></a><strong>自定义集合 API</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们已经为我们的系列奠定了基础，让我们开始向其中添加一些 <code>API</code> ，使我们能够使我们的产品处理代码更好。 我们将从一个自定义的下标重载开始，该重载使我们无需处理可选项就可以获取或设置一系列产品：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(category: <span class="type">Category</span>) -&gt; [<span class="type">Product</span>] &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> products[category] ?? [] &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; products[category] = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还添加一个便捷的 <code>API</code> ，以轻松地将新 <code>product</code> 插入我们的收藏夹：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> product: Product)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> productsInCategory = <span class="keyword">self</span>[product.category]</span><br><span class="line">        productsInCategory.append(product)</span><br><span class="line">        <span class="keyword">self</span>[product.category] = productsInCategory</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以返回原始的 <code>product</code> 处理代码，并将其更新为更好的代码。 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dairyProducts = products[.dairy]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dairyProducts.isEmpty &#123;</span><br><span class="line">    renderEmptyView()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    render(dairyProducts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> products = <span class="type">ProductCollection</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(product: Product)</span></span> &#123;</span><br><span class="line">        products.insert(product)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="通过-Key-值获取"><a href="#通过-Key-值获取" class="headerlink" title="通过 Key 值获取"></a><strong>通过 Key 值获取</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，到了关键时候！ 由于我们的自定义集合基本上只是字典的包装，因此我们可以轻松地添加对使用字典文字进行初始化的支持。 这样做将使我们能够编写如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> products: <span class="type">ProductCollection</span> = [</span><br><span class="line">    .dairy: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Milk"</span>, category: .dairy),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Butter"</span>, category: .dairy)</span><br><span class="line">    ],</span><br><span class="line">    .vegetables: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Cucumber"</span>, category: .vegetables),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Lettuce"</span>, category: .vegetables)</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;太酷了！ 这不仅对减少生产代码中的冗长有用，而且还将使在我们的测试中设置产品集合模拟更加简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要做的就是遵守    <code>ExpressibleByDictionaryLiteral</code> ，它要求我们实现一个带有文字的初始化程序，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span>: <span class="title">ExpressibleByDictionaryLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Key</span> = <span class="type">Category</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Value</span> = [<span class="type">Product</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(dictionaryLiteral elements: (<span class="type">Category</span>, [<span class="type">Product</span>])...) &#123;</span><br><span class="line">        <span class="keyword">for</span> (category, productsInCategory) <span class="keyword">in</span> elements &#123;</span><br><span class="line">            products[category] = productsInCategory</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用自定义集合可能是一种非常强大的工具，可以以一种更加可预测且易于使用的方式来处理一组值。 当您处理多个值时，它不一定总是您的首选解决方案，但在正确的情况下，它确实可以帮助你编写更简洁的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在调试时，了解诸如集合之类的事物的工作方式也非常有帮助，或者使你了解如何优化与集合相关的代码。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 迭代器设计模式 </tag>
            
            <tag> Collection </tag>
            
            <tag> Collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift迭代器设计模式</title>
      <link href="/Swift%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用一些 <a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/" title="自定义序列"><code>自定义序列</code></a>（符合 <code>Swift</code> 标准库中的 <code>IteratorProtocol</code> ），学习迭代器设计模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在面向对象编程里，<a href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="迭代器模式">迭代器模式</a> 是一种设计模式，是一种最简单也最常见的设计模式。它可以让用户透过特定的接口访问容器中的每一个元素而不用了解底层的实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，我将重点介绍迭代器设计模式。 该模式在 <a href="https://developer.apple.com/documentation/swift/swift_standard_library" target="_blank" rel="noopener" title="Swift标准库"><code>Swift标准库</code></a> 中大量使用，如果你需要创建迭代器，有一些协议可以为你提供支持，但是老实说：我从来没有直接实现过这种模式。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实是，在99％的用例中，你将永远不必处理这种模式，因为对 <code>Swift</code> 中直接内置的迭代器提供了惊人的支持。 始终使用序列，数组，字典而不是直接实现此模式，但是很高兴知道事情是如何进行的。 🙃</p><a id="more"></a></br><h1 id="什么是迭代器设计模式？"><a href="#什么是迭代器设计模式？" class="headerlink" title="什么是迭代器设计模式？"></a><strong>什么是迭代器设计模式？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顾名思义，该模式使你可以迭代一组元素。 这是其中一种定义：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供一种在不暴露其基础表示的情况下顺序访问聚合对象的元素的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长话短说，迭代器为你提供了一个界面，无论你在后台如何实现这些集合，都可以使你对集合进行迭代。 这是上面使用字符串迭代器的理论的快速示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">StringIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStringIterator</span>: <span class="title">StringIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> values: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> index: <span class="type">Int?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> values: [<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.values = values</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">for</span> index: Int?)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = index, index &lt; <span class="keyword">self</span>.values.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="literal">nil</span>, !<span class="keyword">self</span>.values.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = <span class="keyword">self</span>.nextIndex(<span class="keyword">for</span>: <span class="keyword">self</span>.index) &#123;</span><br><span class="line">            <span class="keyword">self</span>.index = index</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.values[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Iterable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">StringIterator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataArray</span>: <span class="title">Iterable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> dataSource: [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataSource = [<span class="string">"🐶"</span>, <span class="string">"🐔"</span>, <span class="string">"🐵"</span>, <span class="string">"🦁"</span>, <span class="string">"🐯"</span>, <span class="string">"🐭"</span>, <span class="string">"🐱"</span>, <span class="string">"🐮"</span>, <span class="string">"🐷"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">StringIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ArrayStringIterator</span>(<span class="keyword">self</span>.dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="type">DataArray</span>()</span><br><span class="line"><span class="keyword">let</span> iterator = data.makeIterator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> next = iterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，它们有两个主要协议和一个非常简单的实现。 现在，我们的 <code>DataArray</code> 类的行为就像一个真实的数组，可以通过使用循环来迭代基础元素。 让我们抛开理论，通过使用实际的 <code>Swift标准库组件</code> 从上面重新实现示例。 😉</p></br><h1 id="Swift-中的自定义序列"><a href="#Swift-中的自定义序列" class="headerlink" title="Swift 中的自定义序列"></a><strong>Swift 中的自定义序列</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 具有内置的序列协议，可帮助你创建迭代器。 在 <code>Swift</code> 中实现自己的序列就是通过创建自定义迭代器对象来隐藏基础数据结构。 你只需存储当前索引，并在每次调用下一个函数时根据该索引返回下一个元素。 😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Emojis</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> animals: [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">EmojiIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">EmojiIterator</span>(<span class="keyword">self</span>.animals)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EmojiIterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> values: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> index: <span class="type">Int?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> values: [<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.values = values</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">for</span> index: Int?)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = index, index &lt; <span class="keyword">self</span>.values.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="literal">nil</span>, !<span class="keyword">self</span>.values.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = <span class="keyword">self</span>.nextIndex(<span class="keyword">for</span>: <span class="keyword">self</span>.index) &#123;</span><br><span class="line">            <span class="keyword">self</span>.index = index</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.values[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emojis = <span class="type">Emojis</span>(animals: [<span class="string">"🐶"</span>, <span class="string">"🐔"</span>, <span class="string">"🐵"</span>, <span class="string">"🦁"</span>, <span class="string">"🐯"</span>, <span class="string">"🐭"</span>, <span class="string">"🐱"</span>, <span class="string">"🐮"</span>, <span class="string">"🐷"</span>])</span><br><span class="line"><span class="keyword">for</span> emoji <span class="keyword">in</span> emojis &#123;</span><br><span class="line">    <span class="built_in">print</span>(emoji)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，<a href="https://developer.apple.com/documentation/swift/sequence" target="_blank" rel="noopener" title="Sequence protocol"><code>Sequence protocol</code></a> 与第一个示例中使用的自定义可迭代协议的通用对应项。   <a href="https://developer.apple.com/documentation/swift/iteratorprotocol" target="_blank" rel="noopener" title="IteratorProtocol"><code>IteratorProtocol</code></a> 有点像之前使用的字符串迭代器协议，但是更加迅捷，当然也更通用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，这很棒。 最后，你知道如何创建自定义序列。 如果你想隐藏数据结构并提供通用的可迭代接口，那么这很好。 想象一下，如果你将要开始使用字典而不是使用数组来存储命名的表情符号而没有用于包装它们的迭代器，将会发生什么。 🤔</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我想谈谈 <code>Swift标准库</code> 中还有另外一个超级有用的东西。 没错，一个抽象级别的应用，我们看这里：</p></br><h1 id="Swift-中的自定义集合"><a href="#Swift-中的自定义集合" class="headerlink" title="Swift 中的自定义集合"></a><strong>Swift 中的自定义集合</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://developer.apple.com/documentation/swift/collection" target="_blank" rel="noopener" title="Collections"><code>Collections</code></a> 是序列之外的第一步。 它们内部的元素可以通过下标访问，它们还定义了 <code>startIndex</code> 和 <code>endIndex</code> ，而且集合中的各个元素可以多次访问。 听起来不错？ 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时创建 <a href=""自定义集合类型""><code>自定义集合类型</code></a> 可能很有用。 例如，如果你想消除可选值。 想象一下分类的收藏夹机制，对于每个类别，您都有一系列的收藏夹，因此你必须处理空的和不存在的案例。 使用自定义集合，你可以将多余的代码隐藏在自定义数据结构中，并为应用程序的其余部分提供一个简洁的界面。 😍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">FavoriteType</span> = [<span class="type">String</span>: [<span class="type">String</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> list: <span class="type">FavoriteType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Favorites</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.list = <span class="type">FavoriteType</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Favorites</span>: <span class="title">Collection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">FavoriteType</span>.<span class="type">Index</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">FavoriteType</span>.<span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.startIndex</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.endIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Index</span>) -&gt; <span class="type">Iterator</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list[index]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Index)</span></span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.index(after: i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">String</span>) -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list[index] ?? []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> value: String, category: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> values = <span class="keyword">self</span>.list[category] &#123;</span><br><span class="line">            <span class="keyword">guard</span> !values.<span class="built_in">contains</span>(value) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            values.append(value)</span><br><span class="line">            <span class="keyword">self</span>.list[category] = values</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.list[category] = [value]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> value: String, category: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> values = <span class="keyword">self</span>.list[category] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        values = values.<span class="built_in">filter</span> &#123; $<span class="number">0</span> == value &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> values.isEmpty &#123;</span><br><span class="line">            <span class="keyword">self</span>.list.removeValue(forKey: category)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.list[category] = values</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Favorites</span>.shared.add(<span class="string">"apple"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.add(<span class="string">"pear"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.add(<span class="string">"apple"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Favorites</span>.shared[<span class="string">"fruits"</span>]</span><br><span class="line"></span><br><span class="line"><span class="type">Favorites</span>.shared.remove(<span class="string">"apple"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.remove(<span class="string">"pear"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.list</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我知道，这是一个非常简单的示例，但它说明了为什么集合比纯序列更高级。 此外，在下面的链接中，有很好的演示，演示了精心编写的收藏集。 随时了解有关隐藏在Swift标准库中（不是那么深）的这些超级协议和自定义数据类型的更多信息。 🤐</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 迭代器设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift适配器设计模式</title>
      <link href="/Swift%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用真实示例和 <code>Swift</code> 中的适配器设计模式，将不兼容的对象转换为目标接口或类。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设计模式中，<a href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="适配器模式">适配器模式</a>（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。</p><a id="more"></a><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h1><p>有两种类型的适配器模式：</p><ul><li><p><strong>对象适配器模式</strong></p><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。</p><p>  <img src="http://q8wtfza4q.bkt.clouddn.com/adp-stp1.png" alt="对象适配器模式" title="对象适配器模式"></p></li></ul><br><ul><li><strong>类适配器模式</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种适配器模式下，适配器继承自已实现的类（一般多重继承）。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/adp-stp2.png" alt="类适配器模式" title="类适配器模式"></p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适配器是一种结构设计模式，允许具有不兼容接口的对象一起工作。 换句话说，它转换对象的接口以使其适应不同的对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，适配器可以将一件事转换为另一件事，有时也称为包装器，因为它可以包装对象并在其周围提供一个新接口。 就像特定接口或旧类的软件加密狗一样。 </p><br><h1 id="适配器设计模式的实现"><a href="#适配器设计模式的实现" class="headerlink" title="适配器设计模式的实现"></a><strong>适配器设计模式的实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建适配器实际上是一件非常容易的事情。 你只需要创建一个新对象，将旧对象“装箱”到其中，并在新类或结构上实现所需的接口即可。 换句话说，包装器对象将是我们的适配器，通过包装另一个适配器对象来实现目标接口。</p><h2 id="Adaptee"><a href="#Adaptee" class="headerlink" title="Adaptee"></a><strong>Adaptee</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们正在适应特定目标的对象（例如，老式的USB-A端口）。</p><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a><strong>Adapter</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个包装原始对象并产生由某些目标接口指定的新要求的对象（这完成了实际工作，也就是上面的小软件狗）。</p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们要与（我们的 <code>USB-C</code> 插座）适配器一起使用的对象。</p><br><h1 id="如何在Swift中使用适配器模式？"><a href="#如何在Swift中使用适配器模式？" class="headerlink" title="如何在Swift中使用适配器模式？"></a><strong>如何在Swift中使用适配器模式？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要在代码中集成第三方库，则可以使用适配器，但是其接口与你的要求不匹配。 例如，你可以围绕整个 <code>SDK</code>或后端 <code>API</code> 端点创建包装器，以创建一个公分母。 👽</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我的示例中，我将使用适配器类包装 <code>EKEvent</code> 对象，以实现全新的协议。 📆</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> EventKit</span><br><span class="line"></span><br><span class="line"><span class="comment">// our target protocol</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> startDate: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> endDate: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adapter (wrapper class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> dateFormatter: <span class="type">DateFormatter</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        dateFormatter.dateFormat = <span class="string">"yyyy. MM. dd. HH:mm"</span></span><br><span class="line">        <span class="keyword">return</span> dateFormatter</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> event: <span class="type">EKEvent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(event: <span class="type">EKEvent</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.event = event</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// actual adapter implementation</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">EventAdapter</span>: <span class="title">Event</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.event.title</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> startDate: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dateFormatter.string(from: event.startDate)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> endDate: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dateFormatter.string(from: event.endDate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let's create an EKEvent adaptee instance</span></span><br><span class="line"><span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()</span><br><span class="line">dateFormatter.dateFormat = <span class="string">"MM/dd/yyyy HH:mm"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> calendarEvent = <span class="type">EKEvent</span>(eventStore: <span class="type">EKEventStore</span>())</span><br><span class="line">calendarEvent.title = <span class="string">"Adapter tutorial deadline"</span></span><br><span class="line">calendarEvent.startDate = dateFormatter.date(from: <span class="string">"07/30/2018 10:00"</span>)</span><br><span class="line">calendarEvent.endDate = dateFormatter.date(from: <span class="string">"07/30/2018 11:00"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// now we can use the adapter class as an Event protocol, instead of an EKEvent</span></span><br><span class="line"><span class="keyword">let</span> adapter = <span class="type">EventAdapter</span>(event: calendarEvent)</span><br><span class="line"><span class="comment">// adapter.title</span></span><br><span class="line"><span class="comment">// adapter.startDate</span></span><br><span class="line"><span class="comment">// adapter.endDate</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个用例是当你必须使用几个现有的最终类或结构，但它们缺少某些功能，并且你想在它们之上构建一个新的目标接口时。 有时，实现包装程序来处理这种混乱情况是一个不错的选择。 🤷‍♂️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是适配器设计模式的全部内容。 通常，用 <code>Swift</code> 或任何其他编程语言实现它确实很容易，但是它非常有用，有时是不可避免的。 孩子们，请记住：不要在加密狗上太用力！😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 适配器设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift关于Dependency Injection (DI)</title>
      <link href="/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/"/>
      <url>/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 为我们许多人打开了函数式编程的世界。 但这仍然是面向对象的语言，而不是功能的语言。 我们的主要工具 <code>Cocoa frameworks</code> 是面向对象的。 因此，我们自己可能仍然会继续编写面向对象的代码。 这样做的问题是实际上很难编写设计良好的面向对象的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有很多不同的设计原则，例如 <code>SOLID</code> ，<code>KISS</code> ，<code>DRY</code> 等（ <code>YAGNI</code> ， <code>RAP</code> ，<code>CQS</code> ），甚至更多的设计模式。 至少对于我来说，有这么多不同的原理和模式这一事实意味着，即使有可能，良好的面向对象设计也很难。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖注入本身不是我刚才提到的 <code>SOLID</code> 原则的一部分。 但这与他们所有人息息相关。 不幸的是，依赖注入的概念被许多误解所包围。</p><a id="more"></a><blockquote><p>维基百科为我们提供了非常复杂的定义：<br>“在软件工程中，依赖性注入是一种软件设计模式，可实现控制反转以解决依赖性。”  - <code>Wikipedia</code></p></blockquote><blockquote><p>还有几句话……相反，一些开发人员说依赖注入只是传递一个实例变量。<br>“依赖注入实际上只是传递一个实例变量。”  - <code>James Shore</code></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他人则认为这是某种奇巧淫技，需要使用复杂而缓慢的框架，或者它仅与测试有关，只会使代码更难以理解。 我会说所有这些都是对依赖注入的误解。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将尽我所能使其更加清晰，并展示我对依赖注入的了解。 我将尝试展示如何进行依赖注入。 不仅如此，我们不应该这样做。</p></br><h1 id="为什么要依赖注射？"><a href="#为什么要依赖注射？" class="headerlink" title="为什么要依赖注射？"></a><strong>为什么要依赖注射？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，让我们看看依赖注入首先要解决的问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编程中，我们总是必须处理不同种类和级别的抽象。他们无处不在。接口，方法，闭包，甚至是具体的类型和变量名称-它们都是抽象的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了实现良好的代码设计，使用适当的抽象非常重要，因为它们会使我们的代码松散耦合。这意味着我们代码的不同组件可以替换为其他实现，而不会影响其他组件。当我们的代码松散耦合时，它变得更容易测试，更容易扩展，更容易重用，更容易并行开发。所有这些使维护变得更容易。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;松耦合代码是依赖注入的主要目标。它使我们能够编写松耦合的代码。因此，它使测试，扩展和重用代码变得更加容易。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多时候，仅在单元测试中讨论依赖注入。实际上，它极大地提高了可测试性，尤其是在 <code>Swift</code> 中。但是实际情况要广泛得多。如果我们的最终目标不仅是对某些类进行单元测试，还需要松散的耦合并使代码可维护，那么我们将需要付出更多的努力，而不仅仅是传递实例变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管从本质上讲，依赖注入实际上是关于传递实例变量，或者说将依赖传递给它们的使用者更好。这是第一步，也是每个第一步中最重要的一步。但这只是一个故事的一部分。还有第二步，甚至第三步。这些步骤使仅传递变量和依赖注入之间有所不同。</p></br><h1 id="依赖注射模式"><a href="#依赖注射模式" class="headerlink" title="依赖注射模式"></a><strong>依赖注射模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们从第一步开始。 有几种模式可以将依赖关系传递给消费者：</p><ul><li>构造函数注入</li><li>属性注入</li><li>方法注入</li><li>环境语境</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看看来自 <code>Cocoa frameworks</code> 的示例的使用。</p></br><h1 id="CONSTRUCTOR注入"><a href="#CONSTRUCTOR注入" class="headerlink" title="CONSTRUCTOR注入"></a><strong>CONSTRUCTOR注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是从 <strong><code>CoreData</code></strong> 注入构造函数的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NSPersistentStore</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(</span><br><span class="line">        persistentStoreCoordinator root: <span class="type">NSPersistentStoreCoordinator?</span>, </span><br><span class="line">        configurationName name: <span class="type">String?</span>, </span><br><span class="line">        <span class="type">URL</span> url: <span class="type">NSURL</span>, </span><br><span class="line">        options: [<span class="type">NSObject</span>: <span class="type">AnyObject</span>]?</span><br><span class="line">    )</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> persistentStoreCoordinator: <span class="type">NSPersistentStoreCoordinator?</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，持久性存储协调器的实例与其他一些参数一起传递给 <code>NSPersistentStore</code> 的构造函数。 然后，对协调器的引用将被存储，并且在运行时无法更改。</p><blockquote><p>通过构造函数注入，我们将依赖项作为构造函数参数传递并将其存储在只读属性中。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管在 <code>Cocoa frameworks</code> 中没有太多构造函数注入的示例，但这是注入依赖关系的首选方法。 因为它是最容易实现的，所以可以确保始终存在依赖项，并且在运行时不会更改依赖项，这使它更加安全。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在某些情况下，构造函数注入是不可能的或不合适的。 在这些情况下，我们应该使用属性注入。</p></br><h1 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a><strong>属性注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何 <code>iOS</code> 应用程序中到处都有这种模式。 例如，委托模式通常使用属性注入来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">public</span> <span class="keyword">var</span> transitioningDelegate: <span class="type">UIViewControllerTransitioningDelegate?</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，这里的视图控制器公开了用于转换委托的可写属性，如果要覆盖 <code>dafault</code> 行为，我们可以随时更改它。</p><blockquote><p>使用属性注入，消费者通过可写属性获得其依赖关系，该属性也具有一些默认值。</p></blockquote></br><h1 id="本地和外部默认设置"><a href="#本地和外部默认设置" class="headerlink" title="本地和外部默认设置"></a><strong>本地和外部默认设置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果存在良好的本地默认依赖关系，则应使用属性注入。 “本地”表示在同一模块中定义。 nil也是理想的本地默认值，它只是使依赖项成为可选项。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当实现来自单独的模块时，它是外来的。然后，我们不应将其用作默认值。而且我们不应该将属性注入用于这种依赖性。相反，我们应该使用构造函数注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象一下，传递委托的默认实现不是在 <code>UIKit</code> 中定义的，而是在其他框架中定义的。然后，即使我们从不使用此 <code>API</code> ，也始终需要链接到该框架。 <code>UIKit</code> 与该框架紧密结合。它拖延了这种无用的依赖性。我们自己的代码也会发生同样的情况，这将使重用变得更加困难。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与构造函数注入属性注入进行比较可能更容易理解，并且使我们的 <code>API</code> 看起来更灵活。但是与此同时，它可能更难以实现，并使我们的代码更脆弱。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要适当的默认实现或以适当的方式处理可选值，这可能会导致带有可选包装的可选代码混乱。其次，我们不能将属性定义为不可变的。因此，如果我们不想在设置后就对其进行更改，则需要确保在运行时而不是在编译时进行更改。另外，我们可能需要同步对其进行访问，以防止出现线程问题。由于这些原因，如果我们可以使用构造函数注入，那么我们应该首选属性注入。</p></br><h1 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a><strong>方法注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一个模式，方法注入，就像将参数传递给方法一样简单。 例如，这里是 <code>NSCoding</code> 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">NSCoding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encodeWithCoder</span><span class="params">(aCoder: NSCoder)</span></span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次将该方法称为不同的实例，甚至可以将 <code>NSCoder</code> 的实现作为参数传递。</p><blockquote><p>使用方法注入依赖关系作为参数传递给方法。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当依赖关系随每个方法调用而变化时，或者当依赖关系是暂时的并且不需要在方法范围之外保持对它的引用时，通常使用方法注入。</p><h1 id="AMBIENT-CONTEXT"><a href="#AMBIENT-CONTEXT" class="headerlink" title="AMBIENT CONTEXT"></a><strong>AMBIENT CONTEXT</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一种模式-环境上下文-在 <code>Cocoa</code> 中很难找到。 <code>NSURLCache</code> 可能是最接近的示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NSURLCache</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">setSharedURLCache</span>(<span class="title">cache</span>: <span class="title">NSURLCache</span>)</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">class</span> <span class="title">func</span> <span class="title">sharedURLCache</span>() -&gt; <span class="title">NSURLCache</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在这里我们可以将 <code>NSURLCach</code> 的任何子类设置为共享实例，然后使用静态 <code>getter</code> 访问它。 这是它与不可写的单例的主要区别。</p><blockquote><p>使用静态方法或具有某些默认值的静态可写属性来实现AMBIENT CONTEXT。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此模式仅应用于表示一些跨领域关注点的真正通用依赖项，例如日志记录，无性，访问时间和日期等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>AMBIENT CONTEXT</code> 有其自身的优势。 它使依赖关系始终可访问，并且不会污染 <code>API</code>。 非常适合跨领域的关注。 但是在其他情况下，它并不能证明其缺点。 它使依赖关系隐式化，并表示可能不是您想要的全局可变状态。</p><p>因此，如果依赖性不是真正通用的，那么我们应该考虑使用其他DI模式。</p><h1 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a><strong><em>关注点分离</em></strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会注意到，所有这些模式都非常简单，它们共享一个共同的原则-关注点分离。我们从依赖的使用者中消除了几项责任：使用什么具体实现，如何配置它以及如何管理其生命周期。这使我们可以轻松地在不同的上下文或测试中替换依赖关系，更改其生存期策略，例如使用共享或单独的实例，或更改依赖关系的构造方式。所有这些都无需改变其消费者。这使消费者不再依赖于它们，从而使它们更易于重用，扩展，开发和测试。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些模式的明显副作用是，现在我们代码的每个用户都需要提供其定义。但是他们如何得到它们？如果他们直接创建它们，那么它们将与那些依赖关系紧密地联系在一起。因此，我们只是将问题移到另一个地方。这个问题将我们带到了所谓的“合成根”（Compound Root）问题上。</p></br><h1 id="COMPOSITION-ROOT"><a href="#COMPOSITION-ROOT" class="headerlink" title="COMPOSITION ROOT"></a><strong>COMPOSITION ROOT</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>COMPOSITION ROOT</code> 是将应用程序不同层的组件连接在一起的地方。 拥有复合根的主要目的是将配置逻辑与我们其余的代码分开，并以通用的方式在定义明确的位置进行配置。 拥有一段代码，单个职责就是配置其他组件。 创建依赖关系并将其注入到构造函数或属性中只能在“合成根目录”中完成。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/di-stp1.png" alt="COMPOSITION ROOT"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 理想情况下，应用程序中应该有一个<code>COMPOSITION ROOT</code>，并且它应该靠近应用程序入口点。 就像这张图一样。 但是不必使用单个方法或类来实现。 它可以包含所需的多个类和方法，直到它们在同一组件层中在一起为止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是VIPER示例应用程序中 <code>COMPOSITION ROOT</code> 的示例实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDependencies</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        configureDependencies()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">configureDependencies</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Root Level Classes</span></span><br><span class="line">        <span class="keyword">let</span> coreDataStore = <span class="type">CoreDataStore</span>()</span><br><span class="line">        <span class="keyword">let</span> clock = <span class="type">DeviceClock</span>()</span><br><span class="line">        <span class="keyword">let</span> rootWireframe = <span class="type">RootWireframe</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// List Module Classes</span></span><br><span class="line">        <span class="keyword">let</span> listPresenter = <span class="type">ListPresenter</span>()</span><br><span class="line">        <span class="keyword">let</span> listDataManager = <span class="type">ListDataManager</span>()</span><br><span class="line">        <span class="keyword">let</span> listInteractor = <span class="type">ListInteractor</span>(dataManager: listDataManager, clock: clock)</span><br><span class="line">        ...    </span><br><span class="line">        listInteractor.output = listPresenter</span><br><span class="line">        listPresenter.listInteractor = listInteractor</span><br><span class="line">        listPresenter.listWireframe = listWireframe</span><br><span class="line">        listWireframe.addWireframe = addWireframe</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们有一些根类，仅管理窗口根视图控制器的根线框以及一些待办事项列表的单独组件，例如演示者，交互器，线框。 然后，我们将它们全部连接在一起。 它全部在一类中实现。 我们使用此类的唯一地方是应用程序委托：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> appDependencies = <span class="type">AppDependencies</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        application: UIApplication, </span></span></span><br><span class="line"><span class="function"><span class="params">        didFinishLaunchingWithOptions launchOptions: [NSObject : AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        appDependencies.installRootViewControllerIntoWindow(window!)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们首先创建依赖项类，它将配置所有组件并将它们连接在一起。 然后，我们只调用一个在窗口中设置根视图控制器的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，将通过一个调用在此处创建整个对象图，并且稍后将在运行时创建的唯一对象是视图控制器和视图。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，关于DI的文章或讨论中通常不会讨论不幸的成分根。 但这可能是依赖注入的最重要部分之一。 如果我们能够做到这一点，我们已经走了很长一段路。</p><blockquote><p>正确实现DI的最大挑战是将所有具有依赖项的类移至Composition Root。 - Mark Seeman</p></blockquote><h1 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a><strong>反模式</strong></h1><p>但是，由于在尝试正确实现某些模式时经常会发生这种情况，因此我们很容易以反模式结束。 因此，现在让我们进入黑暗的一面，看看什么是常见的DI反模式。</p><h1 id="控制怪胎"><a href="#控制怪胎" class="headerlink" title="控制怪胎"></a><strong>控制怪胎</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个是控制狂。 那就是当我们根本不使用DI的时候。 依赖项的使用者何时控制创建依赖项的方式和时间。 每当使用者在 <code>Composition Root</code> 之外的任何地方使用构造函数直接或间接获得依赖项时，都会发生这种情况。 例如，在其自己的构造函数中或仅在需要时使用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repository: <span class="type">RecipesRepository</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.repository = <span class="type">CoreDataRecipesRepository</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这是否意味着根本不允许我们使用构造函数？ 当然不是。 这取决于我们构建的依赖类型。</p><h1 id="稳定和波动的依赖"><a href="#稳定和波动的依赖" class="headerlink" title="稳定和波动的依赖"></a><strong>稳定和波动的依赖</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它们有两种-稳定的和易变的。当涉及到稳定的依赖关系时，我们不必担心直接在其使用者内部构造它们。但是我们应该避免对不稳定的依赖项这样做。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是易失性依赖项？需要某种特定环境设置（例如数据库或网络访问）的任何依赖项。实现不确定性行为的依赖项是易变的，例如，如果它们使用随机数，依赖于时间或实现加密，则它们是易变的。当我们期望依赖项将被替换或者由于它是并行开发而尚未准备就绪时，它也是易变的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易失性依赖项的症状是它们禁用了一些宽松的耦合好处。如果依赖关系不允许我们并行测试，扩展，重用或开发我们的代码，则应将其视为易变的。否则，它是一个稳定的依赖项。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，首先，我们需要了解依赖项是易失性还是​​稳定的，并在其易失性时使用“依赖项注入”模式注入它。</p><h1 id="Bastard-注入"><a href="#Bastard-注入" class="headerlink" title="Bastard 注入"></a><strong>Bastard 注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一个反模式称为 <code>Bastard</code> 注入。 当我们有让我们为测试提供依赖关系的构造函数以及在生产中使用默认实现的另一个构造函数时，就会发生这种情况。 在 <code>Swift</code> 中，我们可以使用以下示例中的默认参数轻松地做到这一点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repository: <span class="type">RecipesRepository</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(repository: <span class="type">RecipesRepository</span> = <span class="type">CoreDataRecipesRepository</span>()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.repository = repository</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从某一方面来看，这种模式提高了可测试性。 这种反模式的问题是使用默认的外部默认值-在其他模块中定义。 这使我们的代码可测试，但与另一个模块紧密耦合。 如果默认实现是本地的，则此反模式的影响会小得多。 也许最好将其重构为属性注入。 但是，当默认实现是外部实现时，我们应该使用构造函数注入，并且不要为此参数提供默认值。 相反，我们应该在 <code>“Composition Root”</code> 中提供它。 这样我们就不会失去任何灵活性，而是避免与另一个模块紧密耦合。</p><h1 id="服务定位器"><a href="#服务定位器" class="headerlink" title="服务定位器"></a><strong>服务定位器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要讨论的最后一个反模式是服务定位器。 服务定位器是某些服务的通用名称，我们可以查询以前在其中注册的不同对象。 这是最棘手的反模式，因为它可以使我们感到一切都很好。 许多开发人员甚至根本不认为它是反模式。 但是 <code>Service Locator</code> 实际上与依赖注入相反。</p><p>让我们看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locator = <span class="type">ServiceLocator</span>.sharedInstance</span><br><span class="line"></span><br><span class="line">locator.register( &#123; <span class="type">CoreDataRecipesRepository</span>() &#125;, </span><br><span class="line">                    forType: <span class="type">RecipesRepository</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repository: <span class="type">RecipesRepository</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> locator = <span class="type">ServiceLocator</span>.sharedInstance</span><br><span class="line">        <span class="keyword">self</span>.repository = locator.resolve(<span class="type">RecipesRepository</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此示例中，我们提供了一些可以使用静态属性访问的服务。然后，对于我们的依赖关系类型，我们注册一个产生一些具体实例的工厂。然后，我们在需要时向此服务询问我们的依赖关系，而不是使用构造函数或属性注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;似乎 <code>Service Locator</code> 提供了依赖注入的所有好处。它提高了可扩展性和可测试性，因为我们可以注册依赖的另​​一种实现而无需更改其使用者。它将配置与使用分开，还支持并行开发。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是它没有几个主要缺点。它使依赖项隐式而不是显式，从而隐藏了真实类的复杂性。为了能够使用此类，我们现在需要了解其内部详细信息。我们没有看到它的依赖关系，只会在运行时或通过检查其实现或文档来找到它们的依赖关系。借助服务定位器，我们的代码也与之紧密结合。这完全破坏了可重用性，并使代码的可维护性降低。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于这些原因，我倾向于认为 <code>Service Locator</code> 是一种反模式。而不是使用它，我们应该显式定义依赖项，使用 <code>DI</code> 模式注入它们，并使用 <code>Composition Root</code> 将它们连接在一起。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们总结一下到那时为止我们已经讨论过的内容。我们讨论了依赖注入用于实现松散耦合，这使我们的代码更易于维护。我们讨论了不同的 <code>DI</code> 模式，其中应该优先选择构造函数注入。我们讨论了什么是本地和外部依赖关系以及什么是稳定和易失性依赖关系。我们还讨论了应避免的常见 <code>DI</code> 反模式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这一点上，我们使用 <code>DI</code> 模式将依赖关系明确化，并将所有配置移到了 <code>Composition Root</code> 中，这已经是我们实现目标的一大步-松散耦合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们的代码还没有完全耦合。下一步是使用抽象对依赖关系进行建模。让我们记住 <code>SOLID</code> 原则之一。</p></br><h1 id="依赖反转原理（DIP）"><a href="#依赖反转原理（DIP）" class="headerlink" title="依赖反转原理（DIP）"></a><strong>依赖反转原理（DIP）</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖反转原则说，高级代码不应依赖于低级代码，它们都应依赖于抽象，而抽象不应依赖于细节。关键是该类及其依赖项应处于相同的抽象级别。如果我们有一些服务，它不应该依赖于具体的API存储库或数据库存储库，因为它们属于较低层。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，我们不应依赖通过 <code>Alamofire</code> 实现的 <code>API</code> 存储库或通过 <code>CoreData</code> 或 <code>Realm</code> 实现的数据库存储库。因为这将使我们的代码与特定的实现紧密结合。相反，我们应该依靠更高级别的抽象。服务和存储库都应依赖于该抽象。因此，较高和较低级别之间的依赖性方向是相反的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们应该遵循这一原则来松散耦合代码。依赖注入不仅是我们之前讨论的模式。它要求同时应用模式和依赖倒置原则。没有这些，我们将无法获得松耦合的所有好处。</p><blockquote><p><strong><em>DI = DI patterns + DIP</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常说，松散耦合是通过针对接口而不是针对实现进行编程来实现的。</p><blockquote><p><strong><em>编程到接口而不是实现（设计模式：可重用的面向对象软件的元素</em></strong>）</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是依赖倒置原则说它不是关于接口，而是关于抽象。 松耦合并不意味着到处都有接口或协议。 因为并非总是接口是好的和可重用的抽象。</p><blockquote><p><strong><em>编程为 <del>接口</del> 抽象</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口（或协议）只是一种我们可以用来对抽象进行建模的语言构造。 这是我们的代码与之通信的一种方式。 但这并不能保证良好和可重用的抽象，这是松散耦合的关键。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基类有时可以和协议一样好的抽象。 当然，大多数时候我们可能会使用协议对抽象进行建模。 但是在各处引入协议时要小心。 它可能是不需要的独立级别。 在Swift协议中，有时会比较麻烦。</p><blockquote><p><strong><em>Interfaces are not abstractions - Mark Seeman</em></strong> </p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/di-stp2.png" alt="Interfaces&amp;&amp;abstractions"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你在构造函数中传递依赖项或使用属性或方法注入时-您应将其作为抽象传递（同样，不必使用协议）。 如果使用 <code>ambinet</code>上下文，则相同。 它不仅是一些共享的静态实例，还应该是抽象的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，依赖注入和松散耦合不仅可以通过依赖注入模式来实现，而且可以通过依赖反转原理以及使用抽象对依赖关系进行建模来实现。</p></br><h1 id="控制和DI容器的反转"><a href="#控制和DI容器的反转" class="headerlink" title="控制和DI容器的反转"></a><strong>控制和DI容器的反转</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，使用另一种设计原则，我们还可以采取进一步的措施。该原理称为控制反转。通常将其视为框架的定义特征。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用库时，流程是“正常的”，我们从代码中调用库。但是在框架的情况下，它是倒置的-框架使用不同的回调方法调用我们的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并且我们可以将这一原理应用于使用特殊框架来管理依赖项。通常，这些框架称为依赖注入容器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有许多不同的容器可用。实际上，大多数人可能甚至不知道使用了一个DI容器。它是 <code>Interface Builder</code> 。在 <code>Interface Builder</code> 中，我们可以通过接口或基类使用 <code>@IBOutlet</code> 拖放任何 <code>NSObject</code> 并对其进行引用。与视图控制器相同。我们可以将情节提要和 <code>Xibs</code> 视为视图控制器的工厂。 <code>Interface Builder</code>是 <code>XML</code> 配置样式的示例。当然，它不是功能齐全的 <code>DI</code> 容器，也不是其主要目标，但仍然可以用于该目的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你访问 <code>CocoaPods</code> 并搜索“依赖注入”，则会发现很多不同的开源 <code>DI</code> 容器。也许甚至太多了。但是你会注意到，其中只有少数成功和流行。让我们简短地看一下其中的两个-一个来自 <code>Objective-C</code> ，另一个来自 <code>Swift</code> 。</p></br><h1 id="TYPHOON"><a href="#TYPHOON" class="headerlink" title="TYPHOON"></a><strong>TYPHOON</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个是 <strong><em><a href="http://typhoonframework.org" target="_blank" rel="noopener"><code>Typhoon</code></a></em></strong> ，它可能是 <code>Cocoa</code> 开发者中最受欢迎的DI容器。 它具有相对简单且文档齐全的 <code>API</code> ，具有许多强大的功能。 它得到了良好的维护和支持，并且仍将继续改进。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就 <code>API</code> <code>Typhoon</code> 而言，构件是称为程序集的对象。 这是此类装配接口的示例。 它看起来像一个简单的工厂。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIClientAssembly</span>: <span class="title">TyphoonAssembly</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">apiClient</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在实现中，不是返回某种类型的具体实例（如从工厂方法中返回），而是返回 <code>TyphoonDefinition</code> ，它描述了在请求实例时应如何创建该实例。 应该使用什么初始化以及使用什么参数，应该注入什么属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">apiClient</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">TyphoonDefinition</span>.withClass(<span class="type">APIClientImp</span>.<span class="keyword">self</span>) &#123; definition <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        definition.useInitializer(#selector(<span class="type">APIClientImp</span>.<span class="keyword">init</span>(session:))) &#123;</span><br><span class="line">            initializer <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            initializer.injectParameterWith(<span class="keyword">self</span>.session())</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        definition.injectProperty(<span class="string">"logger"</span>, with: <span class="keyword">self</span>.logger())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们定义 <code>API Client</code> 将使用 <code>init（session :)</code> 构造函数创建，并且其 <code>session</code> 参数将由同一程序集提供。 我们还定义了将由同样的程序集提供的 <code>logger</code> 实例注入 <code>logger</code> 属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以为组件定义不同的范围或生命周期策略。 例如，对于 <code>Singleton</code> 范围， <code>Typhoon</code> 将仅创建一个 <code>logger</code> 实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">TyphoonDefinition</span>.withClass(<span class="type">NSURLSession</span>.<span class="keyword">self</span>) &#123; definition <span class="keyword">in</span></span><br><span class="line">        definition.useInitializer(#selector(<span class="type">NSURLSession</span>.sharedSession))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">TyphoonDefinition</span>.withClass(<span class="type">ConsoleLogger</span>.<span class="keyword">self</span>) &#123; definition <span class="keyword">in</span></span><br><span class="line">        definition.scope = .<span class="type">Singleton</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要从程序集中获取某种类型的实例，我们首先将其激活，然后仅调用其接口方法。 激活后，组装方法将不返回 <code>TyphoonDefinitions</code> ，而是返回根据我们提供的规则创建的实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> assembly = <span class="type">APIClientAssembly</span>().activate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apiClient = assembly.apiClient() <span class="keyword">as</span>! <span class="type">APIClient</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使这项工作有效， <code>Typhoon</code> 大量使用了 <code>Objective-C</code> 运行时。 <code>在使用Objective-C</code> 运行时的 <code>Swift</code> 应用程序中看起来并不正确。 我们仍然可以在 <code>Swift</code> 以及 <code>Objective-C</code> 中使用 <code>Typhoon</code> 。 但是，我们将面临一些问题：</p><ul><li>需要子类 <code>NSObject</code> 并使用 <code>@objc</code> 定义协议</li><li>注射过程中调用的方法应该是动态的</li><li>需要类型转换</li><li>并非所有功能都可以在 <code>Swift</code> 中使用</li><li><code>Swift</code> 的 <code>API</code> 太冗长</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Typhoon</code> 团队最近宣布，他们开始着手于纯粹的 <code>Swift</code> 实施，而我迫不及待地想看看他们会提出什么建议。 但是现在我不会在纯 <code>Swift</code> 代码库中以当前状态使用 <code>Typhoon</code> 。 尤其是当本机解决方案已经很少时。</p><h1 id="DIP"><a href="#DIP" class="headerlink" title="DIP"></a><strong>DIP</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em><a href="https://github.com/AliSoftware/Dip" target="_blank" rel="noopener"><code>Dip</code></a></em></strong> 是其中之一。 它仅在 <code>Swift</code> 中工作，根本不需要 <code>Objective-C</code> 运行时。 实际上，它甚至没有对 <code>Foundation</code> 的引用，因此我们可以在可以使用 <code>Swift</code> 的任何平台上使用它。 它也是类型安全的，与 <code>Typhoon</code> 相比实现起来并不复杂。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 就 <code>API</code> 而言，它采用的方法对于其他平台上的 <code>DI</code> 容器而言更为传统，并遵循“注册解析”模式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们用于 <code>Typhoon</code> 的相同示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="type">DependencyContainer</span>()</span><br><span class="line"></span><br><span class="line">container.register &#123; </span><br><span class="line">    <span class="keyword">try</span> <span class="type">APIClientImp</span>(session: container.resolve()) <span class="keyword">as</span> <span class="type">APIClient</span> </span><br><span class="line">&#125;</span><br><span class="line">.resolveDependencies &#123; container, client <span class="keyword">in</span></span><br><span class="line">    client.logger = <span class="keyword">try</span> container.resolve()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.register &#123; <span class="type">NSURLSession</span>.sharedSession() <span class="keyword">as</span> <span class="type">NetworkSession</span> &#125;</span><br><span class="line">container.register(.<span class="type">Singleton</span>) &#123; <span class="type">ConsoleLogger</span>() <span class="keyword">as</span> <span class="type">Logger</span> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们将 <code>APIClientImp</code> 注册为 <code>APIClient</code> 协议的实现。 容器还将解析构造器参数，并且在创建实例时将设置 <code>logger</code> 属性。 对于会话参数容器，它将使用共享的 <code>URL</code> 会话，对于记录器，它将创建一个单例实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，当我们需要获取 <code>APIClient</code> 的实例时，我们只需调用容器的 <code>resolve</code> 方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apiClient = <span class="keyword">try</span>! container.resolve() <span class="keyword">as</span> <span class="type">APIClient</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会注意到，该 <code>API</code> 与我们在 <code>Service Locator</code> 中看到的几乎相同。 但这与 <code>API</code> 或实现无关，而与我们如何使用它有关。 如果您不想将容器用作服务定位器，请记住，只能在 <code>“Composition Root”</code> 中调用它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Dip</code> 还提供了一些很酷的功能，例如自动接线。 例如，我们可以定义要自动注入的 <code>logger</code> 属性。 容器将首先创建 <code>APIClient</code> 实例，然后使用其镜像查找 <code>logger</code> 属性并将真实实例注入其中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIClientImp</span>: <span class="title">APIClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _logger = <span class="type">Injected</span>&lt;<span class="type">Logger</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> logger: <span class="type">Logger?</span> &#123; <span class="keyword">return</span> _logger.value &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，当我们使用其构造函数注册 <code>APIClient</code> 而不是调用 <code>resolve</code> 获取 <code>NetworkSession</code> 参数时，我们只是说我们要使用传递给工厂闭包的第一个参数。 然后容器将推断出它的类型并为我们解决。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIClientImp</span>: <span class="title">APIClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">NetworkSession</span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.register &#123; <span class="type">APIClientImp</span>(session: $<span class="number">0</span>) <span class="keyword">as</span> <span class="type">APIClient</span> &#125;</span><br></pre></td></tr></table></figure><p>这样可以大大简化配置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们比较 <code>“Typhoon”</code> 和 <code>“Dip”</code> 的基本特征，我们会注意到它们共享大多数特征。 尽管它没有像 <code>Objective-C</code> 一样强大的运行时功能，但是在 <code>Swift</code> 中几乎可以实现相同的功能似乎令人惊讶。 但是，泛型和类型推断实际上是其中的重点。</p><table><thead><tr><th align="left"></th><th align="center">Typhoon</th><th align="right">Dip</th></tr></thead><tbody><tr><td align="left"><strong>Constructor, property, method injection</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Lifecycle management</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Circular dependencies</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Runtime arguments</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Named definitions</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Storyboards integration</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Auto-wiring</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Thread safety</strong></td><td align="center">✘</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Interception</strong></td><td align="center">✔︎</td><td align="right">✘</td></tr><tr><td align="left"><strong>Infrastructure</strong></td><td align="center">✔︎</td><td align="right">✘</td></tr></tbody></table></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会问，当我自己可以做时，为什么需要使用 <code>Typhoon</code> 或 <code>Dip</code> 或任何其他 <code>DI</code> 容器。 我可以建议的理由很少。 它们提供了与情节提要板的轻松集成，可以为您管理有时可能很棘手的组件生命周期，可以简化某些配置， <code>Typhoon</code> 还使用 <code>NSProxy</code> 和其他一些附加功能提供了轻松的拦截功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是请记住， <code>DI</code> 容器是可选的，并且依赖注入与使用 <code>DI</code> 容器不同。</p><blockquote><p><strong><em>DI ≠ DI Container</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在新项目中，我们可以根据需要从它开始，但是在旧代码库中，我们应该首先使用依赖注入模式，组合根和依赖反转原理对其进行重构，然后查看是否需要DI容器（在大多数情况下，回答将为“否”）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您具有复杂的配置，并且发现自己实现了一些类似 <code>DI</code> 容器的方法来简化它们，或者需要它提供的一些其他功能，那么可能会受益于使用现有的实现。但是，如果您对自己的工厂还可以的话-它的工厂很棒，请继续使用它们。不要仅仅为了使用 <code>DI</code> 容器而使用它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DI</code> 本身也是如此。对于在何处应用它以及需要解耦系统的哪些部分，要保持理性。不要尝试解决你尚未遇到的问题。也许你永远不会拥有它们，或者当你真正面对它们时，现在解决它们的方式将不合适。最后， <code>DI</code> 只是达到目的的一种手段，就像我们使用的任何其他模式或技术一样。它本身不是目标。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我想提到一些有用的资源，你可以在其中找到有关DI和一些相关主题的更多信息。</p></br><ul><li><a href="https://www.manning.com/books/dependency-injection-in-dot-net" target="_blank" rel="noopener"><code>“Dependency Injection in .Net” by Mark Seeman</code></a></li><li><a href="https://ilya.puchka.me/dependency-injection-in-swift/" target="_blank" rel="noopener"><code>Mark Seeman’s blog</code></a></li><li><a href="https://www.objc.io/issues/15-testing/dependency-injection/" target="_blank" rel="noopener"><code>objc.io Issue 15: Testing. Dependency Injection, by Jon Reid</code></a></li><li><a href="https://martinfowler.com/articles/dipInTheWild.html" target="_blank" rel="noopener"><code>“DIP in the wild”</code></a></li><li><a href="http://www.loosecouplings.com/2011/02/non-di-code-spaghetti-code.html" target="_blank" rel="noopener"><code>Non-DI code == spaghetti code?</code></a></li></ul><hr><hr><ul><li><p><a href="https://www.manning.com/books/dependency-injection-in-dot-net" target="_blank" rel="noopener"><code>&quot;Dependency Injection in .Net&quot; Mark Seeman</code></a> ↩︎</p></li><li><p><a href="https://github.com/mutualmobile/VIPER-SWIFT/blob/master/VIPER-SWIFT/Classes/AppDependencies.swift" target="_blank" rel="noopener"><code>https://github.com/mutualmobile/VIPER-SWIFT/blob/master/VIPER-SWIFT/Classes/AppDependencies.swift</code></a> ↩︎</p></li><li><p><a href="http://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/" target="_blank" rel="noopener"><code>http://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/</code></a> ↩︎</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 依赖注入设计模式 </tag>
            
            <tag> Dependency Injection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift依赖注入设计模式</title>
      <link href="/Swift%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用Swift学习依赖注入模式,使用DI编写松耦合代码。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我真的很喜欢James Shore的这句话：依赖注入意味着给对象一个实例变量，如此而已。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我看来，学习依赖注入要稍微复杂一点，但是如果你将问题弄清楚，你将意识到实现 <a href="http://www.xuebaonline.com/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/" title="DI模式">DI模式</a> 就像给对象实例变量一样简单。 别开玩笑，这确实是理所当然的，但是许多开发人员使它过于复杂，并在错误的位置使用了注入。 💉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习DI并不是关于实现细节，而是关于你将如何使用该模式。 依赖项注入有四个小变化，让我们通过使用真实的示例进行遍历，这些示例将帮助你了解何时使用依赖项注入。 现在抓住键盘！ 💻</p><a id="more"></a></br><h1 id="了解依赖注入-dependency-injection"><a href="#了解依赖注入-dependency-injection" class="headerlink" title="了解依赖注入(dependency injection)"></a><strong>了解依赖注入(dependency injection)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我之前提到的，DI是一个简单概念，你实际上并不需要外部库或框架来开始使用它。假设你有两个单独的对象。对象A要使用对象B。向你的第一个依赖发送一个消息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果将对象B硬编码为对象A，那将是不好的，因为从那时起，如果没有B，就无法使用A。现在将其扩展到约100个对象级别。如果你对此问题不采取任何措施，那么你会毫无头绪。 🍝</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，主要目标是创建尽可能多的独立对象，或者创建一些松散耦合的代码，以提高可重用性和可测试性。关注分离和去耦也是在这里使用，因为在大多数情况下，你应该从字面上将逻辑功能分离为独立的对象。 🤐</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，从理论上讲，两个对象都应该只做一件特定的事情，并且它们之间的依赖关系通常是通过通用描述符（协议）实现的，而无需对具体实例进行硬编码。为此，使用依赖注入可以提高代码质量，因为可以在不更改其他对象实现的情况下替换依赖。这对于模拟，测试，重用等很有用。</p></br><h1 id="如何在Swift中进行DI？"><a href="#如何在Swift中进行DI？" class="headerlink" title="如何在Swift中进行DI？"></a><strong>如何在Swift中进行DI？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 是一种了不起的编程语言，对协议和面向对象的原理都提供了出色的支持。 它也具有强大的功能，但是现在让我们忽略它。 依赖关系注入可以通过多种方式完成，但是在本教程中，我将只关注一些基本的，没有任何外部依赖关系注入的基础知识。 😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，让我们从一个协议开始，但这只是因为 <code>Swift</code> 不会向公众公开 <code>Encoder</code> ，但是我们在演示中需要类似的东西。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Encoder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span>&lt;T&gt;<span class="params">(<span class="number">_</span> value: T)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Encodable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">JSONEncoder</span>: <span class="title">Encoder</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PropertyListEncoder</span>: <span class="title">Encoder</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性列表和JSON编码器已经实现了此方法，我们只需要扩展对象以符合我们的全新协议即可。</p><h1 id="Custructor-注入"><a href="#Custructor-注入" class="headerlink" title="Custructor 注入"></a><strong>Custructor 注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖项注入的最常见形式是构造函数注入或基于初始化的注入。 主要的思路是通过初始化程序传递依赖关系，并将该对象存储在（私有只读/不可变）属性变量中。 这里的主要好处是，在对象创建之前，你的对象将具有所有依赖关系，以使其正常工作。 🔨</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> encoder: <span class="type">Encoder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> title</span><br><span class="line">        <span class="keyword">case</span> content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>, encoder: <span class="type">Encoder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">        <span class="keyword">self</span>.encoder = encoder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encoded</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Constructor injection"</span>, encoder: <span class="type">JSONEncoder</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encoded(), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以在构造函数中为编码器指定一个 <code>defult</code> 值，但是你应该担心恶意注入反模式！ 这意味着如果默认值来自另一个模块，则你的代码将与该模块紧密耦合。 所以请三思！ 🤔</p></br><h1 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a><strong>属性注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时很难进行初始化初始化注入，因为你的类必须从系统类继承。 如果你必须使用视图或控制器，这将使过程变得非常困难。 对于这种情况，一个好的解决方案是使用基于属性的注入设计模式。 也许你不能完全控制初始化，但是你始终可以控制属性。 唯一的缺点是，你必须先检查该属性是否已显示（已设置），然后再进行任何操作。 🤫</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> encoder: <span class="type">Encoder?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> title</span><br><span class="line">        <span class="keyword">case</span> content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encoded</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> encoder = <span class="keyword">self</span>.encoder <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Encoding is only supported with a valid encoder object."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Property injection"</span>)</span><br><span class="line">post.encoder = <span class="type">JSONEncoder</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encoded(), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>iOS</code> 框架中有很多属性注入模式，委托模式通常是这样实现的。 另外一个很大的好处是这些属性可以是可变的，因此你可以即时替换它们。 ✈️</p><h1 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a><strong>方法注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果只需要一次依赖关系，则实际上不需要将其存储为对象变量。 除了可以使用初始化参数或公开的可变属性，你还可以将依赖项作为方法参数传递，这种方法称为方法注入或基于参数的注入。 👍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(using encoder: Encoder)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Method injection"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encode(using: <span class="type">JSONEncoder</span>()), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次调用此方法时，你的依赖关系可能会有所不同，不需要从该依赖关系中保留引用，因此将仅在本地方法范围内使用它。</p></br><h1 id="上下文语境"><a href="#上下文语境" class="headerlink" title="上下文语境"></a><strong>上下文语境</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的最后一个模式非常危险。 它仅应用于与多个对象实例一起共享的通用依赖项。 日志，分析或缓存机制就是一个很好的例子。 🚧</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encoded</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">Post</span>.encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> _encoder: <span class="type">Encoder</span> = <span class="type">PropertyListEncoder</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setEncoder</span><span class="params">(<span class="number">_</span> encoder: Encoder)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._encoder = encoder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> encoder: <span class="type">Encoder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Post</span>._encoder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Ambient context"</span>)</span><br><span class="line"><span class="type">Post</span>.setEncoder(<span class="type">JSONEncoder</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encoded(), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上下文语境有一些缺点。 它可能很适合横切关注点，但会创建隐式依赖关系并表示全局可变状态。 强烈不建议这样做，你应该首先考虑其他依赖注入方式，但是有时它可能非常适合你。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 依赖注入设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift委托设计模式</title>
      <link href="/Swift%E5%A7%94%E6%89%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%A7%94%E6%89%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;委托设计模式是通过 <code>Swift</code> 中的通用接口（协议）在两个对象之间进行通信的相对简单的方法。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="委托模式">委托模式</a>（delegation pattern）是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承。</p><a id="more"></a></br><h1 id="在Swift中实现委派"><a href="#在Swift中实现委派" class="headerlink" title="在Swift中实现委派"></a><strong>在Swift中实现委派</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你将需要一个委托协议，一个实际委托任务的委托人以及一个实现委托协议并完成 <strong>“老板”</strong> 所要求的实际工作的委托对象。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：客户端报告一个错误。 项目经理会创建一个问题，并告诉一位开发人员尽快解决问题。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的场景就是委托👆。 在某个时刻发生了事件，因此委托人（经理）使用外部资源（开发人员）使用一个公共接口（描述双方的问题）来完成某件事（修复🐛）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了演示委托在现实生活中的工作方式，我举了一个非常简单的例子。 我将使用类似的方法（因为Xcode游乐场仍然每1-5分钟冻结一次），就像我对命令模式所做的那样，但是此方法的目的几乎是完全不同的，因为我们正在谈论委托模式。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env swift</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InputDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldContinueListening: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didStartListening</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(input: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> delegate: <span class="type">InputDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate?.didStartListening()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> input = <span class="built_in">readLine</span>() <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.delegate?.didReceive(input: input)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.delegate?.shouldContinueListening ?? <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputReceiver</span>: <span class="title">InputDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldContinueListening: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didStartListening</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"👻 Please be nice and say \"hi\", if you want to leave just tell me \"bye\":"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(input: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> input &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"hi"</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"🌎 Hello world!"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"bye"</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"👋 Bye!"</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"🔍 Command not found! Please try again:"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inputHandler = <span class="type">InputHandler</span>()</span><br><span class="line"><span class="keyword">let</span> inputReceiver = <span class="type">InputReceiver</span>()</span><br><span class="line">inputHandler.delegate = inputReceiver</span><br><span class="line">inputHandler.listen()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是你可以在 <code>Swift</code> 中创建自己的委托模式的方式。 你可以想象，<code>Apple</code> 正在使用 <code>UICollectionViewDataSource</code> ，<code>UICollectionViewDelegate</code> 等在后台做同样的事情。你只需实现委托，它们将提供协议和委托人。 🤔</p></br><h1 id="弱属性，委托和类"><a href="#弱属性，委托和类" class="headerlink" title="弱属性，委托和类"></a><strong>弱属性，委托和类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存管理是非常重要的事情，因此值得一提的是，所有的类委托都应该是 <strong>弱引用</strong>，否则你将 <strong>很难管理器生命周期，易引起内存泄露</strong>，这一点必须注意。 😱</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InputDelegate</span>: <span class="title">class</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">InputDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputReceiver</span>: <span class="title">InputDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是修改后的 <code>Swift</code> 代码段，但是现在使用一个类作为委托。 你只需要稍微更改协议和委托者内部的属性即可。 如果要将类分配为委托，请始终使用弱引用该变量。 ⚠️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如代码中展示的，委托模式很容易，但是很危险。 它通过提供可以由实现委托（有时是数据源）协议的任何人使用的公共接口来帮助解耦。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 委托设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift命令设计模式</title>
      <link href="/Swift%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令设计模式是众多设计模式中的一种，也比较常用。 这是用Swift编写的命令设计模板的一个小例子。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="命令模式">命令模式</a>（英语：Command pattern）是一种设计模式，它尝试以对象来代表实际行动。命令对象可以把行动(action) 及其参数封装起来，于是这些行动可以被：</p><ul><li>重复多次</li><li>取消（如果该对象有实现的话）</li><li>取消后又再重做</li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些都是现代大型应用程序所必须的功能，即“撤销”及“重复”。除此之外，可以用命令模式来实现的功能例子还有：</p><ul><li>交易行为</li><li>进度列</li><li>向导</li><li>用户界面按钮及功能表项目</li><li>线程 pool</li><li>宏收录</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想为稍后将要执行的不同操作提供一个通用界面，那么该命令模式将非常方便。 通常，它是一个对象，其中包含正确运行基础操作所需的所有信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令通常用于处理用户界面操作，创建撤消管理器或管理事务。 让我们通过使用表情符号创建命令行参数处理程序来查看 <code>Swift</code> 中的命令模式实现。 💾</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env swift</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelpCommand</span>: <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Help</span>().info()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Help</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">info</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">             🤖 Commander 🤖</span></span><br><span class="line"><span class="string">                  v1.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Available commands:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            👉 help      This command</span></span><br><span class="line"><span class="string">            👉 ls        List documents</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Bye! 👋</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListCommand</span>: <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">List</span>().homeDirectoryContents()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">homeDirectoryContents</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> documentsURL = fileManager.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask).first <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Could not open documents directory"</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> fileURLs = <span class="keyword">try</span> fileManager.contentsOfDirectory(at: documentsURL, includingPropertiesForKeys: <span class="literal">nil</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\n\t📁 Listing documents directory:\n"</span>)</span><br><span class="line">            <span class="built_in">print</span>(fileURLs.<span class="built_in">map</span> &#123; <span class="string">"\t\t💾 "</span> + $<span class="number">0</span>.lastPathComponent &#125;.joined(separator: <span class="string">"\n\n"</span>) + <span class="string">"\n"</span> )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> commands: [<span class="type">String</span>:<span class="type">Command</span>] = [:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.commands[<span class="string">"help"</span>] = <span class="type">HelpCommand</span>()</span><br><span class="line">        <span class="keyword">self</span>.commands[<span class="string">"ls"</span>] = <span class="type">ListCommand</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arguments = <span class="type">CommandLine</span>.arguments[<span class="number">1</span>...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> key = arguments.first, <span class="keyword">self</span>.commands[key] != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Usage: ./command.swift [\(self.commands.keys.joined(separator: "</span>|<span class="string">"))]"</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.commands[key]!.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">App</span>().run()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果保存此文件，只需在终端窗口中键入 <code>./file-name.swift</code> 即可运行它。 <code>Swift</code> 编译器将负责其余的工作。 ⚒</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令设计模式的实际用例：</p><ul><li>各种按钮动作</li><li>集合/表视图选择操作</li><li>在控制器之间导航</li><li>历史记录管理/撤消管理器</li><li>交易行为</li><li>进度管理</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如你所了解那样，该模式可以应用于多个区域。 苹果为此专门制作了一个名为 <code>NSInvocation</code> 的特定类，但不幸的是，由于它的动态行为，它在 <code>Swift</code> 中不可用。 没什么大不了的，你始终可以制定自己的协议和实现，在大多数情况下，你只需要一个包装基础命令逻辑的额外类即可。 😛</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 命令设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift原型设计模式</title>
      <link href="/Swift%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型设计模式用于创建基础对象的克隆，因此让我们看一些用Swift编写的实际示例。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式是 <a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="创建型模式">创建型模式</a> 的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这也是一种创新的设计模式，当你对一个对象进行非常基本的配置并且想要将这些预定义值提供（复制）给另一个对象时，这很有用。 基本上，你是从原型对象制作复制。 😊😊😊</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法有一些好处，例如，你不必继承子类，但可以单独配置复制。 这也意味着，如果你要使用原型，则可以删除一堆样板代码（配置）。 🤔</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paragraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> font: <span class="type">UIFont</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(font: <span class="type">UIFont</span> = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>),</span><br><span class="line">         color: <span class="type">UIColor</span> = .darkText,</span><br><span class="line">         text: <span class="type">String</span> = <span class="string">""</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = font</span><br><span class="line">        <span class="keyword">self</span>.color = color</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clone</span><span class="params">()</span></span> -&gt; <span class="type">Paragraph</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Paragraph</span>(font: <span class="keyword">self</span>.font, color: <span class="keyword">self</span>.color, text: <span class="keyword">self</span>.text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> base = <span class="type">Paragraph</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = base.clone()</span><br><span class="line">title.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">title.text = <span class="string">"This is the title"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = base.clone()</span><br><span class="line">first.text = <span class="string">"This is the first paragraph"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> second = base.clone()</span><br><span class="line">second.text = <span class="string">"This is the second paragraph"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上面的代码所示，实现只是几行代码。 你只需要一个默认的初始化程序和一个复制方法。 一切都将在 <code>init</code> 方法中针对原型对象进行预配置，并且你可以使用 <code>clone</code> 方法进行复制，但这时很明显……</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们再看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paragraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> font: <span class="type">UIFont</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(font: <span class="type">UIFont</span> = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>),</span><br><span class="line">         color: <span class="type">UIColor</span> = .darkText,</span><br><span class="line">         text: <span class="type">String</span> = <span class="string">""</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = font</span><br><span class="line">        <span class="keyword">self</span>.color = color</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clone</span><span class="params">()</span></span> -&gt; <span class="type">Paragraph</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Paragraph</span>(font: <span class="keyword">self</span>.font, color: <span class="keyword">self</span>.color, text: <span class="keyword">self</span>.text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> base = <span class="type">Paragraph</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = base.clone()</span><br><span class="line">title.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">title.text = <span class="string">"This is the title"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = base.clone()</span><br><span class="line">first.text = <span class="string">"This is the first paragraph"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> second = base.clone()</span><br><span class="line">second.text = <span class="string">"This is the second paragraph"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你打算获取已知对象状态的快照，则原型设计模式也很有用。 例如，在绘图应用程序中，你可以将形状类作为原型，可以开始向其添加路径，有时甚至可以从中创建快照。 你可以继续处理新对象，但这将使你能够在将来的任何时间返回到保存状态。 🎉</p><p>当你的应用程序不依赖于创建，合成和表示对象的方法时，应考虑选择它，以及至少下列各项之一：</p><ul><li>在运行时创建对象</li><li>你想避免工厂的复杂层次结构</li><li>对象只能有很少的状态</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，就是 <code>Swift</code> 中的原型设计模式。 🐿</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 原型设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比较工厂设计模式</title>
      <link href="/%E6%AF%94%E8%BE%83%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/%E6%AF%94%E8%BE%83%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用Swift语言了解静态工厂，简单工厂，工厂方法和抽象工厂之间的区别。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为对所有工厂模式进行汇总比较会很高兴，所以这里是你应该了解的所有内容。 构造它们相对简单，在本示例中，我将使用一些用 <code>Swift</code> 编程语言编写的 <code>UIColor</code> 来向你展示基础知识。 🧙‍♂️</p><a id="more"></a><h1 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a><strong>静态工厂</strong></h1><ul><li>没有单独的工厂类别</li><li>命名静态方法来初始化对象</li><li>可以具有缓存并可以返回子类型</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> primary: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> .black &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> secondary: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> .white &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> primary = <span class="type">UIColor</span>.primary</span><br><span class="line"><span class="keyword">let</span> secondary = <span class="type">UIColor</span>.secondary</span><br></pre></td></tr></table></figure><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a><strong>简单工厂</strong></h1><ul><li>一个工厂类</li><li>枚举( <code>switch-case</code> )出其中的实例对象</li><li>封装各种代码</li><li>如果列表太大，请使用工厂方法</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> primary</span><br><span class="line">        <span class="keyword">case</span> secondary</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> style: Style)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style</span><br><span class="line">        <span class="keyword">case</span> .primary:</span><br><span class="line">            <span class="keyword">return</span> .black</span><br><span class="line">        <span class="keyword">case</span> .secondary:</span><br><span class="line">            <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primary = factory.create(.primary)</span><br><span class="line"><span class="keyword">let</span> secondary = factory.create(.secondary)</span><br></pre></td></tr></table></figure><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong>工厂方法</strong></h1><ul><li>多个（解耦的）工厂类</li><li>每个实例的工厂方法</li><li>为工厂创建一个简单的协议</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .black</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> primaryColorFactory = <span class="type">PrimaryColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> secondaryColorFactory = <span class="type">SecondaryColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primary = primaryColorFactory.create()</span><br><span class="line"><span class="keyword">let</span> secondary = secondaryColorFactory.create()</span><br></pre></td></tr></table></figure><h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a><strong>抽象工厂</strong></h1><ul><li>结合简单的工厂和工厂方法</li><li>对整个应用程序具有全局作用</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exact same factory method pattern from above</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .black</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple factory pattern from above using the factory methods</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> dark</span><br><span class="line">        <span class="keyword">case</span> light</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> theme: Theme)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> theme &#123;</span><br><span class="line">        <span class="keyword">case</span> .dark:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">PrimaryColorFactory</span>().create()</span><br><span class="line">        <span class="keyword">case</span> .light:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">SecondaryColorFactory</span>().create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">AppColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primaryColor = factory.create(.dark)</span><br><span class="line"><span class="keyword">let</span> secondaryColor = factory.create(.light)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，所有这些都是使用 <code>Swift</code> 编写的实际示例的工厂模式。 👍</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 工厂设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift抽象工厂设计模式</title>
      <link href="/Swift%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们将工厂方法与简单的工厂外观结合起来：这是用Swift语言编写的抽象工厂设计模式！</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82" target="_blank" rel="noopener" title="抽象工厂模式">抽象工厂模式</a>（英语：Abstract factory pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举个例子来说，比如一个抽象工厂类叫做DocumentCreator（文档创建器），此类提供创建若干种产品的接口，包括createLetter()（创建信件）和createResume()（创建简历）。其中，createLetter()返回一个Letter（信件），createResume()返回一个Resume（简历）。系统中还有一些DocumentCreator的具体实现类，包括FancyDocumentCreator和ModernDocumentCreator。这两个类对DocumentCreator的两个方法分别有不同的实现，用来创建不同的“信件”和“简历”（用FancyDocumentCreator的实例可以创建FancyLetter和FancyResume，用ModernDocumentCreator的实例可以创建ModernLetter和ModernResume）。这些具体的“信件”和“简历”类均继承自抽象类，即Letter和Resume类。客户端需要创建“信件”或“简历”时，先要得到一个合适的DocumentCreator实例，然后调用它的方法。一个工厂中创建的每个对象都是同一个主题的（“fancy”或者“modern”）。客户端程序只需要知道得到的对象是“信件”或者“简历”，而不需要知道具体的主题，因此客户端程序从抽象工厂DocumentCreator中得到了Letter或Resume类的引用，而不是具体类的对象引用。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“工厂”是创建产品（对象）的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够抵消这样的“额外工作”。</p></blockquote><h1 id="Swift抽象工厂"><a href="#Swift抽象工厂" class="headerlink" title="Swift抽象工厂"></a><strong>Swift抽象工厂</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂模式提供了一种封装一组具有共同主题的单个工厂而无需指定其具体类的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，抽象工厂可以为你创建相关对象的族。 该实现通常结合简单的工厂和工厂方法原理。 单个对象是通过工厂方法创建的，而整个对象都包装在一个“抽象”的简单工厂中。 现在检查代码！ 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service protocols</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StagingService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://dev.localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StagingServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">StagingService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// production</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://live.localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProductionService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// abstract factory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Environment</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> production</span><br><span class="line">        <span class="keyword">case</span> staging</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> env: <span class="type">Environment</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(env: <span class="type">Environment</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.env = env</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>.env &#123;</span><br><span class="line">        <span class="keyword">case</span> .production:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ProductionServiceFactory</span>().create()</span><br><span class="line">        <span class="keyword">case</span> .staging:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">StagingServiceFactory</span>().create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">AppServiceFactory</span>(env: .production)</span><br><span class="line"><span class="keyword">let</span> service = factory.create()</span><br><span class="line"><span class="built_in">print</span>(service.url)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上代码看到的，使用抽象工厂将影响整个应用程序逻辑，而工厂方法仅对本地部分产生影响。 实现可能会有所不同，例如你也可以为抽象工厂创建一个独立的协议，但是在此示例中，我想使事情尽可能简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂通常用于实现对象独立性。 例如，如果你使用通用接口用 <code>Swift</code> 编写了多个不同的 <code>SQL</code> 数据库连接器（ <code>PostgreSQL</code> ，<code>MySQL</code> 等），则可以随时使用此模式在它们之间轻松切换。 可以将类似的逻辑应用于具有类似情况的业务。 🤔</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 抽象工厂设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift工厂方法设计模式</title>
      <link href="/Swift%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法设计模式是一种专用的非静态方法，用于隐藏对象的创建逻辑。 让我们用Swift做吧！</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p><a id="more"></a><h1 id="工厂方法只是一种非静态方法"><a href="#工厂方法只是一种非静态方法" class="headerlink" title="工厂方法只是一种非静态方法"></a><strong>工厂方法只是一种非静态方法</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面对现实，这种模式只是通常由简单协议和类支持的一种方法。 从一个非常简单的示例开始：想象一个可以为您的服务端点创建基本URL的类。 我们称之为服务工厂。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createProductionUrl</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ServiceFactory</span>()</span><br><span class="line">factory.createProductionUrl()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会想，这甚至不接近工厂方法模式，但请稍候…让我们通过为服务类创建协议以及返回 <code>URL</code> 的协议，使事情变得有些复杂。 现在，我们可以将基本生产环境url协议实现为一个单独的类，并从生产服务工厂类返回该特定实例。 只需检查一下代码即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProductionService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ProductionServiceFactory</span>()</span><br><span class="line"><span class="keyword">let</span> request = factory.create()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么我们将所有逻辑分为两类和协议？ 请相信我去耦是一件好事。 从现在开始，你可以轻松编写带有虚拟 <code>url</code> 的模拟服务。 显然，这需要一个匹配的工厂类。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些模拟实例还将实现服务协议，因此你可以以相对轻松的方式添加新类型，而无需更改原始代码库。 工厂方法解决了简单工厂模式的一个特定问题。 如果列表（ <code>switch-case</code> 的列表）太长，那么只有一个工厂就很难维护新对象。 工厂方法通过引入多个工厂对象来解决此问题。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 工厂方法设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中快速简单的工厂设计模式</title>
      <link href="/Swift%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，我们来讨论简单的工厂设计模式，该模式使用Swift以一种非常简单的方式封装对象创建。</p></blockquote><h1 id="使用-switch-case-实现简单的工厂模式"><a href="#使用-switch-case-实现简单的工厂模式" class="headerlink" title="使用 switch-case 实现简单的工厂模式"></a><strong>使用 switch-case 实现简单的工厂模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式的目标是封装一些经常变化的东西。 想象一下应用程序的调色板。 你可能必须每天根据设计师的最新习惯来更改颜色。 如果你不得不手动搜索和替换每个单独的颜色代码实例，那将给你带来极大的不便。 因此，让我们在Swift中创建一个简单的工厂，该工厂可以根据给定的样式返回颜色。 🎩</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> text</span><br><span class="line">        <span class="keyword">case</span> background</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> style: Style)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style &#123;</span><br><span class="line">        <span class="keyword">case</span> .text:</span><br><span class="line">            <span class="keyword">return</span> .black</span><br><span class="line">        <span class="keyword">case</span> .background:</span><br><span class="line">            <span class="keyword">return</span> .white</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> textColor = factory.create(.text)</span><br><span class="line"><span class="keyword">let</span> backgroundColor = factory.create(.background)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这真的很有用，尤其是涉及复杂的对象初始化过程时。 您还可以定义一个协议，并使用 <code>switch-case</code> 块返回实现所需接口的各种实例类型。 🚦</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevEnvironment</span>: <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"dev"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiveEnvironment</span>: <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"live"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnvironmentFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> dev</span><br><span class="line">        <span class="keyword">case</span> live</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> type: EnvType)</span></span> -&gt; <span class="type">Environment</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> type &#123;</span><br><span class="line">        <span class="keyword">case</span> .dev:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">DevEnvironment</span>()</span><br><span class="line">        <span class="keyword">case</span> .live:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">LiveEnvironment</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">EnvironmentFactory</span>()</span><br><span class="line"><span class="keyword">let</span> dev = factory.create(.dev)</span><br><span class="line"><span class="built_in">print</span>(dev.identifier)</span><br></pre></td></tr></table></figure><p>因此，有关简单工厂设计模式的几件事要记住：</p><ul><li>通过分离初始化和使用逻辑，有助于松耦合</li><li>它只是包装可以经常更改的东西的包装器</li><li>可以使用枚举和开关盒在Swift中实现简单的工厂</li><li>如果您计划返回不同的对象（POP🎉），请使用协议</li><li>保持简单🏭</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式将创建与实际用法分开，并将职责移至特定角色，因此，如果发生某些变化，你只需要修改工厂即可。 你可以保留所有测试，而其他所有功能则完全不受影响。 强大而简单！ 💪</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 工厂模式 </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 静态工厂方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中构造函数与静态工厂方法的比较</title>
      <link href="/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当实例化对象时，哪个更好：构造函数还是静态工厂方法？ 我们来看一看。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我相信Joshua Bloch 在他的非常不错的书 《Effective Java》 中首先说了它：与构造函数相比，静态工厂方法是实例化对象的首选方法。 我不同意。 不仅因为我相信静态方法是纯粹的邪恶，而且主要是因为在这种特殊情况下，它们形成好的方法，使我们认为我们必须偏向使用它们。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从面向对象的角度分析推理并弄清楚其原因。这是一个具有一个主要构造函数和两个次要构造函数的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">Color</span>(<span class="type">String</span> rgb) &#123;</span><br><span class="line">        this(<span class="type">Integer</span>.parseInt(rgb, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Color</span>(int red, int green, int blue) &#123;</span><br><span class="line">        this(red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是带有三个静态工厂方法的类似类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromRGB(<span class="type">String</span> rgb) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(<span class="type">Integer</span>.parseInt(rgb, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromPalette(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromHex(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你更喜欢哪一个？</p><p>根据Joshua Bloch的说法，使用静态工厂方法而不是构造函数具有三个基本优点（实际上有四个优点，但是第四个不再适用于Java）：</p><ul><li>他们有名字。</li><li>他们可以缓存。</li><li>它们可以是子类型。</li></ul><p>我认为，如果设计错误，那么这三者都是很合理的。 它们是解决问题的好办法。 让我们一一介绍。</p><h1 id="命名存在"><a href="#命名存在" class="headerlink" title="命名存在"></a><strong>命名存在</strong></h1><p>这是使用构造函数制作 <code>red tomato</code> 颜色对象的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>这是使用静态工厂方法的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>makeFromPalette（）</code> 在语义上比新的 <code>Color（）</code> 更丰富。 如果我们将它们传递给构造函数，谁知道这三个数字意味着什么。 但是“palette”可以帮助我们立即解决所有问题。</p><p>但是，正确的解决方案是使用多态和封装，以将问题分解为几个语义丰富的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="type">Color</span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HexColor</span> <span class="title">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">HexColor</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RGBColor</span> <span class="title">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Color</span> origin;</span><br><span class="line">    <span class="type">RGBColor</span>(int red, int green, int blue) &#123;</span><br><span class="line">        this.origin = new <span class="type">HexColor</span>(</span><br><span class="line">            red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们使用类的构造函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">RGBColor</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure></br><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h1><p>假设我在应用程序中的多个位置需要一个 <code>red tomato</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// ... sometime later</span></span><br><span class="line"><span class="type">Color</span> red = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此创建两个对象，这显然是低效的，因为它们是相同的。 最好将第一个实例保留在内存中的某个位置，并在第二个调用到达时将其返回。 静态工厂方法可以解决这个问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// ... sometime later</span></span><br><span class="line"><span class="type">Color</span> red = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在 <code>Color</code> 内的某个地方，保存一个私有静态 <code>Map</code> ，其中已实例化了所有对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Map</span> &lt; <span class="type">Integer</span>, <span class="type">Color</span> &gt; <span class="type">CACHE</span> =</span><br><span class="line">        new <span class="type">HashMap</span> &lt; &gt; ();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromPalette(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">final</span> int hex = red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Color</span>.<span class="type">CACHE</span>.computeIfAbsent(</span><br><span class="line">            hex, h - &gt; new <span class="type">Color</span>(h)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是非常高效的。 对于像我们的 <code>Color</code> 这样的对象，问题可能不会那么明显，但是当对象较大时，其实例化和垃圾回收可能会浪费大量时间。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有一种面向对象的方法可以解决此问题。 我们只是介绍了一个新的类 <code>Palette</code> ，它将变成一个颜色存储区：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Palette</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Map</span> &lt; <span class="type">Integer</span>, <span class="type">Color</span> &gt; colors =</span><br><span class="line">        new <span class="type">HashMap</span> &lt; &gt; ();</span><br><span class="line">    <span class="type">Color</span> take(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">final</span> int hex = red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue;</span><br><span class="line">        <span class="keyword">return</span> this.computerIfAbsent(</span><br><span class="line">            hex, h - &gt; new <span class="type">Color</span>(h)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们一次创建一个 <code>Palette</code> 实例，并要求它在每次需要时向我们返回一种颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = palette.take(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// Later we will get the same instance:</span></span><br><span class="line"><span class="type">Color</span> red = palette.take(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p><strong>没有静态方法，没有静态属性。</strong></p></br><h1 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a><strong>子类型</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们的 <code>Color</code> 类具有 <code>lighter()</code> 方法，该方法应该将颜色转移到下一个可用的 <code>lighter</code> 上：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    protected <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(hex + <span class="number">0x111</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有时更希望通过一组可用的 <code>Pantone</code> 颜色选择下一种较浅的颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PantoneColor</span> <span class="title">extends</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">PantoneName</span> pantone;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">String</span> name) &#123;</span><br><span class="line">        this(new <span class="type">PantoneName</span>(name));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">PantoneName</span> name) &#123;</span><br><span class="line">        this.pantone = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">PantoneColor</span>(this.pantone.up());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建一个静态工厂方法，该方法将决定哪种 <code>Color</code> 实现最适合我们：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> code;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> make(int h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> new <span class="type">PantoneColor</span>(<span class="string">"19-1664 TPX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">RGBColor</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果要求使用真正的红色，我们将返回 <code>PantoneColor</code> 的一个实例。 在所有其他情况下，它只是标准的 <code>RGBColor</code> 。 该决定是通过静态工厂方法做出的。 这就是我们所说的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> color = <span class="type">Color</span>.make(<span class="number">0xBF1932</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于构造函数只能返回在其中声明的类，因此不可能对构造函数执行相同的 <code>“forking”</code> 。静态方法具有返回 <code>Color</code> 的任何子类型所需的所有自由。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是，在面向对象的世界中，我们可以而且必须以不同的方式去做。 首先，我们将 <code>Color</code> 设置为接口：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="type">Color</span> &#123;</span><br><span class="line">    <span class="type">Color</span> lighter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们将需要的构造方法移至其自己的类 <code>Colors</code> ，就像在上一个示例中所做的那样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colors</span> </span>&#123;</span><br><span class="line">    <span class="type">Color</span> make(int h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> new <span class="type">PantoneColor</span>(<span class="string">"19-1664-TPX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">RGBColor</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而且我们将使用 <code>Colors</code> 类的实例，而不是 <code>Color</code> 内部的静态方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colors.make(<span class="number">0xBF1932</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，这仍然不是真正的面向对象的思维方式，因为我们正在将决策权从它所属的对象上移开。 通过静态工厂方法 <code>make（</code>）或新类 <code>Colors</code> （实际上并不重要），我们将对象分成两部分。 第一部分是对象本身，第二部分是决策算法，它位于其他地方。<br>面向对象的设计是将逻辑放入 <code>PantoneColor</code> 类的对象中，该对象将装饰原始的RGBColor：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PantoneColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Color</span> origin;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">Color</span> color) &#123;</span><br><span class="line">        this.origin = color;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Color</span> next;</span><br><span class="line">        <span class="keyword">if</span> (this.origin.hex() == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            next = new <span class="type">RGBColor</span>(<span class="number">0xD12631</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next = this.origin.lighter();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">PantoneColor</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建一个 <code>RGBColor</code> 实例，并使用 <code>PantoneColor</code> 装饰它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> red = new <span class="type">PantoneColor</span>(</span><br><span class="line">    new <span class="type">RGBColor</span>(<span class="number">0xBF1932</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要求红色返回较浅的颜色，它返回 <code>Pantone</code> 调色板中的一种，而不是仅在 <code>RGB</code> 坐标中较浅的颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> lighter = red.lighter(); <span class="comment">// 0xD12631</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，这个示例是原始的，如果我们真的希望它适用于所有 <code>Pantone</code> 颜色，则需要进一步改进。 逻辑必须保留在类内部，而不是外部，静态工厂方法甚至其他补充类中。 当然，我在说的是属于这个特定类的逻辑。 如果与类实例的管理有关，则可以有容器和存储，就像上面的上一个示例一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总而言之，我强烈建议您不要使用静态方法，尤其是当它们要替换对象构造函数时。 通过其构造函数生成对象是任何面向对象软件中最“神圣”的时刻，请不要错过它的美丽。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 工厂模式 </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 静态工厂方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift静态工厂设计模式</title>
      <link href="/Swift%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，我们一起看一下有关 <a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95" target="_blank" rel="noopener" title="静态工厂设计模式">静态工厂设计模式</a> 的知识，并展示一些使用Swift编程语言的用例。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。” </p></blockquote><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个对象常常需要复杂的过程，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。</p></blockquote></br><h1 id="静态工厂模式示例"><a href="#静态工厂模式示例" class="headerlink" title="静态工厂模式示例"></a><strong>静态工厂模式示例</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象创建中的有些过程包括决定创建哪个对象、管理对象的生命周期，以及管理特定对象的创建和销毁的概念。</p></blockquote><h2 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a><strong>命名构造函数</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于静态装饰模式的第一个好处是，每个静态装饰方法都可以有一个名称。 <code>Apple</code> 在其 <code>UIColor</code> 类实现中使用此模式来创建诸如 <code>.red</code> ，<code>.yellow</code> 等的命名颜色。请注意，<code>Swift</code> 中的实现实际上不是方法，而是静态属性，它返回实际实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">TimeInterval</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> second: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> minute: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">60</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> hour: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">3_600</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> day: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">86_400</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> week: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">604_800</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果很难记住一天或一周是几秒钟，为什么不为它创建一个命名初始化器。 看到 <code>TimeInterval.week</code> 比 <code>604_800</code> 好得多。 😅</p></br><h2 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a><strong>缓存对象</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态工厂模式的下一个优点是，为了更好地使用内存，它可以支持缓存。 这样，如果你通过静态构造函数（也称为<a href="http://www.xuebaonline.com/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/" title="Swift中构造函数与静态工厂方法的比较">静态工厂方法</a>）对其进行初始化，则可以限制所创建对象的数量。 🏭</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - cache</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> cache: [<span class="type">String</span>:<span class="type">Service</span>] = [:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cached</span><span class="params">(name: String)</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">Service</span>.cache[name] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="type">Service</span>.cache[name] = <span class="type">Service</span>(named: name)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cache[name]!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - static factory</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> local: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cached(name: <span class="string">"local"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> remote: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cached(name: <span class="string">"remote"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(named name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h2 id="本地初始化范围"><a href="#本地初始化范围" class="headerlink" title="本地初始化范围"></a><strong>本地初始化范围</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于静态工厂方法的另一个好处是，你可以将类的初始化限制为私有作用域。 换句话说，只能通过静态工厂方法进行对象创建。 你只需要将 <code>init</code> 方法设为私有。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> local: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>(name: <span class="string">"local"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> remote: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>(name: <span class="string">"remote"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>请注意，您可以使用 <code>final＆static</code> 关键字限制子类化。 如果要允许子类化，则应删除 <code>final</code> 并为属性使用 <code>class</code> 关键字而不是 <code>static</code> ，这样子类可以覆盖工厂方法。</strong> 🤔</p></br><h2 id="静态返回任何数据"><a href="#静态返回任何数据" class="headerlink" title="静态返回任何数据"></a><strong>静态返回任何数据</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 静态工厂也可以返回给定对象的子类型，但是为什么我们不更进一步呢？ 你还可以从静态方法返回任何类型的数据，我知道这似乎是一种作弊，因为我不是在这里创建 <code>UIColor</code> 的实例，但是我相信在这里值得一提这个方法，静态工厂。 有时，这个技术可能非常有用。 😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span><span class="params">(with color: UIColor)</span></span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">1</span>, height: <span class="number">1</span>)</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(rect.size)</span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()!</span><br><span class="line">        context.setFillColor(color.cgColor)</span><br><span class="line">        context.fill(rect)</span><br><span class="line">        <span class="keyword">let</span> img = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> img!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> redImage: <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>.image(with: .red)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift生成器模式</title>
      <link href="/Swift%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>了解如何在Swift中实现生成器模式，以隐藏创建具有许多单独属性的对象的复杂性。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>iOS</code> 开发中，会使用到很多设计模式，<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="生成器模式">生成器模式</a> 也叫构建器模式，我们也会经常用到。在以下的行文过程中均使用生成器模式来表述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成器模式（英：Builder Pattern）是一种设计模式，又名：建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p><a id="more"></a></br><h1 id="生成器模式如何工作？"><a href="#生成器模式如何工作？" class="headerlink" title="生成器模式如何工作？"></a><strong>生成器模式如何工作？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成器模式可以通过多种方式实现，但是如果你了解该模式的主要目标，那实际上就没有关系：</p><blockquote><p><strong>Builder设计模式的目的是将复杂对象的构造与其表示分开。</strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如果你有一个具有很多属性的对象，想隐藏初始化过程的复杂性，可以编写一个生成器并通过该生成器构造该对象。 它可以像控制整个构建过程的构建方法或外部类一样简单。 这完全取决于给定的环境。 🏗</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，我们对该设计模式有一个详细的认知，让我们来看一下使用实例和强大的 <code>Swift</code> 编程语言的生成器模式！ 💪</p></br><h1 id="简单的-Emitter-生成器"><a href="#简单的-Emitter-生成器" class="headerlink" title="简单的 Emitter 生成器"></a><strong>简单的 Emitter 生成器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SKEmitterNode</code> 是一个很好的例子。 如果要创建自定义 <code>Emitter</code> 并以编程方式设置属性（通常用于 <code>SpriteKit</code> 游戏），则像这样的 <code>Emitter</code> 生成器类可能是一个合理的解决方案。 👾</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmitterBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKEmitterNode</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> emitter = <span class="type">SKEmitterNode</span>()</span><br><span class="line">        emitter.particleTexture = <span class="type">SKTexture</span>(imageNamed: <span class="string">"MyTexture"</span>)</span><br><span class="line">        emitter.particleBirthRate = <span class="number">100</span></span><br><span class="line">        emitter.particleLifetime = <span class="number">60</span></span><br><span class="line">        emitter.particlePositionRange = <span class="type">CGVector</span>(dx: <span class="number">100</span>, dy: <span class="number">100</span>)</span><br><span class="line">        emitter.particleSpeed = <span class="number">10</span></span><br><span class="line">        emitter.particleColor = .red</span><br><span class="line">        emitter.particleColorBlendFactor = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> emitter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">EmitterBuilder</span>().build()</span><br></pre></td></tr></table></figure></br><h1 id="简单的-theme-生成器"><a href="#简单的-theme-生成器" class="headerlink" title="简单的 theme 生成器"></a><strong>简单的 theme 生成器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们远离游戏，想象一下你正在为UIKit应用程序创建一个主题引擎，该引擎具有许多自定义字体，颜色等。生成器对于构造独立主题可能很有用。 🔨</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> textColor: <span class="type">UIColor?</span></span><br><span class="line">    <span class="keyword">let</span> backgroundColor: <span class="type">UIColor?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> light</span><br><span class="line">        <span class="keyword">case</span> dark</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(<span class="number">_</span> style: Style)</span></span> -&gt; <span class="type">Theme</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style &#123;</span><br><span class="line">        <span class="keyword">case</span> .light:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Theme</span>(textColor: .black, backgroundColor: .white)</span><br><span class="line">        <span class="keyword">case</span> .dark:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Theme</span>(textColor: .white, backgroundColor: .black)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="type">ThemeBuilder</span>()</span><br><span class="line"><span class="keyword">let</span> light = builder.build(.light)</span><br><span class="line"><span class="keyword">let</span> dark = builder.build(.dark)</span><br></pre></td></tr></table></figure></br><h1 id="“Chained”-URL构建器"><a href="#“Chained”-URL构建器" class="headerlink" title="“Chained” URL构建器"></a><strong>“Chained” URL构建器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用这种方法，你可以通过多种方法配置对象，并且每个方法都将返回相同的生成器对象。 这样，您可以链接配置，并在最后一步构建最终对象实例。 ⛓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> components: <span class="type">URLComponents</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.components = <span class="type">URLComponents</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(scheme: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.scheme = scheme</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(host: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.host = host</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(port: Int)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.port = port</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(path: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> path = path</span><br><span class="line">        <span class="keyword">if</span> !path.hasPrefix(<span class="string">"/"</span>) &#123;</span><br><span class="line">            path = <span class="string">"/"</span> + path</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.components.path = path</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addQueryItem</span><span class="params">(name: String, value: String)</span></span> -&gt; <span class="type">URLBuilder</span>  &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.components.queryItems == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.components.queryItems = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.components.queryItems?.append(<span class="type">URLQueryItem</span>(name: name, value: value))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">URL?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.components.url</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URLBuilder</span>()</span><br><span class="line">    .<span class="keyword">set</span>(scheme: <span class="string">"https"</span>)</span><br><span class="line">    .<span class="keyword">set</span>(host: <span class="string">"localhost"</span>)</span><br><span class="line">    .<span class="keyword">set</span>(path: <span class="string">"api/v1"</span>)</span><br><span class="line">    .addQueryItem(name: <span class="string">"sort"</span>, value: <span class="string">"name"</span>)</span><br><span class="line">    .addQueryItem(name: <span class="string">"order"</span>, value: <span class="string">"asc"</span>)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure></br><h1 id="director-类的生成器模式"><a href="#director-类的生成器模式" class="headerlink" title="director 类的生成器模式"></a><strong>director 类的生成器模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们认识一下 <code>director</code> 实例。 使构建器与确切的配置部分解耦。 因此，举例来说，你可以制作带有圆圈的游戏，但是后来如果你改变主意并想使用正方形，那相对容易。 你只需要创建一个新的生成器，其他所有内容都可以相同。 🎬</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NodeBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">SKColor</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NodeDirector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> builder: <span class="type">NodeBuilder</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleNodeBuilder</span>: <span class="title">NodeBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">SKColor</span> = .clear</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="type">SKShapeNode</span>(circleOfRadius: <span class="keyword">self</span>.size)</span><br><span class="line">        node.name = <span class="keyword">self</span>.name</span><br><span class="line">        node.fillColor = <span class="keyword">self</span>.color</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerNodeDirector</span>: <span class="title">NodeDirector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> builder: <span class="type">NodeBuilder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(builder: <span class="type">NodeBuilder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.builder = builder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.builder.name = <span class="string">"Hello"</span></span><br><span class="line">        <span class="keyword">self</span>.builder.size = <span class="number">32</span></span><br><span class="line">        <span class="keyword">self</span>.builder.color = .red</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.builder.build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="type">CircleNodeBuilder</span>()</span><br><span class="line"><span class="keyword">let</span> director = <span class="type">PlayerNodeDirector</span>(builder: builder)</span><br><span class="line"><span class="keyword">let</span> player = director.build()</span><br></pre></td></tr></table></figure><h1 id="基于Block的构建器"><a href="#基于Block的构建器" class="headerlink" title="基于Block的构建器"></a><strong>基于Block的构建器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一种更快捷的方法是使用 <code>Block</code> 而不是生成器类来配置对象。 当然，我们可以争论这是否仍然是生成器模式…😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(block: <span class="params">(<span class="params">(UILabel)</span></span></span></span> -&gt; <span class="type">Void</span>)) -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        block(label)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> label = <span class="type">UILabel</span>.build &#123; label <span class="keyword">in</span></span><br><span class="line">    label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    label.text = <span class="string">"Hello wold!"</span></span><br><span class="line">    label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 请注意，生成器的实现可能会因具体实例而异。 有时，生成器模式与工厂模式结合在一起。 对此，几乎每个人都以不同的方式解释它，但是我认为这不是问题。 设计模式是精心设计的准则，但有时你必须这么做。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 生成器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Swift中重构单例模式用法</title>
      <link href="/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/"/>
      <url>/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>清洁，模块化和可测试代码库的小技巧。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件开发中，不鼓励使用单例，并且对此表示反对，但这是有充分理由的。 它们很难测试或无法测试，并且在其他类中隐式使用它们时会纠缠你的代码库，从而使代码重用变得困难。 在大多数情况下，单例模式无非是对全局易变状态的保存。 每个人至少知道这是一个糟糕的主意。 但是，<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="单例模式">单例模式</a> 有时是不可避免和必要的错误。 我们如何以一种干净，模块化和可测试的方式将它们合并到我们的代码中？</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 </p></blockquote><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p></blockquote><h1 id="单例模式无处不在"><a href="#单例模式无处不在" class="headerlink" title="单例模式无处不在"></a><strong>单例模式无处不在</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 <code>Apple</code> 平台上，<code>Cocoa</code> 和 <code>Cocoa Touch</code> 框架中到处都有单例。 有 <code>UIApplication.shared</code>，<code>FileManager.default</code>，<code>NotificationCenter.default</code>，<code>UserDefaults.standard</code>，<code>URLSession.shared</code> 等。 设计模式甚至在 <code>Cocoa</code> 核心能力指南中都有自己的部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当你隐式引用这些（以及你自己的）单例时，将增加更改代码所需的工作量。 这也使测试代码变得困难或不可能，因为无法从使用它们的类之外更改或模拟这些单例。 这是你在iOS应用中都会看到的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentUser = <span class="type">CurrentUserManager</span>.shared.user</span><br><span class="line">        <span class="keyword">if</span> currentUser != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// do something with current user</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mySetting = <span class="type">UserDefaults</span>.standard.bool(forKey: <span class="string">"mySetting"</span>)</span><br><span class="line">        <span class="keyword">if</span> mySetting &#123;</span><br><span class="line">            <span class="comment">// do something with setting</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">URLSession</span>.shared.dataTask(with: <span class="type">URL</span>(string: <span class="string">"http://someResource"</span>)!) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// handle response</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这就是我所说 隐式引用 的意思-你只需在类中直接使用单例。 我们可以做得更好。 在Swift中，有一种轻量级，简便且影响小的方式来改善这一点。 Swift也使其使用起来更加优雅。</p><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简而言之，答案是 <a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener" title="依赖注入"><strong>依赖注入</strong></a> 。 该原则表明你应该设计类和函数，以使所有输入都是显式的。 如果你重构上面的代码片段以使用依赖项注入，它将看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> userManager: <span class="type">CurrentUserManager</span></span><br><span class="line">    <span class="keyword">let</span> defaults: <span class="type">UserDefaults</span></span><br><span class="line">    <span class="keyword">let</span> urlSession: <span class="type">URLSession</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userManager: <span class="type">CurrentUserManager</span>, defaults: <span class="type">UserDefaults</span>, urlSession: <span class="type">URLSession</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">        <span class="keyword">self</span>.defaults = defaults</span><br><span class="line">        <span class="keyword">self</span>.urlSession = urlSession</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentUser = userManager.user</span><br><span class="line">        <span class="keyword">if</span> currentUser != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// do something with current user</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mySetting = defaults.bool(forKey: <span class="string">"mySetting"</span>)</span><br><span class="line">        <span class="keyword">if</span> mySetting &#123;</span><br><span class="line">            <span class="comment">// do something with setting</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        urlSession.dataTask(with: <span class="type">URL</span>(string: <span class="string">"http://someResource"</span>)!) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// handle response</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此类不再隐式（或显式）依赖于任何单例。 它显式依赖于 <code>CurrentUserManager</code>， <code>UserDefaults</code> 和 <code>URLSession</code> ，但是有关这些依赖项的任何内容均表示它们是单例。 这个细节不再重要，但是功能保持不变。 视图控制器仅知道这些对象的实例存在。 在需要使用该对象时，你可以传递单例。 同样，从类的角度来看，此细节无关紧要。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>(userManager: .shared, defaults: .standard, urlSession: .shared)</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p><strong>特别提示：<code>Swift</code> 类型推断在这里起作用。 除了编写 <code>URLSession.shared</code>，您还可以编写 <code>.shared</code> 。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你需要提供其他默认值（例如，如果你需要与<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW6" target="_blank" rel="noopener" title="应用组内共享数据">应用组共享数据</a>），则更改起来很容易。 实际上，你不必更改此类中的任何代码。 而不传递 <code>UserDefaults.standard</code>，而是传递 <code>UserDefaults（suiteName：“ com.myApp”）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，在单元测试中，你现在可以传递这些类的其他实例。 在Swift中无法进行真正的模拟，但是有一些解决方法。 这取决于您要如何构造代码。 你可以为 <code>CurrentUserManager</code> 使用协议，然后可以在测试中“模拟”该协议。 你可以为 <code>UserDefaults</code> 提供构造的方法类进行测试。 你可以将 <code>URLSession</code> 设置为可选，并在测试中传递 <code>nil</code>。</p><h1 id="重构陷阱"><a href="#重构陷阱" class="headerlink" title="重构陷阱"></a><strong>重构陷阱</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能对这个想法很感兴趣，现在你想解开并解放陷入困境的代码库。尽管依赖注入是理想的选择，并且可以为你提供更纯净的对象模型，但是实现它通常很困难。更重要的是，在首次编写代码时，很少会设计出适应这种情况的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们上面重构的内容现在更具模块化和可测试性-但确实存在问题。 <code>MyViewController</code> 的初始值设定项曾经是空的 <code>（init（））</code> ，但现在需要三个参数。每个调用位置都必须更改。构造此方法的干净而正确的方法是将实例从上到下或从以前的视图控制器传递到此实例。这将需要将数据从对象图的根传递到所有子类。特别是在iOS中，当你将数据从视图控制器传递到视图控制器时，这可能会引起很多麻烦。尤其是传统代码库将难以立即实现如此大的更改。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大多数类（尤其是视图控制器）的初始化程序都需要更改。当你意识到必须重构整个应用程序时，这种更改变得异常困难。要么一切都将被破坏，要么仅某些类将被更新以进行依赖注入，而其他一些类将继续隐式引用单例。这种不一致可能在将来引起问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在复杂、大型的旧版代码库中，这样的重构可能根本不可行-至少不能同时进行，而且也不能没有回归。因此，你可能会争辩说，你根本不应该重构并忍受这种情况。然后需要几个月或几年的时间你您必须支持多个用户-现在在实现切换帐户时 <code>CurrentUserManager</code> 无法正常工作。你如何应对？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一种更为先进的方式，也有一种从一开始就设计你要使用的类以适应下一次此类变化的方法。</p><h1 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a><strong>默认参数值</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最喜欢的Swift功能之一是默认参数值。 它们非常有用，可以为你的代码带来很大的灵活性。 使用默认参数，你可以解决上述问题，而不必担心依赖注入问题，也不会在代码库中引入过多的复杂性。 也许你的应用程序实际上只有一个用户，所以实现所有这种依赖注入是不必要的开销。</p><p>你可以给单例设置默认参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userManager: <span class="type">CurrentUserManager</span> = .shared, defaults: <span class="type">UserDefaults</span> = .standard, urlSession: <span class="type">URLSession</span> = .shared) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">        <span class="keyword">self</span>.defaults = defaults</span><br><span class="line">        <span class="keyword">self</span>.urlSession = urlSession</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，从方法调用的角度来看，初始化程序没有改变。 但是类本身存在很大的差异，它现在使用依赖项注入，不再引用单例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>()</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你从此更改中学到了什么？你可以使用此模式重构每个类，而无需更新任何调用的地方。语义上或功能上都没有改变。但是，你的类也在使用依赖注入。他们只是在内部使用实例。你可以如上所述测试它们并维护一个灵活的模块化API，同时公共接口保持不变。本质上，你可以继续在代码库中工作，就好像什么都没有改变一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有时间传入自定义非空参数，你可以执行此操作而无需更改任何类。你只需要更新调用的位置即可。此外，如果你决定使用成熟的依赖关系注入并从上至下传递每个单个依赖关系，则只需删除默认参数并从上方传递依赖关系。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要，你甚至可以选择加入或选择退出任何默认值。在以下示例中，我们提供了自定义 <code>UserDefaults</code>，但保留了 <code>CurrentUserManager</code> 和 <code>URLSession</code> 的默认参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appGroupDefaults = <span class="type">UserDefaults</span>(suiteName: <span class="string">"com.myApp"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>(defaults: appGroupDefaults)</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></bar><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 使这种“部分”依赖注入变得很方便实用。通过为类添加新属性和带有默认值的初始化参数，你可以使你的代码具有更大的模块化和可测试性，而不必重构，也不必完全使用成熟的依赖项注入。如果从一开始就设计这样的类，那么你会发现自己写出 <code>bug</code> 的概率降低了很多-当你遇到 <code>bug</code> 是，将更容易定位和解决。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 除了此处的简单示例（类，结构，枚举，函数）之外，你还可以将这些概念和设计应用于代码的所有区域。 <code>Swift</code> 中的每个函数都可以采用默认参数值。通过花一些时间来思考未来可能发生的变化，我们可以创建可以轻松适应变化的类型和功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 构建和设计好的软件意味着编写<strong>易于更改</strong>但<strong>难以破解的代码</strong>。这就是依赖项注入的动机，而 <code>Swift</code> 的默认参数可以帮助你快速，轻松且优雅地实现这一目标。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift单例模式</title>
      <link href="/Swift%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Singleto</code>n 是有史以来最受争议的设计模式。了解在 <code>iOS</code> 项目中使用 <code>Swift</code> 单例类的正确方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每个人都在批评的单例模式，大多数人都将其称为反模式。但是单例模式到底是什么，为什么这么差呢？</p><a id="more"></a><h1 id="Singleton-是什么"><a href="#Singleton-是什么" class="headerlink" title="Singleton 是什么?"></a><strong>Singleton 是什么?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于简单，这是一种非常流行且普遍采用的模式。在整个应用程序生命周期中，单例类只能有一个实例。单个实例只能通过静态属性访问，并且初始化后的对象通常在全局范围内共享。这就像一个全局变量。 🌏</p><h1 id="全局变量和状态"><a href="#全局变量和状态" class="headerlink" title="全局变量和状态"></a><strong>全局变量和状态</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式的声誉很差，因为他们共享全局可变的状态。即使在经验丰富的开发人员圈子中，始终会担心使用 <code>global</code> 关键字。全局状态和变量是副作用的温床。可以从程序的任何位置访问全局变量，因此使用它们的类将变为有状态，不安全，紧密耦合且难以调试。出于明显的原因，通过这种方式与对象共享状态不是一个好习惯。 🤮</p><h1 id="Singleton-的副作用"><a href="#Singleton-的副作用" class="headerlink" title="Singleton 的副作用"></a><strong>Singleton 的副作用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你应该尽可能确定范围和隔离变量，并最大程度地减少代码的状态性。这将消除副作用，使您的代码更安全地使用。考虑以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// method is written by someone else</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    global = x</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">global = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> result = square(<span class="number">5</span>)</span><br><span class="line">result += global <span class="comment">//we assume that global is 1</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">//wtf 30 it should be 26</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>square</code> 方法由其他人编写，由于某种原因，他们希望将输入存储在相同的全局变量中。现在，当您调用该函数时，除非您查看他的代码，否则您将一无所获。想象一下，在一个由多个代码作者编写的具有大量oop类的项目中的此类问题……GOOD LUCK! 🐛🐛🐛</p><h1 id="单例对象的生命周期"><a href="#单例对象的生命周期" class="headerlink" title="单例对象的生命周期"></a><strong>单例对象的生命周期</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 单例创建一次并永久存在，它们的工作几乎就像全局变量一样，这就是为什么你必须格外小心。你应该仅使用在应用程序整个生命周期内都能维持的单例状态来管理这些状态。例如，特定于用户的会话通常是不好的做法，你应该重新考虑设计。另外，默认情况下，Swift也不是线程安全的，因此，如果你使用单例，则还必须为多线程问题做好准备。但是，如果它们因此造成问题，我们难道不应该完全避免它们吗？答案是不。 🚫</p><h1 id="我们应该在什么时候使用单例类"><a href="#我们应该在什么时候使用单例类" class="headerlink" title="我们应该在什么时候使用单例类"></a><strong>我们应该在什么时候使用单例类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>UIApplication</code> 很可能是单例的，因为应该只有一个应用程序实例，并且该实例应该一直存在，直到你将其关闭为止。这就是单例的完美例子。另一个用例可以是 <code>Logger</code> 类。使用单例是安全的，因为无论记录器是否打开，你的应用程序的行为都不会有所不同。没有其他人会拥有或管理记录器，并且你只会将信息传递到记录器中，因此状态不会混乱。<strong>结论：对于单例模式的使用，控制台或记录器类是完全可以接受的方案。</strong> 👏</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Console</span>.<span class="keyword">default</span>.notice(<span class="string">"Hello I'm a singleton!"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apple 框架中有很多“单一”（并非一切都是真正的单例对象）用例，这是一个简短列表，因此您可以从中获得一些启发：</p><ul><li>HTTPCookieStorage.shared</li><li>URLCredentialStorage.shared</li><li>URLSessionConfiguration.default</li><li>URLSession.shared</li><li>FileManager.default</li><li>Bundle.main</li><li>UserDefaults.standard</li><li>NotificationCenter.default</li><li>UIScreen.main</li><li>UIDevice.current</li><li>UIApplication.shared</li><li>MPMusicPlayerController.systemMusicPlayer</li><li>GKLocalPlayer.localPlayer（）</li><li>SKPaymentQueue.default（）</li><li>WCSession.default</li><li>CKContainer.default（）</li><li>etc</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经看到许多管理器类以单例形式实现，例如网络，位置或核心数据管理器，但是这些对象通常不应该是单例，仅仅是因为它可以是多个单例。 💩</p><p><strong>单例模式可能非常有用，但应谨慎使用。</strong></p><p>如果要将某个类变成单例，请问自己以下问题：</p><ul><li>还有其他任何东西拥有，管理或负责吗？</li><li>是否将只有一个实例？</li><li>它会是一个全局状态变量吗？</li><li>我真的应该使用全局共享对象吗？</li><li>是否应该贯穿整个应用程序生命周期？</li><li>有其他选择吗？</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果以上所有内容的答案都是肯定的，那么您可以“安全地”使用单例或全局变量来存储数据。 🎉🎉🎉</p><h1 id="如何使用Swift创建一个单例"><a href="#如何使用Swift创建一个单例" class="headerlink" title="如何使用Swift创建一个单例?"></a><strong>如何使用Swift创建一个单例?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建单例对象确实很容易，但是在应用此设计模式之前，请务必三思而后行，并考虑其他选择。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Singleton</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// don't forget to make this private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> singleton = <span class="type">Singleton</span>.shared</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，我总是创建一个特定的单例对象，称为App。通过这种方式，我可以将与应用程序相关的全局状态属性连接到那个单例中。命名约定也有助于关联和理解其中的内容。 💡</p><h1 id="如何消除单例"><a href="#如何消除单例" class="headerlink" title="如何消除单例?"></a><strong>如何消除单例?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果还有其他方法，则应在大约90％的情况下使用该方法。单例模式最常见的替代解决方案是依赖注入。首先，你应该将单例方法抽象为协议，然后，如果仍然需要，可以将其用作默认实现。现在，您可以将单例或<a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/" title="重构对象">重构的对象</a>注入正确的位置。这样，你的代码就可以使用协议的模拟对象进行测试，甚至可以忽略单例本身。 😎</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">DataCompletionBlock</span> = (<span class="type">Data?</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. abstract away the required functions</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. make your "singleton" conform to the protocol</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSession</span>: <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> task = <span class="keyword">self</span>.dataTask(with: request) &#123; data, <span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            completionHandler(data)</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> session: <span class="type">Session</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. using dependency injection with the "singleton" object</span></span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">Session</span> = <span class="type">URLSession</span>.shared) &#123;</span><br><span class="line">        <span class="keyword">self</span>.session = session</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(<span class="number">_</span> request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.session.make(request: request, completionHandler: completionHandler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. create mock object</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockedSession</span>: <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        completionHandler(<span class="string">"Mocked data response"</span>.data(using: .utf8))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. write your tests</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> api = <span class="type">ApiService</span>(session: <span class="type">MockedSession</span>())</span><br><span class="line">    <span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)!)</span><br><span class="line">    api.load(request) &#123; data <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(data: data!, encoding: .utf8)!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像你看到的，单例模式非常容易实现，但是很难决定其应用程序形式。我并不是说这是一种反模式，因为显然不是这样，但是如果你打算使用单例模式，请当心。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSCODER和SWIFT初始化</title>
      <link href="/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您正在使用 <code>Swift</code> 并想对实现 <code>NSCoding</code> 的东西进行子类化（例如 <code>UIView</code>，<code>UIViewController</code> 等），则可能会遇到麻烦的情况。即，<code>NSCoding</code> 协议需要 <code>init(coder：aDecoder)</code> 初始化程序，这意味着如果你为超类重写了指定的初始化程序，则需要实现该初始化程序。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那就好了，但是 <code>Swift</code> 在确保对类的所有属性进行超级严格的调用之前，都要确保在 <code>init()</code> 中分配了一个值。这意味着，如果您想提供自己的初始化程序，则无法执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    name = <span class="string">"Bar"</span></span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle:<span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>init（coder :)</code> 初始值设定项未设置 <code>name</code> 属性，因此不会进行编译。你可以在两个初始值设定项中都重复初始化和设置名称，但是当你在init中进行了很多工作时，这很糟糕（如果希望尽可能避免使用可选属性，则应该这样做）。</p><p>在 Objective-C 中，如果要在多个 <code>init</code> 方法之间共享初始化逻辑，则只需定义一个通用的 <strong>“setup”</strong> 方法即可执行所有共享的东西，并从两个初始化器中调用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype) <span class="keyword">init</span> &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span> <span class="keyword">self</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype) initWithCoder:(<span class="type">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span> <span class="keyword">self</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) setup &#123;</span><br><span class="line">  <span class="keyword">self</span>.name = @<span class="string">"Foo"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  这种方式不会立即就创建出你想要的对象。问题在于，在这两个初始化程序中，我们都在调用    <code>[super init]</code> 之前，先给 <code>self.name</code> 分配了一个值，但这在 <code>Swift</code> 语法中是不可行的。我们也不能将对 <code>self.setup</code> 的调用移到对 <code>super.init（）</code> 的调用之上，因为在类通过调用 <code>super.init（）</code> 完全初始化之后，才允许您引用 <code>self</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  那么，如何将这只鸡从鸡蛋中取出并放到盘子上呢？好吧，我们要等到初始化后才能对 <code>self</code> 调用方法，但是只要我们从 <strong>“convienience”</strong> 初始化程序中调用它，就可以调用另一个 <code>init</code> 。仅通过示例进行解释可能更容易：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> coder: <span class="type">NSCoder?</span> = <span class="literal">nil</span>) &#123;</span><br><span class="line">    name = <span class="string">"Bar"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> coder = coder &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle:<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(coder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在指定的初始化程序中添加了一个可选的 <code>NSCoder</code> 参数，并将其默认设置为 <code>nil</code> ，因此我们仍然可以像以前一样在没有任何参数的情况下调用它。但是，现在已将<code>NSCoding</code> 协议中要求的 <code>init（coder :)</code> 初始值设定项标记为<strong>convienience</strong>，这意味着它可以调用指定的初始值设定项并传入编码器。</p><p>在指定的 <code>init</code> 中，我们检查 <code>coder</code> 是否为非 <code>nil</code> （如果让coder = conditional为条件），如果是，则调用 <code>super.init（coder :)</code> 。如果为 <code>nil</code>，我们将执行本来应该做的事情，并调用 <code>super.init（nibName：nil，bundle：nil）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，编译器很高兴在调用 <code>super.init（）</code> 之前为属性分配值，并且可以将初始化逻辑放在一个地方。如果要在情节提要中使用 <code>ViewController</code> ，则框架将调用init（coder :)，如果要以编程方式创建一个，则可以说 <code>let fooVC = FooViewController（）</code>。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIKit初始化模式</title>
      <link href="/UIKit%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/"/>
      <url>/UIKit%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>了解UIKit中两个常用类的初始化过程。了解UIViewcontroller和UIView初始化模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIKit</code> 是在iOS开发过程中必须也是使用频次最高的一个类库，里面包含了许多与用户直接交互的控件比如：<code>UIView</code>, <code>UITableView</code>, <code>UIScrollView</code> 等。在收到用户交互的设计图之后，我们要合理的使用这些控件，就能编写出交互良好的应用。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了类库中包含的基础控件之外，我们也能够对控件根据业务需要进行整合，也就是设计出一套适用于本公司的组件，提高开发速度。</p><h1 id="UIViewController-初始化"><a href="#UIViewController-初始化" class="headerlink" title="UIViewController 初始化"></a><strong>UIViewController 初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，<code>UIViewController</code> 的初始化非常简单。如果要完全控制，则只需要重写一些方法。这取决于你使用何种方式调用 <code>init</code> ，如果你使用一个 <code>storyboard</code> 初始化控制器，那么 <a href="http://www.xuebaonline.com/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/" title="NSCODER和SWIFT初始化">init(coder)</a> 是你所需要的。如果你尝试从外部 <code>nib</code> 文件启动控制器，则将调用 <code>init（nib，bundle）</code> 。你还有第三个选择，你可以通过代码以编程方式初始化控制器。简而言之，为了进行合理的初始化过程，这是你必须要做的。</p></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍两种 <code>UIViewControllers</code> 的初始化模式，第一种只是一个常见的init函数，在每种情况下都可以调用该函数来初始化控制器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(nibName nibNameOrNil: <span class="type">String?</span>, bundle nibBundleOrNil: <span class="type">Bundle?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do your stuff here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以在之后的子类中隐藏 <code>init（nib，bundle）</code> 和 <code>init（coder）</code> 方法。在子类中不必重写 <code>init（nib，bundle）</code>，并且可以将 <code>init（coder）</code> 标记为默认初始化程序。这个似乎是有点棘手的解决方案，使用起来不是很方便，但确实可以完成 <code>ViewController</code> 的初始化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do your stuff here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFutureViewController</span>: <span class="title">ViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> vc = <span class="type">MyFutureViewController</span>()</span><br></pre></td></tr></table></figure><hr></br><h1 id="UIView-初始化"><a href="#UIView-初始化" class="headerlink" title="UIView 初始化"></a><strong>UIView 初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通常为 <code>UIView</code> 创建一个通用的初始化程序，以使初始化过程更加轻松，使用起来更加方便。还会在该初始值设定项方法中将 <code>translate autoresizing mask</code> 属性设置为 <code>false</code> ，因为它是2017年，没有人再使用 <code>spring＆struts</code> 了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用自动布局助手也很不错，如果你想从nib文件中初始化视图，那么有一些便利的方法也很好。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(autolayout: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(autolayout: Bool = <span class="literal">true</span>)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _self = <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">let</span> view  = _self <span class="keyword">as</span> <span class="type">UIView</span></span><br><span class="line">        view.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">        <span class="keyword">return</span> _self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">createFromNib</span><span class="params">(owner: <span class="keyword">Any</span>? = <span class="literal">nil</span>, options: [AnyHashable: <span class="keyword">Any</span>]? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Bundle</span>.main.loadNibNamed(<span class="type">String</span>(describing: <span class="keyword">self</span>), owner: owner, options: options)?.last <span class="keyword">as</span>! <span class="type">UIView</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> view = <span class="type">UIView</span>(autolayout: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>使用这些代码片段，为所有 <code>UIKit</code> 类维护一个合理的初始化过程确实很容易，因为其中大多数都是从这两个 “主要” 类派生的。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端实践三:Ubuntu18.04安装Vapor4.0</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89:Ubuntu18.04%E5%AE%89%E8%A3%85Vapor4.0/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89:Ubuntu18.04%E5%AE%89%E8%A3%85Vapor4.0/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文章《<a href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/" title="后端实践二:Ubuntu18.04安装最新版Swift5.2">后端实践二:Ubuntu18.04安装最新版Swift5.2</a>》可以在 Ubuntu18.04 的服务器上顺利安装最新版本的 <code>Swift</code> 。我们参照 <a href="https://docs.vapor.codes/3.0/install/ubuntu/" target="_blank" rel="noopener">官网文档</a> 安装 <code>Vapor4.0</code> 的开发环境。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官网上的文档跟开发维护的速度有一定的版本误差，所以现在在官网上看到的安装方法是针对 <code>Vapor(&gt;3.0 &amp;&amp; &lt; 4.0)</code> 的版本。由于版本间差异比较大，在实践过程中，只会关注到 <code>Vapor(&gt;=4.0)</code> 以上版本的新特性。在创建工程和引入依赖库的过程中也会出现微小的差别，我们在后续的实践中会总结到。</p></blockquote><h1 id="验证-Swift-安装"><a href="#验证-Swift-安装" class="headerlink" title="验证 Swift 安装"></a><strong>验证 Swift 安装</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过访问 <code>Swift.org</code>，可以得到一份如何在 <code>Linux</code> 上安装 <code>Swift</code> 的文档。我们完成对 <code>Swift</code> 的安装之后，在终端中输入如下命令：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><a id="more"></a><p>如果在终端中输出如下信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Apple</span> <span class="type">Swift</span> version <span class="number">4.1</span>.<span class="number">0</span> (swiftlang-<span class="number">900.0</span>.<span class="number">69.2</span> clang-<span class="number">900.0</span>.<span class="number">38</span>)</span><br><span class="line"><span class="type">Target</span>: x86_64-apple-macosx10.<span class="number">9</span></span><br></pre></td></tr></table></figure><p>那么标识我们在 <code>Linux</code> 上成功安装 <code>Swift</code>。</p><h1 id="安装-Vapor-Toolbox"><a href="#安装-Vapor-Toolbox" class="headerlink" title="安装 Vapor Toolbox"></a><strong>安装 Vapor Toolbox</strong></h1><p>在 <code>Vapor 4.0</code> 发布之前，在 <code>Linux</code> 上安装，只需要在终端中敲入如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL apt.vapor.sh -o apt.vapor.sh</span><br></pre></td></tr></table></figure><p>这个执行安装的命令已经被废弃。</p><h2 id="Toolbox-源代码"><a href="#Toolbox-源代码" class="headerlink" title="Toolbox 源代码"></a><code>Toolbox</code> 源代码</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于之后的版本中，不在将该文件托管至软件源，所以我们在安装时需要做出如下操作获取到 <code>Toolbox</code> 源代码到本地文件夹中：</p><p>下载 <code>Toolbox</code> 源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vapor/toolbox.git</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-1stp.png" alt="Toolbox"></p><h2 id="编译-Vapor-可执行文件"><a href="#编译-Vapor-可执行文件" class="headerlink" title="编译 Vapor 可执行文件"></a>编译 <code>Vapor</code> 可执行文件</h2><p>进入到 <code>Toolbox</code> 工程的根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> toolbox/</span><br></pre></td></tr></table></figure><p>编译 <code>Toolbox</code>  发布版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build -<span class="built_in">c</span> release</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于获取的源代码中缺少部分文件，期间或存在报错发现 <code>Toolbox</code> 中没有 <code>LinuxMain.swift</code> 文件在 <code>Tests</code> 文件夹中，这时我们进入到 <code>XCTest</code> 文件夹中。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-2stp.png" alt="Vapor"></p><p>创建 <code>LinuxMain.swift</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch LinuxMain.swift</span><br></pre></td></tr></table></figure><p>编辑 <code>LinuxMain.swift</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim LinuxMain.swift</span><br></pre></td></tr></table></figure><p>向 <code>LinuxMain.swift</code> 文件中添加测试代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> AppTests</span><br><span class="line"></span><br><span class="line"><span class="type">XCTMain</span>([testCase(<span class="type">AppTests</span>.allTests)])</span><br></pre></td></tr></table></figure><p>保存修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq!</span><br></pre></td></tr></table></figure><p>重新执行如下命令，完成编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build -c release</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-3stp.png" alt="Vapor"></p><p>找到编译成功的 <code>Vapor</code> 文件</p><blockquote><p>执行完 <code>build</code> 命令之后，会在输出的文件中生成一个可执行的二进制文件。</p></blockquote><p>查找 <code>Vapor</code> 所在的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name vapor</span><br></pre></td></tr></table></figure><blockquote><p>这时会看到输出一个类似如下的文件夹 <code>.build/x86_64-unknown-linux/release/vapor</code> ,这个文件夹里就是我们要使用到的文件 <code>Vapor</code> 。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-4stp.png" alt="Vapor"></p><p>配置 <code>Vapor</code> 的环境变量</p><p>将包含可执行文件 <code>Vapor</code> 的文件目录添加在 <code>PATH</code> 中。</p><p>配置 <code>Vapor</code> 环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp vapor /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>验证是否配置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vapor --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-5stp.png" alt="Vaporhelp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此 <code>Vapor 4.0</code> 的环境配置已经完成。由于 <code>3.0</code> 和 <code>4.0</code> 版本差异比较大，在配置方面也有差异。在创建项目时更需要加上 <code>branch=4</code> 等。后续会加入：创建第一个 <code>Hello World</code> 工程。</p>]]></content>
      
      
      <categories>
          
          <category> Server </category>
          
          <category> Vapor4.0 </category>
          
          <category> Ubuntu18.04 </category>
          
          <category> Swift5.2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Server </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端实践二:Ubuntu18.04安装最新版Swift5.2</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文章《<a href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/" title="后端实践一:开发环境搭建VMware下安装Ubuntu18.04">后端实践一:开发环境搭建VMware下安装Ubuntu18.04</a>》可以完成在  <code>mac</code> 上搭建起可用的 <code>Ubuntu 18.04</code> 的服务器。接下来我们要在此基础上完善 <code>Vapor 4.0</code> 的开发环境。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ubuntu 18.04 安装 Swift 5.2.2 ，可在 Vapor 官网的引导完成。这篇文章就是讲解如何完成在 Ubuntu 上安装最新版本 Swift，构建出一个强大的云端服务器。</p></blockquote><h1 id="Ubuntu-系统环境搭建"><a href="#Ubuntu-系统环境搭建" class="headerlink" title="Ubuntu 系统环境搭建"></a><strong><code>Ubuntu</code> 系统环境搭建</strong></h1><h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里使用的SecureCRT作为终端连接服务器，也可以使用 <code>iTerm2</code> 连接服务器。</p></blockquote><a id="more"></a><p>使用 <code>SecureCRT</code> 提供的远程登录功能连接 <code>Ubuntu</code> 服务器的配置信息：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-1stop.png" alt="SecureCRT"></p><p>使用 <code>SecureCRT</code> 终端使用系统自带的远程登录功能连接 <code>Ubuntu</code> 服务器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-2stp.png" alt="使用SecureCRT"></p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-3stp.png" alt="使用SecureCRT"></p><p>使用 <code>iTerm2</code> 终端使用系统自带的远程登录功能连接Ubuntu 服务器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-4stp.png" alt="iTerm2"></p><p>查看当前服务器系统版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><blockquote><p>Swift 依赖一些三方类库。</p></blockquote><p>必须安装的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install clang libicu-dev -y</span><br><span class="line">sudo apt-get install libcurl3 libpython2.7 libpython2.7-dev</span><br></pre></td></tr></table></figure><h2 id="安装-Swift"><a href="#安装-Swift" class="headerlink" title="安装 Swift"></a>安装 <code>Swift</code></h2><p>在 <a href="https://swift.org/download/#releases" target="_blank" rel="noopener">Swift.org</a> 查找我们要安装的Swift对应版本的Toolchain，复制下载链接。</p><blockquote><p>在写这篇文章时最新版的Swift是v5.2.2。</p></blockquote><p>找到对应系统以及对应版本<a href="https://swift.org/builds/swift-5.2.2-release/ubuntu1804/swift-5.2.2-RELEASE/swift-5.2.2-RELEASE-ubuntu18.04.tar.gz" target="_blank" rel="noopener">下载链接</a>：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-5stp.png" alt="下载链接"></p><p>可以采用两种下载方式：</p><ul><li>在本机上使用上方链接，下载 <code>Toolchain</code> ，上传到 <code>Ubuntu</code> 服务器上，完成后续安装；</li><li>在 <code>Ubuntu</code> 上使用 <code>wget url</code> 的方式直接在服务器上安装。</li></ul><p>接下来 使用  <code>wget url</code> 下载 <code>swift</code> 安装包，并解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://swift.org/builds/swift-5.2.2-release/ubuntu1804/swift-5.2.2-RELEASE/swift-5.2.2-RELEASE-ubuntu18.04.tar.gz</span><br></pre></td></tr></table></figure><p>解压 <code>swift</code> 到文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf swift-5.2.2-RELEASE-ubuntu18.04.tar.gz</span><br></pre></td></tr></table></figure><p>将解压的文件保存在 <code>share</code> 目录下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv swift-5.2.2-RELEASE-ubuntu18.04 /usr/share/swift</span><br></pre></td></tr></table></figure><h2 id="配置-Swift-环境变量"><a href="#配置-Swift-环境变量" class="headerlink" title="配置 Swift 环境变量"></a>配置 <code>Swift</code> 环境变量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成以上操作即完成了 <code>swift</code> 的的安装，为了更方便的使用 <code>Swift</code> ，需要配置其在全局任意目录下可使用。</p><p>配置 <code>Swift</code> 环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=/usr/share/swift/usr/bin:<span class="variable">$PATH</span>"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h2><p>检查当前系统的 <code>Swift</code> 版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift -version</span><br></pre></td></tr></table></figure><ul><li>如果出现 <code>Command &#39;swift&#39; not found ...</code> 该提示，关闭连接终端，重新连接服务器，再次执行上述命令。</li></ul><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-6stp.png" alt="installSuccess"></p><h1 id="运行-Swift-程序"><a href="#运行-Swift-程序" class="headerlink" title="运行 Swift 程序"></a><strong>运行 <code>Swift</code> 程序</strong></h1><h2 id="在终端运行程序，简单测试环境是否达建成功。"><a href="#在终端运行程序，简单测试环境是否达建成功。" class="headerlink" title="在终端运行程序，简单测试环境是否达建成功。"></a>在终端运行程序，简单测试环境是否达建成功。</h2><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift</span><br></pre></td></tr></table></figure><p>此时进入到终端界面。</p><p>编辑一段 <code>Swift</code> 程序代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>, b = <span class="number">13</span>, <span class="built_in">c</span> = a + b</span><br></pre></td></tr></table></figure><p>在终端输入以下命令退出编辑模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:exit</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-7stp.png" alt="Swift"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成 <code>Swift</code> 在 <code>Ubuntu</code> 环境下的配置，接下来可以配置 <code>Vapor 4.0</code> 的开发环境。</p>]]></content>
      
      
      <categories>
          
          <category> Server </category>
          
          <category> Vapor4.0 </category>
          
          <category> Ubuntu18.04 </category>
          
          <category> Swift5.2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Server </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04替换国内源</title>
      <link href="/Ubuntu18.04%E6%9B%BF%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"/>
      <url>/Ubuntu18.04%E6%9B%BF%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再国内使用国外的软件源普遍会比较慢，但是国内也有很多的软件源可供选择。在修改软件源之前，查看系统软件源版本：</p><p><strong><em>查看版本：</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -c</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong><em>备份系统源配置文件：</em></strong></p><p>在修改之前要对系统的配置文件做好备份，这是个好习惯。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h1 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a><strong>阿里源</strong></h1><h2 id="更新源的配置文件"><a href="#更新源的配置文件" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multivers</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a><strong>中科大源</strong></h1><h2 id="更新源的配置文件-1"><a href="#更新源的配置文件-1" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="163源"><a href="#163源" class="headerlink" title="163源"></a><strong>163源</strong></h1><h2 id="更新源的配置文件-2"><a href="#更新源的配置文件-2" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-2"><a href="#更新-2" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a><strong>清华源</strong></h1><h2 id="更新源的配置文件-3"><a href="#更新源的配置文件-3" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-3"><a href="#更新-3" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Ubuntu18.04的配置中，更新了系统的软件源，国内源推荐使用清华源。</p>]]></content>
      
      
      <categories>
          
          <category> Server </category>
          
          <category> Vapor4.0 </category>
          
          <category> Ubuntu18.04 </category>
          
          <category> Ubuntu软件源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端实践一:开发环境搭建VMware下安装Ubuntu18.04</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Mac</code> 环境下使用 <code>VMware</code> 安装 <code>Ubuntu 18.04</code> 的主要目的是用于对后端开发框架：<code>Vapor 4.0</code> 的实践。由于 <code>Vapor 4.0</code> 框架支持 <code>MacOS</code> 和 <code>Ubuntu</code> ，所以实践时间，以使用 <code>Ubuntu</code> 为主。</p><a id="more"></a><blockquote><p>VMware  的下载和安装这里就不在赘述，自行下载安装即可。</p></blockquote><h1 id="下载-Ubuntu-的-ISO-文件"><a href="#下载-Ubuntu-的-ISO-文件" class="headerlink" title="下载 Ubuntu 的 ISO 文件"></a><strong>下载 <code>Ubuntu</code> 的 <code>ISO</code> 文件</strong></h1><h2 id="国内有很多镜像源，这里选用网易的镜像源。"><a href="#国内有很多镜像源，这里选用网易的镜像源。" class="headerlink" title="国内有很多镜像源，这里选用网易的镜像源。"></a>国内有很多镜像源，这里选用<a href="http://mirrors.163.com/ubuntu-releases/" target="_blank" rel="noopener" title="网易的镜像源">网易的镜像源</a>。</h2><p>这里建议使用 <code>Ubuntu 18.04</code> 版本，按照图示下载即可。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/163-source.png" alt="网易镜像源"></p><p>本次安装中使用的镜像为：<a href="http://mirrors.163.com/ubuntu-releases/18.04/ubuntu-18.04.4-live-server-amd64.iso" target="_blank" rel="noopener" title="Ubuntu18.04"><code>ubuntu-18.04.4-live-server-amd64.iso</code></a>。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/Ubuntu-1804-server.png" alt="Ubuntu1804"></p><h1 id="VMware-虚拟机配置"><a href="#VMware-虚拟机配置" class="headerlink" title="VMware 虚拟机配置"></a><strong><code>VMware</code> 虚拟机配置</strong></h1><p>在使用 <code>VMware</code> 安装 <code>Ubuntu</code>虚拟机时，按照引导安装即可。</p><h2 id="打开-VMware-软件"><a href="#打开-VMware-软件" class="headerlink" title="打开 VMware 软件"></a>打开 <code>VMware</code> 软件</h2><blockquote><p>根据提示我们在准备安装时，选择<strong>自定义安装</strong>。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-1stp.png" alt="自定义安装"></p><h2 id="选择虚拟的操作系统"><a href="#选择虚拟的操作系统" class="headerlink" title="选择虚拟的操作系统"></a>选择虚拟的操作系统</h2><p>这里选择 <code>Linux</code> -&gt; <code>Ubuntu</code> 64位。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们下载的系统就是 <code>Ubuntu 18.04</code> 64位。还有很重要的一点，因为安装这个操作系统的目的是作为 <code>Vapor 4.0</code> 的服务器，所以在选用操作系统时，我们不需要图形界面。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-2stp.png" alt="选择操作系统类型"></p><h2 id="选择固件类型"><a href="#选择固件类型" class="headerlink" title="选择固件类型"></a>选择固件类型</h2><p>选择固件类型其实就是选择磁盘引导方式。</p><blockquote><p>相对这两种方式进一步了解，可自行查资料。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-3stp.png" alt="选择引导方式"></p><h2 id="选择虚拟磁盘"><a href="#选择虚拟磁盘" class="headerlink" title="选择虚拟磁盘"></a>选择虚拟磁盘</h2><p>选择虚拟磁盘为虚拟操作系统在本机上开辟操作磁盘的空间。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为不会再虚拟机上做比较大的文件操作， <code>20G</code> 的磁盘空间已经够用。在开辟磁盘空间时，开辟的是空间使用上限，在虚拟操作系统文件所占用的空间以实际使用为准，并不是开辟了多少，就是用多少。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-4stp.png" alt="选择虚拟磁盘"></p><h2 id="完成配置"><a href="#完成配置" class="headerlink" title="完成配置"></a>完成配置</h2><p>点击继续即可完成虚拟机配置。</p><blockquote><p>虚拟机配置采用 <code>VMWare</code> 提供的默认配置即可，不用过多的操作。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-5stp.png" alt="完成配置"></p><h2 id="保存虚拟机文件"><a href="#保存虚拟机文件" class="headerlink" title="保存虚拟机文件"></a>保存虚拟机文件</h2><p>点击保存将虚拟机文件保存在默认文件夹中。</p><blockquote><p>文件的保存位置可以是默认位置，也可以是自定义的位置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-6stp.png" alt="完成配置"></p><h1 id="安装-Ubuntu-18-04"><a href="#安装-Ubuntu-18-04" class="headerlink" title="安装 Ubuntu 18.04"></a><strong>安装 <code>Ubuntu 18.04</code></strong></h1><p>在使用 <code>VMware</code> 完成对 <code>Ubuntu</code>虚拟机配置时，即会进入系统的安装界面。</p><h2 id="开启-CD-DVD-，并选取镜像"><a href="#开启-CD-DVD-，并选取镜像" class="headerlink" title="开启 CD/DVD ，并选取镜像"></a>开启 <code>CD/DVD</code> ，并选取镜像</h2><p>在完成对虚拟机配置之后，进入到引导界面，开启 <code>CD/DVD</code> ，并加载镜像。</p><blockquote><p>因为启动时未加载系统镜像，所在期初会出现引导出错的问题。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-7stp.png" alt="引导失败"></p><blockquote><p>开启CD/DVD，并加载镜像。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-8stp.png" alt="加载镜像"></p><h2 id="选择系统引导语言"><a href="#选择系统引导语言" class="headerlink" title="选择系统引导语言"></a>选择系统引导语言</h2><p>镜像加载完成，选择系统引导语言的默认语言。</p><blockquote><p>安装系统的提示比较简单，也见名知意，所以在安装的全过程，我们均会使用英文完成安装。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-9stp.png" alt="选择系统引导语言"></p><h2 id="选择系统语言"><a href="#选择系统语言" class="headerlink" title="选择系统语言"></a>选择系统语言</h2><p>镜像加载完成，选择操作系统的默认语言。</p><blockquote><p>因为是作为服务器使用，为了避免以后因为字符编码上造成不必要的麻烦，这里选择英文。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-10stp.png" alt="选择系统语言"></p><h2 id="选择键盘布局"><a href="#选择键盘布局" class="headerlink" title="选择键盘布局"></a>选择键盘布局</h2><p>选择键盘布局默认选择英文键盘。</p><blockquote><p>键盘布局选择英文，大部分的笔记本、台式电脑键盘采用英文布局。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-11stp.png" alt="选择键盘布局"></p><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>网络设置主要是设置操作系统的网络链接方式，这里采用默认跟随本机网络变化。</p><blockquote><p>因为是在虚拟软件中使用操作系统，网络配置采用默认配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-12stp.png" alt="网络设置"></p><h2 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h2><p>系统需要一个代理接口联网，默认网络链接走本机。</p><blockquote><p>代理网络可以设置链接特定的网络中，比如公司内网。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-13stp.png" alt="代理设置"></p><h2 id="设置系统镜像"><a href="#设置系统镜像" class="headerlink" title="设置系统镜像"></a>设置系统镜像</h2><p>这里的镜像是软件包的镜像源。</p><blockquote><p>在安装的过程中使用默认的软件包镜像源，后续推荐替换的国内镜像。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-14stp.png" alt="设置系统镜像"></p><h2 id="设置文件系统"><a href="#设置文件系统" class="headerlink" title="设置文件系统"></a>设置文件系统</h2><p>文件系统设置采用默认设置。</p><blockquote><p>选取使用整个磁盘空间。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-15stp.png" alt="设置文件系统"></p><blockquote><p>文件系统采用系统推荐的默认方式配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-16stp.png" alt="设置文件系统"></p><blockquote><p>文件系统分区采用默认的分区方式。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-17stp.png" alt="设置文件系统"></p><h2 id="个人信息设置"><a href="#个人信息设置" class="headerlink" title="个人信息设置"></a>个人信息设置</h2><p>个人信息设置主要是设置 <code>root</code> 账户密码，服务器名称，登录账户及密码。</p><blockquote><p>完成设置信息之后，建议对该信息进行备份保存。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-18stp.png" alt="个人信息设置"></p><h2 id="OpenSSH-设置"><a href="#OpenSSH-设置" class="headerlink" title="OpenSSH 设置"></a><code>OpenSSH</code> 设置</h2><p>OpenSSH可是系统支持远程登录，远程操作。</p><blockquote><p>建议安装，在以后的操作中会比较方便，远程操作软件推荐 <code>SecureCRT</code> 。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-19stp.png" alt="OpenSSH设置"></p><h2 id="服务软件"><a href="#服务软件" class="headerlink" title="服务软件"></a>服务软件</h2><p>这里可以选择性的安装。</p><blockquote><p>针对自己想用的软件进行安装，建议用到什么安装什么。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-20stp.png" alt="服务软件一览"></p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>完成所有的配置之后，系统机会进入安装界面，安装过程比较久。</p><blockquote><p>系统安装时间会长一些，具体看各自电脑配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-21stp.png" alt="安装系统"></p><h1 id="登录-Ubuntu18-04"><a href="#登录-Ubuntu18-04" class="headerlink" title="登录 Ubuntu18.04"></a><strong>登录 <code>Ubuntu18.04</code></strong></h1><p>完成安装之后，系统就会进入终端，输入用户名和密码进入系统。</p><h2 id="输入用户信息"><a href="#输入用户信息" class="headerlink" title="输入用户信息"></a>输入用户信息</h2><p>输入用户名和密码，按照提示输入。</p><blockquote><p>在 <code>2.9</code> 中的用户信息，就是需要的登录信息。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-22stp.png" alt="输入用户信息"></p><blockquote><p>成功进入 <code>Ubuntu</code> 系统中。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-23stp.png" alt="输入用户信息"></p><h1 id="Ubuntu-18-04-个性化配置"><a href="#Ubuntu-18-04-个性化配置" class="headerlink" title="Ubuntu 18.04 个性化配置"></a><strong><code>Ubuntu 18.04</code> 个性化配置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后续会加入一些实用的小技巧：国内的软件源，远程登录、配置数据库、安装 <code>Vapor 4.0</code> 开发环境等。</p>]]></content>
      
      
      <categories>
          
          <category> Server </category>
          
          <category> Vapor4.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
