<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Advanced Swift系列(一): Swift 简介</title>
      <link href="/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%80):%20Swift%20%E7%AE%80%E4%BB%8B/"/>
      <url>/Advanced%20Swift%E7%B3%BB%E5%88%97(%E4%B8%80):%20Swift%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Advanced Swift</code> 是一本书的大胆标题，所以也许我们应该从它的意思开始。</p><p>当我们开始编写本书的第一版时， <code>Swift</code> 才刚满一岁。我们是在2.0版Beta发布之前这样做的-尽管只是暂时的，因为我们怀疑该语言在进入第二年后会继续发展。很少有语言（也许没有其他语言）被如此众多的开发人员如此迅速地采用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这给人们留下了未解之谜。你如何编写“惯用”  <code>Swift</code> ？有正确的方法来做某些事情吗？标准库提供了一些线索，但是即使随着时间的推移，它也发生了变化，删除了一些约定并采用了其他约定。自从将近五年前 <code>Swift</code> 推出以来， <code>Swift</code> 取得了长足的发展，并且变得更加清晰。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于来自另一种语言的人， Swift 可以使他们喜欢他们所选择的语言。低级位扭曲看起来可能与C非常相似（并且可以与C一样性能），但是没有许多未定义的行为陷阱。  <code>Rubyists</code> 熟悉 <code>map</code> 或 <code>lter</code> 的轻量级 <code>尾随闭包语法</code> 。  <code>Swift泛型</code> 类似于 <code>C++模板</code> ，但是具有类型约束，以确保泛型函数在定义时（而不是在使用时）是正确的。高阶函数的灵活性和运算符重载意味着你​​可以编写与 <code>Haskell</code> 或 <code>F＃</code> 风格相似的代码。  <code>@objc</code> 和 <code>dynamic</code> 关键字允许你以与 <code>Objective-C</code> 相同的方式使用选择器和运行时动态性。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到这些相似之处，很容易采用其他语言的习惯用法。恰当的例子： <code>Objective-C</code> 示例项目几乎可以机械地移植到 <code>Swift</code> 。  <code>Java</code> 或 <code>C＃设计模式</code> 以及大多数功能编程模式也是如此。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是随之而来的是沮丧。为什么我们不能将 协议扩展 与相关类型（如Java中的接口）一起使用？为什么数组不像我们期望的那样协变？为什么我们不能写 <code>“ functor”</code> ？有时答案是因为有关  <code>Swift</code> 的部分尚未实现。但是更常见的是，这是因为有一种类似 <code>Swift</code> 的方式来完成你想做的事情，或者是因为你认为 <code>Swift</code> 功能实际上与其他语言中的等效功能实际上并不完全一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 是一种复杂的语言-大多数编程语言都是。但这很好地掩盖了这种复杂性。你可以在 <code>Swift</code> 中启动并运行开发应用程序，而无需了解 <code>泛型</code> 或 <code>重载</code> 或 <code>静态</code> 和 <code>动态调度</code> 之间的区别。你当然可以使用 <code>Swift</code> ，而无需调用 <code>C库</code> 或编写自己的集合类型，但是过了一会儿，我们认为你有必要了解<br>这些事情-是提高代码的性能，还是使其更优雅或更富表现力，或者仅仅是为了完成某些事情。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本书旨在进一步了解这些功能。我们打算回答许多“我该怎么做？”或“为什么Swift会那样表现？”我们在各种论坛上反复提出的问题。希望，一旦你阅读了我们的书，你将从了解语言的基础到了解许多高级功能以及对 <code>Swift</code> 的工作原理有更好的了解。熟悉所提供的材料可能是必要的，即使不够用，也要称自己为 <code>高级Swift程序员</code> 。</p></br><h1 id="这本书是给谁的？"><a href="#这本书是给谁的？" class="headerlink" title="这本书是给谁的？"></a><strong>这本书是给谁的？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本书面向有经验的（尽管不一定是专家） 程序员 ，例如现有的 <code>Apple平台开发人员</code> 。这也适用于那些来自其他语言（例如 <code>Java</code> 或 <code>C++</code> ）的人，他们希望将自己对 <code>Swift</code> 的知识提高到与“入门”语言相同的水平。此外，它适合刚开始使用 <code>Swift</code> 并熟悉基础知识并希望将其提升到新水平的新程序员。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这本书并不是要介绍 <code>Swift</code> 。假定你熟悉该语言的语法和结构。如果你希望对 <code>Swift</code> 的基础知识有一个很好的紧凑介绍，最好的资料是 <code>Apple Swift官方</code> 书（可在iBooks或Apple的网站上找到）。如果你已经是一名自信的程序员，则可以尝试同时阅读我们的书和Apple Swift书。<br>这也不是有关为macOS或iOS设备编程的书。当然，由于 <code>Swift</code> 在Apple平台上的开发用途很多，因此我们尝试提供一些实际使用的示例，但我们希望这本书对非Apple平台的程序员也有用。本书中的绝大多数示例在其他操作系统上应保持不变。那些根本不与Apple平台相关联的（因为它们使用iOS框架或依赖于Objective-C运行时），或者只需要很小的更改。从个人经验可以说， <code>Swift</code> 是编写运行在 <code>Linux</code> 上的服务器应用程序的绝佳语言，过去几年来，生态系统和社区不断发展，使之成为可行的选择。</p></br><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a><strong>主题</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本书的组织方式使每一章都涵盖一个特定的概念。关于一些基本的基本概念（例如，可选参数和字符串），有深入的章节，同时还深入探讨了诸如C互操作性之类的主题。但是在整本书中，希望有一些关于Swift的主题出现：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em><code>Swift</code> 桥接了多个抽象级别。</em></strong>  <code>Swift</code> 是一种高级语言，它允许你使用 <code>map</code> 和 <code>reduce</code> 来编写与 <code>Ruby</code> 和 <code>Python</code> 类似的代码，并轻松编写自己的高阶函数。  <code>Swift</code> 还允许你编写快速代码，这些代码可以直接编译为本机二进制文件，其性能类似于用 <code>C语言</code> 编写的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们兴奋的是，我们最欣赏的 <code>Swift</code> 方面是，你能够同时做这两项事情。将闭包表达式映射到数组上将编译为与循环访问连续内存块相同的汇编代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，要充分利用此功能，你需要了解一些事情。例如，对 <code>结构</code> 和 <code>类</code> 的差异有所了解，或者对 <code>动态</code> 和 <code>静态方法</code> 分配之间的区别有所了解，将使你受益（稍后我们将更深入地讨论诸如此类的主题）。而且，如果你需要降到较低的抽象层次并直接操作指针， <code>Swift</code> 也可以使你做到这一点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 是一种 <code>多范式语言</code> 。你可以使用它来使用不可变值编写面向对象的代码或纯函数代码，也可以使用指针算法编写类似 <code>C</code> 的 <code>命令式代码</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这既是福也是祸。太好了，因为你有很多可用的工具，而且你不必被迫以一种方式编写代码。但这也使你面临用 <code>Swift</code> 编写 <code>Java</code> 或 <code>C</code> 或 <code>Objective-C</code> 的风险。</p><figure class="highlight plain"><figcaption><span>仍然可以使用 ```Objective-C``` 的大多数功能，包括 ```消息发送``` ， ```运行时类型识别``` 和 ```键值观察``` 。但是 ```Swift``` 引入了许多在 ```Objective-C``` 中不可用的功能。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;著名的编程语言专家 &#96;&#96;&#96;Erik Meijer&#96;&#96;&#96; 在2015年10月发布了以下推文：</span><br><span class="line">&gt; 在这一点上，&#96;&#96;&#96;@SwiftLang&#96;&#96;&#96; 可能是比 &#96;&#96;&#96;Haskell&#96;&#96;&#96; 更好，更有价值的学习 &#96;&#96;&#96;函数式编程&#96;&#96;&#96; 的工具。</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#96;&#96;&#96;Swift&#96;&#96;&#96; 通过使用 &#96;&#96;&#96;泛型&#96;&#96;&#96; ， &#96;&#96;&#96;协议&#96;&#96;&#96; ， &#96;&#96;&#96;值类型&#96;&#96;&#96; 和 &#96;&#96;&#96;闭包&#96;&#96;&#96; ，很好地介绍了一种更具功能性的编程风格。 甚至可以使用它来编写将 &#96;&#96;&#96;函数组合&#96;&#96;&#96; 在一起的 &#96;&#96;&#96;运算符&#96;&#96;&#96; 。 也就是说， &#96;&#96;&#96;Swift社区&#96;&#96;&#96; 中的大多数人似乎更喜欢命令式风格，同时融入了源于 &#96;&#96;&#96;函数式编程&#96;&#96;&#96; 的模式。  &#96;&#96;&#96;Swift&#96;&#96;&#96; 的 &#96;&#96;&#96;值类型&#96;&#96;&#96; &#96;&#96;&#96;可变性&#96;&#96;&#96; 概念及其 &#96;&#96;&#96;错误处理模型&#96;&#96;&#96; 是友好的命令式语法背后的语言“隐藏”功能概念的示例。</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#96;&#96;&#96;Swift&#96;&#96;&#96; 非常灵活。 在《关于Lisp的书》的简介中，Paul Graham写道：</span><br><span class="line"></span><br><span class="line">&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;经验丰富的 &#96;&#96;&#96;Lisp程序员&#96;&#96;&#96; 对程序进行了不同的划分。 除自上而下的设计外，它们还遵循可称为自下而上的设计的原则-更改语言以适应问题。 在 &#96;&#96;&#96;Lisp&#96;&#96;&#96; 中，你不仅要按照语言编写程序，还要按照程序编写语言。 在编写程序时，你可能会想“我希望Lisp拥有这样的运算符。” 所以你去写吧。 之后，你意识到使用 &#96;&#96;&#96;new运算符&#96;&#96;&#96; 将简化程序另一部分的设计，依此类推。 语言和程序一起发展。</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#96;&#96;&#96;Swift&#96;&#96;&#96; 与 &#96;&#96;&#96;Lisp&#96;&#96;&#96; 有很大的不同。但是，我们仍然感觉到 &#96;&#96;&#96;Swift&#96;&#96;&#96; 也具有鼓励“自下而上”编程的特征-简化编写非常通用的 可重用构建基块 ，然后将其组合成更大的功能，然后将其用于解决实际问题的特性。  &#96;&#96;&#96;Swift&#96;&#96;&#96; 特别擅长使这些构建基块看起来像原始语言，就像语言的一部分一样。这方面的一个很好的证明是，你可能认为许多基本功能（例如可选功能或基本运算符）的功能实际上是在库中定义的- &#96;&#96;&#96;Swift标准库&#96;&#96;&#96; -而不是直接在语言中定义。 尾随闭包 使你可以使用内置的功能扩展语言。</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#96;&#96;&#96;Swift&#96;&#96;&#96; 代码可以紧凑而简洁，同时仍然清晰。  &#96;&#96;&#96;Swift&#96;&#96;&#96; 使自己适合相对简洁的代码。这里有一个潜在的目标，那就是不能节省打字。这个想法是为了更快地解决问题，并通过删除很多</span><br><span class="line">在其他语言中，你经常看到的“典范”样板模糊而不是澄清了代码的含义。</span><br><span class="line">例如， &#96;&#96;&#96;类型推论&#96;&#96;&#96; 消除了从上下文显而易见的类型声明的混乱情况。没有什么价值的分号和括号都消失了。 &#96;&#96;&#96;泛型&#96;&#96;&#96; 和 &#96;&#96;&#96;协议扩展&#96;&#96;&#96; 鼓励你通过将常见操作打包到 &#96;&#96;&#96;可重用函数&#96;&#96;&#96; 中来避免重复。目的是一眼就能看懂代码。</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先，这可能会令人反感。如果你从未使用过 &#96;&#96;&#96;map&#96;&#96;&#96; ， &#96;&#96;&#96;maplter&#96;&#96;&#96; 和 &#96;&#96;&#96;reduce&#96;&#96;&#96; 之类的 &#96;&#96;&#96;函数&#96;&#96;&#96; ，那么它们可能比简单的 &#96;&#96;&#96;for循环难读&#96;&#96;&#96; 。但是我们希望这是一条短暂的学习曲线，而回报是代码，它可以带来更多</span><br><span class="line">乍看之下“显然是正确的”。</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#96;&#96;&#96;Swift&#96;&#96;&#96; 会尝试尽可能实际地保持安全，直到你告知并非如此为止。这与 &#96;&#96;&#96;C&#96;&#96;&#96; 和 &#96;&#96;&#96;C++&#96;&#96;&#96; （你可能会因忘记做某事而很不安全）或 &#96;&#96;&#96;Haskell&#96;&#96;&#96; 或 &#96;&#96;&#96;Java&#96;&#96;&#96; （无论你是否喜欢它有时都是安全的）这样的语言不同。</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#96;&#96;&#96;C＃&#96;&#96;&#96; 的主要设计师之一埃里克·利珀特（Eric Lippert）讲述了他对 &#96;&#96;&#96;C＃&#96;&#96;&#96; 的十个遗憾，包括以下课程：</span><br><span class="line"></span><br><span class="line">&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有时，你需要实现仅适用于正在 &#96;&#96;&#96;构建基础架构&#96;&#96;&#96; 的专家的功能； 这些功能应清楚地标记为危险-不会与其他语言的功能相似。</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;埃里克（Eric）特别是指 &#96;&#96;&#96;C＃&#96;&#96;&#96; 的 &#96;&#96;&#96;finalizers&#96;&#96;&#96; ，类似于 &#96;&#96;&#96;C++&#96;&#96;&#96; 的 &#96;&#96;&#96;析构函数&#96;&#96;&#96; 。 但是与 &#96;&#96;&#96;析构函数&#96;&#96;&#96; 不同的是，它们在 &#96;&#96;&#96;垃圾收集器&#96;&#96;&#96; 的要求下（并在 &#96;&#96;&#96;垃圾收集器&#96;&#96;&#96; 的线程上）在不确定的时间运行（也许永远不会）。 但是，被 &#96;&#96;&#96;引用计数的Swift&#96;&#96;&#96; 确实可以确定地 &#96;&#96;&#96;执行类的deinit&#96;&#96;&#96; 。</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#96;&#96;&#96;Swift&#96;&#96;&#96; 以其他方式体现了这一观点。 默认情况下， **避免未定义和不安全的行为** 。 例如，变量必须在初始化之前才能使用，并且在 &#96;&#96;&#96;数组上&#96;&#96;&#96; 使用 &#96;&#96;&#96;越界下标&#96;&#96;&#96; 将被捕获，而不是继续使用可能的垃圾值。</span><br><span class="line">当你确实需要它们时，可以使用许多“不安全”选项（例如 &#96;&#96;&#96;unsafeBitCast函数&#96;&#96;&#96; 或 &#96;&#96;&#96;UnsafeMutablePointer类型&#96;&#96;&#96; ）。 但是强大的力量带来了巨大的不确定行为。 例如，你可以编写以下内容：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; Swift</span><br><span class="line">var someArray &#x3D; [1, 2, 3]</span><br><span class="line">let uhOh &#x3D; someArray.withUnsafeBufferPointer &#123; ptr in</span><br><span class="line">return ptr &#125;</span><br><span class="line">&#x2F;&#x2F; Later...</span><br><span class="line">print(uhOh[10])</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它会编译，但是谁知道它会做什么。  <code>ptr变量</code> 仅在 <code>闭包表达式</code> 中有效，并且将其返回给调用者是非法的。但是，没有什么阻止你让它逃脱到野外。但是，你不能说没有人警告过你。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 是一种自以为是的语言。作为作者，我们对编写 <code>Swift</code> 的“正确”方法有强烈的意见。你会在本书中看到许多这样的内容，有时甚至表示它们是事实。但它们只是我们的意见-随时可以不同意！ <code>Swift</code> 还是年轻的<br>语言，许多事情还没有解决。无论你正在阅读什么，最重要的事情就是亲自尝试一下，检查它们的行为，并决定你对它们的感觉。认真思考，并注意过时的信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 继续发展。年度语法大变动的时期已经过去，但是该语言的重要领域仍未完成（ <code>字符串API</code> ， <code>泛型系统</code> ）， <code>不断变化（反射）</code> 或 <code>尚未解决（并发）</code> 。</p></br><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h1><blockquote><p>‘When I use a word,’ Humpty Dumpty said, in rather a scornful tone, ‘it means just what I choose it to mean — neither more nor less.’<br>— Through the Looking Glass, by Lewis Carroll</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序员经常抛出艺术术语。为 <code>避免混淆</code> ，以下是我们在本书中使用的一些术语定义。在可能的情况下，我们尝试遵守与官方文档相同的用法，有时甚至坚持 <code>Swift社区</code> 广泛采用的定义。这些定义中的许多定义将在后面的章节中更详细地介绍，因此请放心，如果不是所有事情都立即生效的话。如果你已经熟悉所有这些术语，那么最好还是先略过一遍，以确保你所接受的含义与我们的含义相同。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中，我们区分 <code>值</code> ， <code>变量</code> ， <code>引用</code> 和 <code>常量</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>值</code> 是永远不变的，永远不变。例如，1，true和[1,2,3]均为值。这些是文字的示例，但是值也可以在运行时生成。将数字5平方时得到的数字是一个值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用 <code>var x = [1,2]</code> 为名称分配值时，我们将创建一个名为x的变量，其中包含值[1,2]。通过更改 <code>x</code> 通过执行 <code>x.append（3）</code> ，我们没有更改原始值。相反，我们将 <code>x</code> 所保存的值替换为新值[1,2,3]-至少在逻辑上，如果不在实际实现中（这实际上可能只是在一些现有内存的后面添加新条目）。我们称此为 <code>变量变量</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以用 <code>let</code> 而不是 <code>var声明常量变量（简称常量）</code> 。一旦为常数分配了值，就永远不能为其分配新值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们也不需要立即为 <code>变量赋值</code> 。我们可以先声明变量 <code>（让x：Int ）</code>，然后再给它赋一个值 <code>（x = 1）</code> 。  <code>Swift</code> 强调 <code>安全性</code> ，将在读取变量值之前检查所有可能的代码路径是否导致为变量分配了值。没有一个变量具有尚未定义的值的概念。当然，如果变量用 <code>let声明</code> ，则只能赋给一次。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>结构</code> 和 <code>枚举</code> 是 值类型 。当将一个结构变量分配给另一个时，两个变量将包含相同的值。你可以认为内容是被复制的，但是更准确地说，一个变量已更改为包含与另一个变量相同的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>引用</code> 是一种特殊的值：它是一个 <code>“指向”内存</code> 中其他位置的值。因为两个引用可以引用相同的位置，所以这会导致存储在该位置的值立即被程序的两个不同部分 <code>突变的可能性</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>类</code> 是 <code>引用类型</code> 。你不能直接在 <code>变量</code> 中 <code>保存类的实例</code> （有时可能将其称为 <code>对象</code> ，这个术语充满了麻烦！）。相反，你必须在变量中保存对它的引用，然后通过该 <code>引用</code> 对其进行访问。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>引用类型</code> 具有标识-你可以使用 <code>===</code> 检查两个变量是否引用了 <code>完全相同的对象</code> 。你也可以检查它们是否相等，假设为相关类型实现了 <code>==</code> 。具有不同身份的两个 <code>对象仍然可以相等</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>值类型</code> 没有身份。你无法检查 <code>特定变量</code> 是否与另一个 <code>变量</code> 具有“相同”的数字2。你只能检查它们是否都包含值2。 <code>===</code> 确实是在问：“这两个变量是否都具有与它们的值相同的引用？”在编程语言文献中， <code>==</code> 有时称为 <code>结构相等</code> ，而 <code>===</code> 有时又称为 <code>指针相等</code> 或 <code>引用相等</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中， <code>类引用</code> 并不是唯一的一种引用。例如，还存在通过 <code>UnsafeMutablePointer函数</code> 等 <code>访问的指针</code> 。但是 <code>类</code> 是最简单的 <code>引用类型</code> ，部分原因是它们的类引用性质被语法糖部分地隐藏了，这意味着你不需要像使用其他语言的 <code>指针</code> 那样进行任何显式的 <code>“解引用”</code> 。 （我们将在“互操作性”一章中详细介绍其他类型的参考。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用 <code>let声明</code> 保存引用的变量，即引用是 <code>常量</code> 。这意味着该变量 <code>永远不能更改为引用其他内容</code> 。但是-这很重要-并不意味着 <code>它所指的对象不能更改</code> 。因此，在将 <code>变量称为常量</code> 时，请小心-它 <code>仅指向常量</code> 。这并不意味着它指向的是  <code>恒定的</code> 。 （注意：如果最后几句话听起来像是双重说话，请不要担心，因为我们将在“结构和类”一章中再次介绍该内容。）不幸的是，这意味着当用 <code>let查看变量</code> 的声明时，你不能一眼就知道声明的内容是否完全不变。相反，你必须知道它是 <code>值类型</code> 还是 <code>引用类型</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>复制值类型</code> 时，通常会执行 <code>深度复制</code> ，即，它包含的所有值也会 <code>递归复制</code> 。此副本可以急于发生（每当引入新变量时），也可能懒惰（每当变量被突变时）。执行 <code>深拷贝的类型</code> 被称为具有 <code>值语义</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们遇到了另一个麻烦。如果 <code>结构</code> 包含 <code>引用类型</code> ，则将 <code>结构</code> 分配给新变量后， 不会自动复制引用的对象 。相反，仅 <code>引用本身会被复制</code> 。这些被称为 <code>浅拷贝</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如， <code>Foundation</code> 中的 <code>Data结构</code> 是 <code>存储实际字节</code> 的类的 <code>包装</code> 。但是，只要 <code>Data结构</code> 发生突变， <code>Data结构</code> 的作者就会采取额外的步骤来执行 <code>类实例</code> 的 <code>深层副本</code> 。他们使用称为 <code>写时复制</code> 的技术有效地做到了这一点，我们将在 <code>“结构和类”</code> 一章中对此进行说明。目前，重要的是要知道这种 <code>行为不是免费的</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>标准库</code> 中的 <code>集合</code> 还包装了 <code>引用类型</code> ，并使用 <code>写时复制</code> 有效地提供了 <code>值语义</code> 。但是，如果集合中的元素是引用（例如，包含对象的数组），则不会复制对象。相反，仅引用被复制。这意味着Swift数组仅在其元素也具有值语义的情况下才具有值语义。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有些类是完全不可变的-也就是说，它们在创建后不提供更改其内部状态的方法。这意味着，即使它们是类，它们也具有值语义（因为即使它们是共享的，它们也永远不会改变）。但是要小心-只能保证最终类不会被添加了可变状态。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中， <code>函数</code> 也是值。你可以将 <code>函数</code> 分配给 <code>变量</code> ，具有 <code>函数数组</code> ，然后调用保留在变量中的函数。将其他函数作为 <code>参数的函数</code> （例如map，其使用对变换序列中每个元素的函数进行转换）或返回函数称为 <code>高阶函数</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不必在顶层声明函数-你可以在另一个函数内或在 do 或其他范围内声明一个函数。在 外部作用域中 定义但从中传递出去的函数（例如，作为函数的返回值）可以“捕获”局部变量，在这种情况下，当局部作用域结束时，这些局部变量不会被破坏，并且该函数可以通过他们保持状态。此行为称为 <code>closures</code> 变量 ，执行此操作的函数称为 <code>closures</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用 <code>func关键字</code> 或使用称为 <code>闭包表达式</code> 的速记 <code>{}语法</code> 来声明函数。有时将其简化为 <code>“闭包”</code> ，但不要让你给人以为只有闭包表达式才可以是 <code>闭包</code> 。使用 <code>func关键字</code> 声明的函数在作为 <code>closures</code> 外部变量时也属于 <code>闭包</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Functions</code> 通过引用保留。这意味着将已捕获状态的函数分配给另一个变量不会复制该状态。它共享它，类似于 <code>对象引用</code> 。更重要的是，当两个闭包关闭同一个局部变量时，它们都共享该变量，因此它们共享状态。这可能非常令人惊讶，我们将在“功能”一章中对此进行更多讨论。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>类</code> 或 <code>协议</code> 内部定义的函数是方法，它们具有隐式的 <code>self参数</code> 。有时我们称函数为 <code>非方法自由函数</code> 。这是为了将它们与方法区分开。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <code>Swift</code> 中的标准函数名称不仅包括函数的基本名称（括号前的部分），还包括参数标签。例如，将集合索引移动许多步的方法的全名是 <code>index（_：offsetBy :)</code> ，指示此函数接受两个参数（由两个冒号表示），其中第一个没有标签（由下划线表示）。如果从上下文可以清楚地知道我们指的是什么功能，我们通常会省略书中的标签；编译器允许你执行相同操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>自由函数</code> 和在结构上调用的方法是 <code>静态分派的</code> 。这意味着将在编译时知道要调用的函数。这也意味着编译器可能能够 内联该函数 ，即根本不调用该函数，而是将其替换为该函数将执行的代码。 优化器 还可以 丢弃或简化 在编译时无法实际运行的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>类</code> 或 <code>协议</code> 上的方法可能会 <code>动态调度</code> 。这意味着编译器不一定在编译时就知道哪个函数将运行。通过使用 <code>vtables（类似于Java和C ++动态分配的工作方式）</code> 或在某些 <code>@objc类</code>和 <code>协议</code> 的情况下，通过使用 <code>选择器</code> 和 <code>objc_msgSend</code> 来完成此动态行为。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>子类型化</code> 和 <code>方法重写</code> 是获得 <code>多态行为</code> 的一种方法，<br>即根据所涉及的类型而变化的行为。第二种方法是 <code>函数重载</code> ，其中针对不同类型多次写入函数。 （重要的是不要混淆重写和重载，因为它们的行为截然不同。）第三种方式是通过 <code>泛型</code> ， <code>泛型</code> 是将 函数或方法编写一次 ，以采用任何提供某些函数或方法的类型，但是这些函数的实现可以变化。与方法重写不同， <code>函数重载</code> 和 <code>泛型</code> 的结果在编译时是 <code>静态已知</code> 的。我们将在“泛型”一章中对此进行详细介绍。</p></br><h1 id="Swift风格指南"><a href="#Swift风格指南" class="headerlink" title="Swift风格指南"></a><strong>Swift风格指南</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编写本书以及为我们自己的项目编写 <code>Swift代码</code> 时，我们尝试遵循以下规则：</p><ul><li>→ 进行命名，在使用时进行清晰性是最重要的考虑因素。由于API的使用次数超过了声明的次数，因此，应针对API的名称进行优化，以确保它们在调用站点上的正常运行。熟悉《 Swift API设计指南》，并尝试在你自己的代码中遵守它们。</li><li>→Clarityisoft的简洁性可以帮助其实现，但简洁性不应成为其本身。</li><li>→始终向功能添加文档注释，尤其是通用名称。</li><li>→类型以UpperCaseLetters开头。函数，变量和枚举以lowerCaseLetters开头。</li><li>→使用类型推断。显式但显而易见的类型会影响可读性。</li><li>→不要在模棱两可的情况下使用类型推断，或者在定义合同时（<br>例如，这就是为什么func具有显式的返回类型）。</li><li>→默认值构造为实际上不包含类或功能的引用<br>语义。</li><li>→除非你已明确设计了MTBE可继承性，否则将其标记为“类”。如果要在内部使用继承，但不允许外部客户继承，则将类标记为public，但不要打开。</li><li>→使用尾随密封句法，除非紧接在另一开口括号之后。</li><li>→尽早使用保镖退出功能。</li><li>→Eschewforce展开并隐式展开可选的选项。有时<br>有用，但是经常需要它们通常是一个标志，这是错误的。</li><li>→不要自己重复。如果发现多次编写相同的代码片段，请将其提取到一个函数中。考虑将该功能作为协议扩展。</li><li>→收藏夹和过滤器。但是不要强制使用：在有意义时使用循环。高阶函数的目的是使代码更具可读性。当更简单的for循环更加清晰时，混淆地使用reduce会破坏此目的。</li><li>→Favorimmutable变量：默认为除非你知道你需要的突变。但是，在使代码更清晰或更高效时，请使用突变。再说一次，不要强迫：结构上的变异方法通常比返回全新的结构更惯用和有效。</li><li><ul><li>→Swift泛型（尤其是与协议约束组合）倾向于导致很长的函数签名。不幸的是，我们尚未找到将长函数声明分成多行的好方法。我们将尝试在示例代码中保持一致。</li></ul></li><li>→离开自己。当你不进行编辑时。附件表示中存在自我。是一个明确的信号，表明自我正在被封闭所捕获。</li><li>→代替编写自由功能，写扩展名类型或协议（如果可以）。这有助于提高可读性和可发现性。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于本书中的代码示例的最后一点：为了节省空间并专注于要点，我们通常会省略使代码编译所需的 <code>import</code> 语句。如果你亲自尝试该代码，并且编译器告诉你它无法识别特定符号，请尝试添加 <code>import Foundation</code> 或 <code>import UIKit</code> 语句。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Advanced Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Advanced Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 Combine Publishers和Subscribers通过URLSession下载文件？</title>
      <link href="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Combine%20Publishers%E5%92%8CSubscribers%E9%80%9A%E8%BF%87URLSession%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%9F/"/>
      <url>/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Combine%20Publishers%E5%92%8CSubscribers%E9%80%9A%E8%BF%87URLSession%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>URLSessionDownloadTask</code> 和 <code>Swift</code> 中的 <code>Combine框架</code> 将远程图像异步加载到 <code>UIImageView</code> 中。</p></br><h1 id="一个简单的图像下载器"><a href="#一个简单的图像下载器" class="headerlink" title="一个简单的图像下载器"></a><strong>一个简单的图像下载器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 <code>URL下载资源</code> 似乎是一项艰巨的任务，但这真的那么容易吗？ 这要看情况。 如果必须 <a href="http://www.xuebaonline.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Codable%20protocol%E5%9C%A8Swift%E4%B8%AD%E8%A7%A3%E6%9E%90JSON%EF%BC%9F/"><strong><em><code>下载和解析</code></em></strong></a> 只有几个KB的 <code>JSON文件</code> ，则可以采用经典方式，也可以对 <a href="http://www.xuebaonline.com/Swift%20URLSession%20&&%20Combine%20framework/"><strong><em><code>Combine框架中的URLSession对象</code></em></strong></a> 使用新的 <code>dataTaskPublisher</code> 方法。</p><a id="more"></a><h2 id="不良做法⚠️"><a href="#不良做法⚠️" class="headerlink" title="不良做法⚠️"></a><strong>不良做法⚠️</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用一些快速且肮脏的方法从互联网上获取一些较小的数据。 这些方法的问题在于你必须处理大量线程和队列。 幸运的是，使用 <a href="http://www.xuebaonline.com/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Swift%E4%B8%AD%E7%9A%84Grand%20Central%20Dispatch/"><strong><em><code>Dispatch框架</code></em></strong></a> 有很多帮助，因此你可以将阻止功能转换为非阻止功能。 🚧</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos/1"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="comment">// Synchronous download using Data &amp; String</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// get the content as String synchronously</span></span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">try</span> <span class="type">String</span>(contentsOf: url)</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the content of the url as Data synchronously</span></span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Turning sync to async</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//this is happening on a background thread</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> content = <span class="keyword">try</span> <span class="type">String</span>(contentsOf: url)</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="comment">//this is happening on the main thread</span></span><br><span class="line">            <span class="built_in">print</span>(content)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Apple</code> 在其 <a href="https://developer.apple.com/documentation/foundation/nsdata/1547245-datawithcontentsofurl" target="_blank" rel="noopener"><strong><em><code>官方数据文档</code></em></strong></a> 中做了一个重要说明，即你不应该使用这些方法来下载 <code>非文件URL</code> ，但是仍然有人在教导/使用这些不良做法，但是为什么呢？ 😥</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em><code>Don&#39;t use this synchronous method to request network-based URLs.</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的建议是：始终使用 <a href="https://developer.apple.com/documentation/foundation/urlsession" target="_blank" rel="noopener"><strong><em><code>URLSession</code></em></strong></a> 来执行与网络相关的数据传输。 创建数据任务很简单，默认情况下是异步操作，回调在后台线程上运行，因此默认情况下不会阻塞任何内容。 现代网络 <code>API</code> 在 <code>iOS</code> 上确实不错，在99％的情况下，你不再需要 <a href="https://github.com/alamofire/alamofire" target="_blank" rel="noopener"><strong><em><code>Alamofire</code></em></strong></a> 来完成这些任务。 对依赖说不！ 🚫</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The best approach without using Combine</span></span><br><span class="line"><span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// do your stuff here...</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="comment">// do something on the main queue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你需要使用其他 <code>HTTP方法</code> （而不是 <code>GET</code> ），发送特殊的标头（凭证，接受策略等）或在正文中提供额外的数据，则还需要提及，首先需要构造一个 <code>URLRequest对象</code> 。 你只能使用 <code>URLSession API</code> 发送这些自定义请求。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Apple平台</code> 上 ，你将不再被允许使用不安全的 <code>HTTP协议</code> 。 如果要访问不带安全层 <code>（HTTPS）的URL</code> ，则必须禁用 <a href="https://developer.apple.com/security/" target="_blank" rel="noopener"><strong><em><code>应用程序传输安全性</code></em></strong></a> 。</p></blockquote><h2 id="数据任务的问题"><a href="#数据任务的问题" class="headerlink" title="数据任务的问题"></a><strong><em>数据任务的问题</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大文件（例如图像）呢？ 让我向你展示一些教程，然后再进行深入研究：</p><ul><li><a href="https://stackoverflow.com/questions/47030822/uiimageview-load-uiimage-from-remote-url" target="_blank" rel="noopener"><strong><em><code>UIImageView, Load UIImage from remote URL</code></em></strong></a></li><li><a href="https://stackoverflow.com/questions/9786018/loading-an-image-into-uiimage-asynchronously" target="_blank" rel="noopener"><strong><em><code>Loading an image into UIImage asynchronously</code></em></strong></a></li><li><a href="https://www.hackingwithswift.com/example-code/uikit/how-to-load-a-remote-image-url-into-uiimageview" target="_blank" rel="noopener"><strong><em><code>How to load a remote image URL into UIImageView</code></em></strong></a></li><li><a href="https://iosdevcenters.blogspot.com/2018/06/how-to-downloading-image-from-server.html" target="_blank" rel="noopener"><strong><em><code>How To Downloading Image from server URL on Swift 4?</code></em></strong></a></li><li><a href="https://stackoverflow.com/questions/46199203/downloading-uiimage-via-alamofireimage" target="_blank" rel="noopener"><strong><em><code>Downloading UIImage via AlamofireImage?</code></em></strong></a></li><li><a href="https://medium.com/swlh/loading-images-from-url-in-swift-2bf8b9db266" target="_blank" rel="noopener"><strong><em><code>Loading images from URL in Swift</code></em></strong></a></li><li><a href="https://www.tutorialspoint.com/how-do-i-load-an-image-by-url-on-ios-device-using-swift" target="_blank" rel="noopener"><strong><em><code>How do I load an image by URL on iOS device using Swift?</code></em></strong></a></li><li><a href="http://swiftdeveloperblog.com/code-examples/uiimageview-and-uiimage-load-image-from-remote-url/" target="_blank" rel="noopener"><strong><em><code>UIImageView and UIImage. Load Image From Remote URL.</code></em></strong></a></li><li><a href="https://www.youtube.com/watch?v=DnZvlanmpNE" target="_blank" rel="noopener"><strong><em><code>Asynchronously Loading Images in SwiftUI</code></em></strong></a></li><li><a href="https://onmyway133.github.io/blog/How-to-load-remote-image-in-SwiftUI/" target="_blank" rel="noopener"><strong><em><code>How to load remote image in SwiftUI</code></em></strong></a></li><li><a href="http://www.xuebaonline.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Combine%20Publishers%E5%92%8CSubscribers%E9%80%9A%E8%BF%87URLSession%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%9F/"><strong><em><code>Loading/Downloading image from URL on Swift</code></em></strong></a></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大文件（例如图像）呢？ 让我向你展示一些教程，然后再进行深入研究：<br>出于所有应有的尊重，我认为以上所有这些链接实际上都是加载远程映像的不良示例。 当然，他们可以完成工作，而且实施起来也很容易，但是也许我们应该涵盖整个故事……🤐</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于与远程服务器的小型交互，可以使用U <code>RLSessionDataTask类</code> 将响应数据接收到内存中（与使用 <code>URLSessionDownloadTask类</code> 不同，后者将数据直接存储到文件系统中）。 数据任务非常适合调用 <code>Web服务端点</code> 之类的用途。</p></blockquote><h2 id="URLSessionDataTask和URLSessionDownloadTask有什么区别？"><a href="#URLSessionDataTask和URLSessionDownloadTask有什么区别？" class="headerlink" title="URLSessionDataTask和URLSessionDownloadTask有什么区别？"></a><strong><em>URLSessionDataTask和URLSessionDownloadTask有什么区别？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们仔细阅读文档，很明显， <strong>数据任务</strong> 不是下载大型资源的合适人选。 该类旨在仅请求较小的对象，因为基础数据将被加载到内存中。 另一方面，下载任务将响应的内容保存在磁盘上（而不是内存），并且你将收到本地文件URL，而不是数据对象。 事实证明，从数据任务转移到下载任务将对你的内存消耗产生巨大影响。 我有一些数字。 📈</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我使用这两种方法下载了以下<a href="https://images.unsplash.com/photo-1554773228-1f38662139db" target="_blank" rel="noopener"><strong><em><code>图像文件（6000x4000px×13.1MB</code></em></strong></a>）。 我做了一个基于Swift 5.1项目的全新情节提要。 基本的RAM使用量约为52MB，当我使用 <code>URLSessionDataTask类</code> 获取图像时，内存使用量跃升至82MB。 将数据任务转换为下载任务仅使基本内存大小增加了约4MB（总计约56MB），这是一项重大改进。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://images.unsplash.com/photo-1554773228-1f38662139db"</span>)!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// data task</span></span><br><span class="line"><span class="type">URLSession</span>.shared.dataTask(with: url) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">self</span>?.imageView.image = <span class="type">UIImage</span>(data: data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// download task</span></span><br><span class="line"><span class="type">URLSession</span>.shared.downloadTask(with: url) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] url, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span></span><br><span class="line">        <span class="keyword">let</span> cache = <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: .cachesDirectory, <span class="keyword">in</span>: .userDomainMask).first,</span><br><span class="line">        <span class="keyword">let</span> url = url</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> file = cache.appendingPathComponent(<span class="string">"\(UUID().uuidString).jpg"</span>)</span><br><span class="line">        <span class="keyword">try</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.moveItem(atPath: url.path,</span><br><span class="line">                                         toPath: file.path)</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">self</span>?.imageView.image = <span class="type">UIImage</span>(contentsOfFile: file.path)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我使用 <code>UIImageView</code> 渲染图像时，数据任务的内存占用量约为118MB（总计：〜170MB），下载任务的内存占用约为93MB（总计：〜145MB）。 快速摘要：</p><ul><li>数据任务：〜30MB</li><li>带有渲染的数据任务：〜118MB</li><li>下载任务：〜4MB</li><li>带有渲染的下载任务：〜93MB</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;希望你明白我的意思。 请不要忘记， <code>Foundation网络层</code> 附带了四种类型的会话任务。 你应该始终使用适合工作的合适的工具。 我们可以说 <a href="https://stackoverflow.com/questions/20604910/what-is-difference-between-nsurlsessiondatatask-vs-nsurlsessiondownloadtask" target="_blank" rel="noopener"><strong><em><code>URLSessionDataTask与URLSessionDownloadTask之间的区别</code></em></strong></a> 是：大量内存（在这种情况下，大约25MB的RAM）。</p><blockquote><p><strong><em><code>提示：</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener"><strong><em><code>Kingfisher</code></em></strong></a> 或 <a href="https://github.com/SDWebImage/SDWebImage" target="_blank" rel="noopener"><strong><em><code>SDWebImage</code></em></strong></a> 下载和处理远程图像。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会说这是一个边缘情况，因为大多数图像（甚至是高清图像）最大都只有几百千字节。 不过，我的主要收获是我们可以做得更好，如果可能的话，我们应该始终这样做。 🤓</p></br><h1 id="使用-Combine-下载图像"><a href="#使用-Combine-下载图像" class="headerlink" title="使用 Combine 下载图像"></a><strong>使用 Combine 下载图像</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>WWDC19</code> 上，Apple宣布了 <code>Combine框架</code> ，该框架为我们带来了一些 <code>Foundation对象</code> 的一些新扩展。 现代需要现代API，对吗？ 如果你已经熟悉了很好的新SDK，但是如果你不知道这种声明式功能响应性疯狂到底是什么，那么你应该阅读我有关 <a href="http://www.xuebaonline.com/Swift%20URLSession%20&&%20Combine%20framework/"><strong><em><code>Combine框架</code></em></strong></a> 的综合教程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Combine</code> 的第一个版本附带了一个不错的 <code>dataSessionPublisher扩展</code> 方法，用于 <code>URLSession类</code> 。 等一下，其他人呢？ 没有下载任务发布者？ 我们现在应该做什么？ 🤔</p><h2 id="如何编写自定义-Publisher？"><a href="#如何编写自定义-Publisher？" class="headerlink" title="如何编写自定义 Publisher？"></a><strong><em>如何编写自定义 Publisher？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://twitter.com/twannl" target="_blank" rel="noopener"><strong><em><code>SwiftLee</code></em></strong></a> 有一个很好的关于 <a href="https://www.avanderlee.com/swift/custom-combine-publisher/" target="_blank" rel="noopener"><strong><em><code>Combine的教程</code></em></strong></a> ，可以帮助你处理UIControl事件。  <a href="https://twitter.com/donnywals" target="_blank" rel="noopener"><strong><em><code>Donny Wals</code></em></strong></a> 的另一本很棒的读物（甚至比第一本更好）是关于 <a href="https://www.donnywals.com/understanding-combines-publishers-and-subscribers/" target="_blank" rel="noopener"><strong><em><code>理解发布者和订阅者</code></em></strong></a> 的。 这是一篇写得很好的文章，你绝对应该检查一下，我强烈建议你阅读。 🤘🏻</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们开始创建自己的 <code>DownloadTaskPublisher</code> 。 如果在 <code>Xcode</code> 中命令+单击 <code>dataTaskPublisher</code> 方法，则可以看到相应的界面。 右下方还有一个 <code>DataTaskPublisher</code> 结构。 基于该模板，我们可以创建自己的扩展程序。 同一数据任务方法有两种变体，我们将复制此行为。 我们需要的另一件事是 <code>DownloadTaskPublisher</code> 结构，我将首先向你展示Swift代码，然后我们将讨论实现细节。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">downloadTaskPublisher</span><span class="params">(<span class="keyword">for</span> url: URL)</span></span> -&gt; <span class="type">URLSession</span>.<span class="type">DownloadTaskPublisher</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskPublisher(<span class="keyword">for</span>: .<span class="keyword">init</span>(url: url))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">downloadTaskPublisher</span><span class="params">(<span class="keyword">for</span> request: URLRequest)</span></span> -&gt; <span class="type">URLSession</span>.<span class="type">DownloadTaskPublisher</span> &#123;</span><br><span class="line">        .<span class="keyword">init</span>(request: request, session: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">DownloadTaskPublisher</span>: <span class="title">Publisher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Output</span> = (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>)</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Failure</span> = <span class="type">URLError</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">let</span> request: <span class="type">URLRequest</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">let</span> session: <span class="type">URLSession</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">init</span>(request: <span class="type">URLRequest</span>, session: <span class="type">URLSession</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.request = request</span><br><span class="line">            <span class="keyword">self</span>.session = session</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">receive</span>&lt;S&gt;<span class="params">(subscriber: S)</span></span> <span class="keyword">where</span> <span class="type">S</span>: <span class="type">Subscriber</span>,</span><br><span class="line">            <span class="type">DownloadTaskPublisher</span>.<span class="type">Failure</span> == <span class="type">S</span>.<span class="type">Failure</span>,</span><br><span class="line">            <span class="type">DownloadTaskPublisher</span>.<span class="type">Output</span> == <span class="type">S</span>.<span class="type">Input</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> subscription = <span class="type">DownloadTaskSubscription</span>(subscriber: subscriber, session: <span class="keyword">self</span>.session, request: <span class="keyword">self</span>.request)</span><br><span class="line">            subscriber.receive(subscription: subscription)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Publisher</code> 可以将输出或失败消息发送给附加的订阅者。 你必须为每种类型创建一个新的类型别名，因为它们都是协议级别上定义的通用约束。 接下来，我们将存储会话和请求对象供以后使用。 协议一致性的最后一部分是你必须实现 <code>receive &lt;S&gt;（subscriber：S）</code> 通用方法。 此方法负责通过订阅对象附加新的订阅者。 嗯…什么？ 🤨</p><blockquote><p><strong><em><code>提示：</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Combine</code> 中的 <code>publisher/subscriber</code> 关系在第三个对象（订阅）中得到巩固。 创建订阅者并订阅发布者时，发布者将创建订阅对象，并将订阅的引用传递给订阅者。 然后，订阅者将向订阅请求多个值，以开始接收这些值。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>publisher</code> 和 <code>subscriber</code> 通过 <code>Subscription</code> 连接。  <code>subscriber</code> 仅创建 <code>Subscription</code> 并将其传递给 <code>subscriber</code> 。  <code>Subscription</code> 包含将为 <code>subscriber</code> 获取新数据的逻辑。 订阅服务器接收订阅，值和完成（成功或失败）。</p><ul><li><strong>订阅者</strong> 订阅 <strong>发布者</strong></li><li><strong>发布者</strong> 创建一个 <strong>订阅</strong></li><li><strong>发布者</strong> 将此 <strong>订阅</strong> 提供给 <strong>订阅者</strong></li><li><strong>订阅者</strong> 要求 <strong>订阅</strong> 提供一些值</li><li><strong>订阅</strong> 尝试收集值（成功或失败）</li><li><strong>订阅</strong> 根据需求策略将值发送给 <strong>订阅者</strong></li><li>如果发生错误，订阅会将失败完成发送给 <strong>订阅者</strong></li><li>如果没有更多可用值， <strong>订阅</strong> 将发送完成</li></ul><h2 id="如何编写自定义-Subscription？"><a href="#如何编写自定义-Subscription？" class="headerlink" title="如何编写自定义 Subscription？"></a><strong><em>如何编写自定义 Subscription？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，是时候为我们的小型基于 <code>Combine</code> 的下载器创建订阅了，我认为，如果我们将最后的代码片段放在一起，你将理解这三个对象之间的关系。 🧩</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadTaskSubscription</span>&lt;<span class="title">SubscriberType</span>: <span class="title">Subscriber</span>&gt;: <span class="title">Subscription</span> <span class="title">where</span></span></span><br><span class="line"><span class="class">        <span class="title">SubscriberType</span>.<span class="title">Input</span> == (<span class="title">url</span>: <span class="title">URL</span>, <span class="title">response</span>: <span class="title">URLResponse</span>),</span></span><br><span class="line"><span class="class">        <span class="title">SubscriberType</span>.<span class="title">Failure</span> == <span class="title">URLError</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> subscriber: <span class="type">SubscriberType?</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> session: <span class="type">URLSession!</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> request: <span class="type">URLRequest!</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> task: <span class="type">URLSessionDownloadTask!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span>(subscriber: <span class="type">SubscriberType</span>, session: <span class="type">URLSession</span>, request: <span class="type">URLRequest</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.subscriber = subscriber</span><br><span class="line">            <span class="keyword">self</span>.session = session</span><br><span class="line">            <span class="keyword">self</span>.request = request</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(<span class="number">_</span> demand: Subscribers.Demand)</span></span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> demand &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.task = <span class="keyword">self</span>.session.downloadTask(with: request) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] url, response, error <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> error = error <span class="keyword">as</span>? <span class="type">URLError</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>?.subscriber?.receive(completion: .failure(error))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>?.subscriber?.receive(completion: .failure(<span class="type">URLError</span>(.badServerResponse)))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> url = url <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>?.subscriber?.receive(completion: .failure(<span class="type">URLError</span>(.badURL)))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> cacheDir = <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: .cachesDirectory, <span class="keyword">in</span>: .userDomainMask).first!</span><br><span class="line">                    <span class="keyword">let</span> fileUrl = cacheDir.appendingPathComponent((<span class="type">UUID</span>().uuidString))</span><br><span class="line">                    <span class="keyword">try</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.moveItem(atPath: url.path, toPath: fileUrl.path)</span><br><span class="line">                    <span class="number">_</span> = <span class="keyword">self</span>?.subscriber?.receive((url: fileUrl, response: response))</span><br><span class="line">                    <span class="keyword">self</span>?.subscriber?.receive(completion: .finished)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>?.subscriber?.receive(completion: .failure(<span class="type">URLError</span>(.cannotCreateFile)))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.task.resume()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.task.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;订户具有输入和失败类型。订阅者只能订阅具有相同类型的发布者。发布者的输出和失败类型必须与订阅输入和失败类型相同。这次我们不能使用 <code>associatedType</code> ，但是我们必须使用where子句创建一个对这些要求有约束的通用值。其背后的原因是我们不知道哪种订阅者将订阅此订阅。可以是A类或B类，谁知道…🤷️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们必须在 <code>init方法</code> 中传递一些属性，将它们存储为实例变量（请谨慎使用类，如果适用，则应使用weak）。最后，我们通过遵守需求政策来实施价值请求方法。需求只是一个数字。它告诉我们最多可以发送回给订户多少个值。在我们的例子中，我们将拥有最大1的值，因此，如果需求大于零，那么我们就走了。你可以通过在订阅者上调用各种接收方法来向订阅者发送消息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你必须手动发送带有 <code>.finished</code> 或 <code>.failure（T）</code>值的完成事件。同样，我们必须在完成块返回之前移动下载的临时文件，否则我们将完全丢失它。这次，我将简单地将文件移动到应用程序缓存目录。免费取消是结束电池耗尽操作的好方法。你只需要实现一个自定义的 <code>cancel（）</code>方法。在我们的例子中，我们可以在底层 <code>URLSessionDownloadTask</code> 上调用相同的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而已。我们已经准备好自定义发布者和订阅。想尝试一下吗？</p><h2 id="如何创建自定义-Subscriber-？"><a href="#如何创建自定义-Subscriber-？" class="headerlink" title="如何创建自定义 Subscriber ？"></a><strong><em>如何创建自定义 Subscriber ？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有4种订阅。 你可以使用 <code>.sink</code> 或 <code>.assign</code> 方法进行新的订阅，还有一个名为 <code>Subject</code> 的东西，可以为发布者事件进行订阅，或者可以构建自己的 <code>Subscriber对象</code> 。 如果选择此路径，则可以使用 <code>.subscribe方法</code> 来关联发布者和订阅者。 你还可以订阅主题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadTaskSubscriber</span>: <span class="title">Subscriber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Input</span> = (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>)</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Failure</span> = <span class="type">URLError</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> subscription: <span class="type">Subscription?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(subscription: Subscription)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.subscription = subscription</span><br><span class="line">        <span class="keyword">self</span>.subscription?.request(.unlimited)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(<span class="number">_</span> input: Input)</span></span> -&gt; <span class="type">Subscribers</span>.<span class="type">Demand</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Subscriber value \(input.url)"</span>)</span><br><span class="line">        <span class="keyword">return</span> .unlimited</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(completion: Subscribers.Completion&lt;Failure&gt;)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Subscriber completion \(completion)"</span>)</span><br><span class="line">        <span class="keyword">self</span>.subscription?.cancel()</span><br><span class="line">        <span class="keyword">self</span>.subscription = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的 <code>subscriber</code> 将只打印输出值。 我们必须非常小心地进行内存管理。 收到的订阅将存储为强属性，但是当发布者发送完成事件时，我们应取消订阅并删除引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当值到达时，我们必须返回需求。 在我们的情况下，这并不重要，因为我们只有1个传入值，但是如果你想限制发布者，则可以使用例如 <code>.max（1）</code> 作为需求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是使用 <code>Swift 5.1</code> 编写的所有 <code>Combine订阅者</code> 类型的快速示例代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://images.unsplash.com/photo-1554773228-1f38662139db"</span>)!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> defaultValue: (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>) = &#123;</span><br><span class="line">        <span class="keyword">let</span> fallbackUrl = <span class="type">URL</span>(fileURLWithPath: <span class="string">"fallback-image-path"</span>)</span><br><span class="line">        <span class="keyword">let</span> fallbackResponse = <span class="type">URLResponse</span>(url: fallbackUrl, mimeType: <span class="string">"foo"</span>, expectedContentLength: <span class="number">1</span>, textEncodingName: <span class="string">"bar"</span>)</span><br><span class="line">        <span class="keyword">return</span> (url: fallbackUrl, response: fallbackResponse)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> value: (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>) = <span class="type">ViewController</span>.defaultValue</span><br><span class="line">    <span class="keyword">let</span> subject = <span class="type">PassthroughSubject</span>&lt;(url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>), <span class="type">URLError</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> subscriber = <span class="type">DownloadTaskSubscriber</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sinkOperation: <span class="type">AnyCancellable?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> assignOperation: <span class="type">AnyCancellable?</span></span><br><span class="line">    <span class="keyword">var</span> assignSinkOperation: <span class="type">AnyCancellable?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> subjectOperation: <span class="type">AnyCancellable?</span></span><br><span class="line">    <span class="keyword">var</span> subjectSinkOperation: <span class="type">AnyCancellable?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.sinkExample()</span><br><span class="line">        <span class="keyword">self</span>.assignExample()</span><br><span class="line">        <span class="keyword">self</span>.subjectExample()</span><br><span class="line">        <span class="keyword">self</span>.subscriberExample()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sinkExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.sinkOperation = <span class="type">URLSession</span>.shared</span><br><span class="line">            .downloadTaskPublisher(<span class="keyword">for</span>: <span class="type">ViewController</span>.url)</span><br><span class="line">            .sink(receiveCompletion: &#123; completion <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Sink completion: \(completion)"</span>)</span><br><span class="line">            &#125;) &#123; value <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Sink value: \(value.url)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">assignExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.assignSinkOperation = <span class="keyword">self</span>.$value.sink &#123; value <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Assign value: \(value.url)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.assignOperation = <span class="type">URLSession</span>.shared</span><br><span class="line">            .downloadTaskPublisher(<span class="keyword">for</span>: <span class="type">ViewController</span>.url)</span><br><span class="line">            .replaceError(with: <span class="type">ViewController</span>.defaultValue)</span><br><span class="line">            .assign(to: \.value, on: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subjectExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.subjectSinkOperation = <span class="keyword">self</span>.subject.sink(receiveCompletion: &#123; completion <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Subject completion: \(completion)"</span>)</span><br><span class="line">        &#125;) &#123; value <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Subject value: \(value.url)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.subjectOperation = <span class="type">URLSession</span>.shared</span><br><span class="line">            .downloadTaskPublisher(<span class="keyword">for</span>: <span class="type">ViewController</span>.url)</span><br><span class="line">            .subscribe(<span class="keyword">self</span>.subject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subscriberExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">URLSession</span>.shared</span><br><span class="line">            .downloadTaskPublisher(<span class="keyword">for</span>: <span class="type">ViewController</span>.url)</span><br><span class="line">            .subscribe(<span class="type">DownloadTaskSubscriber</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;真的很好, 我们可以使用自定义的基于 <code>Combine</code> 的 <code>URLSession扩展名</code> 下载文件。</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要忘记 <strong>存储</strong> <code>AnyCancellable指针</code> ，否则在你可以从链/流中接收任何内容之前，将重新分配整个 <code>Combine操作</code> 。</p></blockquote><h2 id="把所有的操作放在一起"><a href="#把所有的操作放在一起" class="headerlink" title="把所有的操作放在一起"></a><strong><em>把所有的操作放在一起</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我保证可以使用图片下载器，所以让我解释一下整个流程。 我们有一个自定义的下载任务发布者，它将在本地保存我们的删除图像文件，并返回一个包含文件url和响应的元组。 ✅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我将简单地假设url后面有一个有效的图像，并且服务器返回了一个有效的响应，因此我将把发布者的输出映射到 <code>UIImage对象</code> 。 我还将用后备图像值替换任何类型的错误。 在实际的应用程序中，你应该始终对 <code>URLResponse对象</code> 进行一些额外的检查，但是为了简单起见，我暂时将其跳过。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一件事是使用返回的图像更新我们的图像视图。 由于这是一个UI任务，它应该在主线程上发生，因此我们必须使用 <code>receive（on :)</code> 操作来切换上下文。 如果要在 <code>Combine框架</code> 中了解有关调度程序的更多信息，则应[<strong><em><code>阅读Vadim Bulavin的文章</code></em></strong>] (<a href="https://www.vadimbulavin.com/understanding-schedulers-in-swift-combine-framework/" target="_blank" rel="noopener">https://www.vadimbulavin.com/understanding-schedulers-in-swift-combine-framework/</a> “”) 。 这是一颗宝石。 💎</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你未在某些 <code>appleOS版本</code> 上接收到值，则可能是因为在2019年12月前后，“合并”中发生了更改。你应检查以下链接： <a href="https://forums.swift.org/t/combine-receive-on-runloop-main-loses-sent-value-how-can-i-make-it-work/28631/47" target="_blank" rel="noopener"><strong><em><code>link1</code></em></strong></a> ， <a href="https://heckj.github.io/swiftui-notes/#coreconcepts-lifecycle" target="_blank" rel="noopener"><strong><em><code>link2</code></em></strong></a></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，这是可能的图像下载操作的最终Swift代码，简单而声明性。 👍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> operation: <span class="type">AnyCancellable?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://images.unsplash.com/photo-1554773228-1f38662139db"</span>)!</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.operation = <span class="type">URLSession</span>.shared</span><br><span class="line">            .downloadTaskPublisher(<span class="keyword">for</span>: url)</span><br><span class="line">            .<span class="built_in">map</span> &#123; <span class="type">UIImage</span>(contentsOfFile: $<span class="number">0</span>.url.path)! &#125;</span><br><span class="line">            .replaceError(with: <span class="type">UIImage</span>(named: <span class="string">"fallback"</span>))</span><br><span class="line">            .receive(on: <span class="type">DispatchQueue</span>.main)</span><br><span class="line">            .assign(to: \.image, on: <span class="keyword">self</span>.imageView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我们可以显示图像。 哎呀，但是等等…还有改进的余地。 缓存呢？ 再加上一个 <code>6000x4000</code> px的图片对于一个小显示器来说是巨大的，我们不应该首先调整图像的大小/缩放比例吗？ 如果我要使用列表中的图像会发生什么，我不应该在用户滚动时取消下载任务吗？ 😳</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也许我会在即将到来的教程中写这些问题，但是我认为这是结束本文的重点。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Combine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Combine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在2020年学习iOS / Swift的最佳实践是什么？</title>
      <link href="/%E5%9C%A82020%E5%B9%B4%E5%AD%A6%E4%B9%A0iOS%20/%20Swift%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/%E5%9C%A82020%E5%B9%B4%E5%AD%A6%E4%B9%A0iOS%20/%20Swift%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你正在学习 <code>iOS开发</code> 吗？ 寻找 <code>Swift</code> 最佳做法？ 这是开始作为移动应用程序开发人员的旅程的正确位置。</p></br><h1 id="Hello-Swift"><a href="#Hello-Swift" class="headerlink" title="Hello Swift!"></a><strong>Hello Swift!</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习编程语言很困难。 即使经过十多年的软件开发人员经验，仍然觉得自己只是在摸索。 我对底层汇编代码不了解，也不知道如何使用着色器等创建3D游戏。 仍然，我们每天都在学习新的东西。 这是终生的旅程，道路上充满了障碍，但是如果你继续前进，你会发现路的尽头有金子。 我仍然喜欢用纯代码来创建新东西。 😍</p><p><strong><em><code>Everyone can code</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚开始时，你会感觉必须学习一百万件事，但你不必担心，因为时间是你的朋友。 每天你都会学到一些新知识，这些新知识将帮助你前进以实现下一个目标。 我相信这里最重要的是获得乐趣。 如果因为无法理解某件事而感到沮丧，请寻求帮助或休息一下。  <code>Swift社区</code> 是一群很棒的人，每个人都非常有帮助，因此，如果你选择这种编程语言来实现你的想法，那么你将遇到一些很棒的人。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我向你展示开始 <code>Swift应用程序开发人员</code> 所需要的条件。👨💻</p></br><h1 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a><strong>Hardware</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开始你的 <code>Apple开发人员</code> 职业所需的第一件事是 <code>Mac</code> 。 不幸的是， <code>Mac</code> 如今是非常昂贵的机器，当前的 <code>MacBook系列（Air和Pro都具有完全损坏的蝶形键盘机制）</code> 。 希望这将很快改变。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我想说，你应该使用蝴蝶前款式，如果你想便宜的话，可以寻找二手市场。 否则，你可以使用 <code>Mac mini</code> ，但是如果你购买 <code>Mac mini</code>，则应考虑显示器，键盘和鼠标等额外费用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你没有足够的资金，则应该使用一些高端设备，例如新的 <code>MacBook Pro 16“</code> ， <code>iMac Pro</code> 或只是购买 <code>Mac Pro</code> 。尽管如此，你始终应该选择配备SSD的计算机。 2020年，基本的iMac配备了极其慢的HDD。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个选择是建立一个 <code>hackintosh</code> ，但是恕我直言，这是你最糟糕的事情。 你将不会获得相同的经验，而且你将在与系统的斗争中挣扎很多。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会听说有传言说 <code>iPad</code> 和 <code>Swift playgrounds</code> 会很好。 老实说，事实并非如此。 即使使用 <code>Linux机器</code> ，你也可以玩耍并学习 Swift编程语言 ，但是如果你要制作自己的 <code>iOS/iPadOS/macOS/watchOS</code> 应用程序，则肯定需要 <code>Mac</code> 。</p></blockquote></br><h1 id="Software"><a href="#Software" class="headerlink" title="Software"></a><strong>Software</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，你拥有一台不错的 <code>Mac</code> 。 让我们看看如果你要开始开发 iOS应用程序 ，将需要哪种软件。 你可能听说过苹果的操作系统是 <code>macOS</code> 。 首先，如果你以前从未使用过 Mac ，则应该熟悉系统本身。 当我购买第一台 <code>MacBook Pro</code> 时，我花了大约一周的时间来习惯所有应用程序，系统快捷方式和其他所有功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不想自己搞定一切，那么你来对地方了。 让我逐步介绍一下作为专业移动/后端开发人员在我的工作中使用的每个应用程序和工具。</p><h2 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a><strong><em>Terminal</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该习惯的最重要的事情是终端（控制台）应用程序。 如果你之前从未听说过终端，则应该只寻找初学者指南教程，但是我强烈建议你至少学习真正的基本命令。</p><h2 id="Brew-amp-cask"><a href="#Brew-amp-cask" class="headerlink" title="Brew &amp; cask"></a><strong><em>Brew &amp; cask</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该在新 <code>Mac</code> 上安装的第一件事是 <a href="https://brew.sh/" target="_blank" rel="noopener"><strong><em><code>Homebrew</code></em></strong></a> 。 如果你以前使用过 <code>linux</code> ，可能会发现此工具很熟悉（它也可以在 <code>linux</code> 上运行）。 根据 <code>Max Howell</code> （创作者）：</p><blockquote><p><strong><code>适用于macOS（或Linux）的缺少的包管理器.</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以通过使用 <code>cask子命令</code> 将常规应用程序与 <code>brew安装</code> 在一起。 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install firefox</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我更喜欢创建一个我一直使用的工具列表，所以当我重新安装计算机时，我只需将这些命令复制并粘贴到终端中，我就或多或少地准备好恢复过程。 如果必须从头开始重新安装 <code>macOS</code> ，这将非常方便。</p><h2 id="MAS"><a href="#MAS" class="headerlink" title="MAS"></a><strong><em>MAS</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会注意到，我已经为 <code>Terminal</code> 安装了一些软件。 如果你不喜欢<code>App Store</code> 的界面，则可以安装 <a href="https://github.com/mas-cli/mas" target="_blank" rel="noopener"><strong><em><code>MAS（一种辅助工具）</code></em></strong></a> 。 借助它，你可以使用终端命令安装商店中所有可用的内容。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>GitHub</code> 上的自述文件非常好，你应该仔细阅读。 无论如何，你都不需要 <code>mas-cli</code> 来进行 <code>iOS</code> 开发，但是由于它确实很方便，所以我建议你进行检查。</p><h2 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a><strong><em>Xcode</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你肯定需要的第一工具是 <a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener"><strong><code>Xcode</code></strong></a> 。 还有一个名为 <a href="https://www.jetbrains.com/objc/" target="_blank" rel="noopener"><strong><code>AppCode</code></strong></a> 的IDE工具，但它总是落后于其他社区，绝大多数社区都喜欢 <code>Xcode</code> 。 🔨</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每年都会发布具有全新功能的 <code>Xcode新版本</code> 。 我建议使用最新版本（也应始终升级现有项目以支持最新版本）。 你可以从 <code>App Store</code> 获取 <code>Xcode</code> ，它是完全免费的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你的机器上安装 <code>Xcode</code> 会花费很多时间，但是几个小时后不用担心，它可以帮助你编写第一个 <code>iOS应用程序</code> 。 所以要耐心点。 :)</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong><em>Git</em></strong></h2><blockquote><p>Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个开发人员都应使用适当的 <a href="https://en.wikipedia.org/wiki/Version_control" target="_blank" rel="noopener"><strong><em><code>版本控制系统（又名Git）</code></em></strong></a> 。  <code>Git</code> 是事实上的版本控制标准工具，你可以在大约15分钟内<a href="https://try.github.io/levels/1/challenges/1" target="_blank" rel="noopener"><strong><em><code>学习基础知识</code></em></strong></a>。 当然，掌握它会花费更长的时间，但是完全值得一试。</p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a><strong><em>GitHub</em></strong></h2><p><strong><em><code>GitHub是基于Web的托管服务，用于使用git进行版本控制。</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;老实说， <code>GitHub</code> 不再只是一个存储库托管服务，它是一个完整的平台，具有用于问题管理，项目计划，持续集成支持等的工具。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>GitHub</code> 为你提供了针对个人的公共和私有 <code>Git存储库</code> 的 <strong>免费服务</strong> 。 在2019年，它被Microsoft收购（每个人都担心这一变化，因为MS拥有破坏良好服务的历史），但到目前为止，他们推出了许多令人惊叹的新功能。 立即获取免费帐户！</p></br><h1 id="使用Swift进行iOS应用开发"><a href="#使用Swift进行iOS应用开发" class="headerlink" title="使用Swift进行iOS应用开发"></a><strong>使用Swift进行iOS应用开发</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我相信 <code>Swift</code> 在过去5年中已发展成为稳定且成熟的语言。 如果你考虑一下，这是编写具有前瞻性的iOS应用程序的唯一好选择。 你显然应该忘记 <code>Objective-C</code> ，因为苹果已经做出了选择。 最终， <code>Swift</code> 将成为 <code>Apple</code> 支持的唯一编程语言，已经有一些Swift框架“仅”。 只需看看 <a href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener"><strong><em><code>SwiftUI</code></em></strong></a> 。 我的意思是，尽管该框架与基于 <code>Objective-C</code> 的项目100％兼容，但你无法在 <code>Objective-C</code> 中编写 <code>SwiftUI视图</code> 。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a><strong><em>依赖管理</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在某些时候，你不想自己编写所有内容，因为你希望快速进步。 这是外部程序包出现的地方。 听我的劝告：</p><p><strong><em><code>切勿手动连接第三方库</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift软件包管理器</code> 本地集成到 <code>Xcode</code> 中。 过去， <code>CocoaPods</code> 是iOS项目的最终依赖性管理器（有些人更喜欢 <code>Carthage</code> ），但是如今使用 <code>SPM</code> 更好。 如果你需要集成外部库， <code>SwiftPM</code> 是2020年的正确选择。如果你不知道它的工作方式，则应该阅读我有关<a href=""""><strong><em><code>如何使用 Swift Package Manager 的综合教程</code></em></strong></a>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;去年，我还写了一篇相当受欢迎的文章，介绍用 <a href="http://www.xuebaonline.com/Swift%E7%BC%96%E5%86%99%E7%9A%8420%E4%B8%AAiOS%E5%BA%93(%E4%B8%80)/"><strong><em><code>Swift 编写的最好/最受欢迎的iOS库</code></em></strong></a>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，如果你不知道从哪里开始以及将哪些内容集成到 <code>Swift项目</code> 中，则应该阅读我的博客文章，因为它仍然是最新的。 幸运的是，这些事情并没有经常改变。</p><h2 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a><strong><em>应用架构</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为即将到来的 <code>iOS项目</code> 选择正确的架构是最困难的事情之一。另一个正在建立你的用户界面，但让我们将该主题保留。你永远不应该害怕架构。即使你选择 <code>MVC</code> ， <code>MVP</code> ， <code>MVVM</code> 或 <code>VIPER</code> ，你也可以拥有一个编写良好的应用程序结构。这一点非常重要，因为你不想让2000多行 <a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener"><strong><em><code>面条式代码</code></em></strong></a>的视图控制器使自己将来感到生气，但它会带来一些讨厌的副作用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，你应该如何选择架构？由于它们很多，因此你甚至可以随机选择一个。好吧，这是iOS开发人员之间的真正辩论。我最喜欢的是 <code>VIPER</code> ，尽管因此我受到了很多批评。老实说，我真的对此不抱任何想法，因为它对我（和我的团队）有用。不管你是否使用普通的 <code>旧MVC</code> ，直到它可以解决你的问题时，它才真正重要。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你是一个完全初学者，请不要从 <code>VIPER</code> 开始，除非你可以陪伴可以回答你所有问题的人。我在这里的建议只是简单地坐下来，仔细考虑你想要实现的目标并制定基本计划。当然，如果你熟悉这些模式会很有帮助，但是到最后，你会意识到它们都是由人为制作的，而且都不完美。 🤔</p><h2 id="Xcode约定"><a href="#Xcode约定" class="headerlink" title="Xcode约定"></a><strong><em>Xcode约定</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我为 Xcode 制定了一些非常 <a href=""""><strong><em><code>基本的约定</code></em></strong></a> ，如果你不知道如何组织项目，则应检查这些约定。 如果你不熟悉 <code>Xcode格式</code> ，目标，方案，则应在互联网上搜索这样的教程，其中有一些关于整个过程的充分说明的示例。</p><h2 id="使用文件夹表示Xcode中的组"><a href="#使用文件夹表示Xcode中的组" class="headerlink" title="使用文件夹表示Xcode中的组"></a><strong><em>使用文件夹表示Xcode中的组</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你知道，就像在现实生活中一样，你不会将所有衣服都扔到架子上，对吗？ 井井有条是创建一个好的项目的唯一方法。 幸运的是， <code>Apple</code> 也意识到了这一点，现在默认情况下，组以硬盘上的物理文件夹表示。</p><h2 id="始终尝试修复每个警告"><a href="#始终尝试修复每个警告" class="headerlink" title="始终尝试修复每个警告"></a><strong><em>始终尝试修复每个警告</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在警告是有原因的，但是你绝不应在生产代码中留下任何警告。 如果你想变得更激进，可以在Xcode中使用build标志将<a href="http://iosdevelopertips.com/xcode/treat-warnings-as-errors.html" target="_blank" rel="noopener"><strong><em><code>警告视为错误</code></em></strong></a>。 打开它！ 消除所有警告！ 哈哈，不要那样做，但是你应该始终尝试修正所有警告。</p><h2 id="Don’t-let-your-code-to-grow-on-you"><a href="#Don’t-let-your-code-to-grow-on-you" class="headerlink" title="Don’t let your code to grow on you"></a><strong><em>Don’t let your code to grow on you</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你知道这种尴尬的情况，当你打开源文件并开始滚动时，滚动，并且你需要做更多的滚动。 是的，通常这是一个巨大的视图控制器问题，你已经知道自己永远迷路了。 如果到了这一步，你可以尝试通过引入一个新对象来重构代码，该对象可以接管控制器类的某些功能。</p><h2 id="不要重新发明轮子"><a href="#不要重新发明轮子" class="headerlink" title="不要重新发明轮子"></a><strong><em>不要重新发明轮子</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有最佳实践，请使用它。 开始编码之前，应始终查找问题。 在开始编码之前，你还应该仔细考虑问题。 请记住：你并不是唯一一个遇到编码问题的人，我几乎可以保证有人已经遇到了与你正在处理的问题完全相同的问题。  <code>StackOverflow</code> 是寻找解决方案的正确地方。 利用社区的力量，不要害怕在互联网上或从你的同事那里提问，但是不要期望别人会解决你的问题，那就是你的工作。</p></br><h1 id="给初学者的建议-Swift"><a href="#给初学者的建议-Swift" class="headerlink" title="给初学者的建议 Swift"></a><strong>给初学者的建议 Swift</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我将为你提供一些有关如何编写正确的Swift代码的快速建议。我知道我无法在此列表中包含所有内容，但我认为这些是一些非常重要的内容。</p><h2 id="了解如何编写正确的异步代码"><a href="#了解如何编写正确的异步代码" class="headerlink" title="了解如何编写正确的异步代码"></a><strong><em>了解如何编写正确的异步代码</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看，如果你知道厄运的“伟大” <a href="http://www.thomashanning.com/the-pyramid-of-doom/" target="_blank" rel="noopener"><strong><em><code>Pyramid of Doom</code></em></strong></a> 是什么，那么你就会知道我在说什么。你最终将要编写异步代码，大多数API都有异步方法。甚至一个简单的网络任务也是异步的。从一开始就学习如何编写正确的异步代码是明智之举。</p><h2 id="你可以选择几种方法。"><a href="#你可以选择几种方法。" class="headerlink" title="你可以选择几种方法。"></a><strong><em>你可以选择几种方法。</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，你可以通过使用完工块去上学。这是学习该概念的好方法，你可以练习很多，但是有很多更好的方法可以在2020年编写好的异步代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Promises</strong> 是异步任务的高级抽象，它们会让你的生活变得更加美好。你真正的力量来自于你可以使用功能性方法进行链接和转换的事实。 <code>Promises</code> 是惊人的，但实际上并没有内置的取消支持。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以执行 <strong>NSOperation</strong> 任务，但是如果你想使用一些语法糖，建议你使用 <strong>Promises</strong> 。我的问题是，如果必须在操作之间传递数据，则必须创建一个新的操作来执行此操作，但是作为这种不便的交换，它们可以在队列上运行，它们可以具有优先级和依赖性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我相信全新的 <strong>Combine框架</strong> 是2020年处理异步代码的最佳方法。</p><h2 id="仅在必要时使用单例"><a href="#仅在必要时使用单例" class="headerlink" title="仅在必要时使用单例"></a><strong><em>仅在必要时使用单例</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它们是万恶之源。老实说，尽量避免单例。如果你想处理混合状态和不可测试的代码，请与它们一起使用，但是如果你接受我的建议，你的生活会更好。如果你不知道如何避免单例模式，请进行一些研究。网上有很多关于该主题的精彩文章。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个例外：如果你特别在寻找共享状态（例如缓存机制）或本地存储对象（例如UserDefaults），则可以使用单例。否则不要使用单例。</p><h2 id="不要创建-helpers（或-managers）"><a href="#不要创建-helpers（或-managers）" class="headerlink" title="不要创建 helpers（或 managers）"></a><strong><em>不要创建 helpers（或 managers）</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你需要 <code>helpers</code> 课程，那么你做错了！每个对象在你的代码库中都有其自己的位置， <code>helpers</code> 是无用的，对任何事情都没有好处。重新思考，重新定义，重构（如果需要），但不惜一切代价避免使用辅助类。了解 <code>Swift设计模式</code> 或绘制有关模型的图表，但请相信我，代码中没有帮助者的位置。</p><h2 id="避免副作用和全局状态"><a href="#避免副作用和全局状态" class="headerlink" title="避免副作用和全局状态"></a><strong><em>避免副作用和全局状态</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用全局变量是一个非常糟糕的做法。最终，你的代码的某些部分将覆盖global属性，并且事情将变得一团糟。你只需消除这些全局变量即可避免产生副作用。使功能正常运行也是改善代码的一种好方法。</p><h2 id="写一些测试"><a href="#写一些测试" class="headerlink" title="写一些测试"></a><strong><em>写一些测试</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该始终编写测试，我并不是说你应该使用 <code>TDD</code> ，但是 <code>单元测试</code> 是一种好习惯。他们将帮助你考虑可能的错误，并验证你的代码库。 UI测试也很适合验证用户界面，此外，如果不必运行手动测试，则可以节省大量时间。</p></br><h1 id="非技术技能"><a href="#非技术技能" class="headerlink" title="非技术技能"></a><strong>非技术技能</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我知道这是一个清单。不要害怕，你不必一次学习所有内容。开始你的iOS生涯不仅是学习新知识，还应该在旅途中玩得开心。 😊</p><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a><strong><em>时间</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要有耐心和一致。始终每天指定固定的时间进行编码。仅仅半个小时就没关系，如果每天都这样做，就会养成一个习惯，数字也会累加。在这个繁忙的世界中，很难找到时间真正专注于某些事情，但是如果你真的想学习如何编写Swift代码，这是你需要采取的最重要的步骤。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a><strong><em>动机</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你有“梦想”，那么上进很容易。你要构建一个应用程序吗？你是否想学习如何在Swift中写东西？你想找到更好的工作吗？你想为孩子们制作游戏吗？所有这些都可以成为巨大的动力。当你不断遇到障碍时，问题就开始了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要害怕！成为程序员意味着有时你会尝试并失败。如果你想成为一名真正的优秀开发人员，则应该从这些错误中吸取教训，并在第二次做得更好。当然，你也会从其他人那里学到很多东西，但是有时你必须解决自己的问题。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong><em>目标</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要试图追求一个真正的大目标。庆祝小小的成功故事和成就。你还应该为“今天”所做的事情感到自豪。忘记这些小事情很容易，但是开发一个应用程序或学习一种新的编程语言是一个长期的项目。如果你没有时间可以庆祝，那么你最终将失去对“项目”的动力和兴趣。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想学习Swift，我认为这三件事是最重要的非技术技能。每天都有自己专用的时间编写代码。从梦想中获得动力（跟随大局），同时也庆祝你取得的每一个小小的成功故事。循序渐进，你会发现没有什么是你不能学的。无论如何，技术技能只是次要的……🤷️</p></br><h1 id="Swift-社区很棒"><a href="#Swift-社区很棒" class="headerlink" title="Swift 社区很棒"></a><strong>Swift 社区很棒</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很高兴看到仍然有很多专职人员继续撰写有关 <code>iOS/Swift</code> 开发的优缺点的文章。 这是2020年你应该知道的最佳资源。</p><h2 id="最佳iOS-Swift教程网站"><a href="#最佳iOS-Swift教程网站" class="headerlink" title="最佳iOS / Swift教程网站"></a><strong><em>最佳iOS / Swift教程网站</em></strong></h2><ul><li><a href="https://www.raywenderlich.com/" target="_blank" rel="noopener"><strong><em><code>Ray Wenderlich</code></em></strong></a></li><li><a href="https://nshipster.com/" target="_blank" rel="noopener"><strong><em><code>nshipster.com</code></em></strong></a></li><li><a href="https://www.objc.io/blog/" target="_blank" rel="noopener"><strong><em><code>objc.io</code></em></strong></a></li><li><a href="https://www.appcoda.com/" target="_blank" rel="noopener"><strong><em><code>AppCoda</code></em></strong></a></li><li><a href="https://www.pointfree.co/" target="_blank" rel="noopener"><strong><em><code>pointfree.co</code></em></strong></a></li></ul><h2 id="最佳iOS-Swift博客"><a href="#最佳iOS-Swift博客" class="headerlink" title="最佳iOS / Swift博客"></a><strong><em>最佳iOS / Swift博客</em></strong></h2><ul><li><p><a href="https://hackingwithswift.com/" target="_blank" rel="noopener"><strong><em><code>Paul Hudson</code></em></strong></a></p></li><li><p><a href="https://www.swiftbysundell.com/" target="_blank" rel="noopener"><strong><em><code>John Sundell</code></em></strong></a></p></li><li><p><a href="https://www.avanderlee.com/" target="_blank" rel="noopener"><strong><em><code>Antoine van der Lee</code></em></strong></a></p></li><li><p><a href="https://www.vadimbulavin.com/" target="_blank" rel="noopener"><strong><em><code>Vadim Bulavin</code></em></strong></a></p></li><li><p><a href="https://useyourloaf.com/" target="_blank" rel="noopener"><strong><em><code>Keith Harrison</code></em></strong></a></p></li><li><p><a href="https://swiftwithmajid.com/" target="_blank" rel="noopener"><strong><em><code>Majid Jabrayilov</code></em></strong></a></p></li><li><p><a href="https://cocoacasts.com/" target="_blank" rel="noopener"><strong><em><code>Bart Jacobs</code></em></strong></a></p></li><li><p><a href="http://khanlou.com/" target="_blank" rel="noopener"><strong><em><code>Soroush Khanlou</code></em></strong></a></p></li><li><p><a href="https://ericasadun.com/" target="_blank" rel="noopener"><strong><em><code>Erica Sadun</code></em></strong></a></p></li><li><p><a href="https://www.andrewcbancroft.com/" target="_blank" rel="noopener"><strong><em><code>Andrew Bancroft</code></em></strong></a></p></li></ul><h2 id="最佳iOS-Swift新闻通讯"><a href="#最佳iOS-Swift新闻通讯" class="headerlink" title="最佳iOS / Swift新闻通讯"></a><strong><em>最佳iOS / Swift新闻通讯</em></strong></h2><ul><li><a href="http://ios-goodies.com/" target="_blank" rel="noopener"><strong><em><code>iOS Goodies</code></em></strong></a></li><li><a href="https://iosdevweekly.com/" target="_blank" rel="noopener"><strong><em><code>iOS Dev Weekly</code></em></strong></a></li><li><a href="https://andybargh.com/swiftdevelopments/" target="_blank" rel="noopener"><strong><em><code>Swift Developments</code></em></strong></a></li><li><a href="http://indieiosfocus.com/" target="_blank" rel="noopener"><strong><em><code>Indie iOS focus weekly</code></em></strong></a></li></ul><h2 id="最佳iOS-Swift播客"><a href="#最佳iOS-Swift播客" class="headerlink" title="最佳iOS / Swift播客"></a><strong><em>最佳iOS / Swift播客</em></strong></h2><ul><li><a href="https://podcasts.apple.com/us/podcast/ios-dev-discussions-sean-allen/id1426167395" target="_blank" rel="noopener"><strong><em><code>iOS Dev Discussions</code></em></strong></a></li><li><a href="https://podcasts.apple.com/us/podcast/swift-over-coffee/id1435076502" target="_blank" rel="noopener"><strong><em><code>Swift over Coffee</code></em></strong></a></li><li><a href="https://swiftbysundell.com/podcast/" target="_blank" rel="noopener"><strong><em><code>Swift by Sundell</code></em></strong></a></li><li><a href="https://devchat.tv/iphreaks/" target="_blank" rel="noopener"><strong><em><code>iPhreaks</code></em></strong></a></li></ul><h2 id="最佳iOS-Swift播客-1"><a href="#最佳iOS-Swift播客-1" class="headerlink" title="最佳iOS / Swift播客"></a><strong><em>最佳iOS / Swift播客</em></strong></h2><ul><li><a href="https://podcasts.apple.com/us/podcast/ios-dev-discussions-sean-allen/id1426167395" target="_blank" rel="noopener"><strong><em><code>iOS Dev Discussions</code></em></strong></a></li><li><a href="https://podcasts.apple.com/us/podcast/swift-over-coffee/id1435076502" target="_blank" rel="noopener"><strong><em><code>Swift over Coffee</code></em></strong></a></li><li><a href="https://swiftbysundell.com/podcast/" target="_blank" rel="noopener"><strong><em><code>Swift by Sundell</code></em></strong></a></li><li><a href="https://devchat.tv/iphreaks/" target="_blank" rel="noopener"><strong><em><code>iPhreaks</code></em></strong></a></li></ul><h2 id="关注Twitter帐户"><a href="#关注Twitter帐户" class="headerlink" title="关注Twitter帐户"></a><strong><em>关注Twitter帐户</em></strong></h2><ul><li><a href="https://twitter.com/aciidb0mb3r" target="_blank" rel="noopener"><strong><em><code>Ankit Aggarwal</code></em></strong></a></li><li><a href="https://twitter.com/harlanhaskins" target="_blank" rel="noopener"><strong><em><code>Harlan Haskins</code></em></strong></a></li><li><a href="https://twitter.com/nnnnnnnn" target="_blank" rel="noopener"><strong><em><code>Nate Cook</code></em></strong></a></li><li><a href="https://twitter.com/slava_pestov" target="_blank" rel="noopener"><strong><em><code>Slava Pestov</code></em></strong></a></li><li><a href="https://twitter.com/tkremenek" target="_blank" rel="noopener"><strong><em><code>Ted Kremenek</code></em></strong></a></li><li><a href="https://twitter.com/simjp" target="_blank" rel="noopener"><strong><em><code>JP Simard</code></em></strong></a></li><li><a href="https://twitter.com/daniel_dunbar" target="_blank" rel="noopener"><strong><em><code>Daniel Dunbar</code></em></strong></a></li><li><a href="https://twitter.com/dgregor79" target="_blank" rel="noopener"><strong><em><code>Doug Gregor</code></em></strong></a></li><li><a href="https://twitter.com/jckarter" target="_blank" rel="noopener"><strong><em><code>Joe Groff</code></em></strong></a></li><li><a href="https://twitter.com/AirspeedSwift" target="_blank" rel="noopener"><strong><em><code>Ben Cohen</code></em></strong></a></li><li><a href="https://twitter.com/tanner0101" target="_blank" rel="noopener"><strong><em><code>Tanner Wayne Nelson</code></em></strong></a></li><li><a href="https://twitter.com/ashfurrow" target="_blank" rel="noopener"><strong><em><code>Ash Furrow</code></em></strong></a></li><li><a href="https://twitter.com/olebegemann" target="_blank" rel="noopener"><strong><em><code>Ole Begemann</code></em></strong></a></li><li><a href="https://twitter.com/_bartjacobs" target="_blank" rel="noopener"><strong><em><code>Bart Jacobs</code></em></strong></a></li><li><a href="https://twitter.com/daveverwer" target="_blank" rel="noopener"><strong><em><code>Dave Verwer</code></em></strong></a></li><li><a href="https://twitter.com/rwenderlich" target="_blank" rel="noopener"><strong><em><code>Ray Wenderlich</code></em></strong></a></li><li><a href="https://twitter.com/objcio" target="_blank" rel="noopener"><strong><em><code>objc.io</code></em></strong></a></li><li><a href="https://twitter.com/NSHipster" target="_blank" rel="noopener"><strong><em><code>NSHipster</code></em></strong></a></li><li><a href="https://twitter.com/merowing_" target="_blank" rel="noopener"><strong><em><code>Krzysztof Zabłocki</code></em></strong></a></li><li><a href="https://twitter.com/krzyzanowskim" target="_blank" rel="noopener"><strong><em><code>Marcin Krzyzanowski</code></em></strong></a></li><li><a href="https://twitter.com/steipete" target="_blank" rel="noopener"><strong><em><code>Peter Steinberger</code></em></strong></a></li><li><a href="https://twitter.com/chriseidhof" target="_blank" rel="noopener"><strong><em><code>Chris Eidhof</code></em></strong></a></li><li><a href="https://twitter.com/khanlou" target="_blank" rel="noopener"><strong><em><code>soroush</code></em></strong></a></li><li><a href="https://twitter.com/ericasadun" target="_blank" rel="noopener"><strong><em><code>ericasadun</code></em></strong></a></li><li><a href="https://twitter.com/clattner_llvm" target="_blank" rel="noopener"><strong><em><code>Chris Lattner</code></em></strong></a></li><li><a href="https://twitter.com/siracusa" target="_blank" rel="noopener"><strong><em><code>John Siracusa</code></em></strong></a></li><li><a href="https://twitter.com/siracusa" target="_blank" rel="noopener"><strong><em><code>Sean Allen</code></em></strong></a></li><li><a href="https://twitter.com/marcoarment" target="_blank" rel="noopener"><strong><em><code>Marco Arment</code></em></strong></a></li><li><a href="https://twitter.com/twostraws" target="_blank" rel="noopener"><strong><em><code>Paul Hudson</code></em></strong></a></li><li><a href="https://twitter.com/johnsundell" target="_blank" rel="noopener"><strong><em><code>John Sundell</code></em></strong></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift URLSession 和 Combine framework</title>
      <link href="/Swift%20URLSession%20%E5%92%8C%20Combine%20framework/"/>
      <url>/Swift%20URLSession%20%E5%92%8C%20Combine%20framework/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用带有 <code>基础网络</code> 的全新 <code>Combine框架</code> 发出 <code>HTTP请求</code> 并解析响应。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这将是一个非常简短但希望非常有用的教程，它讲述了我如何开始利用 <a href="https://heckj.github.io/swiftui-notes/" target="_blank" rel="noopener"><strong><em><code>Combine框架</code></em></strong></a> 来缓慢替换 <code>Promise库</code> 。 🤫</p></br><h1 id="API-amp-data-structure"><a href="#API-amp-data-structure" class="headerlink" title="API &amp; data structure"></a><strong>API &amp; data structure</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们将需要某种API进行连接，像往常一样，我将对以下数据模型使用我最喜欢的 <a href="https://jsonplaceholder.typicode.com/" target="_blank" rel="noopener"><strong><em><code>JSONPlaceholder</code></em></strong></a> 服务：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTPError</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> statusCode</span><br><span class="line">    <span class="keyword">case</span> post</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> body: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> userId: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Todo</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> completed: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">let</span> userId: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，没有什么特别的，只是一些基本的 <code>Codable元素</code> 和一个简单的错误，如果某件事失败，我们希望显示一些错误。 ❌</p></br><h1 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a><strong>传统方式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中执行 <code>HTTP请求</code> 非常容易，你可以将内置的共享 <code>URLSession</code> 与简单的数据任务结合使用，然后响应一下。 当然，你可能想检查有效的状态码，如果一切正常，则可以使用 <code>Foundation</code> 中的 <code>JSONDecoder</code> 对象来 <a href=""""><strong><em><code>解析响应JSON</code></em></strong></a> 。</p><!-- more --><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//somewhere in viewDidLoad</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Error: \(error.localizedDescription)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>, response.statusCode == <span class="number">200</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Error: invalid HTTP response code"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Error: missing response data"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">        <span class="keyword">let</span> posts = <span class="keyword">try</span> decoder.decode([<span class="type">Post</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">        <span class="built_in">print</span>(posts.<span class="built_in">map</span> &#123; $<span class="number">0</span>.title &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error: \(error.localizedDescription)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task.resume()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要忘记继续 <strong>执行</strong> 数据任务，否则该请求将根本不会触发。 🔥</p></br><h1 id="Data-tasks-和-the-Combine-framework"><a href="#Data-tasks-和-the-Combine-framework" class="headerlink" title="Data tasks 和 the Combine framework"></a><strong>Data tasks 和 the Combine framework</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在你可以看到传统的 <code>“基于块”</code> 的方法很好，但是我们可以在这里做些更好的事情吗？ 你知道吗，就像将整个事物描述成一个链条一样，就像我们过去对 <code>Promises</code> 所做的那样？ 从 <code>iOS13</code> 开始，借助惊人的 <code>Combine框架</code> ，你实际上可以超越！ 😃</p><p><strong><em><code>我最喜欢组合的部分是内存管理和取消。</code></em></strong></p><h2 id="合并数据任务"><a href="#合并数据任务" class="headerlink" title="合并数据任务"></a><strong><em>合并数据任务</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，最常见的示例通常是以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> cancellable: <span class="type">AnyCancellable?</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">self</span>.cancellable = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url)</span><br><span class="line">.<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;</span><br><span class="line">.decode(type: [<span class="type">Post</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line">.replaceError(with: [])</span><br><span class="line">.eraseToAnyPublisher()</span><br><span class="line">.sink(receiveValue: &#123; posts <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(posts.<span class="built_in">count</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">self</span>.cancellable?.cancel()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我喜欢代码 <code>“解释自己”</code> 的方式：</p><ul><li>首先，我们为你的 Publisher 制作一个可取消的存储</li><li>然后，我们创建一个全新的数据任务 publisher 对象</li><li>映射响应，我们只关心数据部分（忽略错误）</li><li>使用 JSONDecoder 解码数据的内容</li><li>如果有任何问题，请使用一个空数组</li><li>消除基本复杂性到简单的 AnyPublisher </li><li>使用接收器显示有关最终值的一些信息</li><li>可选：你可以随时取消网络请求</li></ul><h2 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a><strong><em>Error handling</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们介绍一些 <a href="https://medium.com/codequest/error-handling-in-combine-b6150a9fc2a7" target="_blank" rel="noopener"><strong><em><code>错误处理</code></em></strong></a> ，因为我不喜欢隐藏错误的想法。 发出带有实际错误消息的警报要好得多，不是吗？ 🤔</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTPError</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> statusCode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.cancellable = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url)</span><br><span class="line">.tryMap &#123; output <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> response = output.response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>, response.statusCode == <span class="number">200</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">HTTPError</span>.statusCode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output.data</span><br><span class="line">&#125;</span><br><span class="line">.decode(type: [<span class="type">Post</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line">.eraseToAnyPublisher()</span><br><span class="line">.sink(receiveCompletion: &#123; completion <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> completion &#123;</span><br><span class="line">    <span class="keyword">case</span> .finished:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">fatalError</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, receiveValue: &#123; posts <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(posts.<span class="built_in">count</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，这次我们检查响应代码，如果出现问题，则抛出错误。 现在，由于 <code>publisher</code> 可能会导致错误状态，因此 <code>sink</code> 具有另一个变体，你可以在其中检查整个操作的结果，以便在那里进行自己的错误操作，例如显示警报。 🚨</p><h2 id="将结果分配给属性"><a href="#将结果分配给属性" class="headerlink" title="将结果分配给属性"></a><strong><em>将结果分配给属性</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个常见的模式是将响应存储在视图控制器中某个位置的内部变量中。 你可以简单地通过使用 <code>assign函数</code> 来做到这一点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cancellable: <span class="type">AnyCancellable?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> posts: [<span class="type">Post</span>] = [] &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"posts --&gt; \(self.posts.count)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>)!</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.cancellable = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url)</span><br><span class="line">        .<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;</span><br><span class="line">        .decode(type: [<span class="type">Post</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line">        .replaceError(with: [])</span><br><span class="line">        .eraseToAnyPublisher()</span><br><span class="line">        .assign(to: \.posts, on: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非常简单，你还可以使用 <code>didSet</code> 属性观察器来获取有关更改的通知。</p><h2 id="分组多个请求"><a href="#分组多个请求" class="headerlink" title="分组多个请求"></a><strong><em>分组多个请求</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过去，发送多个请求是一个痛苦的过程。 现在我们有了 <code>Compose</code> ，使用 <code>Publishers.Zip</code> 可以轻松完成此任务。 你可以将多个请求合并在一起，然后等待它们都完成。 🤐</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url1 = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>)!</span><br><span class="line"><span class="keyword">let</span> url2 = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> publisher1 = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url1)</span><br><span class="line">.<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;</span><br><span class="line">.decode(type: [<span class="type">Post</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> publisher2 = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url2)</span><br><span class="line">.<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;</span><br><span class="line">.decode(type: [<span class="type">Todo</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.cancellable = <span class="type">Publishers</span>.<span class="type">Zip</span>(publisher1, publisher2)</span><br><span class="line">.eraseToAnyPublisher()</span><br><span class="line">.<span class="keyword">catch</span> &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="type">Just</span>(([], []))</span><br><span class="line">&#125;</span><br><span class="line">.sink(receiveValue: &#123; posts, todos <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(posts.<span class="built_in">count</span>)</span><br><span class="line">    <span class="built_in">print</span>(todos.<span class="built_in">count</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在我们和以前一样，只是将两个 <code>publishers</code> 压缩在一起。</p><h2 id="请求依赖"><a href="#请求依赖" class="headerlink" title="请求依赖"></a><strong><em>请求依赖</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 有时，你必须从给定的URL加载资源，然后使用另一个资源以其他方式扩展对象。 我说的是请求依赖，如果没有 <code>Combine</code> ，这将是一个很大的问题，但是现在你可以将两个 <code>HTTP调用</code> 与几行 <code>Swift</code> 代码链接在一起。 让我给你演示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> url1 = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>)!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.cancellable = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url1)</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;</span><br><span class="line">    .decode(type: [<span class="type">Post</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line">    .tryMap &#123; posts <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> id = posts.first?.id <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">HTTPError</span>.post</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id</span><br><span class="line">    &#125;</span><br><span class="line">    .flatMap &#123; id <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.details(<span class="keyword">for</span>: id)</span><br><span class="line">    &#125;</span><br><span class="line">    .sink(receiveCompletion: &#123; completion <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    &#125;) &#123; post <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(post.title)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">details</span><span class="params">(<span class="keyword">for</span> id: Int)</span></span> -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">Post</span>, <span class="type">Error</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts/\(id)"</span>)!</span><br><span class="line">    <span class="keyword">return</span> <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url)</span><br><span class="line">        .mapError &#123; $<span class="number">0</span> <span class="keyword">as</span> <span class="type">Error</span> &#125;</span><br><span class="line">        .<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;</span><br><span class="line">        .decode(type: <span class="type">Post</span>.<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line">        .eraseToAnyPublisher()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的技巧是你可以将一个 <code>publisher</code> <strong><code>flatMap</code></strong> 映射到另一个 <code>publisher</code> 。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Combine</code> 是一个了不起的框架，它可以完成很多工作，但是肯定有一些学习过程。 可悲的是，仅当你针对 <code>iOS13或更高版本</code> 时才可以使用它（这意味着你有一年的时间来学习框架的每一点），因此在采用这种新技术之前请三思而后行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还应该注意，当前没有 <a href="http://www.xuebaonline.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Codable%20protocol%E5%9C%A8Swift%E4%B8%AD%E8%A7%A3%E6%9E%90JSON%EF%BC%9F/"><strong><em><code>上载和下载任务publisher</code></em></strong></a> ，但是你可以制定自己的解决方案，直到Apple正式发布某些东西。  🤞</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我真的很喜欢 <code>Apple</code> 如何实现 ··· 的一些概念，我迫不及待地希望 <code>Combine</code> 成为具有 <code>Linux</code> 支持的开源软件包。 ❤️</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Combine framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Combine framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift Promises 探究</title>
      <link href="/Swift%20Promises%20%E6%8E%A2%E7%A9%B6/"/>
      <url>/Swift%20Promises%20%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Promises</code> 是链接异步任务的一种方法。 通常，异步任务以块的形式进行回调（或有时两个，一个用于成功，一个用于失败），该回调在异步操作完成时被调用。 要执行多个异步操作，你必须将第二个嵌套在第一个的完成块中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">APIClient</span>.fetchCurrentUser(success: &#123; currentUser <span class="keyword">in</span></span><br><span class="line"><span class="type">APIClient</span>.fetchFollowers(user: currentUser, success: &#123; followers <span class="keyword">in</span></span><br><span class="line"><span class="comment">// you now have an array of followers</span></span><br><span class="line">&#125;, failure: &#123; error <span class="keyword">in</span></span><br><span class="line"><span class="comment">// handle the error</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;, failure: &#123; error <span class="keyword">in</span></span><br><span class="line"><span class="comment">// handle the error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Promises</code> 是一种形式化这些完成模块的方法，以使链接异步过程变得更加容易。 如果系统知道成功和失败的代码，那么编写这些异步操作将变得更加容易。 例如，编写可重复使用的代码可以：</p><ul><li>最后执行一个相关的异步操作链，并带有一个完成块</li><li>一个完成块同时执行许多独立的异步操作</li><li>开启许多异步操作并返回第一个要完成的值</li><li>重试异步操作</li><li>为异步操作添加超时</li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码示例转换为 <code>Promise</code> 时，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">APIClient</span>.fetchCurrentUser().then(&#123; currentUser <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">APIClient</span>.fetchFollowers(user: currentUser)</span><br><span class="line">&#125;).then(&#123; followers <span class="keyword">in</span></span><br><span class="line"><span class="comment">// you now have an array of followers</span></span><br><span class="line">)&#125;.onFailure(&#123; error <span class="keyword">in</span></span><br><span class="line"><span class="comment">// hooray, a single failure block!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（你会注意到， <code>promise</code> 是将嵌套/缩进代码转换为 <code>flat</code> 代码的东西： <code>promise</code> 是 <code>monad</code> 。）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>JavaScript社区</code> 中， <code>promise</code> 逐渐兴起。因为 <code>Node.js</code> 被设计为具有许多异步功能，所以即使是简单的任务也需要具有异步回调的方法调用链。即使仅执行了其中的3或4个操作，操作也变得很笨拙。 <code>Promise</code> 挽救了这一天，现在已成为 <code>JavaScript ES6</code> 官方规范的一部分。这篇<a href="http://www.mattgreer.org/articles/promises-in-wicked-detail/" target="_blank" rel="noopener"><strong><code>博客文章</code></strong></a> 详细介绍了 <code>JavaScript</code> 的 <code>promise</code> 如何运作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>JavaScript Promise</code> 实现的一大优点是有一个非常明确定义的规范，称为 <strong>A +</strong> ，可以在 <a href="https://www.promisejs.org/" target="_blank" rel="noopener"><strong><code>promisejs.org</code></strong></a> 中找到。这意味着由于 <code>JavaScript</code> 的弱类型系统，可能会出现多个 <code>promise</code> 实现，并且它们可以完全互操作。只要你的 <code>Promise</code> 实现具有符合规范的 <code>then函数</code> ，就可以将其与其他库中的 <code>promise链接</code> 在一起。这太棒了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编写 <code>Backchannel API（位于Node中）</code> 时，我开始喜欢 <code>Promises</code> 。  <strong>A+规范</strong> 具有一个非常不错的 <code>API</code> ，避免了你希望在 <code>monad</code> 上使用的功能名称，以便于这样更简单，更易于理解（将其重载为 <code>flatMap和map</code> ）。尽管该 <code>API</code> 并非适合所有人（特别是，我可以完全理解为什么你偏爱函数名称的显式性），但我确实很喜欢它，并且着手在 <code>Swift</code> 中实现类似的库。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以在 <a href="https://github.com/khanlou/Promise" target="_blank" rel="noopener"><strong><code>Github</code></strong></a> 上找到此库。编写过程很有启发性，我想分享一些我在这里学到的东西。</p></br><h1 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a><strong>Enums</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是的，大家都知道。 枚举很棒。 但是因为 <code>Promises</code> 本质上是一个 <strong>状态机</strong> ，所以枚举在这里特别适合。  <code>JavaScript</code> 的 <code>Promise</code> 的参考实现开始如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="type">PENDING</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="type">FULFILLED</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="type">REJECTED</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">function <span class="type">Promise</span>() &#123;</span><br><span class="line">  <span class="comment">// store state which can be PENDING, FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">var</span> state = <span class="type">PENDING</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store value or error once FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">var</span> value = null;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store success &amp; failure handlers attached by calling .then or .done</span></span><br><span class="line">  <span class="keyword">var</span> handlers = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果尝试，我无法为 <code>Swift的枚举</code> 构想出更完美的例子。 这是 <code>Swift</code> 中的相同代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">State</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Pending</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Fulfilled</span>(value: <span class="type">Value</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Rejected</span>(error: <span class="type">ErrorType</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Promise</span>&lt;<span class="title">Value</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> state: <span class="type">State</span>&lt;<span class="type">Value</span>&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> callbacks: [<span class="type">Callback</span>&lt;<span class="type">Value</span>&gt;] = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于附加数据取决于 <code>Promise</code> 所处的特定状态，因此附加数据将作为关联值存储在每个枚举案例中。 由于将 <code>Promise</code> 置于 <code>.Pending状态</code> 并没有任何价值，因此枚举使其在类型系统中完全无法表达。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我唯一的批评是，泛型类型不能嵌套在其他类型中。</p></br><h1 id="Type-systems"><a href="#Type-systems" class="headerlink" title="Type systems"></a><strong>Type systems</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建新的 <code>JavaScript Promise</code> 时，可以使用便捷的初始化程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">someAsyncRequest(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">reject(error);</span><br><span class="line">&#125;</span><br><span class="line">resolve(result);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你将其传递给一个具有以下两个功能的函数：一个用于 <code>Promise</code> 是否成功，另一个用于 <code>Promise</code> 是否失败。 对于这两个功能，顺序很重要。 而且由于 <code>JavaScript</code> 不是类型安全的，如果你在上面第一行中对函数进行了错误排序，编写了 <code>reject</code> ， <code>resolve</code> （我做得比我想承认的要多得多），你可以轻松地将错误传递给 resolve 功能。 <code>另一方面，Swift</code> 的类型安全性意味着 <code>reject</code> 函数的类型为 <code>（ErrorType）-&gt; Void</code> ，并且不会接受你的成功结果。 担心我会搞混 <code>reject</code> 和 <code>resolve</code> 功能的顺序，这已经成为过去。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Promise类型</code> 是 <code>Value</code> 之上的泛型， <code>Value</code> 是它产生的值的类型。 这意味着你可以依靠类型推断来编写没有类型的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>(value: <span class="string">"initialValue"</span>) <span class="comment">// a fulfilled Promise&lt;String&gt;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>promise</code> 通常是链接在一起的，因此依靠推断来找出你的类型将是特别有用的。 必须在链中的每个步骤中添加显式类型将非常令人沮丧，并且最终不会特别像 <code>Swift</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对此的第一个破解也是对 <code>Error的泛型</code> 。 这种严格性意味着要实现 <code>promise</code> ，就需要你每次都预先指定错误的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>&lt;<span class="built_in">String</span>, APIError&gt;(value: <span class="string">"initialValue"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这在以前的简单代码行中增加了很多不必要的负担，因此我删除了指定错误类型的功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不幸的是，删除显式错误类型意味着我不得不错过一个小型的类型系统好东西。 如果你创建一个名为 <code>NoError</code> 的空枚举，则可以有效地表示诺言不会失败。 由于无法初始化空的枚举，因此无法使 <code>promise</code> 进入 <code>rejected</code> 状态。 这是一个可悲的损失，但是最终，我认为这是值得的，因为它使在其他情况下使用 <code>promise</code> 更加简单。 我希望在实践中使用该课程可以让我深入了解这是否是一个明智的决定。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与此相关， <code>Swift</code> 的泛型清单包含 <code>“默认泛型参数”</code> ，这将是解决此问题的好方法：你可以说默认值为 <code>ErrorType</code> ，并且如果有人想更具体地讲，他们就有这种能力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Promise</code> 类型是 <code>monad</code> ，这意味着你可以在其上调用 <code>flatMap</code> 。你传递给 <code>flatMap</code> 的函数将返回一个新的 <code>Promise</code> ，并且 <code>Promise</code> 的状态成为链的状态。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是， <code>flatMap函数</code> 的名称是完全不可理解的。它无法以一种易于阅读的方式来表示此处实际发生的情况。这是我偏爱 <code>A+</code> 的 <code>Promise API</code> 的部分原因。  <code>JavaScript</code> 中的 <code>then函数</code> 被重载，以充当 <code>flatMap</code> （为链返回一个新的承诺）和 <code>map</code> （为链中的下一个承诺返回一个新值）。那么现在的意思就是“不做下一步”，而不必考虑下一步的工作方式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>Swift的类型系统</code> 知道函数何时返回 <code>Void</code> ，因此还可以重载以接受不返回任何内容的函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦编写了该类的基本实现，就编写了一些测试。 我对 <code>XCTest</code> 的 <code>ExpectationWithDescription</code> 和 <code>waitForExpectationsWithTimeout</code> 有了一些经验，它们是非常不错的 <code>API</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为 <code>Promise类</code> 提供一整套测试非常有用。 与往常一样，编写测试会产生一些前期费用，但这完全值得。 当我重构和清理此代码时，测试捕获了许多错误。  <code>promise</code> 实现非常多样，有关代码执行顺序的微小细节以微妙的方式改变了类的行为。 拥有一个确认重构确实是同构的测试套件非常棒。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为 <code>Promise</code> 本质上处理 线程和异步性 ，所以它必须是 <code>线程安全</code> 的类。为了使该类具有线程安全性，需要从同一队列中全部访问其实例变量。这比我预期的要难。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别是其中两个测试非常不稳定，我运行测试套件每5-10次就会失败一次。没有什么比片状测试更可怕的了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中一项不稳定的测试导致了 <code>EXC_BAD_ACCESS</code> 的产生，这非常令人困惑，因为我无法想到 <code>Swift</code> 中的一种方式来访问不良内存。我花了一段时间，但最终得到一条日志消息，提示它是线程问题。我正在同时将多个线程中的东西添加到数组中。我更正了访问实例变量的代码，以正确使用调度队列，并且不稳定的测试变得可靠。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Promises </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Promises </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift Promises 初体验</title>
      <link href="/Swift%20Promises%20%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/Swift%20Promises%20%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你想要了解的有关 <code>futures</code> 和 <code>promises</code> 的一切。 关于 <code>Swift</code> 中异步编程的初学者指南。</p></br><h1 id="同步与异步执行"><a href="#同步与异步执行" class="headerlink" title="同步与异步执行"></a><strong>同步与异步执行</strong></h1><blockquote><p>编写异步代码是构建应用程序中最难的部分之一。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>同步执行</code> 和 <code>异步执行</code> 之间到底有什么区别？ 好了，我已经在 <a href="http://www.xuebaonline.com/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Swift%E4%B8%AD%E7%9A%84Grand%20Central%20Dispatch/"><strong><em><code>Dispatch框架教程</code></em></strong></a> 中对此进行了解释，但是这里有一个简短的回顾。 同步函数通常会阻塞当前线程，并在以后返回一些值。 一个异步函数将立即返回并将结果值传递给完成处理程序。 你可以使用GCD框架在给定队列上异步执行任务同步。 让我给你看一个简单的例子：</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aBlockingFunction</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    sleep(.random(<span class="keyword">in</span>: <span class="number">1</span>...<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syncMethod</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aBlockingFunction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asyncMethod</span><span class="params">(completion block: @escaping <span class="params">(<span class="params">(String)</span></span></span></span> -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global(qos: .background).async &#123;</span><br><span class="line">        block(aBlockingFunction())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(syncMethod())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"sync method returned"</span>)</span><br><span class="line">asyncMethod &#123; value <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"async method returned"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// "Hello world!"</span></span><br><span class="line"><span class="comment">// "sync method returned"</span></span><br><span class="line"><span class="comment">// "async method returned"</span></span><br><span class="line"><span class="comment">// "Hello world!"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见， <code>async方法</code> 完全在后台队列上运行，该函数不会阻塞当前线程。 这就是为什么异步方法可以立即返回的原因，因此你将始终在最后一个 <code>hello</code> 输出之前看到 <code>return</code> 输出。 存储异步方法的完成块以供以后执行，这就是为什么可以在原始函数返回之后以回调方式返回字符串值的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不使用其他队列会怎样？ 完成块将在当前队列上执行，因此你的函数将对其进行阻止。 这将有点异步，但是实际上你只是将返回值移到完成块中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syncMethod</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fakeAsyncMethod</span><span class="params">(completion block: <span class="params">(<span class="params">(String)</span></span></span></span> -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">    block(<span class="string">"Hello world!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(syncMethod())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"sync method returned"</span>)</span><br><span class="line">fakeAsyncMethod &#123; value <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"fake async method returned"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，我真的不想集中讨论完成块，这可能是一篇独立的文章，但是如果你在并发模型上仍然遇到问题，或者你不了解任务和线程的工作方式，则应该阅读一下 很少研究。</p></br><h1 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a><strong>回调地狱</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;异步代码有什么问题？ 还是编写异步代码的结果是什么？ 简短的答案是，你必须使用完成块（回调）才能处理将来的结果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更详细的答案是管理回调很糟糕。 你必须要小心，因为在一个块中你可以轻松地创建一个 <code>retain-cycle</code> ，因此你必须将变量作为弱引用或 <code>unowned references</code> 来传递。 另外，如果必须使用多个异步方法，那将是非常的痛苦。 🐴</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Todo</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> completed: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Network error: "</span> + error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Not a HTTP response"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> response.statusCode &lt;= <span class="number">200</span>, response.statusCode &gt; <span class="number">300</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Invalid HTTP status code"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"No HTTP data"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> todos = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode([<span class="type">Todo</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">        <span class="built_in">print</span>(todos)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"JSON decoder error: "</span> + error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码段是一个简单的 <code>异步HTTP数据请求</code> 。 如你所见，其中涉及许多可选值，而且，如果要使用自己的类型，则必须执行一些 <code>JSON解析</code> 。 这只是一个请求，但是如果你需要从第一个元素中获取一些详细信息怎么办？ 让我们写一个助手！ ＃没有🤫</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(<span class="number">_</span> url: URL, completion: @escaping <span class="params">(<span class="params">(Data)</span></span></span></span> -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">    <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Network error: "</span> + error.localizedDescription)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Not a HTTP response"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> response.statusCode &lt;= <span class="number">200</span>, response.statusCode &gt; <span class="number">300</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid HTTP status code"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"No HTTP data"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        completion(data)</span><br><span class="line">    &#125;.resume()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos"</span>)!</span><br><span class="line">request(url) &#123; data <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> todos = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode([<span class="type">Todo</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> first = todos.first <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos/\(first.id)"</span>)!</span><br><span class="line">        request(url) &#123; data <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> todo = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">Todo</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">                <span class="built_in">print</span>(todo)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="built_in">fatalError</span>(<span class="string">"JSON decoder error: "</span> + error.localizedDescription)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"JSON decoder error: "</span> + error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到？ 我的问题是我们正在慢慢地向兔子洞下移动。 现在，如果我们有第三个请求怎么办？ 一定不行！ 你必须将所有内容再嵌套一层，而且还必须传递必要的变量，例如。 <code>weak</code> 或 <code>unowned</code> 的视图控制器引用，因为在某个时间点，你必须根据结果更新整个UI。 必须有更好的方法来解决此问题。 🤔</p></br><h1 id="Results-vs-futures-vs-promises"><a href="#Results-vs-futures-vs-promises" class="headerlink" title="Results vs futures vs promises?"></a><strong>Results vs futures vs promises?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.xuebaonline.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Result%20Type%E6%9D%A5%E5%A4%84%E7%90%86Swift%205%E4%B8%AD%E7%9A%84Errors%EF%BC%9F/"><strong><em><code>result type</code></em></strong></a> 是在 <code>Swift 5</code> 中引入的，它对于从公式中消除可选因子非常有用。 这意味着你不必处理可选的数据和可选的错误类型，但是结果就是其中之一。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Futures</strong> 基本上代表着 <code>Futures</code> 的价值。 基础值可以是例如结果，并且应具有以下状态之一：</p><ul><li><strong>pending</strong> - 尚无价值，正在等待…</li><li><strong>fulfilled</strong> - 成功，现在结果有价值</li><li><strong>rejected</strong> - 失败并出现错误</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据定义， <code>futures</code> 不应由最终用户编写。 这意味着开发人员不应创建，实现或拒绝开发者。 但是，如果是这样，并且我们遵守规则，我们将如何制作 <code>futures</code> ？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们向他们保证。 你必须创建一个 <code>Promise</code> ，基本上是一个 <code>futures</code> 的包装，可以根据需要编写（实现，拒绝）或转换。 你不写 <code>futures</code> ，而是 <code>Promise</code> 。 但是，有些框架允许你取回 <code>Promise</code> 的 <code>futures values</code> ，但你根本不应该写那个 <code>futures</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;足够的理论，你准备好爱上 <code>Promise</code> 了吗？ ❤️</p></br><h1 id="Promises-101-入门指南"><a href="#Promises-101-入门指南" class="headerlink" title="Promises 101-入门指南"></a><strong>Promises 101-入门指南</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们使用 <a href="https://github.com/CoreKit/Promises" target="_blank" rel="noopener"><strong><em><code>promise框架</code></em></strong></a> 重构前面的示例！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">HTTPError</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> invalidResponse</span><br><span class="line">        <span class="keyword">case</span> invalidStatusCode</span><br><span class="line">        <span class="keyword">case</span> noData</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dataTask</span><span class="params">(url: URL)</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">Data</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">Data</span>&gt; &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] fulfill, reject <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="type">HTTPError</span>.invalidResponse)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">guard</span> response.statusCode &lt;= <span class="number">200</span>, response.statusCode &gt; <span class="number">300</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="type">HTTPError</span>.invalidStatusCode)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="type">HTTPError</span>.noData)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                fulfill(data)</span><br><span class="line">            &#125;.resume()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TodoError</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> missing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos"</span>)!</span><br><span class="line"><span class="type">URLSession</span>.shared.dataTask(url: url)</span><br><span class="line">.thenMap &#123; data <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode([<span class="type">Todo</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">&#125;</span><br><span class="line">.thenMap &#123; todos -&gt; <span class="type">Todo</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> first = todos.first <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">TodoError</span>.missing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br><span class="line">.then &#123; first <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos/\(first.id)"</span>)!</span><br><span class="line">    <span class="keyword">return</span> <span class="type">URLSession</span>.shared.dataTask(url: url)</span><br><span class="line">&#125;</span><br><span class="line">.thenMap &#123; data <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">Todo</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">&#125;</span><br><span class="line">.onSuccess &#123; todo <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(todo)</span><br><span class="line">&#125;</span><br><span class="line">.onFailure(queue: .main) &#123; error <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚刚发生什么事了？ 好吧，我整理了在 <code>URLSession对象</code> 上实现的数据任务方法的扩展版本。 当然，如果你需要网络层的更多信息，则可以返回 <code>HTTP结果</code> 或仅返回状态代码以及数据。 你可以使用新的响应数据模型，甚至可以使用元组。 🤷‍♂️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，更有趣的部分是源的下半部分。 如你所见，我正在调用全新的 <code>dataTask方法</code> ，该方法返回 <code>Promise &lt;Data&gt;</code>对象。 正如我之前提到的，诺言可以转换。 还是我应该说： <code>chained</code> ？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Chaining promises</code> 是优于回调的最大优势。 源代码看起来不再像是带有疯狂压痕和尝试捕获块的金字塔，而是更像是一连串的动作。 在每一步中，你都可以将先前的结果值转换为其他值。 如果你熟悉一些功能范例，那么将很容易理解以下内容：</p><ul><li><strong><code>thenMap</code></strong> 是 Promise 上的 map</li><li><strong><code>then</code></strong> 基本上是 Promise 上的 flatMap </li><li><strong><code>onSuccess</code></strong> 仅当链中一切正常时才调用 onSuccess</li><li><strong><code>onFailure</code></strong> 仅当链中发生某些错误时，才会调用onFailure</li><li><strong><code>always</code></strong> 始终运行，无论结果如何</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要获取 <code>主队列</code> ，则可以像通过 <code>onFailure</code> 方法一样，通过队列参数进行传递，但是它适用于链中的每个元素。 以上这些功能只是冰山一角。 你还可以进入一条链， <code>validate</code> 结果，对其进行 <code>timeout</code> 或从失败的 <code>promises</code> 中 <code>recover</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一个 <code>Promises命名空间</code> ，用于其他有用的方法，例如 <code>zip</code> ，它可以将 <code>2、3或4种不同类型的promise</code> 压缩在一起。 就像 <code>Promises.all方法</code> 一样， <code>zip函数</code> 会等到每个 <code>promises</code> 都完成后，再在一个块中为你提供所有 <code>promises</code> 的结果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//executing same promises from the same kind, eg. [Promise&lt;Data&gt;]</span></span><br><span class="line"><span class="type">Promises</span>.all(promises)</span><br><span class="line">.thenMap &#123; arrayOfResults <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// e.g. [Data]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//zipping together different kind of promises, eg. Proimse&lt;[Todos]&gt;, Promise&lt;Todo&gt;;</span></span><br><span class="line"><span class="type">Promises</span>.<span class="built_in">zip</span>(promise1, promise2)</span><br><span class="line">.thenMap &#123; result1, result2 <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//e.g [Todos], Todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还值得一提的是， <code>Promises名称空间</code> 下有一个 <code>first</code> ， <code>delay</code> ， <code>timeout</code> ， <code>race</code> ， <code>wait</code> 和 <code>retry</code> 方法。 也可以随意使用它们，有时它们也非常有用和强大。 💪</p></br><h1 id="Promises-有两个问题"><a href="#Promises-有两个问题" class="headerlink" title="Promises 有两个问题"></a><strong>Promises 有两个问题</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个问题是 <strong>取消</strong> 。 你不能简单地取消 <code>running Promises</code> 。 这是可行的，但是它需要一些高级技术或某些说“ hacky”技术。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个是 <strong>异步/等待</strong> 。 如果你想了解更多有关它的信息，则应该阅读Chis Lattner的<a href="https://gist.github.com/lattner/31ed37682ef1576b16bca1432ea9f782" target="_blank" rel="noopener"><strong><em><code>并发宣言</code></em></strong></a>，因此我们只能说这两个关键字可以在代码中添加一些语法糖。 你将不再需要多余的行（然后是 <code>thenMap</code> ， <code>onSuccess</code> ， <code>onFailure</code> ），这样你就可以专注于代码了。 我真的希望我们能在 <code>Swift 6</code>中得到类似的东西，这样我就可以永久丢弃 <code>Promise库</code> 。 哦，顺便说一句， <strong>libraries</strong> …</p></br><h1 id="Promise-值得一看"><a href="#Promise-值得一看" class="headerlink" title="Promise 值得一看"></a><strong>Promise 值得一看</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章值得一读 <a href="http://www.xuebaonline.com/Swift%20Promises%20%E6%8E%A2%E7%A9%B6/"><strong><em><code>Promises In Swift</code></em></strong></a>。 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>github</code> 上有很多 <code>promise库</code> ，但是如果我不得不从中选择（而不是我自己的实现），我肯定会选择以下其中一个：</p><ul><li><a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener"><strong><code>PromiseKit</code></strong></a> - 最受欢迎的一款</li><li><a href="https://github.com/google/promises" target="_blank" rel="noopener"><strong><code>Promises</code></strong></a>  - Google的，功能丰富，也很受欢迎</li><li><a href="https://github.com/khanlou/promise" target="_blank" rel="noopener"><strong><code>Promise</code></strong></a> - 小，但基于<code>JavaScript Promises/A+</code>规范</li><li><a href="https://github.com/apple/swift-nio" target="_blank" rel="noopener"><strong><code>SwiftNIO</code></strong></a> - 不是一个实际的 <code>Promise库</code> ，但是它在后台有一个编写精美的基于事件循环的 <code>Promise</code> 实现</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;专家提示：不要尝试制作自己的 <strong>Promise框架</strong> ，因为多线程非常困难，而且你也不想弄乱线程和锁。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Promise</strong> 确实会上瘾。 一旦开始使用它们，就无法简单地返回并使用回调编写异步代码了。 😅</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Promises </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Promises </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 自定义视图，输入表单和错误提示</title>
      <link href="/iOS%20%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE%EF%BC%8C%E8%BE%93%E5%85%A5%E8%A1%A8%E5%8D%95%E5%92%8C%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/"/>
      <url>/iOS%20%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE%EF%BC%8C%E8%BE%93%E5%85%A5%E8%A1%A8%E5%8D%95%E5%92%8C%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于以编程方式创建自定义视图的一些建议，以及关于为什么使用集合视图构建表单的真相。</p></br><h1 id="如何不为iOS应用构建表单？"><a href="#如何不为iOS应用构建表单？" class="headerlink" title="如何不为iOS应用构建表单？"></a><strong>如何不为iOS应用构建表单？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从一个诚实的声明开始：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.xuebaonline.com/%E4%B8%BAiOS%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E8%BE%93%E5%85%A5%E8%A1%A8%E5%8D%95/"><strong><em><code>为iOS应用构建输入表单</code></em></strong></a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实是，这种表格构建方法仅在单元格始终在屏幕上可见的情况下才有效，这种情况很少见。 我在处理当前项目时发现了此问题，并且当单元格超出框架时，某些字段不断消失，并且将光标移至下一个输入字段停止了工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em><code>可重用性和内存效率并不总是你想要的。</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;似乎 <code>UICollectionView</code> 并不是制作输入表单的最佳解决方案，因为恒定的单元可重用性会弄乱某些预期的行为。 它对于具有“一千个元素”的列表仍然很好，但是对于输入表单，我不再推荐这种技术。 是的，我的错，对此感到抱歉…😬</p><a id="more"></a></br><h1 id="在犯错中学习"><a href="#在犯错中学习" class="headerlink" title="在犯错中学习"></a><strong>在犯错中学习</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长话短说，我犯了一个错误，在你的开发人员职业生涯中，你可能也会收获很多。 这会使你成为一个不好的程序员吗？ 一点也不。 我们是人类，我们不断犯越来越小的错误，但是…</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的错误将永远存在，但是你可以从中学到很多东西。 仅当你一次又一次地犯同样的错误，或者你甚至没有意识到自己在做错事情时，问题才会开始。 退后一步，从更大的角度看问题确实是很难的。 有时你只需要其他人为你指出问题，但是负面反馈也可能会很痛苦。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，我不想太哲学，这是一个Swift开发者博客。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我学到的一些东西：</p><ul><li>我的想法并不总是奏效的🤣</li><li>与其他人一起编码/工作总是更好</li><li>有时“ padawan”会教“大师”😉</li><li>专业的质量检查团队可以为你节省很多时间</li><li><a href="http://www.xuebaonline.com/iOS%20VIPER%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"><strong><em><code>VIPER 是我的架构的杀手锏</code></em></strong></a>，而不是 <a href="http://www.xuebaonline.com/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><strong><em><code>UIcollection视图</code></em></strong></a></li><li>基于UICollectionView的表单构建不起作用…</li><li>…但是集合视图框架仍然适用于复杂的界面</li><li>有一些专用时间来编码美化和重构</li><li>以编程方式使用视图子类（或将来的SwiftUI）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一点是最有趣的一点，让我解释一下原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅来自代码的自定义视图子类</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以编程方式创建 <code>UIView子类</code> 是一项相对容易的任务。 你可以加载一个 <code>nib文件</code> ，也可以直接从代码中加载它。 几周前，我学到了一个新技巧，就是在我使用 <code>Swift</code> 创建新子类时一直困扰着我：</p><blockquote><p>如果根本不使用IB，为什么还要执行 <code>init（coder :)</code>？</p></blockquote><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有 <code>init（frame :)</code> 到底发生了什么，我不想再处理这两个 <code>init</code> 方法，因为我正在使用自动布局，并且我完全试图忽略混乱的 <code>Storyboard</code> 中的界面生成器 和 <code>nibs</code> 。</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">View</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(*, unavailable)</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(*, unavailable)</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方案：将这些愚蠢的 ··· 标记为不可用，因此没有人可以使用它们。 唯一的做法将是你自己的 ··· ，如果你像我一样对如此混乱的初始化过程感到恼火，则这是一种缓解。 😤</p><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，你有了自己的基类，可以将其用作将来视图的父级。 当然，你几乎需要对每个UI元素（例如标签，按钮，文本字段等）执行相同的操作。这需要大量工作，但从长远来看，这是完全值得的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleLabel</span>: <span class="title">Label</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.initialize()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textAlignment = .center</span><br><span class="line">        <span class="keyword">self</span>.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .largeTitle)</span><br><span class="line">        <span class="keyword">self</span>.textColor = .systemBlue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">constraints</span><span class="params">(<span class="keyword">in</span> view: UIView, padding: CGFloat = <span class="number">8</span>)</span></span> -&gt; [<span class="type">NSLayoutConstraint</span>] &#123;</span><br><span class="line">        [</span><br><span class="line">            <span class="keyword">self</span>.topAnchor.constraint(equalTo: view.topAnchor, constant: padding),</span><br><span class="line">            <span class="keyword">self</span>.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: padding),</span><br><span class="line">            <span class="keyword">self</span>.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -<span class="number">1</span> * padding),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个好的做法是为每个自定义用户界面组件都具有子类，例如主按钮，辅助按钮，标题标签，标题标签等。这样，你不必在视图控制器中配置视图，再加上 你可以使用一些辅助方法将常用约束放入子类中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，你还可以进行一些扩展，这些扩展可以帮助你进行视图配置。 你知道，就像 <code>SwiftUI</code> 中的修饰符一样。 你甚至可以重新创建完全相同的语法。 基本行为将不同，但这是另一回事。 📚</p></br><h1 id="iOS中的表单新生成器怎么样？"><a href="#iOS中的表单新生成器怎么样？" class="headerlink" title="iOS中的表单新生成器怎么样？"></a><strong>iOS中的表单新生成器怎么样？</strong></h1><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我有一个全新的但仍然非常相似的解决方案。 我使用的是视图子类，而不是集合视图组件，而且集合视图已被 <code>UIScrollView + UIStackView</code> 组合替换。 🐐</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> scrollView: <span class="type">ScrollView!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> stackView: <span class="type">VerticalStackView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> scrollView = <span class="type">ScrollView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(scrollView)</span><br><span class="line">        <span class="keyword">self</span>.scrollView = scrollView</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([<span class="comment">/*...*/</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> stackView = <span class="type">VerticalStackView</span>()</span><br><span class="line">        <span class="keyword">self</span>.scrollView.addSubview(stackView)</span><br><span class="line">        <span class="keyword">self</span>.stackView = stackView</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([<span class="comment">/*...*/</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.title = <span class="string">"StackForm"</span></span><br><span class="line">        <span class="keyword">self</span>.navigationController?.navigationBar.prefersLargeTitles = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> email = <span class="type">EmailTextField</span>(id: <span class="string">"email-input"</span>, placeholder: <span class="string">"Email"</span>)</span><br><span class="line">        <span class="keyword">self</span>.stackView.addArrangedSubview(email)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> password = <span class="type">PasswordTextField</span>(id: <span class="string">"password-input"</span>, placeholder: <span class="string">"Password"</span>)</span><br><span class="line">        <span class="keyword">self</span>.stackView.addArrangedSubview(password)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> submit = <span class="type">SubmitButton</span>(id: <span class="string">"submit-button"</span>, title: <span class="string">"Submit"</span>)</span><br><span class="line">        .onTouch &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span> <span class="keyword">self</span>?.submit() &#125;</span><br><span class="line">        <span class="keyword">self</span>.stackView.addArrangedSubview(submit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">submit</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> email = (<span class="keyword">self</span>.view.view(withId: <span class="string">"email-input"</span>) <span class="keyword">as</span>? <span class="type">UITextField</span>)?.text,</span><br><span class="line">            <span class="keyword">let</span> password = (<span class="keyword">self</span>.view.view(withId: <span class="string">"password-input"</span>) <span class="keyword">as</span>? <span class="type">UITextField</span>)?.text</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Account: \(email) - \(password)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我仍在使用相同的 <a href="http://www.xuebaonline.com/Swift%20%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%9A%84%E8%A7%86%E5%9B%BE/"><strong><em><code>视图识别技术</code></em></strong></a> ，而且我仍然更喜欢使用类似 <code>SwiftUI</code> 的 <code>.onTouch</code> 操作处理程序。 你可能会问：</p><p><strong><em><code>为什么不简单地使用SwiftUI？</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，事实是 <code>SwiftUI</code> 仅是 <code>iOS13</code> ，如今大约只有55％的采用率，这是主要原因之一，但是 <code>SwiftUI</code> 还是不完整的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我正在尝试尽可能地接近 <code>SwiftUI</code> ，因此过渡到时候来的时候会减少痛苦。  <code>SwiftUI</code> 将会很棒，但是仍然是一个巨大的飞跃。 有时，我认为Apple只是出于市场/开发人员的需求而奔波（是的，我们是非常耐心的动物）。 第一步，也许一个围绕UIKit / AppKit的简单包装框架而没有整个声明性语法会是一个更好的主意…谁知道… CoreKit-&gt; AppleKit？ 🤔</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，你可以从 <a href="https://github.com/theswiftdev/tutorials" target="_blank" rel="noopener"><strong><em><code>GitHub</code></em></strong></a> 下载 <code>Swift 5</code> 中最新的表单构建解决方案的工作示例。 只需在存储库中查找 <code>StackForm</code> 文件夹。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为iOS应用构建输入表单</title>
      <link href="/%E4%B8%BAiOS%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E8%BE%93%E5%85%A5%E8%A1%A8%E5%8D%95/"/>
      <url>/%E4%B8%BAiOS%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E8%BE%93%E5%85%A5%E8%A1%A8%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>了解如何使用更新的集合视图视图模型框架构建复杂的表单，而无需使用 <code>Swift</code> 。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此方法不起作用，因为表单中的单元格将被重用，这会导致某些不一致的情况…… <a href="http://www.xuebaonline.com/iOS%20%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE%EF%BC%8C%E8%BE%93%E5%85%A5%E8%A1%A8%E5%8D%95%E5%92%8C%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/"><strong><em><code>请阅读我的其他文章</code></em></strong></a> 。🤷‍♂️</p></blockquote></br><h1 id="CollectionView和输入表单"><a href="#CollectionView和输入表单" class="headerlink" title="CollectionView和输入表单"></a><strong>CollectionView和输入表单</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/corekit/collectionview" target="_blank" rel="noopener"><strong><em><code>CollectionView框架</code></em></strong></a> 刚刚进行了巨大更新。有很多新变化，但是最大的改进之一是我处理视图模型的方式。过去，你必须在视图模型中使用长函数名，包括通用视图和模型类名。如果你曾经阅读过 <a href="http://www.xuebaonline.com/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><strong><em><code>最终UICollectionView指南</code></em></strong></a> ，那么你应该了解我在说什么。好消息：我现在有一种更好的解决方案！ 😉</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此更新不仅可以清理很多代码，还可以添加自定义视图模型处理程序，因此我可以以一种非常简单的方式与输入字段，切换等交互。另一个巨大的改进是，我开始使用视图标识符。那是偶然的发现，我只想寻找 <a href="http://www.xuebaonline.com/Swift%20%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%9A%84%E8%A7%86%E5%9B%BE/"><strong><em><code>一种通过标签识别视图的替代解决方案</code></em></strong></a> ，然后我有了一个绝妙的主意：为什么不也通过id查找单元格呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果，我现在可以使用框架来创建表单。我仍然相信集合视图是大多数应用程序的最终构建块。是的，你仍然可以说没有灵丹妙药，但是如果此解决方案可以覆盖我90％的用例，那很好。毕竟，大多数应用程序只是以一种不错的或不太好的方式可视化 <code>JSON数据</code> 。 🤷‍♂️</p></br><h1 id="可重复使用的表单组件"><a href="#可重复使用的表单组件" class="headerlink" title="可重复使用的表单组件"></a><strong>可重复使用的表单组件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们使用全新的框架来构建表单。 首先，你需要使用包管理器对其进行集成。 我真的希望在几周内我们可以使用 <code>Swift Package Manager</code> ，直到比你应该使用 <code>CocoaPods</code> 或 <code>carthage</code> 为止。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cocoapods</span><br><span class="line">source 'https:<span class="comment">//github.com/CoreKit/CocoaPods.git'</span></span><br><span class="line">pod '<span class="type">CollectionView'</span>, '~&gt; <span class="number">2.0</span>.<span class="number">0</span>'</span><br><span class="line"></span><br><span class="line"># carthage</span><br><span class="line">github <span class="string">"CoreKit/CollectionView"</span> <span class="string">"2.0.0"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在让我们为输入字段创建一个可重用的单元格。 可以像往常一样随意使用 <code>xib文件</code> ，实现上的唯一区别是，我将在 <code>reset方法</code> 中删除目标侦听器。 我们稍后将在视图模型中添加一个。 🎯</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CollectionView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputCell</span>: <span class="title">Cell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textField: <span class="type">UITextField!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.reset()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textField.removeTarget(<span class="literal">nil</span>, action: <span class="literal">nil</span>, <span class="keyword">for</span>: .editingChanged)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我还将创建一个简单的实体，用于在表单字段为空时显示占位符并存储输入字段的实际值，我们将其称为 <code>InputEntity</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> placeholder: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">String?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在最困难的部分是：在视图和模型之间建立连接。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CollectionView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputViewModel</span>: <span class="title">ViewModel</span>&lt;<span class="title">InputCell</span>, <span class="title">InputEntity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> editingChangeHandler: <span class="type">ViewModelHandler?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> height: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">60</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">updateView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view?.textField.placeholder = <span class="keyword">self</span>.model.placeholder</span><br><span class="line">        <span class="keyword">self</span>.view?.textField.text = <span class="keyword">self</span>.model.value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.view?.textField.addTarget(<span class="keyword">self</span>,</span><br><span class="line">                                       action: #selector(<span class="keyword">self</span>.editingChanged(<span class="number">_</span>:)),</span><br><span class="line">                                       <span class="keyword">for</span>: .editingChanged)</span><br><span class="line">        <span class="keyword">self</span>.view?.textField.addTarget(<span class="keyword">self</span>,</span><br><span class="line">                                       action: #selector(<span class="keyword">self</span>.editingDidEnd(<span class="number">_</span>:)),</span><br><span class="line">                                       <span class="keyword">for</span>: .editingDidEnd)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onEditingChange</span><span class="params">(<span class="number">_</span> handler: @escaping ViewModelHandler)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.editingChangeHandler = handler</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">editingChanged</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.model.value = textField.text</span><br><span class="line">        <span class="keyword">self</span>.editingChangeHandler?(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">editingDidEnd</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"nothing-to-do-here-now..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个非常复杂的视图模型，但是它也可以做很多事情。 你应该了解的第一件事是 <code>ViewModelHandler</code> ，它基本上是可以在视图模型中使用的通用别名。 它使你能够传递回调的类型安全视图模型。 你稍后会看到。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个主要更改是 <code>updateView方法</code> ，该方法用于基于来自模型的数据来更新视图。 我还将目标侦听器添加到视图中，以便可以直接在 <code>view-model类</code> 内部处理用户输入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>onEditingChange</code> 方法是视图模型的 <code>“公共” api</code> 。 我现在使用on前缀将处理程序和侦听器添加到我的视图模型。 如果发生更改事件，它将基本上调用存储的块。 你可以根据需要添加任意数量的事件处理程序块。 我真的希望你能掌握这种方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一件事：现在返回单元格的高度是单线！ 🎊</p></br><h1 id="Composing-forms-and-more"><a href="#Composing-forms-and-more" class="headerlink" title="Composing forms and more"></a><strong>Composing forms and more</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前，该计划将具有一个包含两个输入字段的输入表单。 一个用于电子邮件地址，另一个将用于密码。 诀窍是，这次我不会向你展示整个代码，但是你必须弄清楚其余的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，我将向你展示制作自己的表单所需的所有知识，甚至包括一些复杂的表单。 不用担心，这只是几行代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> CollectionView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">CollectionViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> grid = <span class="type">Grid</span>(columns: <span class="number">1</span>, margin: <span class="type">UIEdgeInsets</span>(all: <span class="number">16</span>), padding: .zero)</span><br><span class="line">        <span class="keyword">self</span>.collectionView.source = .<span class="keyword">init</span>(grid: grid, [</span><br><span class="line">            [</span><br><span class="line">                <span class="type">InputViewModel</span>(id: <span class="string">"email-input"</span>, .<span class="keyword">init</span>(placeholder: <span class="string">"Email"</span>, value: <span class="literal">nil</span>))</span><br><span class="line">                .onEditingChange &#123; viewModel <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> passwordViewModel = viewModel.by(id: <span class="string">"password-input"</span>) <span class="keyword">as</span>? <span class="type">InputViewModel</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    passwordViewModel.model.value = viewModel.model.value ?? <span class="string">""</span></span><br><span class="line">                    passwordViewModel.updateView()</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="type">InputViewModel</span>(id: <span class="string">"password-input"</span>, .<span class="keyword">init</span>(placeholder: <span class="string">"Password"</span>, value: <span class="literal">nil</span>)),</span><br><span class="line">            ],</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你曾经使用过集合视图框架，那么你应该知道我一直使用网格系统，因为我真的不喜欢计算数字。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源是一组按部分分组的视图模型。这里唯一有趣的部分是，现在可以使用节和视图模型的数组来初始化源。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你使用和标识符初始化一个视图模型，则以后可以通过ID查询该视图模型。这正是在编辑更改处理程序块内发生的事情。每个视图模型都可以通过id返回其他一些视图模型。默认情况下，视图模型是类型安全的，由于通用的 <code>ViewModelHandler</code> 别名， <code>viewModel</code> 也在块内传递。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在这个小示例中，如果你在第一个输入字段中键入内容，则完全相同的文本将出现在第二个文本字段中。你可以在需要时按ID获取所有视图模型。例如，如果你必须提交此表单，则可以使用相同的方法来获取电子邮件和密码字段。</p></br><h1 id="建立登录表单"><a href="#建立登录表单" class="headerlink" title="建立登录表单"></a><strong>建立登录表单</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要求你使用我的框架自行构建一个登录表单。 我保证不超过30分钟的工作时间。 我将向你展示我将使用的最终视图控制器，因此这可能会给你一些帮助。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想稍微增加点趣味，甚至可以添加一个复选框以接受隐私策略。 这里的主要思想是你应该为表单中的每个项目创建可重用的组件。 因此，例如，具有相应视图模型的 <code>ToggleView</code> 是一种很好的方法（也适用于按钮）。 🤫</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是最终的提示，你只需要创建自己的视图模型和视图即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> CollectionView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">CollectionViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Ids</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> email = <span class="string">"email-input"</span></span><br><span class="line">        <span class="keyword">case</span> password = <span class="string">"password-input"</span></span><br><span class="line">        <span class="keyword">case</span> privacyPolicy = <span class="string">"privacy-policy-checkbox"</span></span><br><span class="line">        <span class="keyword">case</span> submit = <span class="string">"submit-button"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> grid = <span class="type">Grid</span>(columns: <span class="number">1</span>, margin: <span class="type">UIEdgeInsets</span>(all: <span class="number">16</span>), padding: .zero)</span><br><span class="line">        <span class="keyword">self</span>.collectionView.source = .<span class="keyword">init</span>(grid: grid, [</span><br><span class="line">            [</span><br><span class="line">                <span class="type">InputViewModel</span>(id: <span class="type">Ids</span>.email.rawValue, .<span class="keyword">init</span>(placeholder: <span class="string">"Email"</span>, value: <span class="literal">nil</span>))</span><br><span class="line">                .onEditingEnd &#123; viewModel <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> passwordViewModel = viewModel.by(id: <span class="type">Ids</span>.password.rawValue) <span class="keyword">as</span>? <span class="type">InputViewModel</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    passwordViewModel.view?.textField.becomeFirstResponder()</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="type">InputViewModel</span>(id: <span class="type">Ids</span>.password.rawValue, .<span class="keyword">init</span>(placeholder: <span class="string">"Password"</span>, value: <span class="literal">nil</span>, secure: <span class="literal">true</span>))</span><br><span class="line">                .onEditingEnd &#123; viewModel <span class="keyword">in</span></span><br><span class="line">                    viewModel.view?.textField.endEditing(<span class="literal">true</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">                <span class="type">ToggleViewModel</span>(id: <span class="type">Ids</span>.privacyPolicy.rawValue, .<span class="keyword">init</span>(label: <span class="string">"Privacy policy"</span>, value: <span class="literal">false</span>))</span><br><span class="line">                .onValueChange &#123; viewModel <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> submitViewModel = viewModel.by(id: <span class="type">Ids</span>.submit.rawValue) <span class="keyword">as</span>? <span class="type">ButtonViewModel</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">var</span> model = submitViewModel.model</span><br><span class="line">                    model.enabled = viewModel.model.value</span><br><span class="line">                    submitViewModel.model = model</span><br><span class="line">                    submitViewModel.updateView()</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">                <span class="type">ButtonViewModel</span>(id: <span class="type">Ids</span>.submit.rawValue, .<span class="keyword">init</span>(title: <span class="string">"Submit"</span>, enabled: <span class="literal">false</span>))</span><br><span class="line">                .onSubmit &#123; viewModel <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">guard</span></span><br><span class="line">                        <span class="keyword">let</span> emailViewModel = viewModel.by(id: <span class="type">Ids</span>.email.rawValue) <span class="keyword">as</span>? <span class="type">InputViewModel</span>,</span><br><span class="line">                        <span class="keyword">let</span> passwordViewModel = viewModel.by(id: <span class="type">Ids</span>.password.rawValue) <span class="keyword">as</span>? <span class="type">InputViewModel</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* ... */</span></span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到此为止，这是一个几乎完整的登录表单，仅包含几行代码。 当然有一个基础框架，但是如果你检查 <a href="https://github.com/corekit/collectionview" target="_blank" rel="noopener"><strong><em><code>源代码</code></em></strong></a> ，你实际上会发现它不包含任何被视为黑魔法的东西。 💫</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift编写的20个iOS库(一)</title>
      <link href="/Swift%E7%BC%96%E5%86%99%E7%9A%8420%E4%B8%AAiOS%E5%BA%93(%E4%B8%80)/"/>
      <url>/Swift%E7%BC%96%E5%86%99%E7%9A%8420%E4%B8%AAiOS%E5%BA%93(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我在 <code>github</code> 上收集了最好的开源 <code>Swift框架</code> ，这些框架将帮助你在2020年加快移动应用程序的开发速度。更多精彩的类库持续更新中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，最好使用第三方框架而不是重新发明轮子，但是你首先要提出一些重要问题：</p><ul><li>我真的需要 <code>library</code> 吗？</li><li>我应该怎么用？</li><li>它会得到支持吗？</li><li>如果是 <code>bug</code> 怎么办？ 🐛</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在项目中添加依赖项也会导致技术负担。 不要懒惰，首先学习基础技术（或者至少阅读它，或者问一个真正了解它的人），如果你确定该框架是一个不错的选择，那就给它一个机会。 在此列表中，我尝试收集了大多数开发人员社区使用的面向未来的，可靠的，知名的iOS库。 ⭐️</p><a id="more"></a></br><p><strong><code>选择标准</code></strong></p><ul><li>该框架必须用 <code>Swift</code> 编写</li><li>库不应该是特定于设计的（对此有 <code>cocoacontrols</code> ）</li><li>它应该是一个运行时框架，而不是一个工具包（也就是导入 <code>XY</code> ）</li><li>应该有一些程序包管理器支持（ <code>Carthage</code> ， <code>CocoaPods</code> ， <code>SPM</code> ）</li><li>它必须支持 <code>Swift</code> 的最新主要版本</li><li><code>github</code> 上必须至少有 <code>1000颗星星</code> </li></ul></br><h1 id="🌎与网络相关的库"><a href="#🌎与网络相关的库" class="headerlink" title="🌎与网络相关的库"></a><strong>🌎与网络相关的库</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正在连接…</p><h2 id="Alamofire"><a href="#Alamofire" class="headerlink" title="Alamofire"></a><a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener"><strong><em><code>Alamofire</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Alamofire</code> 是用 <code>Swift</code> 编写的 <code>HTTP网络库</code> 。</p><h2 id="Kingfisher"><a href="#Kingfisher" class="headerlink" title="Kingfisher"></a><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener"><strong><em><code>Kingfisher</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Kingfisher</code> 是一个功能强大的 <code>纯Swift库</code> ，用于从 <strong>Web下载和缓存图像</strong> 。 它为你提供了使用 <code>纯Swift</code> 方法在下一个应用程序中处理远程图像的机会。</p><h2 id="Starscream"><a href="#Starscream" class="headerlink" title="Starscream"></a><a href="https://github.com/daltoniam/Starscream" target="_blank" rel="noopener"><strong><em><code>Starscream</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Starscream</code> 是 <code>Swift</code> 中符合标准的 <code>WebSocket</code> （ <a href="http://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener"><strong><em><code>RFC 6455</code></em></strong></a> ）客户端库。</p></br><h1 id="📦服务器端Swift"><a href="#📦服务器端Swift" class="headerlink" title="📦服务器端Swift"></a><strong>📦服务器端Swift</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;听…</p><h2 id="Vapor"><a href="#Vapor" class="headerlink" title="Vapor"></a><a href="https://github.com/vapor/vapor" target="_blank" rel="noopener"><strong><em><code>Vapor</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Vapor</code> 是 <code>Swift</code> 的 <strong>Web框架</strong> 。 它为你的下一个网站， <code>API</code> 或 <code>云项目</code> 提供了精美而易用的基础。</p><h2 id="SwiftNIO"><a href="#SwiftNIO" class="headerlink" title="SwiftNIO"></a><a href="https://github.com/apple/swift-nio" target="_blank" rel="noopener"><strong><em><code>SwiftNIO</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SwiftNIO</code> 是跨平台的 <strong>异步事件驱动的网络应用程序框架</strong> ，用于快速开发可维护的高性能协议服务器和客户端。</p></br><h1 id="🔨响应式编程"><a href="#🔨响应式编程" class="headerlink" title="🔨响应式编程"></a><strong>🔨响应式编程</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Streams</code> ,  <code>observers</code> , 等…</p><h2 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener"><strong><em><code>ReactiveCocoa</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <code>ReactiveSwift</code> 提供了可组合的，声明性的和灵活的基元，这些基元是围绕随着时间流逝的价值流这一宏伟概念而构建的。 这些原语可用于统一表示常见的可可和通用编程模式，这些模式从根本上是一种观察行为。</p><h2 id="RxSwift"><a href="#RxSwift" class="headerlink" title="RxSwift"></a><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener"><strong><em><code>RxSwift</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Rx</code> 是通过 <code>Observable &lt;Element&gt;</code> 接口表示的通用计算抽象。 这是 <code>Rx</code> 的 <code>Swift版本</code> 。</p></br><h1 id="🦋动画"><a href="#🦋动画" class="headerlink" title="🦋动画"></a><strong>🦋动画</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIView.animated...</code></p><h2 id="Hero"><a href="#Hero" class="headerlink" title="Hero"></a><a href="https://github.com/HeroTransitions/Hero" target="_blank" rel="noopener"><strong><em><code>Hero</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Hero</code> 是用于构建 <code>iOS视图控制器过渡</code> 的库。 它在 <code>UIKit</code> 繁琐的 <code>过渡API</code> 之上提供了一个声明性层-使自定义过渡对于开发人员而言是一项轻松的任务。</p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><a href="https://github.com/MengTo/Spring" target="_blank" rel="noopener"><strong><em><code>Spring</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个库，用于简化 <code>Swift</code> 中的 <code>iOS动画</code> 。</p></br><h1 id="📐自动布局助手"><a href="#📐自动布局助手" class="headerlink" title="📐自动布局助手"></a><strong>📐自动布局助手</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Anchors vs...</code></p><h2 id="SnapKit"><a href="#SnapKit" class="headerlink" title="SnapKit"></a><a href="https://github.com/SnapKit/SnapKit" target="_blank" rel="noopener"><strong><em><code>SnapKit</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SnapKit</code> 是一种 <code>DSL</code> ，可在 <code>iOS</code> 和 <code>OS X</code> 上简化自动布局。</p><h2 id="TinyConstraints"><a href="#TinyConstraints" class="headerlink" title="TinyConstraints"></a><a href="https://github.com/roberthein/TinyConstraints" target="_blank" rel="noopener"><strong><em><code>TinyConstraints</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>TinyConstraints</code> 是使 <code>Auto Layout</code> 更适合人类使用的语法糖。</p></br><h1 id="❌测试"><a href="#❌测试" class="headerlink" title="❌测试"></a><strong>❌测试</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TDD FTW...</code></p><h2 id="Quick"><a href="#Quick" class="headerlink" title="Quick"></a><a href="https://github.com/Quick/Quick" target="_blank" rel="noopener"""><strong><em><code>Quick</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Quick</code> 是 <code>Swift</code> 和 <code>Objective-C</code> 的行为驱动开发框架。</p><h2 id="Nimble"><a href="#Nimble" class="headerlink" title="Nimble"></a><a href="https://github.com/Quick/Nimble" target="_blank" rel="noopener"><strong><em><code>Nimble</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用 <code>Nimble</code> 表示 <code>Swift</code> 或 <code>Objective-C</code> 表达式的预期结果。</p></br><h1 id="⚙️实用工具"><a href="#⚙️实用工具" class="headerlink" title="⚙️实用工具"></a><strong>⚙️实用工具</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我错过了什么？</p><h2 id="PromiseKit"><a href="#PromiseKit" class="headerlink" title="PromiseKit"></a><a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener"><strong><em><code>PromiseKit</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>PromiseKit</code> 是对任何具有 <code>swiftc</code> 平台的 <strong>Promise的深思熟虑和完整的实现</strong> 。</p><h2 id="CryptoSwift"><a href="#CryptoSwift" class="headerlink" title="CryptoSwift"></a><a href="https://github.com/krzyzanowskim/CryptoSwift" target="_blank" rel="noopener"><strong><em><code>CryptoSwift</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>CryptoSwift</code> 是在 <code>Swift</code> 中实现的越来越多的标准和<strong>安全密码算法</strong>集合。</p><h2 id="SwiftDate"><a href="#SwiftDate" class="headerlink" title="SwiftDate"></a><a href="https://github.com/malcommac/SwiftDate" target="_blank" rel="noopener"><strong><em><code>SwiftDate</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SwiftDate</code> 是确定的工具链，可在所有 <code>Apple平台</code> 上甚至在 <code>Linux</code> 和 <code>Vapor</code> 或 <code>Kitura</code> 等 <code>Swift Server Side框架</code> 上操纵和显示日期和时区。</p><h2 id="SwiftyBeaver"><a href="#SwiftyBeaver" class="headerlink" title="SwiftyBeaver"></a><a href="https://github.com/SwiftyBeaver/SwiftyBeaver" target="_blank" rel="noopener"><strong><em><code>SwiftyBeaver</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 <code>Swift 2、3和4、5</code> 中开发和发布期间的便捷日志记录。</p><h2 id="Swinject"><a href="#Swinject" class="headerlink" title="Swinject"></a><a href="https://github.com/Swinject/Swinject" target="_blank" rel="noopener"><strong><em><code>Swinject</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swinject</code> 是 <code>Swift</code> 的轻量级 <code>依赖注入框架</code> 。</p><h2 id="SwiftyJSON"><a href="#SwiftyJSON" class="headerlink" title="SwiftyJSON"></a><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="noopener"><strong><em><code>SwiftyJSON</code></em></strong></a></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SwiftyJSON</code>  使你可以轻松地在 <code>Swift</code> 中处理 <code>JSON数据</code> 。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你正在寻找更多的 <code>Swift库</code> ，则可以随时在 <a href="https://github.com/topics/swift" target="_blank" rel="noopener"><strong><em><code>github</code></em></strong></a> 上探索最受欢迎的 <code>Swift库</code> ，请记住：<strong>始终通过包管理器连接你的依赖项</strong>。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 三方类库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 三方类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 用 compactMap 替换 flatMap</title>
      <link href="/Swift%20%E7%94%A8%20compactMap%20%E6%9B%BF%E6%8D%A2%20flatMap/"/>
      <url>/Swift%20%E7%94%A8%20compactMap%20%E6%9B%BF%E6%8D%A2%20flatMap/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Xcode 9.3</code> 随附的 <code>Swift 4.1</code> 带来了对 <code>Swift语言</code> 和 <code>Swift标准库</code> 的更多更改。 苹果原本打算将其作为对 <code>Swift 4.0</code> 的源兼容升级，但我遭到一次源代码更改的打击，我猜这将是广泛的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在不建议在序列（如 <code>Array</code> ）上使用 <code>flatMap</code> 来过滤映射到 <code>nil</code> 的任何内容，并由 <code>compactMap</code> 取代。</p><h1 id="改变的简短版本"><a href="#改变的简短版本" class="headerlink" title="改变的简短版本"></a><strong>改变的简短版本</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是否正在使用 <code>flatMap</code> 从可选数组中删除 <code>nil</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: [<span class="type">String?</span>] = [<span class="string">"Tom"</span>, <span class="literal">nil</span>, <span class="string">"Peter"</span>, <span class="literal">nil</span>, <span class="string">"Harry"</span>]</span><br><span class="line"><span class="keyword">let</span> valid = names.flatMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// ["Tom", "Peter", "Harry"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Xcode 9.3</code> 显示了以这种方式使用 <code>flatMap</code> 的弃用警告：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/rfc-stp1.png" alt="flatMap"></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Xcode</code> 建议的修复程序将 <code>flatMap</code> 重命名为 <code>compactMap</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: [<span class="type">String?</span>] = [<span class="string">"Tom"</span>, <span class="literal">nil</span>, <span class="string">"Peter"</span>, <span class="literal">nil</span>, <span class="string">"Harry"</span>]</span><br><span class="line"><span class="keyword">let</span> valid = names.compactMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// ["Tom", "Peter", "Harry"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要你在带有闭包的序列上使用 <code>flatMap</code> 并返回可选值，该方法就适用。 所以这也被弃用了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> words = [<span class="string">"53"</span>, <span class="string">"nine"</span>, <span class="string">"hello"</span>,<span class="string">"0"</span>]</span><br><span class="line"><span class="keyword">let</span> values = words.flatMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用 <code>compactMap</code> 替换 <code>flatMap</code> 会删除弃用警告：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = words.compactMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125; <span class="comment">// Returns [Int]</span></span><br><span class="line"><span class="comment">// [53, 0]</span></span><br></pre></td></tr></table></figure></br><h1 id="More"><a href="#More" class="headerlink" title="More"></a><strong>More</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>首先， <code>Swift 4.1</code>不会弃用 <code>flatMap</code> 的所有用法-只有一种情况正在改变。</strong> <code>Swift 4.0</code> 在三种情况下可以使用 <code>flatMap</code> ：</p><ul><li>在具有返回序列的闭包的序列上使用 <code>flatMap</code> ：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sequence</span>.flatMap&lt;<span class="type">S</span>&gt;(<span class="number">_</span> transform: (<span class="type">Element</span>) -&gt; <span class="type">S</span>)</span><br><span class="line">  -&gt; [<span class="type">S</span>.<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">S</span> : <span class="type">Sequence</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为这可能是我在 Swift 中遇到的 <code>flatMap</code> 的首次使用。 使用它对序列的每个元素应用闭包并展平结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scores = [[<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>], [<span class="number">4</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="keyword">let</span> allScores = scores.flatMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// [5, 2, 7, 4, 8, 9, 1, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> passMarks = scores.flatMap &#123; $<span class="number">0</span>.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt; <span class="number">5</span>&#125; &#125;</span><br><span class="line"><span class="comment">// [7, 8, 9]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift 4.1</code> 不会更改 <code>flatMap</code> 的用法。</p><ul><li>在可选值上使用 <code>flatMap</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闭包采用可选值的 <code>非null值</code> ，并返回可选值。 如果原始可选参数为 <code>nil</code> ，则 <code>flatMap</code> 返回 <code>nil</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Optional</span>.flatMap&lt;<span class="type">U</span>&gt;(<span class="number">_</span> transform: (<span class="type">Wrapped</span>) -&gt; <span class="type">U?</span>) -&gt; <span class="type">U?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> input: <span class="type">Int?</span> = <span class="type">Int</span>(<span class="string">"8"</span>)</span><br><span class="line"><span class="keyword">let</span> passMark: <span class="type">Int?</span> = input.flatMap &#123; $<span class="number">0</span> &gt; <span class="number">5</span> ? $<span class="number">0</span> : <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="comment">// Optional(8)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift 4.1</code> 不会更改 <code>flatMap</code> 的用法。</p><ul><li>在带有返回可选项的闭包的序列上使用 <code>flatMap</code> 。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sequence</span>.flatMap&lt;<span class="type">U</span>&gt;(<span class="number">_</span> transform: (<span class="type">Element</span>) -&gt; <span class="type">U?</span>) -&gt; <span class="type">U?</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是 <code>Swift 4.1（Xcode 9.3</code>） 替换为 <code>compactMap</code> 的 <code>flatMap</code> 的使用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names: [<span class="type">String?</span>] = [<span class="string">"Tom"</span>, <span class="literal">nil</span>, <span class="string">"Peter"</span>, <span class="literal">nil</span>, <span class="string">"Harry"</span>]</span><br><span class="line"><span class="keyword">let</span> counts = names.compactMap &#123; $<span class="number">0</span>?.<span class="built_in">count</span> &#125;</span><br><span class="line"><span class="comment">// [3, 5, 5]</span></span><br></pre></td></tr></table></figure></br><h1 id="重点是什么？"><a href="#重点是什么？" class="headerlink" title="重点是什么？"></a><strong>重点是什么？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总而言之，当 <code>plain map</code> 可以完成此工作时，似乎可以减少对 <code>flatMap</code> 的滥用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNames: [<span class="type">String</span>] = [<span class="string">"John"</span>, <span class="string">"Joe"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// No need to flatMap (or compactMap)</span></span><br><span class="line"><span class="keyword">let</span> myCounts = myNames.flatMap &#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;</span><br><span class="line"><span class="comment">// [4, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map is enough</span></span><br><span class="line"><span class="keyword">let</span> myCounts = myNames.<span class="built_in">map</span> &#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;</span><br><span class="line"><span class="comment">// [4, 3, 4]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将名称更改为 ··· 的想法是为了更好地描述该功能的作用。 映射序列，然后通过从结果中删除 <code>值为nil的元素</code> 进行压缩。 <code>Swift</code> 的未来版本可能还会为我们提供从通常情况下从序列中删除 <code>nil值</code> 的紧凑函数。</p></br><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a><strong>扩展阅读</strong></h1><ul><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0187-introduce-filtermap.md" target="_blank" rel="noopener"><strong><em><code>SE-0187 Introduce Sequence.compactMap(_:)</code></em></strong></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift CompactMap vs flatMap：差异说明</title>
      <link href="/Swift%20CompactMap%20vs%20flatMap%EF%BC%9A%E5%B7%AE%E5%BC%82%E8%AF%B4%E6%98%8E/"/>
      <url>/Swift%20CompactMap%20vs%20flatMap%EF%BC%9A%E5%B7%AE%E5%BC%82%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CompactMap</code> 和 <code>flatMap</code> 有什么区别？何时使用它们？  <code>Swift 4.1</code> 在 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0187-introduce-filtermap.md" target="_blank" rel="noopener"><strong><em><code>提案0187</code></em></strong></a> 中引入了这种新方法：引入 <code>Filtermap</code> 可以在 <code>flatMap</code> 用例中获得更多的清晰度。</p></br><h1 id="何时使用compactMap"><a href="#何时使用compactMap" class="headerlink" title="何时使用compactMap"></a><strong>何时使用compactMap</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当转换产生可选值时，使用此方法接收非可选值数组。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以下示例中查看 <code>map</code> 和 <code>compactMap</code> 之间的区别：</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scores = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"5"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapped: [<span class="type">Int?</span>] = scores.<span class="built_in">map</span> &#123; str <span class="keyword">in</span> <span class="type">Int</span>(str) &#125;</span><br><span class="line"><span class="comment">// [1, 2, nil, nil, 5] - Two nil values as "three" and "four" are strings.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compactMapped: [<span class="type">Int</span>] = scores.compactMap &#123; str <span class="keyword">in</span> <span class="type">Int</span>(str) &#125;</span><br><span class="line"><span class="comment">// [1, 2, 5] - The nil values for "three" and "four" are filtered out.</span></span><br></pre></td></tr></table></figure></br><h1 id="何时使用flatMap"><a href="#何时使用flatMap" class="headerlink" title="何时使用flatMap"></a><strong>何时使用flatMap</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当转换为每个元素生成序列或集合时，请使用此方法来接收单级集合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以下示例中查看 <code>map</code> 与 <code>flatMap</code> 之间的区别：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scoresByName = [<span class="string">"Henk"</span>: [<span class="number">0</span>, <span class="number">5</span>, <span class="number">8</span>], <span class="string">"John"</span>: [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapped = scoresByName.<span class="built_in">map</span> &#123; $<span class="number">0</span>.value &#125;</span><br><span class="line"><span class="comment">// [[0, 5, 8], [2, 5, 8]] - An array of arrays</span></span><br><span class="line"><span class="built_in">print</span>(mapped)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flatMapped = scoresByName.flatMap &#123; $<span class="number">0</span>.value &#125;</span><br><span class="line"><span class="comment">// [0, 5, 8, 2, 5, 8] - flattened to only one array</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上， <code>s.flatMap(transform)</code> 等效于 <code>Array(s.map(transform).joined())</code> 。</p></br><h1 id="compactMap-vs-flatMap"><a href="#compactMap-vs-flatMap" class="headerlink" title="compactMap vs flatMap"></a><strong>compactMap vs flatMap</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的一般经验法则提醒你编写代码时的注意事项：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在序列上使用并具有返回可选值的转换，请使用 <code>compactMap</code> 。 如果没有，则 <code>map</code> 或 <code>flatMap</code> 应该会为你提供所需的结果。</p></blockquote><h2 id="命名为compactMap的原因"><a href="#命名为compactMap的原因" class="headerlink" title="命名为compactMap的原因"></a><strong><em>命名为compactMap的原因</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管有人提议引入 <code>filterMap</code> 作为方法名，但是 <code>Swift团队</code> 还是决定使用 <code>compactMap</code> 。 读懂他们的动机可以使事情变得很多，并解释该方法的功能。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>“filterMap”</code> 是其他编程语言中有先例的名称，尤其是功能性语言，但有些人强烈认为该名称具有误导性，因为作为一个组合操作，它并不是一个过滤器或地图。 在替代方案中，最受支持的方案似乎是 <code>“ compactMap”</code> ，它基于 <code>“ compact”</code> 的先例， <code>compactMap</code> 是来自其他语言（尤其是Ruby）的一种操作，它返回输入的副本而没有 <code>nil值</code> 。 <code>Swift</code> 目前没有这样的操作，事实上，目前尚无法表达它。 但是，核心团队同意添加是一个合理的操作，并且 <code>“ compactMap”</code> 是该操作的好名字。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Functional Swift 初探</title>
      <link href="/Functional%20Swift%20%E5%88%9D%E6%8E%A2/"/>
      <url>/Functional%20Swift%20%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您将永远只需要学习一个高阶函数，例如： <code>map</code> ， <code>flatMap</code> ， <code>compactMap</code> ， <code>reduce</code> ， <code>filter</code> 等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener"><strong><em><code>函数式编程</code></em></strong></a>（英语：functional programming）或称 <code>函数程序设计</code> 、 <code>泛函编程</code> ，是一种 <code>编程范式</code> ，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比起 <code>指令式编程</code> ， <code>函数式编程</code> 更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</p><a id="more"></a></br><h1 id="函数式编程说明"><a href="#函数式编程说明" class="headerlink" title="函数式编程说明"></a>函数式编程说明</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先让我强调一件事：<strong><em><code>不要害怕函数式编程！</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使您是新手开发人员，也会看到 <code>函数式编程</code> 并不像您想象的那么难。 如果您仅学习基础知识，则可以节省大量时间，并可以帮助您编写更好的应用程序。 FP范例的主要概念是通过以特殊方式使用函数来消除可变状态和数据。 💫</p><h2 id="一等公民：-函数"><a href="#一等公民：-函数" class="headerlink" title="一等公民： 函数"></a><strong><em>一等公民： 函数</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果编程语言将函数视为一等的公民（与我们期望的类型行为相同），我们就说它具有一等的函数。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这意味着该语言支持将函数作为参数传递给其他函数，将它们作为其他函数的值返回，并将其分配给变量或存储在数据结构中。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中，您可以使用函数指针， <code>闭包（匿名函数）</code> ，因此，是的， <code>Swift</code> 基本上是一种真正的函数式语言。 示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an old-school function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// it's a block!</span></span><br><span class="line"><span class="keyword">let</span> hi: () -&gt; <span class="type">Void</span> = &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hi!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this points to a function</span></span><br><span class="line"><span class="keyword">let</span> function = hello</span><br><span class="line"><span class="comment">// this is a copy of the closure</span></span><br><span class="line"><span class="keyword">let</span> block = hi</span><br><span class="line"></span><br><span class="line">hello() <span class="comment">// simple function call</span></span><br><span class="line">function() <span class="comment">// call through "function pointer"</span></span><br><span class="line"></span><br><span class="line">hi() <span class="comment">// simple closure call</span></span><br><span class="line">block() <span class="comment">// closure call through another variable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// closure parameter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">async</span><span class="params">(completion: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// usually we'd do something here first...</span></span><br><span class="line">    completion()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calling the method with a closure</span></span><br><span class="line">async(completion: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Completed."</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// trailing closure syntax</span></span><br><span class="line">async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Completed."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，有时我将闭包称为块，为简单起见，让我们假装它们是完全相同的东西，并且不要过多地讨论细节。 🙄</p><h2 id="函数组成，柯里化和可变参数"><a href="#函数组成，柯里化和可变参数" class="headerlink" title="函数组成，柯里化和可变参数"></a><strong><em>函数组成，柯里化和可变参数</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>组成函数</code> 基本上是将一个函数的输出传递给另一个函数。 这不是那么有趣，我们一直都在做。 另一方面， <code>泛函函数</code> 是一个更令人兴奋的话题。 基本上， <code>柯里化</code> 将具有多个参数的函数转换为具有一个参数和返回函数的函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>柯里化</code> 有什么用？ 好吧，有人说这只是语法糖，有人说这很有用，因为您可以将逻辑拆分为更小的，更专业的块。 无论您是否发现 <code>柯里化</code> 有用，我都取决于您，但是我认为这是一种非常有趣的技术，值得学习 <code>柯里化</code> 的基础知识。 🍛</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用可变参数表示接受零个或多个指定类型的值。 因此，这意味着您可以使用可变参数Int参数输入任意数量的整数。 创建可变参量非常简单，只需在类型之后添加三个点即可。让我们来看一下这些事情：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function composition</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = increment(increment(increment(increment(<span class="number">10</span>))))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// function currying</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decrement</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> &#123; $<span class="number">0</span> * x &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> y = decrement(<span class="number">10</span>)(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a variadic function that accepts a block as a parameter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variadic</span><span class="params">(<span class="number">_</span> blocks: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)...) &#123;</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> blocks &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// it means you can pass as many parameters as you want...</span></span><br><span class="line">variadic(&#123; <span class="built_in">print</span>(<span class="string">"a"</span>) &#125;, &#123; <span class="built_in">print</span>(<span class="string">"b"</span>) &#125;, &#123; <span class="built_in">print</span>(<span class="string">"c"</span>) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// lol, trailing closure syntax works with variadic block params.</span></span><br><span class="line">variadic &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"d"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这几乎是 <code>Swift</code> 功能功能的快速介绍。 当然，您可以添加更多参数（但仅允许使用一个可变参数），使用泛型等等，但在深入探讨之前，让我们稍等一下。 🏊‍♂️</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a><strong><em>高阶函数</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果至少满足以下规则之一，则该函数为高阶函数：</p><ul><li>将一个或多个函数作为参数</li><li>返回一个函数作为其结果。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换句话说，甚至在 <code>Swift</code> 中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a function that takes another function as a parameter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(value: Int, <span class="number">_</span> transformation: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> transformation(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = transform(value: <span class="number">10</span>) &#123; value -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">// a function that returns another function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increase</span><span class="params">(withMultiplication shouldMultiply: Bool)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> x: Int, <span class="number">_</span> y: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(<span class="number">_</span> x: Int, <span class="number">_</span> y: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x * y &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldMultiply ? multiply : add</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = increase(withMultiplication: <span class="literal">true</span>)(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，正如您所看到的，它不像魔术，我们只是在传递函数。 乍一看，语法似乎很复杂，但是请相信我，这并不难。 如果遇到麻烦，请尝试为函数类型定义自己的类型别名，这将使代码更具可读性。 <code>typealias VoidBlock = () -&gt; Void</code>👍</p><h2 id="一般函数"><a href="#一般函数" class="headerlink" title="一般函数"></a><strong><em>一般函数</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您试图概括 <code>高阶函数</code> ，就会出现真正的问题。 在涉及 <code>泛型</code> 的情况下，语法看起来有些混乱。  <code>Gererics（又称参数多态性）</code> 使我们可以抽象出常规类型。 因此，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this only works for integers</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseInt</span><span class="params">(<span class="number">_</span> x: Int, or y: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Bool</span>.random() ? x : y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// whoa, this is a generic function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choose</span>&lt;T&gt;<span class="params">(<span class="number">_</span> x: T, or y: T)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Bool</span>.random() ? x : y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = chooseInt(<span class="number">1</span>, or: <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">// 1 or 2, but who knows this for sure</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = choose(<span class="string">"heads"</span>, or: <span class="string">"tails"</span>)</span><br><span class="line"><span class="built_in">print</span>(y) <span class="comment">// maybe heads or maybe tails</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的示例中，我们抽象了带有泛型T类型的整数类型，该类型可以是任何类型。 如果我们以字符串作为第一个参数调用泛型函数，则所有剩余的T类型都将用作字符串。 这有意义吗？ 如果是，那么恭喜您，现在您知道什么是通用函数。 🎊</p><h2 id="容器和箱子📦"><a href="#容器和箱子📦" class="headerlink" title="容器和箱子📦"></a><strong><em>容器和箱子📦</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从一个通用框开始。 您可以将任何值放入盒子中（就像您在现实生活中使用的普通纸箱一样），您始终可以打开盒子并使用 <code>value属性</code> 直接从内部获取值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> value: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="type">Box</span>&lt;<span class="type">Int</span>&gt;(<span class="number">360</span>)</span><br><span class="line"><span class="built_in">print</span>(x.value)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，继续讲一些理论，但是我保证我会做的很简短，因为已经用简单的 <a href="http://www.russbishop.net/monoids-monads-and-functors" target="_blank" rel="noopener"><strong><em><code>解释了函子，代名词和单子</code></em></strong></a> 。 我将尽力使它变得更加简单。 😉</p><h3 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a><strong><em>Functors</em></strong></h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函子是可以调用 <code>map</code> 的容器。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接受挑战！ 让我们用 box 类型做一个函子，但是映射到底是什么呢？ 好吧，它基本上将一个值转换为另一个值。 您可以提供自己的转换方法，在该方法中，您将接收原始值作为参数，并且必须以相同或不同的类型返回“新”值。 编码时间！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transformation: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Box</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Box</span>&lt;<span class="type">U</span>&gt;(transformation(<span class="keyword">self</span>.value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="type">Box</span>&lt;<span class="type">Int</span>&gt;(<span class="number">360</span>)</span><br><span class="line"><span class="keyword">let</span> y = x.<span class="built_in">map</span> &#123; <span class="string">"\($0) degrees"</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(y.value)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此 <code>map</code> 只是一个通用的 <code>高阶函数</code> ！ 只是一个 <code>高阶函数</code> …🤔只是一个函数传递给另一个函数。 哦，这是唯一可行的，因为 <code>Swift</code> 支持 <code>first-class</code> 的函数！ 现在您懂了！ 没什么神奇的，只是功能！</p><h3 id="单子"><a href="#单子" class="headerlink" title="单子"></a><strong><em>单子</em></strong></h3><blockquote><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Monad</code> 是可以调用 <code>flatMap</code> 的容器。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这很容易。  <code>flatMap</code> 是一种函数，可以转换值，然后将其重新包装为原始容器类型。 就像地图一样，但是您必须在转换函数中提供容器。 我将向您展示实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transformation: <span class="params">(T)</span></span></span> -&gt; <span class="type">Box</span>&lt;<span class="type">U</span>&gt;) -&gt; <span class="type">Box</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> transformation(<span class="keyword">self</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="type">Box</span>&lt;<span class="type">Int</span>&gt;(<span class="number">360</span>)</span><br><span class="line"><span class="keyword">let</span> y = x.flatMap &#123; <span class="type">Box</span>&lt;<span class="type">String</span>&gt;(<span class="string">"\($0) degrees"</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(y.value)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您准备好迎接更复杂的事情了吗？ 😅</p><h3 id="应用程式"><a href="#应用程式" class="headerlink" title="应用程式"></a><strong><em>应用程式</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://kandelvijaya.com/2018/03/25/functorapplicativemonad/#orgff1f53e" target="_blank" rel="noopener"><strong><em><code>Applicatives</code></em></strong></a> 可让您将转换功能放入容器中。 因此，只有在可以将转换函数应用到包装的值中之后，才必须首先包装转换函数。 这意味着您还必须在转换之前 <code>“取消装箱”</code> 值。 解释事情是一项艰巨的工作，让我在Swift中尝试一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">apply</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transformation: Box&lt;<span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>&gt;) -&gt; <span class="type">Box</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Box</span>&lt;<span class="type">U</span>&gt;(transformation.value(<span class="keyword">self</span>.value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="type">Box</span>&lt;<span class="type">Int</span>&gt;(<span class="number">360</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> transformation = <span class="type">Box</span>&lt;((<span class="type">Int</span>) -&gt; <span class="type">String</span>)&gt;(&#123; x -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(x) degrees"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = x.apply(transformation)</span><br><span class="line"><span class="built_in">print</span>(y.value)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如您所见，这一切都取决于容器，因此，如果您想使用一个看上去有点不同的 <code>apply函数</code> 扩展 <code>Optional枚举</code> 。 容器化很难！ 🤪</p><p>快速回顾：</p><blockquote><p>Container = M Functor = map(f: T -&gt; U) -&gt; M Monad = flatMap(f: T -&gt; M) -&gt; M Applicative = apply(f: M U)&gt;) -&gt; M</p></blockquote><h3 id="更高种类的类型"><a href="#更高种类的类型" class="headerlink" title="更高种类的类型"></a><strong><em>更高种类的类型</em></strong></h3><blockquote><p>其他高阶类型的想法是使多态函数成为first-class</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前，这尚未在 <code>Swift编程语言</code> 中实现，并且不会成为 <code>swift 5发行版</code>的一部分，但是您可以通过一些技巧在 Swift中 模拟 <a href="https://stackoverflow.com/questions/52905485/how-to-declare-protocol-for-hkt-in-swift" target="_blank" rel="noopener"><strong><em><code>HKT功能</code></em></strong></a> 。 老实说，我真的不想现在再谈论更高种类的类型，因为如果您想拥有更多类似的内容，这可能是下一章功能性编程教程中的核心话题。 😉</p><h3 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a><strong><em>Futures</em></strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们谈谈 <code>Futures</code> 。 根据定义，它们是对尚未计算值的只读引用。 换句话说：<code>future</code> 是一个尚不存在的结果的占位符对象。 对于异步编程，这可能超级有用。 您是否听说过回调地狱？ 😈</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>future</code> 基本上是一个通用的 <code>result wrapper</code> ，结合了回调和一些额外的状态管理。 <code>Futures</code> 既是函子又是单子，这意味着您通常可以在其上同时调用 <code>map</code> 和 <code>flatMap</code> ，但是由于 <code>Futures</code> 的只读性质，您通常必须做出 <a href="https://stackoverflow.com/questions/14541975/whats-the-difference-between-a-future-and-a-promise" target="_blank" rel="noopener"><strong><em><code>promise</code></em></strong></a> 才能创建新的 <code>Future对象</code> 。 您可以在 <code>Swift-NIO</code> 中找到一个非常不错的实现。 😎</p><h3 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a><strong><em>Promises</em></strong></h3><blockquote><p>一个 <code>Promises</code> 是一个可写的单任务容器，它完成了 <code>Futures</code> 。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，您必须做出 <code>Promises</code> 而不是 <code>Futures</code> ，因为 <code>Futures</code> 是按设计只读的。  <code>Promises</code> 是可以完成未来的唯一对象（通常只有一次）。 我们可以说，将来的结果将始终由其他人设置（私有结果变量），而 <code>Promises</code> （基础的 <code>Futures</code> ）将由您设置，因为它具有公共拒绝和解决方法。 🚧</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一些 <code>promise</code> 还实现了 <code>future接口</code> ，因此这意味着您可以在 <code>promise</code> 上直接调用 <code>map</code> ， <code>flatMap</code> （通常都称为简单的重载then方法）。 此外，您还可以捕获错误并使用 <code>Promise</code> 做更多伟大的事情，可以随时查看我简单的 <code>Promise</code> 实现或事实上的标准 <a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener"><strong><em><code>PromiseKit</code></em></strong></a> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您准备好使用一些功能强大的 <code>Swift代码</code> 了吗？</p></br><h1 id="Swift-5中的函数式编程"><a href="#Swift-5中的函数式编程" class="headerlink" title="Swift 5中的函数式编程"></a><strong>Swift 5中的函数式编程</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在该练习我们所学的知识了。 在本节中，我将介绍 <code>Swift 5</code> 中最受欢迎的函数方法，并向您展示一些最佳实践。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a><strong><em>map</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 中的 <code>map函数</code> 适用于所有 <code>Sequence类型</code> ，而 <code>Swift 5</code> 中全新的 <code>Result类型</code> 也具有 <code>map函数</code> ，因此您可以根据需要转换这些类型的值，在某些情况下，这非常好。 这里有一些例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array</span></span><br><span class="line"><span class="keyword">let</span> numbers = <span class="type">Array</span>(<span class="number">0</span>...<span class="number">100</span>)</span><br><span class="line">numbers.<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">10</span> &#125; <span class="comment">// 0, 10, 20 ... 1000</span></span><br><span class="line">numbers.<span class="built_in">map</span>(<span class="type">String</span>.<span class="keyword">init</span>) <span class="comment">// "0", "1", "2" ... "100"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dictionary</span></span><br><span class="line"><span class="keyword">let</span> params: [<span class="type">String</span>: <span class="type">Any</span>] = [</span><br><span class="line">    <span class="string">"sort"</span>: <span class="string">"name"</span>,</span><br><span class="line">    <span class="string">"order"</span>: <span class="string">"desc"</span>,</span><br><span class="line">    <span class="string">"limit"</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">"offset"</span>: <span class="number">2</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapValues is basically map for the dictionary values</span></span><br><span class="line"><span class="keyword">let</span> queryItems = params.mapValues &#123; <span class="string">"\($0)"</span> &#125;</span><br><span class="line">                       .<span class="built_in">map</span>(<span class="type">URLQueryItem</span>.<span class="keyword">init</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="keyword">let</span> fruits = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;(arrayLiteral: <span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>)</span><br><span class="line">fruits.<span class="built_in">map</span> &#123; $<span class="number">0</span>.capitalized &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// range</span></span><br><span class="line">(<span class="number">0</span>...<span class="number">100</span>).<span class="built_in">map</span>(<span class="type">String</span>.<span class="keyword">init</span>)</span><br></pre></td></tr></table></figure><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><strong><em>flatMap</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>flatMap</code> 方法在实现地图功能的大多数类型上也可用。 本质上， <code>flatMap</code> 做以下事情： 映射 和 <code>flattens</code> 。 这意味着您将获得扁平化的子数组数组。 让我告诉你它是如何工作的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flatMap</span></span><br><span class="line"><span class="keyword">let</span> groups = [</span><br><span class="line">    <span class="string">"animals"</span>: [<span class="string">"🐔"</span>, <span class="string">"🦊"</span>, <span class="string">"🐰"</span>, <span class="string">"🦁"</span>],</span><br><span class="line">    <span class="string">"fruits"</span>: [<span class="string">"🍎"</span>, <span class="string">"🍉"</span>, <span class="string">"🍓"</span>, <span class="string">"🥝"</span>]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> emojis = groups.flatMap &#123; $<span class="number">0</span>.value &#125;</span><br><span class="line"><span class="comment">// "🐔", "🦊", "🐰", "🦁", "🍎", "🍉", "🍓", "🥝"</span></span><br></pre></td></tr></table></figure><h2 id="compactMap"><a href="#compactMap" class="headerlink" title="compactMap"></a><strong><em>compactMap</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么， <a href="http://www.xuebaonline.com/Swift%20CompactMap%20vs%20flatMap%EF%BC%9A%E5%B7%AE%E5%BC%82%E8%AF%B4%E6%98%8E/"><strong><em><code>flatMap和compactMap有什么关系</code></em></strong></a> 呢？ 过去， <code>flatMap</code> 可以用于从数组中删除可选元素，但是从 <code>Swift 4.1</code> 开始，有一个名为 <code>compactMap</code> 的新函数可以用于此目的。 在大多数情况下，编译器会警告您将 <a href="http://www.xuebaonline.com/Swift%20%E7%94%A8%20compactMap%20%E6%9B%BF%E6%8D%A2%20flatMap/"><strong><em><code>flatMap 替换为 compactMap</code></em></strong></a> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compactMap</span></span><br><span class="line">[<span class="number">1</span>, <span class="literal">nil</span>, <span class="number">3</span>, <span class="literal">nil</span>, <span class="number">5</span>, <span class="number">6</span>].compactMap &#123; $<span class="number">0</span> &#125; <span class="comment">// 1, 3, 5, 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> possibleNumbers = [<span class="string">"1"</span>, <span class="string">"two"</span>, <span class="string">"3"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>, <span class="string">"6"</span>]</span><br><span class="line">possibleNumbers.compactMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125; <span class="comment">//1, 3, 6</span></span><br></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><strong><em>reduce</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>reduce</code> 方法是一个强大的工具。 它可以用于将集合中的所有元素合并为一个元素。 例如，您可以使用它来汇总元素，但是将元素与初始组件结合在一起也非常方便。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = (<span class="number">0</span>...<span class="number">100</span>).<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"><span class="built_in">print</span>(sum) <span class="comment">//5050</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cats = [<span class="string">"🦁"</span>, <span class="string">"🐯"</span>, <span class="string">"🐱"</span>]</span><br><span class="line">cats.<span class="built_in">reduce</span>(<span class="string">"Cats: "</span>) &#123; sum, cat <span class="keyword">in</span> <span class="string">"\(sum)\(cat)"</span>&#125; <span class="comment">// Cats: 🦁🐯🐱</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> basketballScores = [</span><br><span class="line">    <span class="string">"team one"</span>: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    <span class="string">"team two"</span>: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> points = basketballScores.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; sum, element <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> sum + element.value.<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(points) <span class="comment">// 24 (team one + team two scores together)</span></span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong><em>filter</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您可以使用 <code>filter方法</code> 过滤 <a href="https://medium.com/@JLHLonline/superpowered-sequences-a009ccc1ae43" target="_blank" rel="noopener"><strong><em><code>sequences</code></em></strong></a>  ，这很明显！ 您可以为每个元素定义一个条件块，如果条件为true，则给定元素将包含在结果中。 这就像循环遍历元素并挑选一些元素。 🤪</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> evenNumbers = (<span class="number">0</span>...<span class="number">100</span>).<span class="built_in">filter</span> &#123; $<span class="number">0</span>.isMultiple(of: <span class="number">2</span>) &#125;</span><br><span class="line"><span class="keyword">let</span> oddNumbers = (<span class="number">0</span>...<span class="number">100</span>).<span class="built_in">filter</span> &#123; !evenNumbers.<span class="built_in">contains</span>($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [</span><br><span class="line">    <span class="string">"odd"</span>: oddNumbers,</span><br><span class="line">    <span class="string">"even"</span>: evenNumbers,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> luckyThirteen = numbers</span><br><span class="line">.<span class="built_in">filter</span> &#123; element <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> element.key == <span class="string">"odd"</span></span><br><span class="line">&#125;</span><br><span class="line">.mapValues &#123; element <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> element.<span class="built_in">filter</span> &#123; $<span class="number">0</span> == <span class="number">13</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="promises"><a href="#promises" class="headerlink" title="promises"></a><strong><em>promises</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我喜欢 <code>promises</code> ，如果您不知道 <code>promises</code> 如何运作，也应该学习它们。 否则，您仍然可以使用 <a href="http://www.xuebaonline.com/Swift%20Grand%20Central%20Dispatch%20%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"><strong><em><code>Dispatch框架</code></em></strong></a> ，但我更喜欢 <code>Promise</code> ，因为使用 <code>Promise框架</code> 使传递变量更加容易。 正如我之前在事实上的标准中提到的是 <code>PromiseKit</code> ，但这对于我的口味来说有点太复杂了，我也更喜欢我的 <code>promise方法</code> 名称，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Promise</span>&lt;<span class="type">String</span>&gt; &#123; fulfill, reject <span class="keyword">in</span></span><br><span class="line">    fulfill(<span class="string">"Hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line">.thenMap &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> result + <span class="string">" World!"</span></span><br><span class="line">&#125;</span><br><span class="line">.then &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">String</span>&gt;(value: result)</span><br><span class="line">&#125;</span><br><span class="line">.tap &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"debug: \(result)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">.onSuccess(queue: .main) &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br><span class="line">.onFailure &#123; error <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br><span class="line">.always &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="下一步是什么？"><a href="#下一步是什么？" class="headerlink" title="下一步是什么？"></a><strong>下一步是什么？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在项目中尝试使用这些新的技能。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 Result Type来处理Swift 5中的Errors？</title>
      <link href="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Result%20Type%E6%9D%A5%E5%A4%84%E7%90%86Swift%205%E4%B8%AD%E7%9A%84Errors%EF%BC%9F/"/>
      <url>/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Result%20Type%E6%9D%A5%E5%A4%84%E7%90%86Swift%205%E4%B8%AD%E7%9A%84Errors%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从本教程中，你可以学习如何使用带有新 <code>result type</code> 的 <code>do-try-catch</code> 语法来处理 <code>Swift</code> 中的错误。</p></br><h1 id="Swift中的错误处理"><a href="#Swift中的错误处理" class="headerlink" title="Swift中的错误处理"></a><strong>Swift中的错误处理</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自第一个 <code>Swift</code> 版本以来，处理错误的方式发生了很大变化。 第一个重大里程碑发生在 <code>Swift 2</code> 中， <code>Apple</code> 彻底改进了错误管理。 如今，你可以使用 <code>do</code> ， <code>try</code> ， <code>catch</code> ， <code>throw</code> ， <code>throws</code> ， <code>rethrows</code> 关键字来代替处理讨厌的 <code>NSError指针</code> ，因此这是该语言的一个受欢迎的补充。 现在，在 <code>Swift 5</code> 中，我们通过将 <code>Result类型</code> 作为内置泛型引入了另一个巨大的飞跃。 首先，让我向你展示 <code>Swift编程语言</code> 中所有错误处理的最佳实践，接下来，我将通过使用结果来处理错误，向你展示一些很棒的东西。 🚧</p><a id="more"></a><h2 id="错误指示器"><a href="#错误指示器" class="headerlink" title="错误指示器"></a><strong><em>错误指示器</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于简单的情况，你始终可以使用可选值来指示发生了一些不良情况。 而且， <code>guard</code> 声明在这种情况下也非常有用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zeroValue = <span class="type">Int</span>(<span class="string">"0"</span>)! <span class="comment">// Int</span></span><br><span class="line"><span class="keyword">let</span> nilValue = <span class="type">Int</span>(<span class="string">"not a number"</span>) <span class="comment">// Int?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> number = <span class="type">Int</span>(<span class="string">"6"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Ooops... this should always work, so we crash."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(number)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不太在意错误的根本类型，则可以使用这种方法，但是有时情况会变得更加复杂，因此你可能需要一些有关该问题的详细信息。 无论如何，你始终可以通过调用 <code>fatalError方法</code> 来停止执行，但是如果这样做，那么你的应用程序将崩溃。 💥</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;停止执行过程还有其他几种方法，但这可能是一个独立的帖子的主题，因此这里只是可用方法的快速备忘单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">precondition</span>(<span class="literal">false</span>, <span class="string">"ouch"</span>)</span><br><span class="line"><span class="built_in">preconditionFailure</span>(<span class="string">"ouch"</span>)</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>, <span class="string">"ouch"</span>)</span><br><span class="line"><span class="built_in">assertionFailure</span>(<span class="string">"ouch"</span>)</span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"ouch"</span>)</span><br><span class="line">exit(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前提条件和断言之间的主要区别在于，断言仅在调试版本中起作用，而前提条件始终被评估（即使在发行版本中）。 如果条件再次失败，则这两种方法都会触发致命错误。 是错误的。 ⚠️</p><h2 id="通过使用Error协议抛出异常"><a href="#通过使用Error协议抛出异常" class="headerlink" title="通过使用Error协议抛出异常"></a><strong><em>通过使用Error协议抛出异常</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以通过简单地确认内置错误协议来定义自己的错误类型。 通常，大多数开发人员都使用枚举来定义不同的原因。 如果你符合 <code>LocalizedError协议</code> ，则还可以有一个自定义错误消息。 现在你可以抛出自定义错误了，如果你想引发类型错误，只需使用 <code>throw关键字</code> ，但是如果在函数中这样做，则必须使用 <code>throws</code> 将该函数标记为 <code>throwing函数</code> 关键字。 🤮</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DivisionError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> zeroDivisor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DivisionError</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> errorDescription: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .zeroDivisor:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Division by zero is quite problematic. "</span> +</span><br><span class="line">                   <span class="string">"(https://en.wikipedia.org/wiki/Division_by_zero)"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> x: Int, by y: Int)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> y != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">DivisionError</span>.zeroDivisor</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x / y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很好，因此上面的除法函数可以生成自定义错误消息。 如果除数为零，则会抛出 <code>zeroDivision错误</code> 情况。 现在，设想以下情形：你正在尝试从磁盘读取文件的内容。 可能存在与权限或文件存在等相关的多种错误。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重新抛出函数和方法可以使用 <code>rethrows关键字</code> 声明函数或方法，以表明仅当函数参数之一抛出错误时，它才会抛出错误。 这些功能和方法称为重新抛出函数和重新抛出方法。 抛出函数和方法必须至少具有一个抛出函数参数。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，所以 <code>throwing函数</code> 可以发出不同的错误类型，还可以传播所有参数错误，但是我们如何处理（或者我应该说：捕获）这些错误？</p><h2 id="do-try-catch语法"><a href="#do-try-catch语法" class="headerlink" title="do-try-catch语法"></a><strong><em>do-try-catch语法</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你只需要尝试执行一个 <code>throwing函数</code> 。 因此，不要相信 <code>master</code> ，肯定会有尝试的空间！ 开玩笑吧？ 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="keyword">try</span> divide(<span class="number">10</span>, by: <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">DivisionError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Division error handler block"</span>)</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Generic error handler block"</span>)</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，语法非常简单，你有一个 <code>do块</code> ，你可以在其中尝试执行 <code>throwing函数</code> ，如果出现问题，则可以在不同的 <code>catch块</code> 中处理错误。 默认情况下，每个 <code>catch块</code> 内都有一个 <code>error属性</code> ，因此你不必手动定义一个。 但是，可以通过在 <code>catch关键字</code> 旁边使用 <code>let error as MyType</code> <code>sytnax</code> 强制转换特定错误类型的 <code>catch块</code> 。 因此，始终先尝试，不要只是做！ 🤪</p><h2 id="try-try-and-try-之间的差异"><a href="#try-try-and-try-之间的差异" class="headerlink" title="try, try? and try!之间的差异"></a><strong><em>try, try? and try!之间的差异</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如前所述，你可以简单地尝试调用在 <code>do-catch块</code> 内引发错误的函数。 如果函数触发某种错误，则可以将错误处理逻辑放入 <code>catch块</code> 中。 这非常简单明了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，如果你不太在意潜在的错误，则可以使用 <code>try？</code> 将你的 <code>throwing函数</code> 结果简单地转换为可选结果。 使用这种方法，如果发生不好的情况，你将得到零结果，否则，将按预期返回常规值。 这是上面使用 <code>try？</code> 的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> number = <span class="keyword">try</span>? divide(<span class="number">10</span>, by: <span class="number">2</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"This should work!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(number) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种技术是通过使用 <code>try!</code> 来防止错误传播，但是你必须格外小心，因为如果 <code>“尝试功能”</code> 的执行失败，你的应用程序将崩溃。 因此，仅在绝对确定该函数不会引发错误时使用。 ⚠️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="keyword">try</span>! divide(<span class="number">10</span>, by: <span class="number">2</span>) <span class="comment">// This will work for sure!</span></span><br><span class="line"><span class="built_in">print</span>(number)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在某些地方可以使用强制尝试，但在大多数情况下，应使用适当的错误处理程序在替代路径上。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift 5</code> 中嵌套可选吗？ 值将被展平为单个可选值。  <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0230-flatten-optional-try.md" target="_blank" rel="noopener"><strong><em><code>SE-0230</code></em></strong></a> 是已经实施的建议，可能会破坏一些现有的 <code>Swift</code> 代码。 </p></blockquote><h2 id="Swift-错误也不例外"><a href="#Swift-错误也不例外" class="headerlink" title="Swift 错误也不例外"></a><strong><em>Swift 错误也不例外</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift编译器</code> 总是要求你捕获所有引发的错误，因此永远不会发生未处理错误的情况。 我不是在谈论空的 <code>catch块</code> ，而是在处理未处理的 <code>throw函数</code> ，因此，如果没有 <code>do-catch</code> 伙伴，你将无法尝试。 与例外相比，这是一个主要区别。 同样，当引发错误时，执行将仅退出当前作用域。 异常通常会释放堆栈，这可能导致内存泄漏，但是 <code>Swift错误</code> 并非如此。 👍</p></br><h1 id="介绍-Result-Type"><a href="#介绍-Result-Type" class="headerlink" title="介绍 Result Type"></a>介绍 Result Type</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift 5</code> 引入了期待已久的通用<code>result type</code> 。 这意味着错误处理可以更加简单，而无需添加你自己的结果实现。 让我通过使用 <code>Result</code> 向你展示我们之前的除法函数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> x: Int, by y: Int)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>, <span class="type">DivisionError</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> y != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .failure(.zeroDivisor)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> .success(x / y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = divide(<span class="number">10</span>, by: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">switch</span> result &#123;</span><br><span class="line"><span class="keyword">case</span> .success(<span class="keyword">let</span> number):</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line"><span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 中的 <code>结果类型</code> 基本上是具有 <code>.success</code> 和 <code>.failure</code> 情况的通用枚举。 如果调用成功，则可以传递通用值；如果调用失败，则可以传递错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的一个主要优点是结果返回的错误是 <code>类型安全</code> 的。  抛出函数 可以抛出任何类型的错误，但是在这里，你可以从实现中看到，如果发生不好的情况， <code>DivisionError</code> 将返回。 另一个好处是，即使没有默认情况，你也可以使用穷举开关块来 <code>“遍历”</code> 所有可能的错误情况。 这样编译器可以使你安全，例如。 如果要在枚举声明中引入新的错误类型。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，通过使用 <code>Result类型</code> ，很明显，我们可以获取 <code>结果数据</code> 或 <code>强类型错误</code> 。 不可能两者都获得，但是这比使用 <code>throwing函数</code> 更好吗？ 好吧，让我们散开吧！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> x: Int, by y: Int, completion: <span class="params">(<span class="params">(<span class="params">()</span></span></span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">    <span class="keyword">guard</span> y != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        completion &#123; <span class="keyword">throw</span> <span class="type">DivisionError</span>.zeroDivisor &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    completion &#123; <span class="keyword">return</span> x / y &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divide(<span class="number">10</span>, by: <span class="number">0</span>) &#123; calculate <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> number = <span class="keyword">try</span> calculate()</span><br><span class="line">        <span class="built_in">print</span>(number)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内在封闭！ 完成处理程序接受抛出函数，因此我们可以将抛出的错误传播到外部处理程序了！ 🤬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个选择是，我们完全消除了抛出错误，并因此使用了一个可选参数，但是在这种情况下，我们回到 <code>square one</code> 。 没有基础的错误类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> x: Int, by y: Int, completion: <span class="params">(Int?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> y != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> completion(<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    completion(x / y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divide(<span class="number">10</span>, by: <span class="number">0</span>) &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> number = result <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"nil"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终，我们到了这里，但是这次我们也将错误添加为 <code>闭包参数</code> 。 你应该注意，两个参数都必须是可选的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> x: Int, by y: Int, completion: <span class="params">(Int?, Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> y != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> completion(<span class="literal">nil</span>, <span class="type">DivisionError</span>.zeroDivisor)</span><br><span class="line">    &#125;</span><br><span class="line">    completion(x / y, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divide(<span class="number">10</span>, by: <span class="number">0</span>) &#123; result, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> error == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(error!.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> number = result <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Empty result."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，让我们介绍一下结果，以便我们可以从之前的代码中消除可选参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> x: Int, by y: Int, completion: <span class="params">(Result&lt;Int, DivisionError&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> y != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> completion(.failure(.zeroDivisor))</span><br><span class="line">    &#125;</span><br><span class="line">    completion(.success(x / y))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divide(<span class="number">10</span>, by: <span class="number">0</span>) &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> number):</span><br><span class="line">        <span class="built_in">print</span>(number)</span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;强类型错误，无可选。 通过使用 <code>Result类型</code> ，更好地处理 <code>异步函数</code> 中的错误。 如果你认为大多数应用程序都在进行某种形式的联网，并且结果通常是 <code>JSON响应</code> ，那么你已经必须使用可选参数（响应，数据，错误），并且你还有抛出 <code>JSONDecoder</code> 的方法…可以 等待新的API！ ❤️</p><h2 id="在Swift-5中使用Result类型"><a href="#在Swift-5中使用Result类型" class="headerlink" title="在Swift 5中使用Result类型"></a><strong><em>在Swift 5中使用Result类型</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经知道结果类型基本上是带有通用 <code>.succes（T）</code> 和 <code>.failure（Error）</code> 例的枚举，但是我想在这里向你展示更多。 例如，你可以使用以下抛出函数创建结果类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> divide(<span class="number">10</span>, by: <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以通过调用 <code>get函数</code> 来转换回结果值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="keyword">try</span> result.<span class="keyword">get</span>()</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，还有用于转换成功值的 <code>map</code> ， <code>flatMap</code> ，如果你要转换失败，也可以使用 <code>mapError</code> 或 <code>flatMapError</code> 方法。 😎</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = divide(<span class="number">10</span>, by: <span class="number">2</span>) <span class="comment">// Result&lt;Int, DivisionError&gt;</span></span><br><span class="line"><span class="keyword">let</span> mapSuccess = result.<span class="built_in">map</span> &#123; divide($<span class="number">0</span>, by: <span class="number">2</span>) &#125; <span class="comment">// Result&lt;Result&lt;Int, DivisionError&gt;, DivisionError&gt;</span></span><br><span class="line"><span class="keyword">let</span> flatMapSuccess = result.flatMap &#123; divide($<span class="number">0</span>, by: <span class="number">2</span>) &#125; <span class="comment">// Result&lt;Int, DivisionError&gt;</span></span><br><span class="line"><span class="keyword">let</span> mapFailure = result.mapError &#123; <span class="type">NSError</span>(domain: $<span class="number">0</span>.localizedDescription, code: <span class="number">0</span>, userInfo: <span class="literal">nil</span>) &#125;</span><br><span class="line"><span class="keyword">let</span> flatMapFailure = result.flatMapError &#123; .failure(<span class="type">NSError</span>(domain: $<span class="number">0</span>.localizedDescription, code: <span class="number">0</span>, userInfo: <span class="literal">nil</span>)) &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是 <code>Swift 5</code> 中的 <code>Result类型</code> 。正如你所看到的，直接在语言中内置通用实现非常强大。 现在我们有了结果，我只希望有更高种类的类型或 <code>异步/等待</code> 实现。 👍</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Result Type </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Result Type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Swift中的Grand Central Dispatch</title>
      <link href="/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Swift%E4%B8%AD%E7%9A%84Grand%20Central%20Dispatch/"/>
      <url>/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Swift%E4%B8%AD%E7%9A%84Grand%20Central%20Dispatch/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://developer.apple.com/reference/dispatch" target="_blank" rel="noopener"><strong><em><code>Grand Central Dispatch</code></em></strong></a>（简称GCD）是大多数 <code>Swift开发人员</code> 使用无数次的基本技术之一。 它主要是因为能够在不同的并发队列上分派工作而闻名，并且经常用于编写如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="comment">// Run async code on the main queue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是事实证明，如果我们再深入一点， <code>GCD</code> 还提供了一套并非所有人都知道的真正强大的API和功能。 本周，让我们超越 <code>async {}</code> ，看看在某些情况下GCD确实非常有用，以及它如何为许多其他（更常见的） <code>Foundation API</code> 提供更简单（更“迅速”）的选项。</p><a id="more"></a></br><h1 id="使用DispatchWorkItem延迟可取消的任务"><a href="#使用DispatchWorkItem延迟可取消的任务" class="headerlink" title="使用DispatchWorkItem延迟可取消的任务"></a><strong>使用DispatchWorkItem延迟可取消的任务</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于 <code>GCD</code> 的一个常见误解是 <code>“一旦安排了无法取消的任务，就需要使用Operation API”</code>。 虽然过去确实如此，但在 <code>iOS 8</code> 和 <code>macOS 10.10</code> 中引入了 <code>DispatchWorkItem</code> ，它以非常易于使用的API提供了此确切功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们的用户界面具有搜索栏，当用户键入字符时，我们会通过调用后端进行搜索。 由于用户可以快速键入内容，因此我们不希望立即启动网络请求（这可能会浪费大量数据和服务器容量），而我们将对这些事件进行“反跳”操作，而仅执行请求 一旦用户没有输入0.25秒。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是 <code>DispatchWorkItem</code> 的用处。通过将我们的请求代码封装在一个工作项中，无论何时将其替换为新的请求代码，我们都可以轻松地将其取消，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchViewController</span>: <span class="title">UIViewController</span>, <span class="title">UISearchBarDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We keep track of the pending work item as a property</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> pendingRequestWorkItem: <span class="type">DispatchWorkItem?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">searchBar</span><span class="params">(<span class="number">_</span> searchBar: UISearchBar, textDidChange searchText: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Cancel the currently pending item</span></span><br><span class="line">        pendingRequestWorkItem?.cancel()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wrap our request in a work item</span></span><br><span class="line">        <span class="keyword">let</span> requestWorkItem = <span class="type">DispatchWorkItem</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.resultsLoader.loadResults(forQuery: searchText)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new work item and execute it after 250 ms</span></span><br><span class="line">        pendingRequestWorkItem = requestWorkItem</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + .milliseconds(<span class="number">250</span>),</span><br><span class="line">                                      execute: requestWorkItem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们在上面看到的，由于 <code>尾随闭包语法</code> 以及 <code>GCD</code> 导入 <code>Swift</code> 的效果，在 <code>Swift</code> 中使用 <code>DispatchWorkItem</code> 实际上比必须使用 <code>Timer</code> 或 <code>Operation</code> 简单得多。 我们不需要使用 <code>@objc</code> 标记的方法或 <code>#selector</code> - 都可以使用闭包来完成。</p></br><h1 id="使用DispatchGroup分组和链接任务"><a href="#使用DispatchGroup分组和链接任务" class="headerlink" title="使用DispatchGroup分组和链接任务"></a><strong>使用DispatchGroup分组和链接任务</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时我们需要执行一组操作，然后才能继续执行逻辑。 例如，假设我们需要先从一组数据源中加载数据，然后才能创建模型。 不必自己跟踪所有数据源，我们可以轻松地将工作与 <code>DispatchGroup</code> 同步。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用调度组 还为我们提供了一个很大的优势，因为我们的任务可以在单独的队列中同时运行。 这使我们能够从简单开始，然后在需要时轻松添加并发，而无需重写任何任务。 我们要做的就是在调度组上均衡地调用 <code>enter()</code> 和 <code>leave()</code> ，以使其同步我们的任务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看一个示例，在该示例中，我们从本地存储， <code>iCloud Drive</code> 和后端系统加载笔记，然后将所有结果合并到一个 <code>NoteCollection</code> 中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First, we create a group to synchronize our tasks</span></span><br><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// NoteCollection is a thread-safe collection class for storing notes</span></span><br><span class="line"><span class="keyword">let</span> collection = <span class="type">NoteCollection</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// The 'enter' method increments the group's task count…</span></span><br><span class="line">group.enter()</span><br><span class="line">localDataSource.load &#123; notes <span class="keyword">in</span></span><br><span class="line">    collection.add(notes)</span><br><span class="line">    <span class="comment">// …while the 'leave' methods decrements it</span></span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">iCloudDataSource.load &#123; notes <span class="keyword">in</span></span><br><span class="line">    collection.add(notes)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">backendDataSource.load &#123; notes <span class="keyword">in</span></span><br><span class="line">    collection.add(notes)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This closure will be called when the group's task count reaches 0</span></span><br><span class="line">group.notify(queue: .main) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>?.render(collection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码有效，但是其中有很多重复项。 让我们将其重构为 <code>Array的扩展</code> ，使用 <code>DataSource协议</code> 作为 <code>其Element类型</code> 的同类型约束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span> == <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(completionHandler: @escaping <span class="params">(NoteCollection)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line">        <span class="keyword">let</span> collection = <span class="type">NoteCollection</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// De-duplicate the synchronization code by using a loop</span></span><br><span class="line">        <span class="keyword">for</span> dataSource <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            group.enter()</span><br><span class="line">            dataSource.load &#123; notes <span class="keyword">in</span></span><br><span class="line">                collection.add(notes)</span><br><span class="line">                group.leave()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        group.notify(queue: .main) &#123;</span><br><span class="line">            completionHandler(collection)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过以上扩展，我们现在可以将之前的代码简化为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSources: [<span class="type">DataSource</span>] = [</span><br><span class="line">    localDataSource,</span><br><span class="line">    iCloudDataSource,</span><br><span class="line">    backendDataSource</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">dataSources.load &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] collection <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>?.render(collection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好，紧凑！ 👍</p><h1 id="用DispatchSemaphore等待异步任务"><a href="#用DispatchSemaphore等待异步任务" class="headerlink" title="用DispatchSemaphore等待异步任务"></a><strong>用DispatchSemaphore等待异步任务</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管 <code>DispatchGroup</code> 提供了一种同步一组异步操作而又保持异步的好方法，但 <code>DispatchSemaphore</code> 提供了一种同步等待一组异步任务的方法。 这在命令行工具或脚本中非常有用，因为我们没有应用程序运行循环，而只是在全局上下文中同步执行直到完成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像 <code>DispatchGroup</code> 一样， <code>信号量API</code> 非常简单，因为我们只通过调用 <code>wait()</code> 或 <code>signal()</code> 来增加或减少内部计数器。 在 <code>signal()</code> 之前调用 <code>wait()</code>将阻塞当前队列，直到接收到信号为止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们在之前的 <code>Array扩展</code> 中创建另一个重载，该重载同步返回 <code>NoteCollection</code> ，否则将引发错误。 我们将重用以前基于 <code>DispatchGroup</code> 的代码，而仅使用 <code>信号量</code> 协调该任务。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span> == <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">NoteCollection</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> loadedCollection: <span class="type">NoteCollection?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We create a new queue to do our work on, since calling wait() on</span></span><br><span class="line">        <span class="comment">// the semaphore will cause it to block the current queue</span></span><br><span class="line">        <span class="keyword">let</span> loadingQueue = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"></span><br><span class="line">        loadingQueue.async &#123;</span><br><span class="line">            <span class="comment">// We extend 'load' to perform its work on a specific queue</span></span><br><span class="line">            <span class="keyword">self</span>.load(onQueue: loadingQueue) &#123; collection <span class="keyword">in</span></span><br><span class="line">                loadedCollection = collection</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Once we're done, we signal the semaphore to unblock its queue</span></span><br><span class="line">                semaphore.signal()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait with a timeout of 5 seconds</span></span><br><span class="line">        semaphore.wait(timeout: .now() + <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> collection = loadedCollection <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">NoteLoadingError</span>.timedOut</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> collection</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Array</code> 上使用上述新方法，我们现在可以在脚本或命令行工具中同步加载笔记，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSources: [<span class="type">DataSource</span>] = [</span><br><span class="line">    localDataSource,</span><br><span class="line">    iCloudDataSource,</span><br><span class="line">    backendDataSource</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> collection = <span class="keyword">try</span> dataSources.load()</span><br><span class="line">    output(collection)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    output(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="使用DispatchSource观察文件中的更改"><a href="#使用DispatchSource观察文件中的更改" class="headerlink" title="使用DispatchSource观察文件中的更改"></a><strong>使用DispatchSource观察文件中的更改</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我想提出的 <code>GCD</code> 的最后一个“鲜为人知”的功能是 <strong>它如何提供一种观察文件系统中文件更改</strong> 的方法。 像 <code>DispatchSemaphore</code> 一样，如果我们要自动响应用户正在编辑的文件，则在脚本或命令行工具中这可能是超级有用的。 这使我们能够轻松构建具有 <code>“实时编辑”</code> 功能的开发人员工具。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调度源有几种不同的变体，具体取决于我们要观察的内容。 在这种情况下，我们将使用 <code>DispatchSourceFileSystemObject</code> ，它使我们可以观察文件系统中的事件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看一个简单的 <code>FileObserver</code> 的示例实现，该示例实现使我们附加一个闭包，以在每次更改给定文件时运行该闭包。 它通过使用 <code>fileDescriptor</code> 和 <code>DispatchQueue</code> 创建调度源来执行观察，并使用 <code>Files</code> 引用要观察的文件来工作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> file: <span class="type">File</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> queue: <span class="type">DispatchQueue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> source: <span class="type">DispatchSourceFileSystemObject?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(file: <span class="type">File</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.file = file</span><br><span class="line">        <span class="keyword">self</span>.queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.myapp.fileObserving"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">(closure: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="comment">// We can only convert an NSString into a file system representation</span></span><br><span class="line">        <span class="keyword">let</span> path = (file.path <span class="keyword">as</span> <span class="type">NSString</span>)</span><br><span class="line">        <span class="keyword">let</span> fileSystemRepresentation = path.fileSystemRepresentation</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Obtain a descriptor from the file system</span></span><br><span class="line">        <span class="keyword">let</span> fileDescriptor = <span class="keyword">open</span>(fileSystemRepresentation, <span class="type">O_EVTONLY</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create our dispatch source</span></span><br><span class="line">        <span class="keyword">let</span> source = <span class="type">DispatchSource</span>.makeFileSystemObjectSource(</span><br><span class="line">            fileDescriptor: fileDescriptor,</span><br><span class="line">            eventMask: .write,</span><br><span class="line">            queue: queue</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assign the closure to it, and resume it to start observing</span></span><br><span class="line">        source.setEventHandler(handler: closure)</span><br><span class="line">        source.resume()</span><br><span class="line">        <span class="keyword">self</span>.source = source</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们现在可以像这样使用 <code>FileObserver</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">try</span> <span class="type">FileObserver</span>(file: file)</span><br><span class="line"></span><br><span class="line">observer.start &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"File was changed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象一下可以使用此工具构建的所有出色的开发人员工具！ 😀</p></br><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Grand Central Dispatch</code> 是一个非常强大的框架，其功能远不止最初看起来的样子。 希望这篇文章激发了你对它的用途的想象力，我建议你下次尝试执行我们在本文中介绍的任务之一时尝试一下。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我看来，直接使用 <code>GCD</code> 实际上可以简化许多基于 <code>Timer</code> 或 <code>OperationQueue</code> 的代码，以及使用第三方异步框架。🚀</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Grand Central Dispatch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Grand Central Dispatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Swift中生成随机数</title>
      <link href="/%E5%9C%A8Swift%E4%B8%AD%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/%E5%9C%A8Swift%E4%B8%AD%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用最新方法并涵盖一些旧技术，了解在 <code>Swift</code> 中生成随机值所需的一切。</p></br><h1 id="如何使用Swift生成随机数？"><a href="#如何使用Swift生成随机数？" class="headerlink" title="如何使用Swift生成随机数？"></a><strong>如何使用Swift生成随机数？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，自 <code>Swift 4.2</code> 起，统一了随机数生成功能。 这意味着你不再需要导入的 <code>C API</code>，只需在所有平台上使用本机 <code>Swift</code> 方法即可生成随机值！ 😍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> randomBool = <span class="type">Bool</span>.random()</span><br><span class="line"><span class="keyword">let</span> randomInt = <span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">1</span>...<span class="number">6</span>) <span class="comment">//dice roll</span></span><br><span class="line"><span class="keyword">let</span> randomFloat = <span class="type">Float</span>.random(<span class="keyword">in</span>: <span class="number">0</span>...<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> randomDouble = <span class="type">Double</span>.random(<span class="keyword">in</span>: <span class="number">1</span>..&lt;<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，借助 <code>Swift语言</code> 内置的加密安全随机发生器，现在非常容易生成骰子。 新的随机数生成器 <code>API</code> 也更擅长分配数字。 旧的 <code>arc4random</code> 函数存在一些问题，因为由于模偏差的影响，生成的值不均匀地分布在例如1到6之间。 🎲</p><a id="more"></a></br><h1 id="随机数发生器（RNG）"><a href="#随机数发生器（RNG）" class="headerlink" title="随机数发生器（RNG）"></a><strong>随机数发生器（RNG）</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的这些示例隐式使用了 <code>Swift标准库</code> 提供的默认随机数生成器 <code>（SystemRandomNumberGenerator）</code> 。 每个方法都有第二个参数，因此你可以根据需要使用其他RNG。 如果你想改变分布的行为（或者只是给它一些“熵”！🤪），也可以实现自己的 <a href="https://github.com/t-ae/rng-extension" target="_blank" rel="noopener"><strong><em><code>RNG或扩展内置生成器</code></em></strong></a> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rng = <span class="type">SystemRandomNumberGenerator</span>()</span><br><span class="line"><span class="keyword">let</span> randomBool = <span class="type">Bool</span>.random(using: &amp;rng)</span><br><span class="line"><span class="keyword">let</span> randomInt = <span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">1</span>...<span class="number">6</span>, using: &amp;rng) <span class="comment">//dice roll</span></span><br><span class="line"><span class="keyword">let</span> randomFloat = <span class="type">Float</span>.random(<span class="keyword">in</span>: <span class="number">0</span>...<span class="number">1</span>, using: &amp;rng)</span><br><span class="line"><span class="keyword">let</span> randomDouble = <span class="type">Double</span>.random(<span class="keyword">in</span>: <span class="number">1</span>..&lt;<span class="number">100</span>, using: &amp;rng)</span><br></pre></td></tr></table></figure></br><h2 id="集合，随机元素"><a href="#集合，随机元素" class="headerlink" title="集合，随机元素"></a><strong><em>集合，随机元素</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新的随机 <code>API</code> 引入了一些不错的 <code>集合类型扩展</code> 。 现在，选择一个随机元素并混合一个集合中的元素顺序非常简单且高效（同时具有自定义RNG支持）。 😉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="string">"🐶"</span>, <span class="string">"🐱"</span>, <span class="string">"🐮"</span>, <span class="string">"🐷"</span>, <span class="string">"🐔"</span>, <span class="string">"🐵"</span>]</span><br><span class="line"><span class="keyword">let</span> randomArrayElement = array.randomElement()</span><br><span class="line"><span class="keyword">let</span> shuffledArray = array.shuffled()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dictionary = [</span><br><span class="line">    <span class="string">"🐵"</span>: <span class="string">"🍌"</span>,</span><br><span class="line">    <span class="string">"🐱"</span>: <span class="string">"🥛"</span>,</span><br><span class="line">    <span class="string">"🐶"</span>: <span class="string">"🍖"</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> randomDictionaryElement = dictionary.randomElement()</span><br><span class="line"><span class="keyword">let</span> shuffledDictionary = dictionary.shuffled()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sequence = <span class="number">1</span>..&lt;<span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> randomSequenceElement = sequence.randomElement()</span><br><span class="line"><span class="keyword">let</span> shuffledSequence = sequence.shuffled()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;(arrayLiteral: <span class="string">"🐶"</span>, <span class="string">"🐱"</span>, <span class="string">"🐮"</span>, <span class="string">"🐷"</span>, <span class="string">"🐔"</span>, <span class="string">"🐵"</span>)</span><br><span class="line"><span class="keyword">let</span> randomSetElement = <span class="keyword">set</span>.randomElement()</span><br><span class="line"><span class="keyword">let</span> shuffledSet = <span class="keyword">set</span>.shuffled()</span><br></pre></td></tr></table></figure><h2 id="随机化自定义类型"><a href="#随机化自定义类型" class="headerlink" title="随机化自定义类型"></a><strong><em>随机化自定义类型</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以在自定义类型上实现随机函数。 为了遵循 <code>Swift标准库模式</code> ，应牢记两个简单的事情：</p><ul><li>为 <code>自定义RNG</code> 提供一个具有 <code>（inout）</code> 参数的静态方法</li><li>制作使用 <code>SystemRandomNumberGenerator</code> 的 <code>random()</code> 方法</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Animal</span>: <span class="title">String</span>, <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> dog = <span class="string">"🐶"</span></span><br><span class="line">    <span class="keyword">case</span> cat = <span class="string">"🐱"</span></span><br><span class="line">    <span class="keyword">case</span> cow = <span class="string">"🐮"</span></span><br><span class="line">    <span class="keyword">case</span> pig = <span class="string">"🐷"</span></span><br><span class="line">    <span class="keyword">case</span> chicken = <span class="string">"🐔"</span></span><br><span class="line">    <span class="keyword">case</span> monkey = <span class="string">"🐵"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">random</span>&lt;T: RandomNumberGenerator&gt;<span class="params">(using generator: <span class="keyword">inout</span> T)</span></span> -&gt; <span class="type">Animal</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allCases.randomElement(using: &amp;generator)!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Animal</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> rng = <span class="type">SystemRandomNumberGenerator</span>()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Animal</span>.random(using: &amp;rng)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> random: <span class="type">Animal</span> = .random()</span><br><span class="line">random.rawValue</span><br></pre></td></tr></table></figure></br><h1 id="使用GameplayKit生成随机值"><a href="#使用GameplayKit生成随机值" class="headerlink" title="使用GameplayKit生成随机值"></a><strong>使用GameplayKit生成随机值</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://developer.apple.com/documentation/gameplaykit" target="_blank" rel="noopener"><strong><em><code>GameplayKit</code></em></strong></a> 提供了许多帮助你处理随机数生成的功能。 框架内提供了各种随机源和发行版，让我们快速看一下它们。</p><h2 id="GameplayKit中的随机来源"><a href="#GameplayKit中的随机来源" class="headerlink" title="GameplayKit中的随机来源"></a><strong><em>GameplayKit中的随机来源</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>GameplayKit</code> 实现了三种随机源算法，其背后的原因是很难生成随机数，但是通常你会使用 <code>arc4随机源</code> 。 你应该注意，Apple建议你在将其用于重要内容之前将其前769个值重置（将其舍入为1024以使其看起来更好），否则它将产生可猜测的序列。 🔑</p><p><strong><code>GKARC4RandomSource</code></strong> -好的性能和随机性</p><p><strong><code>GKLinearCongruentialRandomSource</code></strong> -快速，较少随机</p><p><strong><code>GKMersenneTwisterRandomSource</code></strong> -随机性好，但速度慢</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以简单地在上述任何一个源上使用 <code>nextInt()</code>方法从 <code>int min</code> 到 <code>int max</code> 生成一个随机数，或者使用 <code>nextInt(upperBound:)</code>方法从0到上限生成一个随机数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GameplayKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arc4 = <span class="type">GKARC4RandomSource</span>()</span><br><span class="line">arc4.dropValues(<span class="number">1024</span>) <span class="comment">//drop first 1024 values first</span></span><br><span class="line">arc4.nextInt(upperBound: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> linearCongruential = <span class="type">GKLinearCongruentialRandomSource</span>()</span><br><span class="line">linearCongruential.nextInt(upperBound: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> mersenneTwister = <span class="type">GKMersenneTwisterRandomSource</span>()</span><br><span class="line">mersenneTwister.nextInt(upperBound: <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="随机分布算法"><a href="#随机分布算法" class="headerlink" title="随机分布算法"></a><strong><em>随机分布算法</em></strong></h2><blockquote><p><strong>GKRandomDistribution</strong> - 生成随机数的生成器，该随机数在特定范围内，并且在多个采样中表现出特定的分布。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本上可以说，该实现正在尝试为我们提供随机分布的值。 这是共享随机源的默认值。 🤨</p><blockquote><p><strong>GKGaussianDistribution</strong> -随机数生成器，在多个采样中遵循高斯分布（也称为正态分布）。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>高斯分布</code> 是一个整形的随机数生成器，因此中间附近的数字更有可能出现。 换句话说，中间元素的发生率会更高，因此，如果你要模拟骰子掷骰，则3发生的可能性要大于1或6。 😅</p><blockquote><p><strong>GKShuffledDistribution</strong> -生成随机数的发生器，这些随机数在许多采样中均匀分布，但是不可能出现相似值的短序列。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;公平随机数生成器或混洗分布是一种以均等分布的相等数量生成其每个可能值的方法。 如果我们将骰子掷骰示例保留为6卷，则你可能会得到6、2、1、3、4、5，但永远不会得到6 6 6 1 2 6。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6 sided dice</span></span><br><span class="line"><span class="keyword">let</span> randomD6 = <span class="type">GKRandomDistribution</span>.d6()</span><br><span class="line"><span class="keyword">let</span> shuffledD6 = <span class="type">GKShuffledDistribution</span>.d6()</span><br><span class="line"><span class="keyword">let</span> gaussianD6 = <span class="type">GKGaussianDistribution</span>.d6()</span><br><span class="line">randomD6.nextInt()   <span class="comment">// completely random</span></span><br><span class="line">shuffledD6.nextInt() <span class="comment">// see below... // eg. 1</span></span><br><span class="line">gaussianD6.nextInt() <span class="comment">// mostly 3, most likely 2, 4 less likely 1, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//goes through all the possible values again and again...</span></span><br><span class="line">shuffledD6.nextInt() <span class="comment">// eg. 3</span></span><br><span class="line">shuffledD6.nextInt() <span class="comment">// eg. 5</span></span><br><span class="line">shuffledD6.nextInt() <span class="comment">// eg. 2</span></span><br><span class="line">shuffledD6.nextInt() <span class="comment">// eg. 6</span></span><br><span class="line">shuffledD6.nextInt() <span class="comment">// eg. 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 20 sided dice</span></span><br><span class="line"><span class="keyword">let</span> randomD20 = <span class="type">GKRandomDistribution</span>.d20()</span><br><span class="line"><span class="keyword">let</span> shuffledD20 = <span class="type">GKShuffledDistribution</span>.d20()</span><br><span class="line"><span class="keyword">let</span> gaussianD20 = <span class="type">GKGaussianDistribution</span>.d20()</span><br><span class="line">randomD20.nextInt()</span><br><span class="line">shuffledD20.nextInt()</span><br><span class="line">gaussianD20.nextInt()</span><br><span class="line"></span><br><span class="line"><span class="comment">// using custom random source, by default it uses arc4</span></span><br><span class="line"><span class="keyword">let</span> mersenneTwister = <span class="type">GKMersenneTwisterRandomSource</span>()</span><br><span class="line"><span class="keyword">let</span> mersoneTwisterRandomD6 = <span class="type">GKRandomDistribution</span>(randomSource: mersenneTwister, lowestValue: <span class="number">1</span>, highestValue: <span class="number">6</span>)</span><br><span class="line">mersoneTwisterRandomD6.nextInt()</span><br><span class="line">mersoneTwisterRandomD6.nextInt(upperBound: <span class="number">3</span>) <span class="comment">//limiting upper bound</span></span><br></pre></td></tr></table></figure><h2 id="如何使用GameplayKit随机播放数组？"><a href="#如何使用GameplayKit随机播放数组？" class="headerlink" title="如何使用GameplayKit随机播放数组？"></a><strong><em>如何使用GameplayKit随机播放数组？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <strong><em>arrayByShufflingObjects(in :)</em></strong> 方法来混合数组中的元素。 你也可以使用种子值来相同地随机播放元素。 这将是一个随机顺序，但可以预见。 如果你需要在多个设备之间同步两个随机阵列，这将很方便。 📱</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dice = [<span class="type">Int</span>](<span class="number">1</span>...<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> random = <span class="type">GKRandomSource</span>.sharedRandom()</span><br><span class="line"><span class="keyword">let</span> randomRolls = random.arrayByShufflingObjects(<span class="keyword">in</span>: dice)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mersenneTwister = <span class="type">GKMersenneTwisterRandomSource</span>()</span><br><span class="line"><span class="keyword">let</span> mersenneTwisterRolls = mersenneTwister.arrayByShufflingObjects(<span class="keyword">in</span>: dice)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fixedSeed = <span class="type">GKMersenneTwisterRandomSource</span>(seed: <span class="number">1001</span>)</span><br><span class="line"><span class="keyword">let</span> fixed1 = fixedSeed.arrayByShufflingObjects(<span class="keyword">in</span>: dice) <span class="comment">// always the same order</span></span><br></pre></td></tr></table></figure><h2 id="GameplayKit最佳实践以生成随机值"><a href="#GameplayKit最佳实践以生成随机值" class="headerlink" title="GameplayKit最佳实践以生成随机值"></a><strong><em>GameplayKit最佳实践以生成随机值</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一个共享的随机源，可用于生成随机数。 如果你不想弄乱发行版或资源，这是理想的选择。 此共享的随机对象使用arc4作为源和随机分布。 😉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sharedRandomSource = <span class="type">GKRandomSource</span>.sharedRandom()</span><br><span class="line">sharedRandomSource.nextBool() <span class="comment">// true / false</span></span><br><span class="line">sharedRandomSource.nextInt() <span class="comment">//from int min - to int max</span></span><br><span class="line">sharedRandomSource.nextInt(upperBound: <span class="number">6</span>) <span class="comment">//dice roll</span></span><br><span class="line">sharedRandomSource.nextUniform() <span class="comment">//float between 0 - 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，不建议将 <code>GameplayKit框架</code> 提供的这些随机数生成解决方案用于加密目的！</p></br><h1 id="Swift-4-2之前的随机生成方法"><a href="#Swift-4-2之前的随机生成方法" class="headerlink" title="Swift 4.2之前的随机生成方法"></a><strong>Swift 4.2之前的随机生成方法</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于历史原因，我将在这里离开此部分。 😅</p><h2 id="arc4random"><a href="#arc4random" class="headerlink" title="arc4random"></a><strong><em>arc4random</em></strong></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arc4random() % <span class="number">6</span> + <span class="number">1</span> <span class="comment">// dice roll</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个 <code>C函数</code> 在生成骰子掷骰时非常常见，但也很危险，因为它可能导致模偏差（或“孔洞原理”），这意味着某些数字的生成频率比其他数字高。 请不要使用它。 😅</p><h2 id="arc4random-uniform"><a href="#arc4random-uniform" class="headerlink" title="arc4random_uniform"></a><strong><em>arc4random_uniform</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此方法将返回均匀分布的随机数。 这是在 <code>Swift 4.2</code> 之前生成随机数的最佳/推荐方式，因为如果上限不是2的幂，它可以避免模偏差问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rndm</span><span class="params">(<span class="built_in">min</span>: Int, <span class="built_in">max</span>: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">max</span> &lt; <span class="built_in">min</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"The max value should be greater than the min value."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">min</span> == <span class="built_in">max</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>((<span class="built_in">max</span> - <span class="built_in">min</span>) + <span class="number">1</span>))) + <span class="built_in">min</span></span><br><span class="line">&#125;</span><br><span class="line">rndm(<span class="built_in">min</span>: <span class="number">1</span>, <span class="built_in">max</span>: <span class="number">6</span>) <span class="comment">//dice roll</span></span><br></pre></td></tr></table></figure><h2 id="drand48"><a href="#drand48" class="headerlink" title="drand48"></a><strong><em>drand48</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>drand48函数</code> 返回介于 <code>0到1</code> 之间的随机浮点数。它对于为随机 <code>UIColor</code> 对象生成颜色值非常有用。 另一面要注意的是，它会生成一个伪随机数序列，并且你必须使用 <code>srand48</code> 和通常是时间参数来提供种子值。 🤷‍♂️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> red = <span class="type">CGFloat</span>(drand48())</span><br><span class="line"><span class="keyword">let</span> green = <span class="type">CGFloat</span>(drand48())</span><br><span class="line"><span class="keyword">let</span> blue = <span class="type">CGFloat</span>(drand48())</span><br></pre></td></tr></table></figure><h2 id="Linux支持，glibc和rand方法"><a href="#Linux支持，glibc和rand方法" class="headerlink" title="Linux支持，glibc和rand方法"></a><strong><em>Linux支持，glibc和rand方法</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我在下面使用此代码段，以便在 <code>appleOS</code> 和 <code>linux平台</code> 上生成随机数。 我知道这并不完美，但是它为我做了工作。 🤐</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env swift</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> os(iOS) || os(tvOS) || os(macOS) || os(watchOS)</span><br><span class="line">    <span class="keyword">import</span> Darwin</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> os(<span class="type">Linux</span>)</span><br><span class="line">    <span class="keyword">import</span> Glibc</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">rndm</span><span class="params">(to <span class="built_in">max</span>: Int, from <span class="built_in">min</span>: Int = <span class="number">0</span>)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    #<span class="keyword">if</span> os(iOS) || os(tvOS) || os(macOS) || os(watchOS)</span><br><span class="line">        <span class="keyword">let</span> scale = <span class="type">Double</span>(arc4random()) / <span class="type">Double</span>(<span class="type">UInt32</span>.<span class="built_in">max</span>)</span><br><span class="line">    #endif</span><br><span class="line">    #<span class="keyword">if</span> os(<span class="type">Linux</span>)</span><br><span class="line">        <span class="keyword">let</span> scale = <span class="type">Double</span>(rand()) / <span class="type">Double</span>(<span class="type">RAND_MAX</span>)</span><br><span class="line">    #endif</span><br><span class="line">    <span class="keyword">var</span> value = <span class="built_in">max</span> - <span class="built_in">min</span></span><br><span class="line">    <span class="keyword">let</span> maximum = value.addingReportingOverflow(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> maximum.overflow &#123;</span><br><span class="line">        value = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        value = maximum.partialValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> partial = <span class="type">Int</span>(<span class="type">Double</span>(value) * scale)</span><br><span class="line">    <span class="keyword">let</span> result = partial.addingReportingOverflow(<span class="built_in">min</span>)</span><br><span class="line">    <span class="keyword">if</span> result.overflow &#123;</span><br><span class="line">        <span class="keyword">return</span> partial</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.partialValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rndm(to: <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>现在我们已经有了 <code>Swift 4.2</code> ，我想鼓励大家改编新的随机数生成 API方法 。 我非常高兴 <code>苹果公司和社区</code> 能够很好地解决这个问题，结果令人赞叹！ 👏👏👏</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> random </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> random </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift Grand Central Dispatch 深入实践</title>
      <link href="/Swift%20Grand%20Central%20Dispatch%20%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"/>
      <url>/Swift%20Grand%20Central%20Dispatch%20%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解 <code>Swift</code> 中 <code>GCD框架</code> 的 <code>多线程原理</code> 。 我保证，将所有需要的 <code>队列</code> ， <code>任务</code> ， <code>组</code> 进行分组。</p></br><h1 id="适用于初学者的GCD并发教程"><a href="#适用于初学者的GCD并发教程" class="headerlink" title="适用于初学者的GCD并发教程"></a><strong>适用于初学者的GCD并发教程</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://developer.apple.com/documentation/dispatch" target="_blank" rel="noopener"><strong><em><code>Grand Central Dispatch （GCD，或仅调度）</code></em></strong></a>框架基于基础 <code>线程池设计模式</code> 。 这意味着系统会生成固定数量的线程-基于某些因素（例如 <code>CPU内核</code> ），它们始终可用，等待任务同时执行。 🚦</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在运行时创建线程是一项昂贵的任务，因此 <a href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1" target="_blank" rel="noopener"><strong><em><code>GCD</code></em></strong></a> 会将任务组织到特定队列中，稍后，将在池中适当且可用的线程上执行等待这些队列中的任务。 这种方法导致了出色的性能和较低的执行延迟。 我们可以说 <a href="https://www.swiftbysundell.com/posts/a-deep-dive-into-grand-central-dispatch-in-swift" target="_blank" rel="noopener"><strong><em><code>Dispatch框架</code></em></strong></a> 是一个非常快速，高效的并发框架，专为现代多核硬件和需求而设计。</p><a id="more"></a></br><h1 id="并发，多任务，CPU内核，并行性和线程"><a href="#并发，多任务，CPU内核，并行性和线程" class="headerlink" title="并发，多任务，CPU内核，并行性和线程"></a><strong>并发，多任务，CPU内核，并行性和线程</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理器可以以编程方式运行你执行的任务，通常称为编码，开发或编程。  <code>CPU内核</code> 执行的代码是线程。因此，你的应用程序将创建一个由线程组成的进程。 🤓</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过去，处理器只有一个内核，一次只能处理一个任务。稍后引入了 <code>时间片</code> ，因此 <code>CPU</code> 可以使用上下文切换并发执行线程。随着时间的流逝，处理器获得了更多的功能和内核，因此它们能够使用并行机制实现真正的多任务处理。 ⏱</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今， <code>CPU</code> 是一个功能非常强大的单元，它每秒能够执行数十亿个任务（周期）。由于这种 <code>高可用性速度</code> ，英特尔引入了一种称为超线程的技术。他们将 <code>CPU时钟周期</code> 划分为同时运行的（通常是两个）进程之间的时间，因此可用线程的数量实际上增加了一倍。 📈</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，并发执行可以通过各种技术来实现，但是你不必太在意。如何解决并发性取决于 <code>CPU体系结构</code> ，操作系统的任务是为底层线程池产生多少线程。  <code>GCD框架</code> 将隐藏所有复杂性，但是了解基本原理始终是一件好事。 👍</p></br><h1 id="同步和异步执行"><a href="#同步和异步执行" class="headerlink" title="同步和异步执行"></a><strong>同步和异步执行</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个工作项都可以 <code>同步或异步执行</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你听说过 <code>阻塞代码</code> 和 <code>非阻塞代码</code> 吗？ 这是这里相同的情景。 使用同步任务，你将阻止执行队列，但是使用异步任务，你的调用将立即返回，并且队列可以继续执行其余任务（或Apple调用的工作项）。 🚧</p><h2 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a><strong><em>同步执行</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当工作项与 <code>sync方法</code> 同步执行时，程序将等到执行完成后再返回方法调用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果函数具有返回值，则它很可能是同步的，因此 <code>func load() -&gt; String</code> 可能会阻塞正在运行的代码，直到资源完全加载并返回。</p><h2 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a><strong><em>异步执行</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当使用 <code>async方法</code> 异步执行工作项时，该方法调用立即返回。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Completion blocks</code> 是异步方法的很好选择，例如，如果你查看此方法 <code>func load（completion：（String）-&gt; Void）</code>，则可以看到它没有返回类型，但是函数的结果通过 <code>Block</code> 返回 <code>(Block 回调)</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个典型的用例，如果你必须等待方法内部的某些事情（例如，从磁盘读取大文件的内容），则不希望由于 <code>IO操作</code> 缓慢而 <code>阻塞CPU</code> 。 在系统从物理硬盘驱动器中读取文件时，可能还会执行其他任务，而这些任务根本不会占用 <code>大量IO</code> （算术运算等）。 💾</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>分派队列</code> ，你可以同步或异步执行代码。 同步执行时，队列等待工作，异步执行时，代码立即返回，而无需等待任务完成。 ⚡️</p></br><h1 id="Dispatch-queues"><a href="#Dispatch-queues" class="headerlink" title="Dispatch queues"></a><strong>Dispatch queues</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我之前提到的， <code>GCD</code> 将 <code>任务组织成队列</code> ，就像在购物中心的队列一样。 在每个调度队列上，将按照将任务添加到队列中的相同顺序执行任务- <code>FIFO</code> ：该行中的第一个任务将首先执行-但你应注意，不能保证完成的顺序。 任务将根据代码复杂度完成。 因此，如果你将两个任务添加到队列中，先是慢任务，然后是快任务，则快任务可以在慢任务之前完成。 ⌛️</p><h2 id="串行和并发队列"><a href="#串行和并发队列" class="headerlink" title="串行和并发队列"></a><strong><em>串行和并发队列</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有两种类型的调度队列。  <code>串行队列</code> 可以一次执行一个任务，这些队列可用于同步对特定资源的访问。 另一方面， <code>并发队列</code> 可以同时并行执行一个或多个任务。  <code>串行队列</code> 就像商场中只有一个收银员的一条生产线， 并发队列 就像是一条拆分成两个或更多收银员的单条生产线。 💰</p><h2 id="主队列，全局队列和定制队列"><a href="#主队列，全局队列和定制队列" class="headerlink" title="主队列，全局队列和定制队列"></a><strong><em>主队列，全局队列和定制队列</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>主队列</code> 是一个 <code>串行队列</code> ， <code>主队列</code> 上的每个任务都在 <code>主线程</code> 上运行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>全局队列</code> 是系统提供的通过操作系统共享的 <code>并发队列</code> 。 恰好有四个按高优先级，默认优先级，低优先级以及 <code>IO限制</code> 的后台队列进行组织。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>定制队列</code> 可以由用户创建。 通过指定 <code>服务质量属性（QoS）</code> ， <code>自定义并发队列</code> 始终映射到全局队列之一。 在大多数情况下，如果要并行运行任务，建议使用 <code>全局并发队列</code> 之一，则应仅创建 <code>自定义串行队列</code> 。</p><h2 id="系统提供的队列"><a href="#系统提供的队列" class="headerlink" title="系统提供的队列"></a><strong><em>系统提供的队列</em></strong></h2><ul><li>Serial main queue</li><li>Concurrent global queues</li><li>high priority global queue</li><li>default priority global queue</li><li>low priority global queue</li><li>global background queue (io throttled)</li></ul><h2 id="按服务质量定制队列"><a href="#按服务质量定制队列" class="headerlink" title="按服务质量定制队列"></a><strong><em>按服务质量定制队列</em></strong></h2><ul><li><strong>userInteractive</strong> (UI updates) -&gt; serial main queue</li><li><strong>userInitiated</strong> (async UI related tasks) -&gt; high priority global queue</li><li><strong>default</strong> -&gt; default priority global queue</li><li><strong>utility</strong> -&gt; low priority global queue</li><li><strong>background</strong> -&gt; global background queue</li><li><strong>unspecified</strong> (lowest) -&gt; low priority global queue</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从理论上已经足够，让我们看看如何在实际中使用 <code>Dispatch框架</code> ！ 🎬</p></br><h1 id="如何在Swift中使用DispatchQueue类？"><a href="#如何在Swift中使用DispatchQueue类？" class="headerlink" title="如何在Swift中使用DispatchQueue类？"></a><strong>如何在Swift中使用DispatchQueue类？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是使用 <code>Swift 3</code> 提供的全新 <code>GCD语法</code> 从上方获取所有队列的方法。请注意，除非要使用 <code>并发队列</code> ，否则应始终使用 <code>全局并发队列</code> 而不是创建自己的 <code>全局并发队列</code> 。 通过 <code>barriers</code> 进行锁定以实现 <a href="http://basememara.com/creating-thread-safe-arrays-in-swift/" target="_blank" rel="noopener"><strong><em><code>线程安全</code></em></strong></a> ，稍后再进行介绍。 😳</p><h2 id="如何获得队列？"><a href="#如何获得队列？" class="headerlink" title="如何获得队列？"></a><strong><em>如何获得队列？</em></strong></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Dispatch</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.main</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .userInitiated)</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .userInteractive)</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .background)</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .<span class="keyword">default</span>)</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .utility)</span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .unspecified)</span><br><span class="line"><span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.serial"</span>)</span><br><span class="line"><span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.concurrent"</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在任务完成后，在 <code>后台队列</code> 上执行任务并更新 <code>主队列</code> 上的 <code>UI</code> 是使用 <code>Dispatch队列</code> 非常容易的一项。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global(qos: .background).async &#123;</span><br><span class="line">    <span class="comment">// do your job here</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="comment">// update ui here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在队列上同步和异步调用"><a href="#在队列上同步和异步调用" class="headerlink" title="在队列上同步和异步调用"></a><strong><em>在队列上同步和异步调用</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列上的 <code>同步和异步方法</code> 之间没有太大区别。  <code>Sync</code> 只是一个带有信号量（稍后说明）的异步调用，该信号量等待返回值。 同步呼叫将被阻止，另一方面，异步呼叫将立即返回。 🎉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = q.sync &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this will block"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"></span><br><span class="line">q.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"this will return instantly"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本上，如果你需要返回值，请使用 sync ，但在其他所有情况下，请使用 async 。 <strong>死锁警告</strong>：<strong><em>永远不要在主队列上调用同步，因为它会导致死锁和崩溃。</em></strong> 如果你正在寻找一种在 <code>主队列/线程上</code> 进行 <code>同步调用</code> 的安全方法，则可以使用此代码段。 👌</p><p><strong><em><code>不要从串行队列的线程在串行队列上调用sync！</code></em></strong></p><h2 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a><strong><em>延迟执行</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <code>Dispatch框架</code> 简单地延迟代码执行。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + .seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="comment">//this code will be executed only after 2 seconds have been passed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行并发循环"><a href="#执行并发循环" class="headerlink" title="执行并发循环"></a><strong><em>执行并发循环</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>调度队列</code> 仅允许你同时执行迭代。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">5</span>) &#123; (i) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a><strong><em>Debugging</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哦，顺便说一句，它仅用于调试目的，但是你可以使用此扩展名来返回当前队列的名称。 不要在生产代码中使用！！！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DispatchQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> currentLabel: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(validatingUTF8: __dispatch_queue_get_label(<span class="literal">nil</span>))!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print(DispatchQueue.currentLabel)</span></span><br></pre></td></tr></table></figure></br><h1 id="在Swift中使用DispatchWorkItem"><a href="#在Swift中使用DispatchWorkItem" class="headerlink" title="在Swift中使用DispatchWorkItem"></a><strong>在Swift中使用DispatchWorkItem</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DispatchWorkItem</code> 封装了可以执行的工作。 可以将工作项目分派到 <code>DispatchQueue</code> 上和 <code>DispatchGroup</code> 中。 也可以将 <code>DispatchWorkItem</code> 设置为 <code>DispatchSource</code> 事件，注册或取消处理程序。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，就像使用工作项进行操作一样，你可以取消正在运行的任务。 工作项也可以在任务完成时通知队列。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> workItem: <span class="type">DispatchWorkItem?</span></span><br><span class="line">workItem = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">6</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> item = workItem, !item.isCancelled <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"cancelled"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workItem?.notify(queue: .main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.global().asyncAfter(deadline: .now() + .seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">    workItem?.cancel()</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.main.async(execute: workItem!)</span><br><span class="line"><span class="comment">// you can use perform to run on the current queue instead of queue.async(execute:)</span></span><br><span class="line"><span class="comment">//workItem?.perform()</span></span><br></pre></td></tr></table></figure></br><h1 id="与-DispatchGroups-并发的任务"><a href="#与-DispatchGroups-并发的任务" class="headerlink" title="与 DispatchGroups 并发的任务"></a><strong>与 DispatchGroups 并发的任务</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，你需要执行多个网络调用以构造视图控制器所需的数据？ 这是 <code>DispatchGroup</code> 可以为你提供帮助的地方。 你所有长时间运行的后台任务都可以同时执行，当一切准备就绪时，你会收到通知。 请注意，你必须使用线程安全的数据结构，因此请务必在同一线程上修改数组！ 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(delay: UInt32, completion: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    sleep(delay)</span><br><span class="line">    completion()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">load(delay: <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">load(delay: <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">load(delay: <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，你始终必须在该组上平衡 进入 和 离开 调用。 调度组还使我们能够跟踪不同工作项的完成情况，即使它们在不同队列中运行也是如此。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.serial"</span>)</span><br><span class="line"><span class="keyword">let</span> workItem = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"start"</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async(group: group) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"group start"</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"group end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.global().async(group: group, execute: workItem)</span><br><span class="line"></span><br><span class="line"><span class="comment">// you can block your current queue and wait until the group is ready</span></span><br><span class="line"><span class="comment">// a better way is to use a notification block instead of blocking</span></span><br><span class="line"><span class="comment">//group.wait(timeout: .now() + .seconds(3))</span></span><br><span class="line"><span class="comment">//print("done")</span></span><br><span class="line"></span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用调度组进行的另一件事：假设你在执行一些实际工作时正在显示动画效果很好的加载指示器。 可能发生的是工作完成得比你预期的快，并且指示符动画无法完成。 为了解决这种情况，你可以添加一个小的延迟任务，以便小组等待直到两个任务都完成。 😎</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">    queue.async(group: group) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(i): Running async task..."</span>)</span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(i): Async task completed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">group.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure></br><h1 id="信号量-Semaphores"><a href="#信号量-Semaphores" class="headerlink" title="信号量(Semaphores)"></a><strong>信号量(Semaphores)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>信号量</code>只是一个变量，用于处理并发系统中的资源共享。 这是一个非常强大的对象，下面是 <code>Swift</code> 中的一些重要示例。</p><h2 id="如何使异步任务同步？"><a href="#如何使异步任务同步？" class="headerlink" title="如何使异步任务同步？"></a><strong><em>如何使异步任务同步？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案很简单，你可以使用信号量！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DispatchError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> timeout</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asyncMethod</span><span class="params">(completion: <span class="params">(String)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    completion(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syncMethod</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String?</span></span><br><span class="line">    queue.async &#123;</span><br><span class="line">        asyncMethod &#123; r <span class="keyword">in</span></span><br><span class="line">            response = r</span><br><span class="line">            semaphore.signal()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    semaphore.wait(timeout: .now() + <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> result = response <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">DispatchError</span>.timeout</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">try</span>? syncMethod()</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><h2 id="锁定-单次访问资源"><a href="#锁定-单次访问资源" class="headerlink" title="锁定/单次访问资源"></a><strong><em>锁定/单次访问资源</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想避免 <code>race condition</code> 问题，则可能要使用互斥。 这可以通过使用信号量对象来实现，但是如果你的对象需要大量读取功能，则应考虑基于 <code>dispatch barrier</code> 的解决方案。 😜</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockedNumbers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> elements: [<span class="type">Int</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> num: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.semaphore.wait(timeout: <span class="type">DispatchTime</span>.distantFuture)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"appended: \(num)"</span>)</span><br><span class="line">        <span class="keyword">self</span>.elements.append(num)</span><br><span class="line">        <span class="keyword">self</span>.semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeLast</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.semaphore.wait(timeout: <span class="type">DispatchTime</span>.distantFuture)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.semaphore.signal()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> !<span class="keyword">self</span>.elements.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="keyword">self</span>.elements.removeLast()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"removed: \(num)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> items = <span class="type">LockedNumbers</span>()</span><br><span class="line">items.append(<span class="number">1</span>)</span><br><span class="line">items.append(<span class="number">2</span>)</span><br><span class="line">items.append(<span class="number">5</span>)</span><br><span class="line">items.append(<span class="number">3</span>)</span><br><span class="line">items.removeLast()</span><br><span class="line">items.removeLast()</span><br><span class="line">items.append(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(items.elements)</span><br></pre></td></tr></table></figure><h2 id="等待多个任务完成"><a href="#等待多个任务完成" class="headerlink" title="等待多个任务完成"></a><strong><em>等待多个任务完成</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像调度组一样，如果多个任务完成，你还可以使用信号量对象来获得通知。 你只需要等待…</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">    queue.async &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"run \(i)"</span>)</span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"wait"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed \(i)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure><h2 id="使用信号量批量执行"><a href="#使用信号量批量执行" class="headerlink" title="使用信号量批量执行"></a><strong><em>使用信号量批量执行</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以创建类似于行为的线程池，以使用调度信号量来模拟有限的资源。 因此，例如，如果你想从服务器下载大量图像，则可以每次运行一批。 非常方便。 🖐</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"start"</span>)</span><br><span class="line"><span class="keyword">let</span> sem = <span class="type">DispatchSemaphore</span>(value: <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        sem.wait()</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        sem.signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"end"</span>)</span><br></pre></td></tr></table></figure></br><h1 id="DispatchSource对象"><a href="#DispatchSource对象" class="headerlink" title="DispatchSource对象"></a><strong>DispatchSource对象</strong></h1><p><strong><em><code>调度源是一种基本数据类型，可协调特定底层系统事件的处理。</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信号，描述符，进程，端口，计时器等。 一切都通过 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html" target="_blank" rel="noopener"><strong><em><code>调度源</code></em></strong></a> 对象处理。 我真的不想深入细节，这是相当底层的东西。 你可以使用调度源监视文件，端口，信号。 请只阅读苹果官方文档。 📄</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我只想在此使用 <a href="https://www.cocoawithlove.com/blog/2016/07/30/timer-problems.html" target="_blank" rel="noopener"><strong><em><code>调度源计时器</code></em></strong></a> 来举例说明。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer = <span class="type">DispatchSource</span>.makeTimerSource()</span><br><span class="line">timer.schedule(deadline: .now(), repeating: .seconds(<span class="number">1</span>))</span><br><span class="line">timer.setEventHandler &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line">timer.resume()</span><br></pre></td></tr></table></figure></br><h1 id="使用调度框架的线程安全"><a href="#使用调度框架的线程安全" class="headerlink" title="使用调度框架的线程安全"></a><strong>使用调度框架的线程安全</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果涉及多线程代码，则 <a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8" target="_blank" rel="noopener"><strong><em><code>线程安全性</code></em></strong></a> 是不可避免的主题。 在开始时，我提到在GCD的内部有一个线程池。 每个线程都有一个与之关联的运行循环对象，你甚至可以手动运行它们。 如果手动创建线程，则会将运行循环自动添加到该线程。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="type">Thread</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.current.name ?? <span class="string">""</span>)</span><br><span class="line">     <span class="keyword">let</span> timer = <span class="type">Timer</span>(timeInterval: <span class="number">1</span>, repeats: <span class="literal">true</span>) &#123; t <span class="keyword">in</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">"tick"</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">RunLoop</span>.current.add(timer, forMode: .defaultRunLoopMode)</span><br><span class="line"></span><br><span class="line">    <span class="type">RunLoop</span>.current.run()</span><br><span class="line">    <span class="type">RunLoop</span>.current.run(mode: .commonModes, before: <span class="type">Date</span>.distantPast)</span><br><span class="line">&#125;</span><br><span class="line">t.name = <span class="string">"my-thread"</span></span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">//RunLoop.current.run()</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你不应该这样做，仅出于演示目的，请始终使用 <code>GCD队列</code> ！</p><h2 id="Queue-Thread"><a href="#Queue-Thread" class="headerlink" title="Queue != Thread"></a><strong><em>Queue != Thread</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>GCD队列</code> 不是线程，如果你在并发队列上运行多个异步操作，则代码可以在满足需求的任何可用线程上运行。</p><p><strong><em><code>线程安全就是要避免混乱的变量状态</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象一下 <code>Swift</code> 中的可变数组。 可以从任何线程进行修改。 那不是很好，因为如果数组不是线程安全的，最终其中的值将像地狱一样被弄乱。 例如，多个线程试图将值插入数组。 怎么了？ 如果它们并行运行，将首先添加哪个元素？ 现在，这就是为什么有时需要创建线程安全资源的原因。</p><h2 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a><strong><em>串行队列</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <code>串行队列</code> 强制执行 <code>互斥</code> 。 队列中的所有任务将连续运行（以 <code>FIFO顺序</code> ），一次仅运行一个进程，任务必须互相等待。 解决方案的一大缺点是 <code>速度</code> 。 🐌</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q = <span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.serial"</span>)</span><br><span class="line"></span><br><span class="line">q.async() &#123;</span><br><span class="line">  <span class="comment">// writes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q.sync() &#123;</span><br><span class="line">  <span class="comment">// reads</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-barriers-的并发队列"><a href="#使用-barriers-的并发队列" class="headerlink" title="使用 barriers 的并发队列"></a><strong><em>使用 barriers 的并发队列</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果为异步方法提供了额外的标志，则可以将 <code>barriers</code> 任务发送到队列。 如果这样的任务到达队列，它将确保在 <code>barriers</code> 任务完成之前不会执行任何其他操作。 综上所述， <code>barriers</code> 任务是并发队列的同步（点）任务。 使用异步 <code>barriers</code> 进行写入，使用同步块进行读取。 😎</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q = <span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.concurrent"</span>, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line">q.async(flags: .barrier) &#123;</span><br><span class="line">  <span class="comment">// writes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q.sync() &#123;</span><br><span class="line">  <span class="comment">// reads</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在线程安全的环境中，此方法将导致读取速度极快。 你还可以使用串行队列，信号量，锁定它们都取决于你当前的情况。 🤐</p></br><h1 id="一些反模式"><a href="#一些反模式" class="headerlink" title="一些反模式"></a><strong>一些反模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你必须非常小心 <a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81" target="_blank" rel="noopener"><strong><em><code>死锁</code></em></strong></a> ， <a href="https://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3" target="_blank" rel="noopener"><strong><em><code>竞态条件</code></em></strong></a> 和 <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem" target="_blank" rel="noopener"><strong><em><code>读者作家</code></em></strong></a> 的问题。 通常在串行队列上调用 <code>sync方法</code> 会给你带来很多麻烦。 另一个问题是 <code>线程安全性</code> ，但是我们已经介绍了该部分。 😉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.serial"</span>)</span><br><span class="line"></span><br><span class="line">queue.sync &#123;</span><br><span class="line">    <span class="comment">// do some sync work</span></span><br><span class="line">    queue.sync &#123;</span><br><span class="line">        <span class="comment">// this won't be executed -&gt; deadlock!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//What you are trying to do here is to launch the main thread synchronously from a background thread before it exits. This is a logical error.</span></span><br><span class="line"><span class="comment">//https://stackoverflow.com/questions/49258413/dispatchqueue-crashing-with-main-sync-in-swift?rq=1</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .utility).sync &#123;</span><br><span class="line">    <span class="comment">// do some background task</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line">        <span class="comment">// app will crash</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你必须非常小心 <a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81" target="_blank" rel="noopener"><strong><em><code>死锁</code></em></strong></a> ， <a href="https://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3" target="_blank" rel="noopener"><strong><em><code>竞态条件</code></em></strong></a> 和 <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem" target="_blank" rel="noopener"><strong><em><code>读者作家</code></em></strong></a> 的问题。 通常在串行队列上调用 <code>sync方法</code> 会给你带来很多麻烦。 另一个问题是 <code>线程安全性</code> ，但是我们已经介绍了该部分。 😉<br> <code>Dispatch框架</code> （又名GCD）是一个了不起的框架，它具有如此巨大的潜力，并且确实需要一些时间来掌握它。 真正的问题是，为了将并发编程提升到一个全新的高度，苹果将采取什么道路？ 承诺或等待，也许是全新的东西，希望我们能在 <code>Swift 6</code> 中看到一些东西。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Grand Central Dispatch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Grand Central Dispatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS如何使用iCloud文档？</title>
      <link href="/iOS%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8iCloud%E6%96%87%E6%A1%A3%EF%BC%9F/"/>
      <url>/iOS%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8iCloud%E6%96%87%E6%A1%A3%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用最新版本的 <code>Swift编程语言</code> 通过共享的 <code>iCloud驱动器文件夹</code> 同步文件和数据。</p></br><h1 id="iCloud驱动器项目设置教程"><a href="#iCloud驱动器项目设置教程" class="headerlink" title="iCloud驱动器项目设置教程"></a><strong>iCloud驱动器项目设置教程</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从为 <code>iOS</code> 创建一个新项目开始。 你可以选择单视图应用程序模板，不必太担心基于文档的应用程序，因为在本教程中，我们根本不会涉及 <code>UIDocument类</code> 。 🤷‍♂️</p><a id="more"></a><p><img src="http://q8wtfza4q.bkt.clouddn.com/iu-stp1.png" alt="UIDocument类"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步是启用 <code>iCloud功能</code> ，它将为你生成一个新的权利文件。 另外，你还必须在 <code>Apple开发者网站</code> 上为 <code>appID启用</code> <code>iCloud应用程序服务</code> 。 你还应该分配将用于存储数据的 <code>iCloud容器</code> 。 只需单击几下，但你必须手动执行此操作。 💩</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你需要有效的 <code>Apple Developer Program</code> 成员身份才能设置高级应用程序功能，例如 <code>iCloud支持</code> 。 因此，你必须每年支付$99。 🤑</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/iu-stp2.png" alt="UIDocument类"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，我相信现在你已经有了启用 <code>iCloud功能</code> 和应用程序服务的正确的 <code>iOS应用程序标识符</code> 。 下一步是最后一步，你必须将这几行添加到 <code>Info.plist</code> 文件中，以便定义要使用的 <code>iCloud驱动器容器（文件夹名称）</code> 。 请注意，一个应用程序可以有多个容器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;<span class="type">NSUbiquitousContainers</span>&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;iCloud.com.tiborbodecs.teszt&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;<span class="type">NSUbiquitousContainerIsDocumentScopePublic</span>&lt;/key&gt;</span><br><span class="line">        &lt;<span class="literal">true</span>/&gt;</span><br><span class="line">        &lt;key&gt;<span class="type">NSUbiquitousContainerName</span>&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;<span class="type">Teszt</span>&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;<span class="type">NSUbiquitousContainerSupportedFolderLevels</span>&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;<span class="type">Any</span>&lt;/string&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我们准备继续进行一些实际的编码。 💻</p><br><h1 id="iCloud-drive-容器中的文件"><a href="#iCloud-drive-容器中的文件" class="headerlink" title="iCloud drive 容器中的文件"></a><strong>iCloud drive 容器中的文件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>Swift</code> 使用 <code>iCloud文件</code> 相对容易。 基本上，你只需要获取 <code>iCloud驱动器</code> 容器的基本 <code>URL</code> ，就可以做任何你想做的事情。 🤔但是，我将向你展示一些最佳做法和技巧。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，你必须检查你的容器文件夹是否已经存在，如果不存在，则应使用 <code>FileManager类</code> 手动创建它。 我还为容器基本 <code>URL</code> 设置了“快捷方式”变量，因此我不必再次写所有这些长单词。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> containerUrl: <span class="type">URL?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.url(forUbiquityContainerIdentifier: <span class="literal">nil</span>)?.appendingPathComponent(<span class="string">"Documents"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// check for container existence</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> url = <span class="keyword">self</span>.containerUrl, !<span class="type">FileManager</span>.<span class="keyword">default</span>.fileExists(atPath: url.path, isDirectory: <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.createDirectory(at: url, withIntermediateDirectories: <span class="literal">true</span>, attributes: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>iCloud驱动器</code> 容器内的路径很简单，你可以将路径组件附加到基本 <code>URL</code> 并根据需要使用该确切的 <code>位置URL</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDocumentUrl = <span class="keyword">self</span>.containerUrl?</span><br><span class="line">        .appendingPathComponent(subDirectory)</span><br><span class="line">        .appendingPathComponent(fileName)</span><br><span class="line">        .appendingPathExtension(fileExtension)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择现有文件也非常简单。 你可以使用 <code>UIKit</code> 中的内置文档选择器类。 这里只有两个 <code>catches</code> 。 🤦‍♂️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，你需要提供要访问的文档的类型。 你听说过 <a href="https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_intro/understand_utis_intro.html#//apple_ref/doc/uid/TP40001319-CH201-SW1" target="_blank" rel="noopener"><strong><em><code>UTI</code></em></strong></a> 吗？ 事实是，你必须为每种文件类型找到合适的 <code>统一类型标识符</code> ，而不是提供扩展名或 <code>mime-type</code> 或一些常用的东西。 🧠</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> picker = <span class="type">UIDocumentPickerViewController</span>(documentTypes: [<span class="string">"public.json"</span>], <span class="keyword">in</span>: .<span class="keyword">open</span>)</span><br><span class="line">picker.delegate = <span class="keyword">self</span></span><br><span class="line">picker.modalPresentationStyle = .fullScreen</span><br><span class="line"><span class="keyword">self</span>.present(picker, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个要点是，在开始读取所选文件之前，你必须对其进行 <code>“解锁”</code> 。 可以通过调用 <code>startAccessingSecurityScopedResource</code> 方法来完成。 不要忘记调用 <code>stopAccessingSecurityScopedResource</code> 方法，否则事情将变得不平衡。 你不要那个，相信我！ 🧤</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">documentPicker</span><span class="params">(<span class="number">_</span> controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL])</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span></span><br><span class="line">        controller.documentPickerMode == .<span class="keyword">open</span>,</span><br><span class="line">        <span class="keyword">let</span> url = urls.first,</span><br><span class="line">        url.startAccessingSecurityScopedResource()</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        url.stopAccessingSecurityScopedResource()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do some work with the url</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他一切都按你的预期工作。 你可以通过 <code>文件API</code> 或使用 <code>UIDocumentPickerViewController</code> 实例将文件直接保存到容器中。 这是一些最常见的 <code>api调用</code> ，可用于处理文件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">try</span> string.write(to: url, atomically: <span class="literal">true</span>, encoding: .utf8)</span><br><span class="line"><span class="keyword">try</span> <span class="type">String</span>(contentsOf: url)</span><br><span class="line"></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="keyword">try</span> data.write(to: url, options: [.atomic])</span><br><span class="line"><span class="keyword">try</span> <span class="type">Data</span>(contentsOf: url)</span><br><span class="line"></span><br><span class="line"><span class="comment">// file manager</span></span><br><span class="line"><span class="type">FileManager</span>.<span class="keyword">default</span>.copyItem(at: local, to: url)</span><br><span class="line"><span class="type">FileManager</span>.<span class="keyword">default</span>.removeItem(at: url)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以读写任何类型的字符串，数据。 通过使用 <code>FileManager</code> ，你可以复制，移动，删除项目或更改文件属性。 你存储在 <code>iCloud驱动器</code> 中的所有文档都可以在每台设备上使用。 显然，你必须使用 <code>iCloud帐户登录</code> ，并具有足够的免费存储空间。 💰</p><br><h1 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a><strong>Debugging</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你更改设置中的某些内容，则可能还需要增加内部版本号，以便将更改通知操作系统。 💡</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Mac</code> 上，所有 <code>iCloud驱动器文件/容器</code> 都位于 <code>Mobile Documents</code> 目录内用户的 <code>Library文件夹</code> 下。 你只需使用 <code>Terminal</code> 或 <code>Finder</code> 到那里并列出所有文件即可。 专业提示：寻找隐藏的东西！ 😉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Library/Mobile\ Documents</span><br><span class="line">ls -la</span><br><span class="line"><span class="comment"># ls -la|grep tiborbodecs</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以通过使用以下命令来监视 <code>CloudDocs</code> 守护程序的活动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># man brctl</span></span><br><span class="line">brctl <span class="built_in">log</span> --<span class="built_in">wait</span> --shorten</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出日志将告诉你同步期间实际发生的情况。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/iu-stp3.png" alt="UIDocument类"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我建议你检查 <code>brctl</code> 命令的手动输入，因为还有其他一些标志可以调试问题更加容易。 🤐</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> iCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> iCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>appleOS的Networking示例</title>
      <link href="/appleOS%E7%9A%84Networking%E7%A4%BA%E4%BE%8B/"/>
      <url>/appleOS%E7%9A%84Networking%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何将 <code>Bonjour</code> 与 <code>UDP/TCP套接字</code>， <code>streams</code> 一起使用，以及如何通过 <code>CoreBluetooth</code> 或 <code>watch API</code> 进行通信。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想学习如何使用 <a href="https://help.dyn.com/bonjour-and-dns-discovery/" target="_blank" rel="noopener"><strong><em><code>Bonjour</code></em></strong></a> 发现服务在设备之间 <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/UsingSocketsandSocketStreams.html#//apple_ref/doc/uid/CH73-SW2" target="_blank" rel="noopener"><strong><em><code>建立网络连接</code></em></strong></a> ，那么你来对地方了。 在这篇文章中，我将向你展示基础知识，例如，你将能够从 <code>手表</code> 或 <code>iOS设备</code> 制作遥控器，以便将数据直接发送到任何 <code>tvOS</code> 或 <code>macOS</code> 机器。</p><a id="more"></a></br><h1 id="多平台开发"><a href="#多平台开发" class="headerlink" title="多平台开发"></a><strong>多平台开发</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要创建支持多个平台的应用程序，则可能要针对 <code>macOS</code> ， <code>iOS</code> ， <code>watchOS</code> ， <code>tvOS</code> 以及 <code>Linux</code> 。 下面的代码段将帮助你检测正在使用的当前平台。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(iOS)</span><br><span class="line">    <span class="keyword">let</span> platform = <span class="string">"iOS"</span></span><br><span class="line">#elseif os(macOS)</span><br><span class="line">    <span class="keyword">let</span> platform = <span class="string">"macOS"</span></span><br><span class="line">#elseif os(watchOS)</span><br><span class="line">    <span class="keyword">let</span> platform = <span class="string">"watchOS"</span></span><br><span class="line">#elseif os(tvOS)</span><br><span class="line">    <span class="keyword">let</span> platform = <span class="string">"tvOS"</span></span><br><span class="line">#elseif os(<span class="type">Linux</span>)</span><br><span class="line">    <span class="keyword">let</span> platform = <span class="string">"linux"</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    <span class="keyword">let</span> platform = <span class="string">"unknown"</span></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(platform)</span><br></pre></td></tr></table></figure></br><h1 id="Network-connection-101"><a href="#Network-connection-101" class="headerlink" title="Network connection 101"></a><strong>Network connection 101</strong></h1><h2 id="Bonjour发现服务"><a href="#Bonjour发现服务" class="headerlink" title="Bonjour发现服务"></a><strong><em>Bonjour发现服务</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Bonjour</code> ，也称为零配置网络，可使用 <code>行业标准IP协议</code> 在局域网上自动发现设备和服务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，基本上，你可以使用 <a href="https://www.eltima.com/dev/post/99996366184/using-bonjour-in-swift" target="_blank" rel="noopener"><strong><em><code>Bonjour</code></em></strong></a> 在本地网络上找到网络设备。 如果你想弄清楚连接到 <code>LAN的设备列表</code> ，这将非常方便。 使用 <code>NetService类</code> 将帮助你检测具有它们支持的可用服务的所有设备。 整个 <code>Bonjour API</code> 相对较小且编写良好。 从服务器方面，你只需创建 <code>NetService对象</code>  ，并通过 <code>NetServiceDelegate监听</code> 传入的连接。</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你必须与所有设备/模拟器都在同一WiFi网络上。</p></blockquote><h2 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a><strong><em>TCP 连接</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>TCP</code> 在通过 <code>IP网络</code> 进行通信的主机上运行的应用程序之间，提供可靠，有序且经过错误检查的八位位组（字节）流交付。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;借助 <a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener"><strong><em><code>TCP</code></em></strong></a> ，你可以建立可靠的网络连接。  Foundation 中有一个 Stream类 ，可帮助你在设备之间来回发送数据。 如果你具有可以正常使用的 NetServiceDelegate 连接形式，则只需侦听流事件以通过 StreamDelegate 处理传入数据。 我不想详细介绍，只需下载 <a href="https://gitlab.com/theswiftdev/networking-for-appleos" target="_blank" rel="noopener"><strong><em><code>示例代码</code></em></strong></a> 并亲自检查一下即可。</p><h2 id="UDP-连接"><a href="#UDP-连接" class="headerlink" title="UDP 连接"></a><strong><em>UDP 连接</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <a href="https://developer.apple.com/library/archive/samplecode/UDPEcho/Listings/Read_Me_About_UDPEcho_txt.html" target="_blank" rel="noopener"><strong><em><code>UDP</code></em></strong></a> ，计算机应用程序可以将消息（在这种情况下称为数据报）发送到 <code>Internet协议（IP）网络</code> 上的其他主机。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果查看有关 <a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener"><strong><em><code>UDP</code></em></strong></a> 的文章，你会清楚地看到与 <code>TCP</code> 的主要区别在于该协议不能保证你数据传输的安全。 数据可能无序到达或重复到达，这是处理这些情况的任务，但是 <code>UDP</code> 很快。 如果要构建文件传输应用程序，则绝对应该使用 <code>TCP</code> ，但是例如控制实时动作游戏 <code>UDP</code> 就足够了。</p><h2 id="CocoaAsyncSocket"><a href="#CocoaAsyncSocket" class="headerlink" title="CocoaAsyncSocket"></a><strong><em>CocoaAsyncSocket</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个库非常好用，对于所有想快速建立网络连接的人来说，它可能是最好的选择，因为与实现委托相比，它所需的代码更少。 当然，你仍然需要在整个内容上方添加 <code>Bonjour层</code> ，但这很好。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你使用的是 <a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener"><strong><em><code>CocoaAsyncSocket</code></em></strong></a> ，你会发现该 <code>API</code> 很简单，只有5分钟后，我才能相对容易地了解发生了什么，并且能够通过网络发送消息。 它支持所有 <code>Apple平台</code> ，你可以使用 <code>Carthage</code> 或 <code>CocoaPods</code> 无缝集成。</p><h2 id="CoreBluetooth-APIs"><a href="#CoreBluetooth-APIs" class="headerlink" title="CoreBluetooth APIs"></a><strong><em>CoreBluetooth APIs</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对 <code>CoreBluetooth框架API</code> 并不是很熟悉，这就是为什么我基本上只是遵循并把这个 <a href="https://code.tutsplus.com/tutorials/ios-7-sdk-core-bluetooth-theoretical-overview--mobile-20728" target="_blank" rel="noopener"><strong><em><code>tutsplus.com</code></em></strong></a> 代码示例移植到 <code>Swift 4</code> 的原因。老实说，我觉得 <code>API</code> 与所有这些凌乱的委托函数过于复杂。 如果必须在 <code>CoreBluetooth</code> 或 <code>CocoaAsyncSocket</code> 之间进行选择，那么我会选择最后一个。 所以，是的，显然我不是蓝牙专家，但是这个小项目对 <code>CB框架</code> 内部的工作原理是一个很好的第一印象。</p><h2 id="WatchConnectivity-framework"><a href="#WatchConnectivity-framework" class="headerlink" title="WatchConnectivity framework"></a><strong><em>WatchConnectivity framework</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要在 <code>iOS</code> 和 <code>watchOS</code> 之间进行通信，则可能会使用 <code>WatchConnectivity框架</code> ，尤其是 <code>WKSession类</code> 。 它实际上并没有那么复杂，只需几行代码，你就可以将手表的信息发送到 <code>iPhone</code> 。 你可以阅读 <a href="https://www.hackingwithswift.com/read/37/8/communicating-between-ios-and-watchos-wcsession" target="_blank" rel="noopener"><strong><em><code>这篇文章</code></em></strong></a> ，但是，如果下载 <a href="https://gitlab.com/theswiftdev/networking-for-appleos" target="_blank" rel="noopener"><strong><em><code>源代码</code></em></strong></a>，则在包中将发现几乎相同的内容。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> appleOS Networking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> appleOS Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Codable protocol在Swift中解析JSON？</title>
      <link href="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Codable%20protocol%E5%9C%A8Swift%E4%B8%AD%E8%A7%A3%E6%9E%90JSON%EF%BC%9F/"/>
      <url>/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Codable%20protocol%E5%9C%A8Swift%E4%B8%AD%E8%A7%A3%E6%9E%90JSON%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本 <code>Swift</code> 教程中，我想为你提供一个有关使用 <code>URLSession</code> 和 <code>Codable协议</code> 获取和解析 <code>JSON</code> 数据的示例。</p></br><h1 id="依存关系"><a href="#依存关系" class="headerlink" title="依存关系"></a><strong>依存关系</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，有关依赖的几句话。 从 <code>Swift 4</code> 开始，你不需要任何依赖来解析 <code>JSON数据</code> ，因为内置的协议可以处理所有事情。 如果你仍在使用某种第三方，则为简单起见，一定要放弃它。 顺便说一句，在将任何外部依赖项添加到项目中之前，请三思。 🤔</p><a id="more"></a></br><h1 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a><strong>Networking</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你的任务仅仅是从 <code>Web</code> 上通过 <code>HTTP</code> 加载某种 <code>JSON文档</code> ，那么-你完全不需要 <code>Alamofire</code> 。 你可以使用内置的 <code>URLSession类</code> 进行请求，并获取所需的一切。  <code>Foundation网络堆栈</code> 已经是一个复杂且非常有用的堆栈，不要通过额外的层使事情变得更加复杂。</p></br><h1 id="JSON-解析"><a href="#JSON-解析" class="headerlink" title="JSON 解析"></a><strong>JSON 解析</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，在简短的介绍之后，让我们深入研究一下，并从 <a href="https://jsonplaceholder.typicode.com/" target="_blank" rel="noopener"><strong><em><code>JSONPlaceholder</code></em></strong></a>   <code>Web服务</code> 获取一些 <code>假JSON数据</code> 。 我将把整个东西放在这里，你可以选择它，将其复制并粘贴到 <code>Swift playground</code> 文件中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"></span><br><span class="line"><span class="type">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> id</span><br><span class="line">        <span class="keyword">case</span> title</span><br><span class="line">        <span class="keyword">case</span> body</span><br><span class="line">        <span class="keyword">case</span> userIdentifier = <span class="string">"userId"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> body: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> userIdentifier: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error: \(error.localizedDescription)"</span>)</span><br><span class="line">        <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>, httpResponse.statusCode == <span class="number">200</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error: invalid HTTP response code"</span>)</span><br><span class="line">        <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error: missing data"</span>)</span><br><span class="line">        <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// feel free to uncomment this for debugging data</span></span><br><span class="line">    <span class="comment">// print(String(data: data, encoding: .utf8))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">        <span class="keyword">let</span> posts = <span class="keyword">try</span> decoder.decode([<span class="type">Post</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(posts.<span class="built_in">map</span> &#123; $<span class="number">0</span>.title &#125;)</span><br><span class="line">        <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error: \(error.localizedDescription)"</span>)</span><br><span class="line">        <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，从 <code>Web</code> 下载和 <code>解析JSON</code> 是一项非常简单的任务。 整个代码段约为 <code>50行</code> 。 当然，这只是概念上的证明，但是它有效，并且你不需要任何 <code>依赖</code> 。 它是 <code>纯Swift</code> 和 <code>Foundation</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Codable协议</code> -实际上是 <code>Encodable＆Decodable协议</code> 的复合类型别名-使在 <code>Swift</code> 中解析 <code>JSON数据</code> 的过程变得神奇。 💫</p><blockquote><p><strong><code>提示:</code></strong><br>为了减少一些输入，你还可以直接使用这些 <a href="https://gitlab.com/-/users/terms?redirect=%2Ftheswiftdev%2Fawesome-xcode-extensions" target="_blank" rel="noopener"><strong><em><code>amazing Xcode extensions</code></em></strong></a> 从JSON结构生成最终对象。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Codable protocol </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Codable protocol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift枚举值</title>
      <link href="/Swift%E6%9E%9A%E4%B8%BE%E5%80%BC/"/>
      <url>/Swift%E6%9E%9A%E4%B8%BE%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本快速教程中，我将向您展示如何使用以 <code>Swift 4</code> 编写的通用解决方案获取 <code>Swift枚举类型</code> 的所有可能值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 <code>Swift 4.2</code> 开始，您只需遵循 <code>CaseIterable协议</code> ，即可获得 <code>allCases静态属性</code> 。 应该将 <code>Swift</code> 语言版本升级到最新版本。 🎉🎉🎉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ABC</span>: <span class="title">String</span>, <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> a, b, <span class="built_in">c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">ABC</span>.allCases.<span class="built_in">map</span> &#123; $<span class="number">0</span>.rawValue &#125;)</span><br></pre></td></tr></table></figure><a id="more"></a></br><h1 id="EnumCollection协议方法"><a href="#EnumCollection协议方法" class="headerlink" title="EnumCollection协议方法"></a><strong>EnumCollection协议方法</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要定义一个新的 <code>EnumCollection协议</code> ，然后在其上进行协议扩展，因此您根本不必编写太多代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">EnumCollection</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cases</span><span class="params">()</span></span> -&gt; <span class="type">AnySequence</span>&lt;<span class="type">Self</span>&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> allValues: [<span class="type">Self</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">EnumCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cases</span><span class="params">()</span></span> -&gt; <span class="type">AnySequence</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AnySequence</span> &#123; () -&gt; <span class="type">AnyIterator</span>&lt;<span class="type">Self</span>&gt; <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">var</span> raw = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">AnyIterator</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> current: <span class="type">Self</span> = <span class="built_in">withUnsafePointer</span>(to: &amp;raw) &#123; $<span class="number">0</span>.withMemoryRebound(to: <span class="keyword">self</span>, capacity: <span class="number">1</span>) &#123; $<span class="number">0</span>.pointee &#125; &#125;</span><br><span class="line">                <span class="keyword">guard</span> current.hashValue == raw <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">                raw += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> current</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> allValues: [<span class="type">Self</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Array</span>(<span class="keyword">self</span>.cases())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从现在开始，您只需要使枚举类型符合 <code>EnumCollection协议</code> ，就可以使用全新的 <code>case方法</code> 和 <code>allValues属性</code> ，其中将包含给定枚举的所有可能值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekdays</span>: <span class="title">String</span>, <span class="title">EnumCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> sunday, monday, tuesday, wednesday, thursday, friday, saturday</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> weekday <span class="keyword">in</span> <span class="type">Weekdays</span>.cases() &#123;</span><br><span class="line">    <span class="built_in">print</span>(weekday.rawValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Weekdays</span>.allValues.<span class="built_in">map</span> &#123; $<span class="number">0</span>.rawValue.capitalized &#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，枚举的基本类型需要为 <code>Hashable</code> ，但这并不重要。 但是，此解决方案就像 <code>Swift 4</code> 一样过去时，请考虑将项目升级到 <code>Swift5</code> 。 👋</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> enum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> enum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode扩展</title>
      <link href="/Xcode%E6%89%A9%E5%B1%95/"/>
      <url>/Xcode%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是当前可用的本地创建的 <code>Xcode源代码编辑器</code> 扩展的最大和最好的集合。</p></br><h1 id="Xcode-extensions"><a href="#Xcode-extensions" class="headerlink" title="Xcode extensions"></a><strong>Xcode extensions</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以找到托管在 <a href="https://github.com/theswiftdev/awesome-xcode-extensions" target="_blank" rel="noopener"><strong><em><code>GitHub</code></em></strong></a> （2,2k +⭐️）上的实际列表。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样做的主要原因是该项目几乎完全由社区推动，这一事实确实令人惊讶！ 在不到一年的时间里，该存储库在 <code>GitHub</code> 上拥有一千颗星，而且还在不断增加！ 很棒的 <code>Xcode扩展列表</code> 对所有人开放，因此，如果你有扩展，请不要犹豫并创建请求请求！</p><a id="more"></a></br><h1 id="如何创建Xcode扩展？"><a href="#如何创建Xcode扩展？" class="headerlink" title="如何创建Xcode扩展？"></a><strong>如何创建Xcode扩展？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会渴望实现自己的扩展。 没问题 这里有一些非常神奇的资源，可以教你如何制作 <code>Xcode插件</code> 。</p><ul><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionCreation.html" target="_blank" rel="noopener"><strong><em><code>Apple - Creating an App extension</code></em></strong></a></li><li><a href="https://developer.apple.com/documentation/xcodekit/creating_a_source_editor_extension" target="_blank" rel="noopener"><strong><em><code>Apple - Creating a Source Editor Extension</code></em></strong></a> </li><li><a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="noopener"><strong><em><code>WWDC16 - Using and Extending the Xcode Source Editor</code></em></strong></a></li><li><a href="http://www.russbishop.net/xcode-extensions" target="_blank" rel="noopener"><strong><em><code>Russ Bishop - Xcode Extensions</code></em></strong></a></li><li><a href="http://allblue.me/xcode/2016/06/28/Build-your-own-Xcode-8-source-editor-extension/" target="_blank" rel="noopener"><strong><em><code>Victor S. Wang - Build your own Xcode 8 Source Editor Extension</code></em></strong></a></li><li><a href="https://code.tutsplus.com/tutorials/how-to-create-an-xcode-source-editor-extension--cms-26772" target="_blank" rel="noopener"><strong><em><code>EnvatoTuts+ - How to Create an Xcode Source Editor Extension</code></em></strong></a></li><li><a href="https://www.youtube.com/watch?v=5m9DOuP4udE" target="_blank" rel="noopener"><strong><em><code>NSCoconut - Build an Xcode Source Editor Extension</code></em></strong></a></li><li><a href="https://littlebitesofcocoa.com/239-creating-an-xcode-source-editor-extension" target="_blank" rel="noopener"><strong><em><code>Little bites of Cocoa - Creating an Xcode Source Editor Extension 🛠</code></em></strong></a></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些篇文章都是非常出色的，我不想深入探讨构建 <code>Xcode源代码编辑器</code> 扩展的细节，你应该阅读（观看）它们并开始构建自己的东西。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> Xcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择Swift而不是Objective-C的5个理由</title>
      <link href="/%E9%80%89%E6%8B%A9Swift%E8%80%8C%E4%B8%8D%E6%98%AFObjective-C%E7%9A%845%E4%B8%AA%E7%90%86%E7%94%B1/"/>
      <url>/%E9%80%89%E6%8B%A9Swift%E8%80%8C%E4%B8%8D%E6%98%AFObjective-C%E7%9A%845%E4%B8%AA%E7%90%86%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在进行 <code>iOS开发</code> 时，最大的问题之一是你应该使用 <code>Objective-C</code> 还是 <code>Swift</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，编程语言的寿命比你预期的更长。 但是，开发人员无法继续使用过时的方法。 他们需要了解所有最新的发展和趋势，这有时意味着做出艰难的选择。 在进行 <code>iOS开发</code> 时，最大的问题之一是你应该使用 <code>Objective-C</code> 还是 <code>Swift</code> 。</p></br><h1 id="语言历史"><a href="#语言历史" class="headerlink" title="语言历史"></a><strong>语言历史</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天， <code>Objective-C</code> 是一种用于开发 <code>iPhone应用程序</code> 的语言。但是，这种语言创建于1980年代。该语言已获得 <code>史蒂夫·乔布斯（Steve Jobs ）</code>的 <code>NeXT Computer Inc.</code> 的许可，用于开发 <code>NeXTStep框架</code> 。随着时间的流逝，它成为了 <code>Apple</code> 创造的许多标志性产品的基础。  <code>Objective-C</code> 基于两种语言： <code>Smalltalk</code> 和 <code>C</code> 。它使用来自 <code>C语言</code> 的语法进行非面向对象的操作，使用来自 <code>Smalltalk</code> 的语法进行面向对象的操作。  <code>Objective-C</code> 的主要优点之一是该语言不是新语言，并且开发人员已经对其进行了多年的测试。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 由苹果公司于2014年发布。据 <code>蒂姆·库克（Tim Cook）</code> 称，新语言在发布后一个月内被下载了超过1100万次。根据 <code>TIOBE Index</code> ， <code>Swift</code> 在2015年成为增长最快的语言。该语言是免费的，所有人均可使用，因此毫不奇怪，它在 <code>iOS开发人员</code> 中迅速流行。  <code>Swift 5.0</code> 于 2019年 发布。它具有一个稳定的二进制接口，可在包括 <code>macOS</code> ， <code>tvOS</code> 和 <code>watchOS</code> 在内的不同 <code>Apple</code> 平台上很好地运行。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Objective-C</code> 基础框架是许多 <code>Swift</code> 功能的基础。 例如， <code>Swift</code> 数据桥接到 <code>NSData</code> 。 但是， <code>Swift</code> 还具有许多 <code>Objective-C</code> 所没有的独特功能。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift 5</code> 发布后，其 <code>核心库</code> 已集成到 <code>iOS</code> ， <code>macOS</code> ， <code>watchOS</code> 和 <code>tvOS版本</code> 中。 因此，由于包含了库，因此为这些平台创建的应用现在可以较小。 稳定的应用程序二进制接口也使 <code>Apple</code> 可以跨平台提供支持。 但是， <code>Apple</code> 继续支持 <code>Objective-C</code> ，因此许多开发人员需要做出选择。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哪种语言对企业更具成本效益且更易于使用？ 这是选择 <code>Swift</code> 而不是 <code>Objective-C</code> 的一些充分理由。</p></br><h1 id="Swift易于阅读"><a href="#Swift易于阅读" class="headerlink" title="Swift易于阅读"></a><strong>Swift易于阅读</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Objective-C</code> 要求你使用带有 <code>“ @”</code> 符号的关键字来制作 <code>NSString</code> 文字。 这样一来，计算机就可以将 <code>NSString</code> 对象与常规 <code>C</code> 中使用的元素区分开。鉴于 <code>Swift</code> 不是基于 <code>C</code> 的，因此你无需使用任何标记对象，因此 <code>Swift</code> 可以统一所有关键字。 这是用 <code>Objective-C</code> 和 <code>Swift</code> 编写的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Objective-C</span><br><span class="line">const int count &#x3D; 10;</span><br><span class="line">double price &#x3D; 23.55;</span><br><span class="line"></span><br><span class="line">NSString *firstMessage &#x3D; @&quot;Swift is awesome. &quot;;</span><br><span class="line">NSString *secondMessage &#x3D; @&quot;What do you think?&quot;;</span><br><span class="line">NSString *message &#x3D; [NSString stringWithFormat: @&quot;%@%@&quot;, firstMessage, secondMessage];</span><br><span class="line"></span><br><span class="line">NSLog(message)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> price = <span class="number">23.55</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstMessage = <span class="string">"Swift is awesome. "</span></span><br><span class="line"><span class="keyword">let</span> secondMessage = <span class="string">"What do you think?."</span></span><br><span class="line"><span class="keyword">let</span> message = firstMessage + secondMessage</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 还摆脱了传统约定。 例如，你不需要在条件表达式中使用括号或在分行中使用分号。  <code>Swift</code> 使用标准方法，将列表和参数括在括号内，并用逗号分隔。 因此， <code>Swift</code> 是一种更具表现力的语言。 它更干净，并且简化了语法和语法。</p></br><h1 id="Swift-是-互动的"><a href="#Swift-是-互动的" class="headerlink" title="Swift 是 互动的"></a><strong>Swift 是 互动的</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;借助 <code>Swift Playgrounds</code>，开发人员可以快速测试其代码，而无需编译大块代码或创建完整的应用程序。 <code>Playgrounds</code> 上可以直观地呈现数据，以便程序员可以当场检查和更改其代码。 感谢最新的 <code>Xcode IDE</code> ，开发人员可以使用简单的编辑器进行实验，该编辑器包括带有图像，线条和最终视图的面板。</p></br><h1 id="Swift更安全"><a href="#Swift更安全" class="headerlink" title="Swift更安全"></a><strong>Swift更安全</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>Objective-C</code> 时，如果调用带有未初始化指针变量的方法，则不会发生任何事情。 在这种情况下，表达式变为空运算。 尽管它不会崩溃，但它引起了许多错误，因为无操作会导致不可预测的行为。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 具有 <code>静态类型系统</code> 。 当程序员使用 <code>nil</code> 可选值时，它通过触发运行时崩溃来确保可预测的行为。 由于这种方法，错误修复过程变得更加容易，因为迅速迫使开发人员立即修复所有问题。 运行时崩溃在包含 <code>nil</code> 可选值的代码行上停止，因此可以更快地修复错误。</p></br><h1 id="Swift更易于维护"><a href="#Swift更易于维护" class="headerlink" title="Swift更易于维护"></a><strong>Swift更易于维护</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>C</code> 不发展，那么 <code>Objective-C</code> 就不会发展。 程序员必须维护两个代码文件，以提高可执行应用程序开发的效率和构建时间。  <code>Swift</code> 不需要两个文件。  <code>LLVM编译器</code> 和 <code>Xcode</code> 可以在了解依赖关系的情况下自动执行增量构建。 因此，你可以忘记将实现文件与头文件分开的重复任务。  <code>Swift</code> 将实现文件 <code>.m</code> 和标头 <code>.h</code> 替换为单个代码文件<code>-.swift</code> 。 但是，它将仍然生成你可以在 <code>Xcode</code> 中看到的接口文件。</p></br><h1 id="统一内存管理"><a href="#统一内存管理" class="headerlink" title="统一内存管理"></a><strong>统一内存管理</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 支持跨 <code>面向对象</code> 和 <code>过程</code> 代码路径的 <code>自动引用计数（ARC）</code> 。 尽管 <code>Objective-C</code> 在面向对象的代码和 <code>Cocoa API</code> 中都支持 <code>ARC</code> ，但它仍然不适用于其他 <code>API</code> ，例如 <code>Core Graphics</code> 和过程 <code>C代码</code> 。 因此，程序员在使用低级 <code>API</code> 时负责处理内存管理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 消除了 <code>Objective-C</code> 中常见的大量内存泄漏，使开发人员可以专注于开发新功能和核心应用逻辑。 在 <code>Swift</code> 中，即使使用较低级别的 <code>API</code> ， <code>ARC</code> 也可以跨面向对象和过程的代码工作。  <code>Swift</code> 使 <code>Apple</code> 能够解决高性能和自动内存管理的问题，从而提高了生产率。 此外，垃圾收集器不会清理未使用的内存，这在用户输入和响应式图形的情况下是非常重要的因素。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管 <code>Apple</code> 仍然为 <code>老派开发人员</code> 提供<code>Objective-C</code> 支持，但是 <code>Swift</code> 提供了许多不可忽视的优势。 它更安全，所需的代码更少，并且更简单。  <code>Swift</code> 使程序员可以忘记与 <code>Objective-C</code> 中使用的过时方法相关的许多问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想要节省时间和金钱的开发人员应该选择 <code>Swift</code> 作为一种更有效的语言。<br>尽管编程语言的消亡速度很慢，但是可以期望 <code>Swift</code> 完全替代 <code>C</code> 来在 <code>Apple</code> 平台上进行编程。  <code>Swift</code> 不仅从 <code>Objective-C</code> 继承了许多有用的组件，而且还引入了一组新功能，这些功能允许开发人员编写更可靠的代码，从而使程序员可以避免进行大量重复性工作，而将精力集中在更全局的任务上。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入研究Swift框架</title>
      <link href="/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Swift%E6%A1%86%E6%9E%B6/"/>
      <url>/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Swift%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解有关 <code>Swift模块</code> ， <code>库</code> ， <code>软件包</code> ， <code>封闭源框架</code> ， <code>命令行工具</code> 等的一切。</p></br><h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a><strong>基本定义</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，你应该对基本术语有清楚的了解。 如果你已经知道模块，程序包，库或框架之间的区别，则可以跳过本节。 但是，如果你对这些事情仍然有一些困惑，请继续阅读，你将不会后悔。 😉</p><h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a><strong><em>Package</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个包由 <code>Swift</code> 源文件和清单文件组成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包是 <code>Swift</code> 源文件的集合。 如果你使用的是 <code>Swift Package Manager</code>，则还必须提供一个清单文件才能制作一个真正的软件包。 如果你想了解更多有关此工具的信息，请查看我的 <code>Swift Package Manager</code> 教程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：这是你的 <code>package</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sources</span></span><br><span class="line">    my-source-file.swift</span><br><span class="line"><span class="type">Package</span>.swift</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以查看 <code>Apple</code> 提供的开源 <code>swift-corelibs-foundation</code> 软件包，该软件包用于构建 <code>Swift</code> 的 <code>Foundation框架</code> 。</p><a id="more"></a><h2 id="Library"><a href="#Library" class="headerlink" title="Library"></a><strong><em>Library</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;库是程序可以链接到的目标文件的打包集合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，库是一堆编译后的代码。 你可以创建两种库：</p><ul><li>static</li><li>dynamic</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从非常简单的角度来看，它们之间的唯一区别就是 <code>“集成”</code> 的方法。 将它们链接到你的项目。 在我进一步介绍该过程之前，首先我们应该讨论目标文件。</p><h2 id="Mach-O文件格式"><a href="#Mach-O文件格式" class="headerlink" title="Mach-O文件格式"></a><strong><em>Mach-O文件格式</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了创建程序，开发人员将源代码转换为目标文件。 然后将目标文件打包到可执行代码或静态库中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译源文件时，基本上是在使用 <code>Mach-O（MachObject）</code> 文件格式来制作目标文件。 这些文件是应用程序，框架和库（动态和静态）的核心构建块。</p><h2 id="链接库"><a href="#链接库" class="headerlink" title="链接库"></a><strong><em>链接库</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接是指从多个目标文件创建单个可执行文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换一种说法：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译器创建完所有目标文件后，将调用另一个程序将它们捆绑到可执行程序文件中。 该程序称为链接器，而将它们捆绑到可执行文件中的过程称为链接。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接只是将你所有的目标文件组合成一个可执行文件，并解决所有外部问题，因此系统将能够调用二进制文件中的所有函数。</p><p><strong>静态链接</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，该库的源代码将被复制到应用程序的源代码中。 这将导致一个较大的可执行文件，它将花费更多的时间来加载，因此二进制文件的启动时间会更慢。 哦，我是否提到过，如果你尝试多次链接同一库，由于符号重复，该过程将失败？</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sf-stp1.png" alt="静态链接"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法也有优点，例如，可执行文件将始终包含正确版本的库，并且仅将那些真正使用过的部分复制到主应用程序中，因此你不必加载全部内容，但是 在某些情况下，似乎动态链接会更好。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a><strong><em>动态链接</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>动态库</code> 未嵌入到二进制源中，而是在运行时加载的。 这意味着，由于使用了轻量级的二进制文件，因此应用程序可以更小，并且启动时间可以大大缩短。 免费提供的动态库可以与多个可执行文件共享，因此它们可以减少内存占用。 这就是为什么有时将它们称为共享库的原因。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sf-stp2.png" alt="动态链接"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，如果动态库不可用-或可用，但该版本不兼容-你的应用程序将无法运行或崩溃。 另一方面，这可能是一个优势，因为动态库的作者可以发布修补程序，而你的应用程序可以从中受益，而无需重新编译。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，像 <code>UIKit</code> 这样的系统库总是可用的，因此你不必太担心这个问题…</p><h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a><strong><em>Framework</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;框架是分层目录，它将共享资源（例如动态共享库，nib文件，图像文件，本地化字符串，头文件和参考文档）封装在一个程序包中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们简化一下：框架是打包成捆绑有一些额外 <code>assets</code> ，用于版本控制的元描述的 <code>静态</code> 或 <code>动态库</code> 。  <code>UIKit</code> 是一个需要图像 <code>assets</code> 来显示某些 <code>UI元素</code> 的框架，并且具有版本描述，通过这种方式， <code>UIKit</code> 的版本与 <code>iOS</code> 的版本相同。</p><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a><strong><em>Module</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 将代码组织到模块中。 每个模块都指定一个名称空间，并强制执行访问控制，以便可以在模块外部使用该代码的哪些部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>import</code> 关键字，你实际上是将 <code>外部模块</code> 导入到你的 <code>项目</code> 中。 在Swift中，你始终使用框架作为模块，但是让我们回顾一下，来了解为什么我们完全需要 <code>模块</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> my-awesome-module</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用模块之前，你必须将框架标头直接导入代码中，并且还必须在 <code>Xcode</code> 中手动链接框架的二进制文件。  <code>#import宏</code> 实际上将整个已解析的依赖项结构复制粘贴到你的代码中，然后编译器对该庞大的源文件进行了处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个脆弱的系统，宏定义可能会出错，你很容易破坏其他框架。 这就是定义带前缀的大写超长宏名称的原因，例如： <code>NS_MYSUPERLONGMACRONAME</code>  …😒</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有另一个问题：复制粘贴会导致不可扩展的编译时间。 为了解决这个问题，预编译的头文件 <code>（PCH）</code> 诞生了，但这只是部分解决方案，因为它们污染了名称空间（你知道是否将 <code>UIKit</code> 导入 <code>PCH</code> 文件中，它随处可见），而且没有人真正维护过 他们。</p><h2 id="Modules-amp-module-maps"><a href="#Modules-amp-module-maps" class="headerlink" title="Modules &amp; module maps"></a><strong><em>Modules &amp; module maps</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经有了 <code>模块映射</code> （定义什么样的头文件是模块的一部分以及什么是实现的二进制文件），我们已经封装了模块化框架。 🎉它们分别编译一次，头文件定义 <code>接口（API）</code>，并且（自动）链接包含实现的 <code>dylib文件</code> 。 在编译期间（可伸缩性）无需解析框架头，因此本地宏定义不会破坏任何内容。 模块可以包含子模块（继承），而你不必在 <code>（Xcode）</code> 项目中显式链接它们，因为 <code>.modulemap文件</code> 包含构建系统所需的所有信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在你知道导入 <code>Foundation</code> 或 <code>导入UIKit</code> 时会发生什么。</p></br><h1 id="Command-line-tools"><a href="#Command-line-tools" class="headerlink" title="Command line tools"></a><strong>Command line tools</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然你知道整个 <code>动态模块化框架</code> 系统背后的逻辑，我们就应该开始研究使该基础架构成为可能的工具。</p><blockquote><p><strong><em><code>提示：</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总是阅读手册页。 RTFM！ 如果你不喜欢阅读太多内容，可以从gitlab下载示例项目并打开的 <code>makefile</code> 。 将有3个主要类别：<code>C</code>， <code>Swift</code> 和 <code>Xcode</code> 项目示例。</p></blockquote><h2 id="clang"><a href="#clang" class="headerlink" title="clang"></a><strong><em>clang</em></strong></h2><blockquote><p><strong><em><code>the Clang C, C++, and Objective-C compiler</code></em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Clang</code> 是 <code>C语言</code> （ <code>C</code> ， <code>C++</code> ， <code>Objective-C</code> ）的前端编译器。 如果你在大学期间曾经尝试使用 <code>gcc</code> 编译 <code>C代码</code> ，你可以想象 <code>clang</code> 与 <code>gcc</code> 差不多，但如今它可以做更多的事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -c main.c -o main.o <span class="meta">#compiles a C source file</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>LLVM</strong> ：编译器后端系统，可以编译和优化由 <code>clang</code> 或 <code>Swift</code> 编译器生成的中间表示 <code>（IR）</code> 代码。 它是独立于语言的，现在让我们说 <code>LLVM</code> 为你的 <code>可执行文件</code> 制作最终的 <code>机器代码</code> 。</p><h2 id="swiftc"><a href="#swiftc" class="headerlink" title="swiftc"></a><strong><em>swiftc</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift编译器</code> 对此没有手动输入，但是不用担心，只需启动 <code>swiftc -h</code> 并看看能为你提供什么。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftc main.swift <span class="meta">#compiles a Swift source file</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，此工具实际上是可以将 <code>Swift源文件</code> 编译为 <code>Mach-O</code> 或最终 <code>可执行文件</code> 的工具。</p><h2 id="ar"><a href="#ar" class="headerlink" title="ar"></a><strong><em>ar</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>ar</code> 实用程序创建并维护组合成档案的文件组。 创建归档文件后，可以添加新文件，并且可以提取，删除或替换现有文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，简而言之，你可以将 <code>Mach-O文件</code> 压缩为一个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -rcs myLibrary.a *.o</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>ar</code> 的帮助下，你可以创建 <code>静态库文件</code> ，但是如今 <code>libtool</code> 具有相同的功能。</p><h2 id="ranlib"><a href="#ranlib" class="headerlink" title="ranlib"></a><strong><em>ranlib</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>ranlib</code> 生成指向档案内容的索引，并将其存储在档案中。 索引列出了由可重定位目标文件的归档成员定义的每个符号。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Ranlib</code> 可以在 <code>静态库</code> 中创建一个索引文件，因此当你要使用库时，事情将会变得更快。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ranlib myLibrary.a</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此， <code>ranlib＆ar</code> 是维护 <code>静态库</code> 的工具，通常 <code>ar</code> 负责维护索引，并且你不必再运行 <code>ranlib</code> 。 但是，还有一个更好的管理 <code>静态（和动态）库</code> 的选择，你应该学习…</p><h2 id="libtool"><a href="#libtool" class="headerlink" title="libtool"></a><strong><em>libtool</em></strong></h2><blockquote><p><strong><em><code>创建类库</code></em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>libtool</code> 可以创建 <code>动态链接的库</code> 或 <code>静态链接的（归档）库</code> 。 该带有 <code>-static</code> 选项的工具旨在替换 <code>ar＆ranlib</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libtool -static *.o -o myLibrary.a</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今， <code>libtool</code> 是构建库文件的主要选项，如果你是本主题的话，一定要学习该工具。 你可以检查示例项目的 <code>makefile</code> 以获得更多信息，或者通常可以阅读手册（<code>man libtool</code>）。 😉</p><h2 id="ld"><a href="#ld" class="headerlink" title="ld"></a><strong><em>ld</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>ld命令</code> 组合了几个目标文件和库，解析引用，并生成输出文件。  <code>ld</code> 可以产生最终的 <code>链接映像</code> （ <code>可执行文件</code> ， <code>dylib</code> 或 <code>bundle</code> ）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们简单点：这是 <code>链接器工具</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld main.o -lSystem -LmyLibLocation -lmyLibrary -o MyApp</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它可以将多个文件链接到一个实体中，因此你可以从 <code>Mach-O</code> 制作 <code>可执行二进制文件</code> 。  <code>链接</code> 是必需的，因为系统需要从链接的库中解析每种方法的地址。 换句话说，可执行文件将能够运行，并且所有功能都可以调用。 📱</p><h2 id="nm"><a href="#nm" class="headerlink" title="nm"></a><strong><em>nm</em></strong></h2><blockquote><p><strong><em><code>显示名称列表（符号表）</code></em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>nm</code> ，你可以查看文件中包含哪些符号。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nm myLibrary.a</span><br><span class="line"># <span class="number">0000000000001000</span> <span class="type">A</span> __mh_execute_header</span><br><span class="line">#                  <span class="type">U</span> _factorial</span><br><span class="line"># 0000000000001f50 <span class="type">T</span> _main</span><br><span class="line">#                  <span class="type">U</span> _printf</span><br><span class="line">#                  <span class="type">U</span> dyld_stub_binder</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从输出中可以看到，某些符号与某些内存地址相关联。 具有地址的地址实际上已给出，所有其他地址都来自其他库（它们尚未解析）。 因此，这意味着它们将在运行时解决。 另一个选择是你必须链接它们。 😅</p><h2 id="otool"><a href="#otool" class="headerlink" title="otool"></a><strong><em>otool</em></strong></h2><blockquote><p><strong><em><code>目标文件显示工具</code></em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>otool</code> ，你可以检查 <code>Mach-O文件</code> 或 <code>库</code> 的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">otool -L myLibrary.a</span><br><span class="line">otool -tV myLibrary.a</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，你可以列出 <code>链接</code> 的库，或查看文件的 <code>反汇编</code> 文本内容。 如果你熟悉 <code>Mach-O文件格式</code> ，那么它是一个非常有用的工具，也是对现有应用程序进行 <code>逆向工程</code> 的好工具。</p><h2 id="lipo"><a href="#lipo" class="headerlink" title="lipo"></a><strong><em>lipo</em></strong></h2><blockquote><p><strong><em><code>创建通用文件或对其进行操作</code></em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;借助 <code>lipo</code> 工具，你可以创建通用（多体系结构）文件。 通常，此工具用于创建通用框架。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -create -output myFramework.framework devices.framework simulator.framework</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设想以下情形：你为 <code>arm7</code> 和 <code>i386</code> 都构建了类库。 在真实设备上，你需要发布 <code>arm7版本</code> ，但对于 <code>iOS模拟器</code>  ，你将需要 <code>i386版本</code> 。 在 <code>lipo</code> 的帮助下，你可以将这些体系结构组合为一个，并交付该框架，因此最终不必再担心此问题。</p></br><h1 id="Xcode相关工具"><a href="#Xcode相关工具" class="headerlink" title="Xcode相关工具"></a><strong>Xcode相关工具</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些工具也可以从命令行调用，但是它们与 <code>Xcode</code> 的关系比以前更多。 让我们快速了解一下。</p><h2 id="xcode-select"><a href="#xcode-select" class="headerlink" title="xcode-select"></a><strong><em>xcode-select</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;管理 <code>Xcode</code> 和 <code>BSD工具</code> 。 如果你的计算机上具有多个版本的 <code>Xcode</code> ，则此工具可以轻松地在各个版本提供的开发人员工具之间切换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --switch path/to/Xcode.app</span><br></pre></td></tr></table></figure><h2 id="xcrun"><a href="#xcrun" class="headerlink" title="xcrun"></a><strong><em>xcrun</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行或找到开发工具和属性。 使用 <code>xcrun</code> ，你基本上可以运行任何可以通过 <code>Xcode</code> 管理的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl list <span class="comment">#list of simulators</span></span><br></pre></td></tr></table></figure><h2 id="codesign"><a href="#codesign" class="headerlink" title="codesign"></a><strong><em>codesign</em></strong></h2><blockquote><p><strong><em><code>创建和操作代码签名</code></em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它可以选择适当的签名对你的应用程序进行签名。 通常，在引入自动签名之前尝试对应用程序进行签名时，此操作失败。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">codesign -s <span class="string">"Your Company, Inc."</span> /path/to/MyApp.app</span><br><span class="line">    codesign -v /path/to/MyApp.app</span><br></pre></td></tr></table></figure><h2 id="xcodebuild"><a href="#xcodebuild" class="headerlink" title="xcodebuild"></a><strong><em>xcodebuild</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构建 <code>Xcode</code> 项目和 <code>workspaces</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它将解析 <code>Xcode项目</code> 或 <code>workspaces</code> 文件，并基于该文件执行适当的 <code>buid命令</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -project Example.xcodeproj -target Example</span><br><span class="line">    xcodebuild -list</span><br><span class="line">    xcodebuild -showsdks</span><br></pre></td></tr></table></figure></br><h1 id="如何使iOS的封闭源通用FATtened（多体系结构）Swift框架？"><a href="#如何使iOS的封闭源通用FATtened（多体系结构）Swift框架？" class="headerlink" title="如何使iOS的封闭源通用FATtened（多体系结构）Swift框架？"></a><strong>如何使iOS的封闭源通用FATtened（多体系结构）Swift框架？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们在这里，整篇文章都是为了学习本教程背后的逻辑而写的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我不想重新发明轮子。 但是，我想为你提供一些更详细的说明，并对脚本进行一些修改。</p><h2 id="Thin-vs-fat-frameworks"><a href="#Thin-vs-fat-frameworks" class="headerlink" title="Thin vs. fat frameworks"></a><strong><em>Thin vs. fat frameworks</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Thin frameworks</code> 仅包含一种体系结构的编译代码。 另一方面，<code>fat frameworks</code> 包含用于多种体系结构的 <code>“slices”</code> 。 架构基本上被称为片，例如 <code>i386</code> 或 <code>arm7 slice</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>slice</code> 这意味着，如果仅针对 <code>i386</code> 和 <code>x86_64架构编译框架</code> ，则该框架仅在模拟器上有效，而在实际设备上则失败。 因此，如果你想构建一个真正的通用框架，则必须为所有现有架构进行编译。</p><h2 id="构建一个-fat-framework"><a href="#构建一个-fat-framework" class="headerlink" title="构建一个 fat framework"></a><strong><em>构建一个 fat framework</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对你有个好消息。 你只需要一个构建阶段脚本和一个聚合目标即可构建一个多体系结构框架。 在这里，从原始文章中无耻地撕下来，进行了一些额外的更改…😁</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">BUILD_PATH=<span class="string">"<span class="variable">$&#123;SRCROOT&#125;</span>/build"</span></span><br><span class="line">DEPLOYMENT_PATH=<span class="string">"<span class="variable">$&#123;SRCROOT&#125;</span>"</span></span><br><span class="line">TARGET_NAME=<span class="string">"Console-iOS"</span></span><br><span class="line">FRAMEWORK_NAME=<span class="string">"Console"</span></span><br><span class="line">FRAMEWORK=<span class="string">"<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>.framework"</span></span><br><span class="line">FRAMEWORK_PATH=<span class="string">"<span class="variable">$&#123;DEPLOYMENT_PATH&#125;</span>/<span class="variable">$&#123;FRAMEWORK&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean the build folder</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    rm -rf <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build the framework for every architecture using xcodebuild</span></span><br><span class="line">xcodebuild -target <span class="string">"<span class="variable">$&#123;TARGET_NAME&#125;</span>"</span> -configuration Release \</span><br><span class="line">    -arch arm64 -arch armv7 -arch armv7s \</span><br><span class="line">    only_active_arch=no defines_module=yes -sdk <span class="string">"iphoneos"</span></span><br><span class="line"></span><br><span class="line">xcodebuild -target <span class="string">"<span class="variable">$&#123;TARGET_NAME&#125;</span>"</span> -configuration Release \</span><br><span class="line">    -arch x86_64 -arch i386 \</span><br><span class="line">    only_active_arch=no defines_module=yes -sdk <span class="string">"iphonesimulator"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove previous version from the deployment path</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;FRAMEWORK_PATH&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    rm -rf <span class="string">"<span class="variable">$&#123;FRAMEWORK_PATH&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy freshly built version to the deployment path</span></span><br><span class="line">cp -r <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>/Release-iphoneos/<span class="variable">$&#123;FRAMEWORK&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;FRAMEWORK_PATH&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># merge all the slices and create the fat framework</span></span><br><span class="line">lipo -create -output <span class="string">"<span class="variable">$&#123;FRAMEWORK_PATH&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>"</span> \</span><br><span class="line">    <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>/Release-iphoneos/<span class="variable">$&#123;FRAMEWORK&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>"</span> \</span><br><span class="line">    <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>/Release-iphonesimulator/<span class="variable">$&#123;FRAMEWORK&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy Swift module mappings for the simulator</span></span><br><span class="line">cp -r <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>/Release-iphonesimulator/<span class="variable">$&#123;FRAMEWORK&#125;</span>/Modules/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>.swiftmodule/"</span> \</span><br><span class="line">    <span class="string">"<span class="variable">$&#123;FRAMEWORK_PATH&#125;</span>/Modules/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>.swiftmodule"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean up the build folder again</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    rm -rf <span class="string">"<span class="variable">$&#123;BUILD_PATH&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以使用 <code>lipo</code> 工具检查创建的框架。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lipo -info Console.framework/Console</span><br><span class="line">    <span class="comment">#Architectures in the fat file: Console.framework/Console are: x86_64 i386 armv7 armv7s arm64</span></span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong><em>用法</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你只需要将全新的框架嵌入到要使用的项目中并设置一些路径即可。 </p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sf-stp3.png" alt="静态链接"></p><h2 id="提交至App-Store"><a href="#提交至App-Store" class="headerlink" title="提交至App Store"></a><strong><em>提交至App Store</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>fat frameworks</code> 只有一个问题。 它们也包含模拟器的切片。 如果要向应用商店提交应用，则必须从框架中切断与模拟器相关的代码库。 其背后的原因是，没有真正的实际设备需要此代码块，那么为什么要提交它呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">APP_PATH=<span class="string">"<span class="variable">$&#123;TARGET_BUILD_DIR&#125;</span>/<span class="variable">$&#123;WRAPPER_NAME&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove unused architectures from embedded frameworks</span></span><br><span class="line">find <span class="string">"<span class="variable">$APP_PATH</span>"</span> -name <span class="string">'*.framework'</span> -<span class="built_in">type</span> d | <span class="keyword">while</span> <span class="built_in">read</span> -r FRAMEWORK</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    FRAMEWORK_EXECUTABLE_NAME=$(defaults <span class="built_in">read</span> <span class="string">"<span class="variable">$FRAMEWORK</span>/Info.plist"</span> CFBundleExecutable)</span><br><span class="line">    FRAMEWORK_EXECUTABLE_PATH=<span class="string">"<span class="variable">$FRAMEWORK</span>/<span class="variable">$FRAMEWORK_EXECUTABLE_NAME</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Executable is <span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>"</span></span><br><span class="line"></span><br><span class="line">    EXTRACTED_ARCHS=()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ARCH <span class="keyword">in</span> <span class="variable">$ARCHS</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Extracting <span class="variable">$ARCH</span> from <span class="variable">$FRAMEWORK_EXECUTABLE_NAME</span>"</span></span><br><span class="line">        lipo -extract <span class="string">"<span class="variable">$ARCH</span>"</span> <span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>"</span> -o <span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>-<span class="variable">$ARCH</span>"</span></span><br><span class="line">        EXTRACTED_ARCHS+=(<span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>-<span class="variable">$ARCH</span>"</span>)</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Merging extracted architectures: <span class="variable">$&#123;ARCHS&#125;</span>"</span></span><br><span class="line">    lipo -o <span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>-merged"</span> -create <span class="string">"<span class="variable">$&#123;EXTRACTED_ARCHS[@]&#125;</span>"</span></span><br><span class="line">    rm <span class="string">"<span class="variable">$&#123;EXTRACTED_ARCHS[@]&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Replacing original executable with thinned version"</span></span><br><span class="line">    rm <span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>"</span></span><br><span class="line">    mv <span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>-merged"</span> <span class="string">"<span class="variable">$FRAMEWORK_EXECUTABLE_PATH</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个小脚本将删除框架中所有不必要的片段，因此你可以通过 <code>iTunes Connect</code> 提交应用程序，而不会出现任何问题。 （哈哈哈。😅）</p><blockquote><p><strong><em><code>提示：</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你必须将此最后一个脚本添加到应用程序的 <code>build phases</code> 中。</p></blockquote></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果你想熟悉幕后的工具，本文将为你展示基础知识。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 架构设计 </tag>
            
            <tag> Swift Package Manager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何为VIPER编写服务？</title>
      <link href="/%E5%A6%82%E4%BD%95%E4%B8%BAVIPER%E7%BC%96%E5%86%99%E6%9C%8D%E5%8A%A1%EF%BC%9F/"/>
      <url>/%E5%A6%82%E4%BD%95%E4%B8%BAVIPER%E7%BC%96%E5%86%99%E6%9C%8D%E5%8A%A1%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并非所有内容都是 <code>VIPER模块</code> 。 在本文中，我将向你展示如何使用 <code>Swift</code> 将 <code>服务层</code> 与 <code>模块</code> 分离。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我可以想象你刚刚开始编写第一个 <a href="http://www.xuebaonline.com/iOS%20VIPER%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"><strong><em><code>VIPER模块</code></em></strong></a> ，你可能会想：我应该把所有与用户界面都不相关的所有 <code>网络通信</code> ， <code>CoreLocation</code> ， <code>CoreData</code> 或 <code>“任何服务”</code> 代码放在哪里？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我通常将它们称为 API ， 位置 ， 存储即服务 ，因为它们为你的 模块 提供某种信息。 另外，它们可以封装基础层，为 VIPER模块 提供定义明确的 API接口 。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，但是 <code>interactors</code> 呢？ 我不应该在这里实现这种东西吗？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，我的答案是否定的，因为 <code>服务</code> 和 <code>interactors</code> 之间存在重大差异。 虽然服务只是一个“虚拟”包装器，但例如 一个 <code>RESTful API</code> ，另一个围绕 <code>CoreData存储</code> ， <code>interactors</code> 可以使用它们两者通过API请求某种数据，并使用存储服务将其保存在本地。  <code>interactors</code> 还可以在 <code>数据传输对象（DTO）</code> 和实体之间进行排序，过滤和转换，稍后将对其进行更多介绍。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，理论足够了，让我们创建一个新服务。</p><a id="more"></a></br><h1 id="服务接口"><a href="#服务接口" class="headerlink" title="服务接口"></a><strong>服务接口</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次如协议目标编程范式所示：            <code>通过定义协议开始设计我们的系统。</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的第一个服务将是对所有服务而言非常简单的服务：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServiceInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// do nothing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在服务初始化过程中将为每个服务调用安装程序。 我们可以扩展基本服务，因此我们不必实现此方法，而仅当我们确实必须执行某些操作（例如设置 <code>CoreData堆栈</code> ）时才可以实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们可以提供我们的 <code>API</code> 服务，在这种情况下，我将实现一个虚拟端点，该端点使用带有 <code>URLSession</code> 的新 <code>Combine框架</code> 加载一些数据，但是当然你也可以使用完成块或 <code>Promises</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ApiServiceInterface</span>: <span class="title">ServiceInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">todos</span><span class="params">()</span></span> -&gt; <span class="type">AnyPublisher</span>&lt;[<span class="type">TodoObject</span>], <span class="type">HTTP</span>.<span class="type">Error</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，我正在为所有与网络相关的内容使用 <code>HTTP</code> 名称空间，例如请求方法，响应，错误等。可以根据需要随意扩展它。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Method</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">get</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Error</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> invalidResponse</span><br><span class="line">        <span class="keyword">case</span> statusCode(<span class="type">Int</span>)</span><br><span class="line">        <span class="keyword">case</span> unknown(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，它非常轻巧，但是非常方便。 我们还没有谈论过 <code>TodoObject</code> 。 这将是我们的第一个 <code>DTO</code> 。 😱</p></br><h1 id="数据传输对象"><a href="#数据传输对象" class="headerlink" title="数据传输对象"></a><strong>数据传输对象</strong></h1><blockquote><figure class="highlight plain"><figcaption><span>-维基百科```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在这种情况下，我们谈论的不是流程，而是 &#96;&#96;&#96;服务&#96;&#96;&#96; 和 [***&#96;&#96;&#96;VIPER模块&#96;&#96;&#96;***](http:&#x2F;&#x2F;www.xuebaonline.com&#x2F;%E6%8E%8C%E6%8F%A1VIPER%E6%9E%B6%E6%9E%84&#x2F; &quot;&quot;) 。 它们存在，因此我们可以将服务层与模块分离。  &#96;&#96;&#96;interactor&#96;&#96;&#96; 可以将 &#96;&#96;&#96;DTO&#96;&#96;&#96; 转换为 &#96;&#96;&#96;模块实体&#96;&#96;&#96; ，因此 &#96;&#96;&#96;VIPER模块&#96;&#96;&#96; 的所有其他部分将完全独立于服务。 值得一提的是， &#96;&#96;&#96;DTO&#96;&#96;&#96; 通常非常简单，在 &#96;&#96;&#96;RESTful API&#96;&#96;&#96; 服务中， &#96;&#96;&#96;DTO&#96;&#96;&#96; 可以实现 &#96;&#96;&#96;Codable&#96;&#96;&#96; 接口，仅此而已；对于 &#96;&#96;&#96;CoreData&#96;&#96;&#96; ， &#96;&#96;&#96;DTO&#96;&#96;&#96; 只能是 &#96;&#96;&#96;NSManagedObject&#96;&#96;&#96; 子类。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; Swift</span><br><span class="line">struct TodoObject: Codable &#123;</span><br><span class="line">   let id: Int</span><br><span class="line">   let title: String</span><br><span class="line">   let completed: Bool</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以使用简单的 <code>DTO</code> 包装请求参数。 例如，你可以使用可以包含一些过滤器或排序参数的 <code>TodoRequestObject</code> 。 你可能会注意到，我始终在 <code>DTO</code> 中使用对象后缀，这是个人喜好，但这有助于我将它们与实体区分开。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进一步介绍一下：你可以使用 <code>SPM</code> 将整个服务层作为封装的 <code>Swift软件包发布</code> ，从Xcode 11开始，这些软件包都受本机支持，因此，如果你仍在使用 <code>CocoaPods</code> ，则应考虑迁移到 <code>Swift软件包管理器</code> ，如下所示： 尽快。</p></br><h1 id="实现-Service"><a href="#实现-Service" class="headerlink" title="实现 Service"></a><strong>实现 Service</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开始构建真实的服务实现之前，最好有一个用于演示或测试目的的假冒产品。 我之所以称其为伪造的，是因为我们将返回固定数量的伪造数据，但这与我们的实际实现很接近。 如果我们的请求将包括过滤或排序，那么此伪造的实现服务应像最终响应那样对我们的响应进行过滤或排序。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FakeApiService</span>: <span class="title">ApiServiceInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> delay: <span class="type">TimeInterval</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(delay: <span class="type">TimeInterval</span> = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.delay = delay</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">fakeRequest</span>&lt;T&gt;<span class="params">(response: T)</span></span> -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">T</span>, <span class="type">HTTP</span>.<span class="type">Error</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Future</span>&lt;<span class="type">T</span>, <span class="type">HTTP</span>.<span class="type">Error</span>&gt; &#123; promise <span class="keyword">in</span></span><br><span class="line">            promise(.success(response))</span><br><span class="line">        &#125;</span><br><span class="line">        .delay(<span class="keyword">for</span>: .<span class="keyword">init</span>(<span class="keyword">self</span>.delay), scheduler: <span class="type">RunLoop</span>.main)</span><br><span class="line">        .eraseToAnyPublisher()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">todos</span><span class="params">()</span></span> -&gt; <span class="type">AnyPublisher</span>&lt;[<span class="type">TodoObject</span>], <span class="type">HTTP</span>.<span class="type">Error</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> todos = [</span><br><span class="line">            <span class="type">TodoObject</span>(id: <span class="number">1</span>, title: <span class="string">"first"</span>, completed: <span class="literal">false</span>),</span><br><span class="line">            <span class="type">TodoObject</span>(id: <span class="number">2</span>, title: <span class="string">"second"</span>, completed: <span class="literal">false</span>),</span><br><span class="line">            <span class="type">TodoObject</span>(id: <span class="number">3</span>, title: <span class="string">"third"</span>, completed: <span class="literal">false</span>),</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.fakeRequest(response: todos)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我想给假对象增加一些延迟，因为它可以帮助我测试 <code>UI堆栈</code> 。 <a href="https://www.scotthurff.com/posts/why-your-user-interface-is-awkward-youre-ignoring-the-ui-stack/" target="_blank" rel="noopener"><strong><em><code>如何解决不良用户界面</code></em></strong></a> 你绝对应该阅读它，因为它很棒，它将帮助你设计更好的产品。 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续前进，这是该服务的实际“实际”实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApiService</span>: <span class="title">ApiServiceInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> baseUrl: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(baseUrl: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.baseUrl = baseUrl</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">todos</span><span class="params">()</span></span> -&gt; <span class="type">AnyPublisher</span>&lt;[<span class="type">TodoObject</span>], <span class="type">HTTP</span>.<span class="type">Error</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="keyword">self</span>.baseUrl + <span class="string">"todos"</span>)!</span><br><span class="line">        <span class="keyword">var</span> request = <span class="type">URLRequest</span>(url: url)</span><br><span class="line">        request.httpMethod = <span class="type">HTTP</span>.<span class="type">Method</span>.<span class="keyword">get</span>.rawValue.uppercased()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: request)</span><br><span class="line">        .tryMap &#123; data, response <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="type">HTTP</span>.<span class="type">Error</span>.invalidResponse</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">guard</span> httpResponse.statusCode == <span class="number">200</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="type">HTTP</span>.<span class="type">Error</span>.statusCode(httpResponse.statusCode)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125;</span><br><span class="line">        .decode(type: [<span class="type">TodoObject</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())</span><br><span class="line">        .mapError &#123; error -&gt; <span class="type">HTTP</span>.<span class="type">Error</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> httpError = error <span class="keyword">as</span>? <span class="type">HTTP</span>.<span class="type">Error</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> httpError</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">HTTP</span>.<span class="type">Error</span>.unknown(error)</span><br><span class="line">        &#125;</span><br><span class="line">        .eraseToAnyPublisher()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题是我们可以做得更好，但是为了简单起见，我将“一起”实现。 我不喜欢隐式解包的 <code>url</code> 和其他许多小细节，但是出于学习目的，这是完全可以的。 😛</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以现在最大的问题是，如何将事情放在一起？ 我的意思是我们有一个有效的服务实现，一个伪造的服务实现，但是如果不将伪造的代码运送到生产环境中，我们应该怎么把所有东西放到一个真正的Xcode项目中呢？</p></br><h1 id="目标环境"><a href="#目标环境" class="headerlink" title="目标环境"></a><strong>目标环境</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，你将具有现场生产环境，开发环境，也许是测试环境，以及用于QA，UAT或演示目的的其他环境。 对于这些环境，情况可能会有所不同，例如最终的 <code>API URL</code>或应用程序图标等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，我将建立一个具有3个独立环境的项目：</p><ul><li>Production</li><li>Development</li><li>Fake</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你从一个新项目开始，则默认情况下将有一个主要（非测试）目标。 你可以通过右键单击目标来复制它。 让我们做两次。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ws-stp1.png" alt="Production"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我通常为目标和方案名称加上后缀，但生产环境除外，在生产环境中，我使用“基本名称”而不使用<code>-Production</code> 后缀。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如你在屏幕截图上所看到的，我具有用于环境的基本文件夹结构。 每个目标都必须有一个单独的 <code>Info.plist</code> 文件，因此我将它们放入适当的 <code>Assets</code> 文件夹中。 <code>FakeApiService.swift</code> 只是伪造目标的一部分，其他所有文件都是共享的。 等等， <code>ServiceBuilder</code> 到底是什么？</p></br><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多种环境意味着我们必须为每个构建目标使用正确的服务（或配置）。 为此，我正在使用依赖项注入设计模式。 服务构建者只是有助于实现此目标的协议。 它定义了如何根据环境设置服务。 让我告诉你它是如何工作的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceBuilderInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> api: <span class="type">ApiServiceInterface</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServiceBuilderInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.api.setup()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，对于每个目标（环境），我都在实际的 <code>ServiceBuilder.swift</code> 文件中实现 <code>ServiceBuilderInterface</code> ，因此可以根据需要设置服务。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBuilder</span>: <span class="title">ServiceBuilderInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> api: <span class="type">ApiServiceInterface</span> = &#123;</span><br><span class="line">        <span class="comment">// this can be the url of the development server</span></span><br><span class="line">        <span class="type">MyApiService</span>(baseUrl: <span class="string">"https://jsonplaceholder.typicode.com"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我通常有一个基本的 <code>service-interactor</code> 类，它将在初始化过程中接收所有服务。 因此，我可以轻松地交换任何东西。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceInteractor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> services: <span class="type">ServiceBuilderInterface</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(services: <span class="type">ServiceBuilderInterface</span> = <span class="type">App</span>.shared.services) &#123;</span><br><span class="line">        <span class="keyword">self</span>.services = services</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DI很不错，但是我不想重复太多，这就是为什么要为此属性提供默认值的原因，该属性位于我唯一的 <code>单例类App</code> 中。 我知道，单例是邪恶的，但是我已经在这里有了一个反模式，所以再引入一个并没有关系，对吗？🤔</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> services = <span class="type">ServiceBuilder</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - singleton</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">App</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// do nothing...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - api</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.services.setup()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要进行测试，此设置非常有用。 如果要测试一个 <code>interactor</code> ，则可以简单地模拟所有服务。 它也很干净，因为你可以像这样在 <code>interactor</code> 中访问方法：<code>self.services.api.todos（）</code> 。</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以对模块应用相同的模式，例如，你可以拥有一个实现 <code>ModuleBuilderInterface</code> 的 <code>ModuleBuilder</code> ，并且所有 <code>routers</code> 都可以通过 <code>DI</code> 来拥有它们，因此你不必使用构建就从头开始初始化所有内容 模块的功能。 😉</p></blockquote></br><h1 id="对象，模型，实体，…是什么？"><a href="#对象，模型，实体，…是什么？" class="headerlink" title="对象，模型，实体，…是什么？"></a><strong>对象，模型，实体，…是什么？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于命名约定的一点建议（我一直都将它们用作后缀）：</p><ul><li>Object</li><li>Entity</li><li>Model</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我的字典中，对象始终是 ··· ，它仅存在于服务层中。 这是一个愚蠢的傻子，没有比提供一个不错的 <code>Swiftish API</code> 多的目的。 这意味着你不必处理 <code>JSON对象</code> 或类似的疯狂对象，但是你可以直接使用这些对象，通常很高兴拥有此功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>实体</code> 与 <code>VIPER模块</code> 相关。 其目的是充当可在视图， <code>interactor</code> ， <code>presenter</code> ， <code>router</code> 之间传递的通信对象，或充当另一个模块的参数。 它可以封装模块所需的本地内容。 这意味着，如果服务层（可能是 <code>DTO</code> ）中的某些内容发生变化，则你的模块将能够工作，则只需对齐 <code>interactor</code> 即可。 😬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模型是指视图模型，它是我在 <code>UICollectionView</code> 类之上的基于 <code>组件</code> 的 <code>UI</code> 构建方法的一部分。 如果你想了解更多信息，则应该查看链接，其语法与 <code>SwiftUI</code> 非常相似，但显然不那么高级。 总之，模型始终具有呈现视图所需的数据，仅此而已。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我希望这篇小文章能帮助你更好地构建应用程序。 由于你必须设计应用程序，因此 <code>VIPER</code> 有时可能会遇到很多问题。 使用这类服务是分离所有不同的API连接，传感器等的好方法，最后请记住：<br><code>并非所有内容都是 VIPER模块 。</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <a href="https://github.com/theswiftdev/tutorials" target="_blank" rel="noopener"><strong><em><code>GitHub</code></em></strong></a> 上的下载本文的源文件。👏</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用VIPER构建SwiftUI Apps？</title>
      <link href="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VIPER%E6%9E%84%E5%BB%BASwiftUI%20Apps%EF%BC%9F/"/>
      <url>/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VIPER%E6%9E%84%E5%BB%BASwiftUI%20Apps%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这篇文章中，我将向你展示如何在真实的 <code>iOS应用程序</code> 示例中将 <code>SwiftUI</code> 与 <code>VIPER架构</code> 结合起来。</p></br><h1 id="SwiftUI-初学者"><a href="#SwiftUI-初学者" class="headerlink" title="SwiftUI-初学者"></a><strong>SwiftUI-初学者</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网上确实有成百上千的 <code>SwiftUI</code> 教程，但是我只能找到一两个专门针对现实用例的东西，而不是像在 <code>SwiftUI</code> 中配置/制作X这样的较小细节。！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对 <code>SwiftUI</code> 也有自己的 “挣扎” ，因为我的集合视图框架的结构与编写 <code>SwiftUI</code> 代码的方式完全相同。😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，我从零开始就知道会有大量新的 <code>SwiftUI</code> 教程到来，并且每个人都会对新的声明性 <code>UI框架</code> 大肆宣传，但是老实说，我已经有了通用的工具包。这就是为什么我不想写它。坦率地说， 比起 <code>SwiftUI</code> 更喜欢 <code>Combine</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终，因为到底是什么让我们尝试了新事物，并且我对 <code>SwiftUI</code> 如何适合我的应用程序构建方法感到好奇，所以我开始根据这些视图创建新的 <code>VIPER模板</code> 。我还想使用最新的新框架制作一个有用的，可扩展的，模块化的实际应用示例。 😛</p><a id="more"></a></br><h1 id="了解现代VIPER架构"><a href="#了解现代VIPER架构" class="headerlink" title="了解现代VIPER架构"></a><strong>了解现代VIPER架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我在过去两年中一直使用 <code>VIPER架构</code> 。 有人说“这太复杂了”或“这不适合小型团队”。 我只能告诉他们一个字：扯！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我相信我已经创建了一种现代且相对简单的模式，几乎可以用于任何东西。得益于简洁的架构和 <code>SOLID原理</code> ，学习 <code>VIPER</code> 肯定会提高你的代码质量。你将更好地了解较小的部分如何协同工作并相互交流。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;孤立的较小组件可以加快开发速度，因为你只需一次做一点工作，而且你可以为特定的事物创建测试，这对于可测试性和代码覆盖率来说是一个巨大的胜利（你不必运行你的应用程序始终都在运行，如果你想测试某些东西，则可以使用你只需要的模块）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我通常使用一个非常简单的代码生成器来启动新模块，这样我可以节省很多时间。如果你必须独自处理项目，则模块生成器和预定义的结构甚至可以为你节省更多时间。而且，如果遵循基本 <code>VIPER规则</code> ，你真的不会弄乱搞乱项目结构。 ⏰</p></br><h1 id="VIPER到底是什么？"><a href="#VIPER到底是什么？" class="headerlink" title="VIPER到底是什么？"></a><strong>VIPER到底是什么？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你以前从未听说过 <code>VIPER</code> ，首先应该知道 <code>VIPER模块</code> 包含以下组件：</p><ul><li><strong>Vi</strong>ew = UIViewController子类或SwiftUI视图</li><li><strong>I</strong>nteractor = 以正确的格式提供所需的数据</li><li><strong>P</strong>resenter = 独立于UI的业务逻辑（具体操作）</li><li><strong>E</strong>ntity = 数据对象（有时模块中不存在）</li><li><strong>R</strong>outer = 建立视图控制器层次结构（显示，显示，关闭等）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这些文件旁边，我总是有一个模块文件，其中我定义了一个模块构建器，该构建器从上面的组件中构建了整个组件，在该文件中，我还定义了特定于模块的协议。 我通常将这些协议称为接口，它们使使用依赖注入可以替换任何组件成为可能。 这样，我们可以在单元测试中使用模拟对象来测试任何东西。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有人说带有 <code>Builder</code> 的 <code>VIPER模块</code> 称为 <code>VIPER/B</code>。 我认为模块文件是存储模块构建器对象，模块接口和模块委托（如果需要的话）的理想场所。</p></blockquote></br><h1 id="面向协议的VIPER架构"><a href="#面向协议的VIPER架构" class="headerlink" title="面向协议的VIPER架构"></a><strong>面向协议的VIPER架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，关键是连接 <code>View-Interactor-Presenter-Router</code> 的6个主要协议。 这些协议确保 <code>VIPER组件</code> 看不到超出要求的内容。 🐛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">View</span>-to-<span class="type">Presenter</span></span><br><span class="line"><span class="type">Presenter</span>-to-<span class="type">View</span></span><br><span class="line"></span><br><span class="line"><span class="type">Router</span>-to-<span class="type">Presenter</span></span><br><span class="line"><span class="type">Presenter</span>-to-<span class="type">Router</span></span><br><span class="line"></span><br><span class="line"><span class="type">Interactor</span>-to-<span class="type">Presenter</span></span><br><span class="line"><span class="type">Presenter</span>-to-<span class="type">Interactor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Module</span></span><br><span class="line"># ---</span><br><span class="line">builds up pointers and returns a <span class="type">UIViewController</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">View</span> implements <span class="type">View</span>-to-<span class="type">Presenter</span></span><br><span class="line"># ---</span><br><span class="line">strong presenter <span class="keyword">as</span> <span class="type">Presenter</span>-to-<span class="type">View</span>-interface</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Presenter</span> implements <span class="type">Presenter</span>-to-<span class="type">Router</span>, <span class="type">Presenter</span>-to-<span class="type">Interactor</span>, <span class="type">Presenter</span>-to-<span class="type">View</span></span><br><span class="line"># ---</span><br><span class="line">strong router <span class="keyword">as</span> <span class="type">Router</span>-to-<span class="type">Presenter</span>-interface</span><br><span class="line">strong interactor <span class="keyword">as</span> <span class="type">Interactor</span>-to-<span class="type">Presenter</span>-interface</span><br><span class="line"><span class="keyword">weak</span> view <span class="keyword">as</span> <span class="type">View</span>-to-<span class="type">Presenter</span>-interface</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Interactor</span> implements <span class="type">Interactor</span>-to-<span class="type">Presenter</span></span><br><span class="line"># ---</span><br><span class="line"><span class="keyword">weak</span> presenter <span class="keyword">as</span> <span class="type">Presenter</span>-to-<span class="type">Interactor</span>-interface</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Router</span> implemenents <span class="type">Presenter</span>-to-<span class="type">Router</span></span><br><span class="line"># ---</span><br><span class="line"><span class="keyword">weak</span> presenter <span class="keyword">as</span> <span class="type">Presenter</span>-to-<span class="type">Router</span>-interface</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，视图（可以是 <code>UIViewController</code> 子类）牢固地保持了 <code>presenter</code> ，并且 <code>presenter</code> 将保留 <code>interactor</code> 和 <code>router</code> 类。 其他所有东西都是弱指针，因为我们不喜欢持有。 乍一看似乎有些复杂，但是在编写了最初的几个模块之后，你将发现将逻辑组件彼此分离是多么的好。 🐍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，并非所有内容都是 <code>VIPER模块</code> 。 不要尝试将你的 <code>API通信层</code> 或 <code>CoreLocation服务</code> 编写为模块，因为这类东西是独立的，例如：服务。 我将在下一篇文章中介绍它们，但现在，我们仅关注 <code>VIPER模块</code> 的剖析。</p></br><h1 id="Swift-5中的VIPER实现"><a href="#Swift-5中的VIPER实现" class="headerlink" title="Swift 5中的VIPER实现"></a><strong>Swift 5中的VIPER实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你准备好编写一些 <code>Swift</code> 代码了吗？ 好吧，让我们创建一些通用的 <code>VIPER接口</code> ，以后可以扩展它们，不要担心不会那么难。 😉</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - interfaces</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">RouterPresenterInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">InteractorPresenterInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">PresenterRouterInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">PresenterInteractorInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">PresenterViewInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ViewPresenterInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - viper</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">RouterInterface</span>: <span class="title">RouterPresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">PresenterRouter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">PresenterRouter!</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">InteractorInterface</span>: <span class="title">InteractorPresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">PresenterInteractor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">PresenterInteractor!</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">PresenterInterface</span>: <span class="title">PresenterRouterInterface</span> &amp; <span class="title">PresenterInteractorInterface</span> &amp; <span class="title">PresenterViewInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">RouterPresenter</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">InteractorPresenter</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">ViewPresenter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> router: <span class="type">RouterPresenter!</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> interactor: <span class="type">InteractorPresenter!</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> view: <span class="type">ViewPresenter!</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ViewInterface</span>: <span class="title">ViewPresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">PresenterView</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">PresenterView!</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">EntityInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ModuleInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">View</span> <span class="keyword">where</span> <span class="type">View</span>: <span class="type">ViewInterface</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Presenter</span> <span class="keyword">where</span> <span class="type">Presenter</span>: <span class="type">PresenterInterface</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Router</span> <span class="keyword">where</span> <span class="type">Router</span>: <span class="type">RouterInterface</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Interactor</span> <span class="keyword">where</span> <span class="type">Interactor</span>: <span class="type">InteractorInterface</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">assemble</span><span class="params">(view: View, presenter: Presenter, router: Router, interactor: Interactor)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">ModuleInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">assemble</span><span class="params">(view: View, presenter: Presenter, router: Router, interactor: Interactor)</span></span> &#123;</span><br><span class="line">        view.presenter = (presenter <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">View</span>.<span class="type">PresenterView</span>)</span><br><span class="line"></span><br><span class="line">        presenter.view = (view <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Presenter</span>.<span class="type">ViewPresenter</span>)</span><br><span class="line">        presenter.interactor = (interactor <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Presenter</span>.<span class="type">InteractorPresenter</span>)</span><br><span class="line">        presenter.router = (router <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Presenter</span>.<span class="type">RouterPresenter</span>)</span><br><span class="line"></span><br><span class="line">        interactor.presenter = (presenter <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Interactor</span>.<span class="type">PresenterInteractor</span>)</span><br><span class="line"></span><br><span class="line">        router.presenter = (presenter <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Router</span>.<span class="type">PresenterRouter</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关联类型只是特定类型的占位符，通过使用通用接口设计，我可以使用通用模块接口扩展来组装模块，如果缺少某些协议，则应用程序将崩溃，就像我尝试初始化不良模块一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我喜欢这种方法，因为它使我省去了许多样板模块构建器代码。 同样，所有内容都将具有基本协议，因此我可以以一种真正整洁的面向协议的方式扩展任何内容。 无论如何，如果你不了解泛型没什么大不了的，那么在实际的模块实现中，你将几乎无法满足它们。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么实际模块的代码如何？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TodoModule.swift</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - router</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoRouterPresenterInterface</span>: <span class="title">RouterPresenterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - presenter</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoPresenterRouterInterface</span>: <span class="title">PresenterRouterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoPresenterInteractorInterface</span>: <span class="title">PresenterInteractorInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoPresenterViewInterface</span>: <span class="title">PresenterViewInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - interactor</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoInteractorPresenterInterface</span>: <span class="title">InteractorPresenterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - view</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoViewPresenterInterface</span>: <span class="title">ViewPresenterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - module builder</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoModule</span>: <span class="title">ModuleInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">View</span> = <span class="type">TodoView</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Presenter</span> = <span class="type">TodoPresenter</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Router</span> = <span class="type">TodoRouter</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Interactor</span> = <span class="type">TodoInteractor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="type">View</span>()</span><br><span class="line">        <span class="keyword">let</span> interactor = <span class="type">Interactor</span>()</span><br><span class="line">        <span class="keyword">let</span> presenter = <span class="type">Presenter</span>()</span><br><span class="line">        <span class="keyword">let</span> router = <span class="type">Router</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.assemble(view: view, presenter: presenter, router: router, interactor: interactor)</span><br><span class="line"></span><br><span class="line">        router.viewController = view</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TodoPresenter.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoPresenter</span>: <span class="title">PresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> router: <span class="type">TodoRouterPresenterInterface!</span></span><br><span class="line">    <span class="keyword">var</span> interactor: <span class="type">TodoInteractorPresenterInterface!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">TodoViewPresenterInterface!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TodoPresenter</span>: <span class="title">TodoPresenterRouterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TodoPresenter</span>: <span class="title">TodoPresenterInteractorInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TodoPresenter</span>: <span class="title">TodoPresenterViewInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TodoInteractor.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoInteractor</span>: <span class="title">InteractorInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> presenter: <span class="type">TodoPresenterInteractorInterface!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TodoInteractor</span>: <span class="title">TodoInteractorPresenterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TodoRouter.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoRouter</span>: <span class="title">RouterInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> presenter: <span class="type">TodoPresenterRouterInterface!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> viewController: <span class="type">UIViewController?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TodoRouter</span>: <span class="title">TodoRouterPresenterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TodoView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoView</span>: <span class="title">UIViewController</span>, <span class="title">ViewInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">TodoPresenterViewInterface!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TodoView</span>: <span class="title">TodoViewPresenterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>VIPER模块</code> 由五个文件组成，与我的旧方法相比，这是一个巨大的改进（我为单个模块使用了9个文件，这仍然比2000行代码的大规模视图控制器要好，但是是的，它的文件很多 …😂）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要，可以使用 <a href="https://github.com/corekit/viper" target="_blank" rel="noopener"><strong><em><code>VIPER协议库</code></em></strong></a> ，也可以将这些接口复制并粘贴到你的项目中。 我还有一个完全用 <code>Swift</code> 编写的 <a href="https://github.com/corekit/vipera" target="_blank" rel="noopener"><strong><em><code>VIPER模块生成器</code></em></strong></a> ，它可以基于此模板生成模块（或者你可以自己创建）。</p><br><h1 id="如何创建VIPER接口？"><a href="#如何创建VIPER接口？" class="headerlink" title="如何创建VIPER接口？"></a><strong>如何创建VIPER接口？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一起看一个示例流程，请考虑以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoRouterPresenterInterface</span>: <span class="title">RouterPresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dismiss</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - presenter</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoPresenterRouterInterface</span>: <span class="title">PresenterRouterInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoPresenterInteractorInterface</span>: <span class="title">PresenterInteractorInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didLoadWelcomeText</span><span class="params">(<span class="number">_</span> text: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoPresenterViewInterface</span>: <span class="title">PresenterViewInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ready</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - interactor</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoInteractorPresenterInterface</span>: <span class="title">InteractorPresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startLoadingWelcomeText</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - view</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TodoViewPresenterInterface</span>: <span class="title">ViewPresenterInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setLoadingIndicator</span><span class="params">(visible: Bool)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setWelcomeText</span><span class="params">(<span class="number">_</span> text: String)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;视图在某个时间点在 <code>presenter</code> 上调用 <code>ready（）</code> ，因此 <code>presenter</code> 可以开始。首先，它通过调用 <code>setLoadingIndicator（visible：true）</code> 告诉视图显示加载指示符，然后要求 <code>interactor</code> 异步加载start欢迎文本<code>(startLoadingWelcomeText（）)</code>。数据返回到 <code>interactor</code> 之后，它可以使用 <code>didLoadWelcomeText（“”）</code> 方法通知 <code>presenter</code> 。现在， <code>presenter</code> 可以使用相同的方法 <code>setLoadingIndicator（visible：false）</code> 和 <code>false</code> 参数告诉视图隐藏加载指示器，并使用<code>setWelcomeText（“”）</code> 显示欢迎文本。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个用例是有人点击视图上的按钮以关闭控制器。该视图在 <code>presenter</code> 上调用close（）， <code>presenter</code> 只需在 <code>router</code> 上调用 <code>dismiss（）</code> 。在要求 <code>router</code> 关闭视图控制器之前，演示者还可以做其他事情（例如清理一些资源）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我希望你能得到例子，自己动手做所有的事情，这是一个很好的练习任务。当然，你可以利用区块，承诺或全新的 <code>Combine框架</code> 使你的生活更轻松。例如，你可以在某些异步数据加载完成后自动通知演示者。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，既然你对现代 <code>VIPER架构</code> 有了基本的了解，就可以讨论如何用 <code>SwiftUI</code> 替换传统的 <code>ViewController</code> 子类。</p><br><h1 id="如何设计基于VIPER的SwiftUI应用程序？"><a href="#如何设计基于VIPER的SwiftUI应用程序？" class="headerlink" title="如何设计基于VIPER的SwiftUI应用程序？"></a><strong>如何设计基于VIPER的SwiftUI应用程序？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SwiftUI</code> 是相当独特的。 视图是结构，因此我们的通用 <code>VIPER协议</code> 需要进行一些更改才能使所有功能正常工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你要做的第一件事是摆脱 <code>ViewPresenterInterface</code> 协议。 接下来，你可以从 <code>PresenterInterface</code> 中删除 <code>view属性</code> ，因为我们将使用可观察的 <code>view-model模式</code> 来自动更新数据视图。 最后的修改是你必须从 <code>ModuleInterface</code> 扩展内的 <code>assemble函数</code> 的默认实现中删除 <code>view</code> 参数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我提到了一个视图模型，让我们做一个。 为了简单起见，我将使用 <code>Bool</code> 来指示是否出了问题，但是你可以使用其他视图，也可以使用独立的 <code>VIPER模块</code> 来显示 <code>提示消息</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Combine</span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoViewModel</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> objectWillChange = <span class="type">ObservableObjectPublisher</span>()</span><br><span class="line"></span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> error: <span class="type">Bool</span> = <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.objectWillChange.send()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> todos: [<span class="type">TodoEntity</span>] = [] &#123;</span><br><span class="line">       <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.objectWillChange.send()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此类符合 <code>ObservableObject</code> ，它使 <code>SwiftUI</code> 可以检查更新并在发生某些更改时重新呈现视图层次结构。 你只需要具有 <code>ObservableObjectPublisher</code> 类型的属性，并从字面上发送一条消息（如果发生某些更改会触发此消息，从而触发视图中的自动更新）。 🔥</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>TodoEntity</code> 只是一个基本结构，它遵循一堆协议，例如 <code>SwiftUI</code> 的新 <code>Identifiable</code> ，因为我们希望在列表中显示实体。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TodoEntity</span>: <span class="title">EntityInterface</span>, <span class="title">Codable</span>, <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> completed: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基本的 <code>SwiftUI</code> 视图仍将实现 <code>ViewInterface</code> ，并且将具有对 <code>presenter</code> 的引用。 我们的 <code>view-model属性</code> 还将在这里使用 <code>@ObservedObject</code> 属性包装器进行标记。 到目前为止的代码是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TodoView</span>: <span class="title">ViewInterface</span>, <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">TodoPresenterViewInterface!</span></span><br><span class="line"></span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">TodoViewModel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"SwiftUI ❤️ VIPER"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>presenter</code> 还将拥有一个弱的 <code>var viewModel：TodoViewModel！</code> 参考以能够更新视图模型。 好像我们通过使用视图模型在视图和 <code>presenter</code> 之间存在双向通信流。 在我看来很好。 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们想在视图层次结构中传递一些数据，我们还可以使用全新的 <code>@EnvironmentObject</code> 。 你只需在环境对象中实现与对视图模型相同的观察协议即可。 例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> Combine</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoEnvironment</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> objectWillChange = <span class="type">ObservableObjectPublisher</span>()</span><br><span class="line"></span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> title: <span class="type">String</span> = <span class="string">"Todo list"</span> &#123;</span><br><span class="line">       <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.objectWillChange.send()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，让我向你展示如何实现模块构建器，因为这非常棘手。 你必须使用新的通用 <code>UIHostingController</code> ，这是一个 <code>UIViewController</code> 子类，因此可以在完成模块构建后将其返回。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoModule</span>: <span class="title">ModuleInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">View</span> = <span class="type">TodoView</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Presenter</span> = <span class="type">TodoPresenter</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Router</span> = <span class="type">TodoRouter</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Interactor</span> = <span class="type">TodoInteractor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> presenter = <span class="type">Presenter</span>()</span><br><span class="line">        <span class="keyword">let</span> interactor = <span class="type">Interactor</span>()</span><br><span class="line">        <span class="keyword">let</span> router = <span class="type">Router</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> viewModel = <span class="type">TodoViewModel</span>()</span><br><span class="line">        <span class="keyword">let</span> view = <span class="type">View</span>(presenter: presenter, viewModel: viewModel)</span><br><span class="line">            .environmentObject(<span class="type">TodoEnvironment</span>())</span><br><span class="line">        presenter.viewModel = viewModel</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.assemble(presenter: presenter, router: router, interactor: interactor)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">UIHostingController</span>(rootView: view)</span><br><span class="line">        router.viewController = viewController</span><br><span class="line">        <span class="keyword">return</span> viewController</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从现在开始放在一起只是小菜一碟。 如果需要，你可以挑战自己构建东西，而无需下载 <a href="https://github.com/theswiftdev/tutorials/tree/master/iOS/VIPERAndSwiftUI" target="_blank" rel="noopener"><strong><code>最终项目</code></strong></a>。 🍰</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> SwiftUI </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> SwiftUI </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>掌握VIPER架构</title>
      <link href="/%E6%8E%8C%E6%8F%A1VIPER%E6%9E%B6%E6%9E%84/"/>
      <url>/%E6%8E%8C%E6%8F%A1VIPER%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>Swift</code> 使用一些 <code>面向协议</code> 的编程技术来掌握 <code>VIPER架构设计模式</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在写了关于 <a href="http://www.xuebaonline.com/%E9%80%82%E7%94%A8%E4%BA%8EiOS%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84VIPER%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"><strong><em><code>VIPER的最佳实践</code></em></strong></a> 之后，我对代码库进行了一些更改。 我已经想到了这些想法，但是却没有足够的时间正确地实施它们。 </p></br><h1 id="VIPER协议"><a href="#VIPER协议" class="headerlink" title="VIPER协议"></a><strong>VIPER协议</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我希望每个 <code>模块组件</code> 都有一个通用接口。 这就是为什么我为以下内容创建 <code>简单协议</code> 的原因：</p><ul><li><strong>View</strong></li><li><strong>Interactor</strong></li><li><strong>Presenter</strong></li><li><strong>Entity</strong></li><li><strong>Router</strong></li><li><strong>Module</strong></li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，通过这种方式，我的 <code>路由器对象</code> 正在实现 <code>路由器协议</code> ，因此，如果在其上进行扩展，则每一个都将具有该特定功能。 这是一个很小但非常令人愉快的功能，使我的模块比以前更强大。 老实说，我从一开始就应该拥有这种功能，但是无论如何从现在开始就应该是这样。 😬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此举意味着将我的 <code>VIPER协议</code> 组织到一个自定义框架中，因此我使用这些组件创建了一个。 你可以在 <a href="https://github.com/CoreKit/VIPER" target="_blank" rel="noopener"><strong><em><code>github</code></em></strong></a> 上找到它，这是一个非常基本的应用程序，可以随时使用，只需在项目中导入 <code>VIPER</code> 。</p><br><h1 id="模块协议"><a href="#模块协议" class="headerlink" title="模块协议"></a><strong>模块协议</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自从我使用 <code>VIPER</code> 以来，它非常渴望实现一个自定义模块，以在 <code>iOS</code> 上呈现系统默认警报消息。 你知道 <code>UIAlertController</code> 是我正在谈论的那个。 </p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们为什么不为路由器创建协议，以便可以在其他所有路由器上实现该协议，也可以简单地在它们上调用 <code>show（alert :)</code> ？</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我喜欢这种方法，因此我们已经建立了它。 原来，它真是太棒了。 因此，我们为模块路由器引入了新协议，实现了默认协议扩展，并且路由器现在能够显示错误消息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，你也可以将相同的模式用于许多其他（相似）的事物。 基本实现如下所示，希望你能理解。 💡</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VIPER</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlertModule</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AlertModuleRouter</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(alert: AlertEntity)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AlertModuleRouter</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">Router</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(alert: AlertEntity)</span></span> &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - other module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyModuleRouter</span>: <span class="title">Router</span>, <span class="title">AlertModuleRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// show(alert:) is now available from this router too</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，该技术也可以用于其他 <code>VIPER组件</code> ，实现起来非常容易，并且 <code>面向协议</code> 的方法为我们带来了巨大的方便。 🏆</p></br><h1 id="Presenter-to-presenter-interactions"><a href="#Presenter-to-presenter-interactions" class="headerlink" title="Presenter to presenter interactions"></a><strong>Presenter to presenter interactions</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我也对参与模块通信流程中的委托实现的位置改变了想法。 在上一篇文章中，我告诉你我将委托存储在路由器上，但是后来我意识到委托主要与业务逻辑有关，因此我只是将它们移到了 <code>presenter层</code> 。 🤷‍♂️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VIPER</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AModulePresenterDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didDoSomething</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AModule</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(with delegate: AModulePresenterDelegate? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="comment">// insert classic viper stuff here</span></span><br><span class="line"></span><br><span class="line">        presenter.delegate = delegate</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AModulePresenter</span>: <span class="title">Presenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">someAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate?.didDoSomething()</span><br><span class="line">        <span class="keyword">self</span>.router?.dismiss()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - other module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BModulePresenter</span>: <span class="title">Presenter</span>, <span class="title">AModulePresenterDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didDoSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello from module A!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，你可以跳过整个路由器层，并且所有与业务相关的逻辑都将在 <code>presenter层</code> 中实现，这应该是唯一的方法。 🤪</p></br><h1 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a><strong>Entities</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了服务层之外，有时使用带有一些额外的元数据的实体包装对于模型对象是非常有用的。 这就是为什么我也创建了一个实体协议，并开始在我的模块中使用它的原因。 例如，可以打开链接的 <code>Web视图模块</code> 可以具有带有标题和内容 <code>url</code> 属性的 <code>WebViewEntity</code> 。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VIPER</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlertEntity</span>: <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的示例 <code>提示信息模块</code> 可以将 <code>AlertEntity</code> 与某些属性一起使用，这些属性可以定义标题，消息或按钮。 这样，你就不必真正考虑将这些对象放在哪里，因为它们是真正的 <code>VIPER实体</code> 。</p></br><h1 id="IO协议"><a href="#IO协议" class="headerlink" title="IO协议"></a><strong>IO协议</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我想尝试的想法，但是基本概念有点像我想为 <code>VIPER模块</code> 层分离输入和输出协议。 同样，这种 IO 差异也可以反映在服务层上（也许将来服务层中的整个对象“ mess”将用作IO实体），一团糟，我的意思是，其中可能存在太多对象 服务/对象目录，因此这意味着它们也可以按模块（也称为实体）进行分组。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，我正在考虑像 <code>RequestEntity</code> ， <code>ResponseEntity</code> 这样的服务通信，对于 <code>VIPER层</code> 通信，我可以想象两个单独的协议，例如。  <code>PresenterInput</code> ， <code>PresenterOutput</code> 。 我们将看到，但是乍一看，这似乎是一件过度设计的事情。</p><br><h1 id="VIPER与"><a href="#VIPER与" class="headerlink" title="VIPER与[*]"></a><strong>VIPER与[*]</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有！请不要认为x优于y。架构和设计模式是简单的工具，可用于使你的生活更轻松。如果你不喜欢x，则应尝试y，但不要怪x，因为那是你的个人看法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我目前最喜欢的架构是 <code>VIPER</code> ，那又如何呢？也许在一两年之内，我会爱上反应式编程而发疯。真的重要吗？我不这么认为。过去，我已经学习并尝试了很多东西，甚至不记得了。 🧠</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适用于iOS开发人员的VIPER最佳实践</title>
      <link href="/%E9%80%82%E7%94%A8%E4%BA%8EiOS%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84VIPER%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/%E9%80%82%E7%94%A8%E4%BA%8EiOS%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84VIPER%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本教程中，我将向你展示有关如何构建完全基于 <code>Swift</code> 的基于 <code>VIPER</code> 的 <code>iOS</code> 应用程序的完整指南。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章有点过时了，请期待很快会有新版本…</p></blockquote></br><h1 id="VIPER入门"><a href="#VIPER入门" class="headerlink" title="VIPER入门"></a><strong>VIPER入门</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，你应该阅读 <a href="http://www.xuebaonline.com/iOS%20VIPER%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"><strong><em><code>关于VIPER架构本身的文章（理论上更深入）</code></em></strong></a>。 这是一个相当不错的文章，解释了所有 <code>VIPER组件</code> 和 <code>内存管理</code> 。  ⭐️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，那篇文章的问题在于，我还没有向你展示真正的技术细节。 用于实现 <code>VIPER</code> 的 <code>Swift</code> 代码。 在使用该体系结构进行了整整一年的项目之后，现在我终于可以与你分享我所有的最佳实践。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们开始创建一个全新的 <code>Xcode</code> 项目，使用单视图应用程序模板，将该项目命名（  <code>VIPER最佳实践</code> ），使用 <code>Swift</code> ，现在你准备好进行下一步，以制作出色的 <code>“企业级” iOS 应用</code> 。</p><a id="more"></a></br><h1 id="生成VIPER模块"><a href="#生成VIPER模块" class="headerlink" title="生成VIPER模块"></a><strong>生成VIPER模块</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;永远不要手动创建模块，始终使用代码生成器，因为这是一项重复性的任务，这很无聊，而且你应该专注于比制作样板代码更重要的事情。 你可以使用轻量级模块生成器：</p><p><a href="https://github.com/binarybirds/swift-template" target="_blank" rel="noopener"><strong><em><code>VIPERA</code></em></strong></a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需从 <code>github</code> 下载或克隆存储库即可。你可以通过运行<code>swift run install --with-templates</code> 安装二进制工具。这会将 <code>vipera</code> 应用程序安装在 <code>/usr/local/bin/</code> 下，并将基本模板安装在 <code>〜/.vipera</code> 目录下。你也可以使用自己的模板，但是现在我将使用默认模板。 🔨</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我通常从名为 <code>Main</code> 的模块开始，这是应用程序的根视图。你可以通过在项目目录中调用 <code>vipera Main</code> 来生成它，因此生成器可以为模板文件中的标题注释使用正确的项目名称。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过应用我的 <code>Xcode</code> 约定来稍微整理项目结构，这意味着资源将转到 <code>Assets文件夹</code> ，所有 <code>Swift</code> 文件都将移至 <code>Sources</code> 目录。如今，我还更改了 <code>AppDelegate.swift</code>文件，并为 <code>UIApplicationDelegate</code> 协议进行了单独的扩展。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Sources</code> 目录下创建一个 <code>Modules组</code> （也有一个物理文件夹），并将新生成的 <code>Main模块</code> 移到该组下。现在，通过从 <code>Assets文件夹</code> 中为当前目标选择 <code>Info.plist</code> 文件来解决项目问题。还要删除 <code>Main Interface</code> ，然后你可以安全地删除 <code>Main.storyboard</code> 和 <code>ViewController.swift</code> 文件，因为我们根本不需要它们。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>AppDelegate.swift</code> 文件中，你必须将 <code>Main模块</code> 的视图控制器设置为根视图控制器，因此它看起来应该像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDelegate</span>: <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication,</span></span></span><br><span class="line"><span class="function"><span class="params">                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class="keyword">Any</span>]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.window = <span class="type">UIWindow</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line">        <span class="keyword">self</span>.window?.rootViewController = <span class="type">MainModule</span>().buildDefault()</span><br><span class="line">        <span class="keyword">self</span>.window?.makeKeyAndVisible()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恭喜，你已经创建了第一个 <code>VIPER模块</code> ！ 🎉</p></br><h1 id="UITabBarController-amp-VIPER"><a href="#UITabBarController-amp-VIPER" class="headerlink" title="UITabBarController &amp; VIPER"></a><strong>UITabBarController &amp; VIPER</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于在 <code>VIPER模块</code> 中使用 <code>UITabBarController</code> ，我有一个非常简单的解决方案。首先，让我们生成一些新模块，这些模块将成为 <code>Tabs</code> 。我将使用 <code>JSONPlaceholder服务</code> ，所以让我们为每个资源设想一个单独的选项卡：帖子，相册，照片，待办事项（具有相同的模块名称）。全部生成它们，然后将其移动到 <code>modules文件夹</code> 中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们再生成一个称为 <code>Home的模块</code> 。这将实现我们的 <code>UITabBarController</code> 。如果你愿意，可以将 <code>Main模块</code> 用于此目的，但我想保留该动画的目的，以便在加载屏幕和 <code>Home模块</code> 之间进行巧妙的转换（这完全取决于你的需求）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，我们要实现的主要逻辑是：主视图将通知 <code>presenter</code> 有关 <code>viewDidAppear</code> 事件的信息， <code>presenter</code> 将要求 <code>router</code> 显示 <code>Home模块</code> 。  <code>Home模块</code>  的视图将是 <code>UITabBarController</code> 的子类，它还将通知其 <code>presenter</code> 有关 <code>viewDidLoad</code> 的信息，并且 <code>presenter</code> 将使用其 <code>router</code> 请求适当的 <code>tabs</code> 。</p><p>这是没有接口的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainDefaultView</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">MainPresenter?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presenter?.viewDidAppear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainDefaultPresenter</span>: <span class="title">MainPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.router?.showHome()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainDefaultRouter</span>: <span class="title">MainRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showHome</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">HomeModule</span>().buildDefault()</span><br><span class="line">        <span class="keyword">self</span>.viewController?.present(viewController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HomeDefaultView</span>: <span class="title">HomeView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(<span class="number">_</span> viewControllers: [UIViewController])</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.viewControllers = viewControllers</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - Home module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HomeDefaultPresenter</span>: <span class="title">HomePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setupViewControllers</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> controllers = <span class="keyword">self</span>.router?.getViewControllers() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.view?.display(controllers)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HomeDefaultRouter</span>: <span class="title">HomeRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getViewControllers</span><span class="params">()</span></span> -&gt; [<span class="type">UIViewController</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="type">PostsModule</span>().buildDefault(),</span><br><span class="line">            <span class="type">AlbumsModule</span>().buildDefault(),</span><br><span class="line">            <span class="type">PhotosModule</span>().buildDefault(),</span><br><span class="line">            <span class="type">TodosModule</span>().buildDefault(),</span><br><span class="line">        ].<span class="built_in">map</span> &#123; <span class="type">UINavigationController</span>(rootViewController: $<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildDefault</span><span class="params">()</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        presenter.setupViewControllers()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“主页”模块构建器函数内部还有另外一行可触发 <code>presenter</code> 设置正确的视图控制器。 那只是因为在初始化过程完成之前调用了 <code>UITabBarController</code>   <code>viewDidLoad</code> 方法。 这种行为是完全没有加载的，但是我认为这是为了保持对视图引用。 😊</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，现在你在项目中有一个适当的选项卡栏，已集成为 <code>VIPER模块</code> 。 现在是时候从服务器中获取一些数据了，这是另一个重要的教训：不是所有的东西都是 <code>VIPER模块</code> 。</p></br><h1 id="Services-amp-Entities"><a href="#Services-amp-Entities" class="headerlink" title="Services &amp; Entities"></a><strong>Services &amp; Entities</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会注意到，我的模块中没有实体。 我通常将 <code>API</code> ， <code>CoreData</code> 和 <code>许多其他数据</code> 提供程序包装为服务。 这样，所有相关实体都可以被抽象化，因此可以轻松地替换服务（例如，使用模拟），并且我所有的 <code>interactors</code> 都可以通过协议定义使用该服务，而无需了解底层实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一件事是，如果我不得不处理异步代码，我总是使用 <a href="https://github.com/corekit/promises" target="_blank" rel="noopener"><strong><em><code>promise</code></em></strong></a> 库。 其背后的原因很简单：与使用回调和可选的结果元素相比，它更优雅。 你也应该学习 <code>promise</code> 。 因此，这是我围绕 <code>JSONPlaceholder API</code> 实现服务的一部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">posts</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Post</span>]&gt;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">comments</span><span class="params">(<span class="keyword">for</span> post: Post)</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Comment</span>]&gt;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">albums</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Album</span>]&gt;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">photos</span><span class="params">(<span class="keyword">for</span> album: Album)</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Photo</span>]&gt;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">todos</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Todo</span>]&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - entities</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> body: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - API implementation</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONPlaceholderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> baseUrl = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/"</span>)!</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Error</span>: <span class="title">LocalizedError</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> invalidStatusCode</span><br><span class="line">        <span class="keyword">case</span> emptyData</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">request</span>&lt;T&gt;<span class="params">(path: String)</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt; <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Decodable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> promise = <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">        <span class="keyword">let</span> url = baseUrl.appendingPathComponent(path)</span><br><span class="line">        <span class="built_in">print</span>(url)</span><br><span class="line">        <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">                promise.reject(error)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>, httpResponse.statusCode == <span class="number">200</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.reject(<span class="type">Error</span>.invalidStatusCode)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.reject(<span class="type">Error</span>.emptyData)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> model = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">T</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">                promise.fulfill(model)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> &#123;</span><br><span class="line">                promise.reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.resume()</span><br><span class="line">        <span class="keyword">return</span> promise</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">JSONPlaceholderService</span>: <span class="title">Api</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">posts</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Post</span>]&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.request(path: <span class="string">"posts"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，我在这里有一个模拟服务实现，因此我可以轻松地测试所需的一切。 如何在这些服务之间切换？ 好吧，我有一个共享的（单人-不要讨厌我，这是完全可以的）应用程序类，我主要将其用于样式设计，但我也将与依赖项注入 <code>（DI）</code> 相关的代码放在了那里。 这样，我可以为 <code>VIPER模块</code> 传递适当的服务对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">App</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> apiService: <span class="type">Api</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">JSONPlaceholderService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostsModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildDefault</span><span class="params">()</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="type">PostsDefaultView</span>()</span><br><span class="line">        <span class="keyword">let</span> interactor = <span class="type">PostsDefaultInteractor</span>(apiService: <span class="type">App</span>.shared.apiService)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - interactor</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostsDefaultInteractor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> presenter: <span class="type">PostsPresenter?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> apiService: <span class="type">Api</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(apiService: <span class="type">Api</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.apiService = apiService</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostsDefaultInteractor</span>: <span class="title">PostsInteractor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">posts</span><span class="params">()</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">Post</span>]&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.apiService.posts()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用其他100种方法来执行此操作，但是我目前更喜欢这种方法。 通过这种方式， <code>interactors</code> 可以直接使用一些额外的细节来调用服务，例如过滤器，订单，排序等。基本上，该服务只是端点周围的高级概念包装，并且 <code>interactors</code> 为该接口创建经过微调（更好）的 <code>API</code> 给 <code>presenter</code> 。</p></br><h1 id="promises"><a href="#promises" class="headerlink" title="promises"></a><strong>promises</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实施业务逻辑是 <code>presenter</code> 的任务。 我总是使用 <code>Promise</code> ，因此基本的 <code>Presenter</code> 实现只能异步加载一些内容并显示结果，否则错误（加上加载指示符）只有几行。 我一直在尝试通过在视图上使用相同的协议命名约定来实现三个基本的 <code>UI堆栈元素</code> （加载，数据，错误）。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在视图方面，我使用的是很好的旧的集合视图逻辑，这大大减少了我必须编写的代码量。 你可以采用传统方式，毕竟为表或集合视图实现一些数据源和委托方法并不是很多代码。 这是我的视图示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostsDefaultPresenter</span>: <span class="title">PostsPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view?.displayLoading()</span><br><span class="line">        <span class="keyword">self</span>.interactor?.posts()</span><br><span class="line">        .onSuccess(queue: .main) &#123; posts  <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.view?.display(posts)</span><br><span class="line">        &#125;</span><br><span class="line">        .onFailure(queue: .main) &#123; error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.view?.display(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - view</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostsDefaultView</span>: <span class="title">CollectionViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">PostsPresenter?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.title = <span class="string">"Posts"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presenter?.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostsDefaultView</span>: <span class="title">PostsView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">displayLoading</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"loading..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(<span class="number">_</span> posts: [Post])</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> grid = <span class="type">Grid</span>(columns: <span class="number">1</span>, margin: <span class="type">UIEdgeInsets</span>(all: <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.source = <span class="type">CollectionViewSource</span>(grid: grid, sections: [</span><br><span class="line">            <span class="type">CollectionViewSection</span>(items: posts.<span class="built_in">map</span> &#123; <span class="type">PostViewModel</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(<span class="number">_</span> error: Error)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>cell</code> 和 <code>ViewModel</code> 在 <code>VIPER模块</code> 之外，我倾向于将 <code>App文件夹</code> 专用于自定义应用程序特定的视图， <code>extensions</code> ， <code>view models</code> 等。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostCell</span>: <span class="title">CollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostViewModel</span>: <span class="title">CollectionViewViewModel</span>&lt;<span class="title">PostCell</span>, <span class="title">Post</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">config</span><span class="params">(cell: PostCell, data: Post, indexPath: IndexPath, grid: Grid)</span></span> &#123;</span><br><span class="line">        cell.textLabel.text = data.title</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">(data: Post, indexPath: IndexPath, grid: Grid, view: UIView)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> width = grid.width(<span class="keyword">for</span>: view, items: grid.columns)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: width, height: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没什么特别的，如果你想了解更多有关此集合视图架构的信息，可以看看这篇文章 <a href="http://www.xuebaonline.com/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><strong><em><code>掌握集合视图的教程</code></em></strong></a> 。</p><br><h1 id="模块通讯"><a href="#模块通讯" class="headerlink" title="模块通讯"></a><strong>模块通讯</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个重要的教训是学习如何在两个 <code>VIPER模块</code> 之间进行通信。 通常，我使用简单的变量-如果必须将信息发送回原始模块，则使用 <code>delegates</code> -在构建方法中传递。 我还将向你展示一个非常简单的示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostsDefaultRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> presenter: <span class="type">PostsPresenter?</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> viewController: <span class="type">UIViewController?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostsDefaultRouter</span>: <span class="title">PostsRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showComments</span><span class="params">(<span class="keyword">for</span> post: Post)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">PostDetailsModule</span>().buildDefault(with: post, delegate: <span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">self</span>.viewController?.show(viewController, sender: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostsDefaultRouter</span>: <span class="title">PostDetailsModuleDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toggleBookmark</span><span class="params">(<span class="keyword">for</span> post: Post)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.presenter?.toggleBookmark(<span class="keyword">for</span>: post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - details</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PostDetailsModuleDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toggleBookmark</span><span class="params">(<span class="keyword">for</span> post: Post)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostDetailsModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildDefault</span><span class="params">(with post: Post, delegate: PostDetailsModuleDelegate? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="type">PostDetailsDefaultView</span>()</span><br><span class="line">        <span class="keyword">let</span> interactor = <span class="type">PostDetailsDefaultInteractor</span>(apiService: <span class="type">App</span>.shared.apiService,</span><br><span class="line">                                                      bookmarkService: <span class="type">App</span>.shared.bookmarkService)</span><br><span class="line">        <span class="keyword">let</span> presenter = <span class="type">PostDetailsDefaultPresenter</span>(post: post)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostDetailsDefaultRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> presenter: <span class="type">PostDetailsPresenter?</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> viewController: <span class="type">UIViewController?</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">PostDetailsModuleDelegate?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostDetailsDefaultRouter</span>: <span class="title">PostDetailsRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toggleBookmark</span><span class="params">(<span class="keyword">for</span> post: Post)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate?.toggleBookmark(<span class="keyword">for</span>: post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostDetailsDefaultPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> router: <span class="type">PostDetailsRouter?</span></span><br><span class="line">    <span class="keyword">var</span> interactor: <span class="type">PostDetailsInteractor?</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">PostDetailsView?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> post: <span class="type">Post</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(post: <span class="type">Post</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.post = post</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PostDetailsDefaultPresenter</span>: <span class="title">PostDetailsPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reload</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view?.setup(with: <span class="keyword">self</span>.interactor!.bookmark(<span class="keyword">for</span>: <span class="keyword">self</span>.post))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//display loading...</span></span><br><span class="line">        <span class="keyword">self</span>.interactor?.comments(<span class="keyword">for</span>: <span class="keyword">self</span>.post)</span><br><span class="line">        .onSuccess(queue: .main) &#123; comments <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.view?.display(comments)</span><br><span class="line">        &#125;</span><br><span class="line">        .onFailure(queue: .main) &#123; error <span class="keyword">in</span></span><br><span class="line">            <span class="comment">//display error...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toggleBookmark</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.router?.toggleBookmark(<span class="keyword">for</span>: <span class="keyword">self</span>.post)</span><br><span class="line">        <span class="keyword">self</span>.view?.setup(with: <span class="keyword">self</span>.interactor!.bookmark(<span class="keyword">for</span>: <span class="keyword">self</span>.post))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>builder</code> 方法中，我可以访问 <code>VIPER模块</code> 的每个组件，因此我可以将变量简单地传递到指定的位置（对于 <code>delegates</code> 参数也是如此）。 我通常在 <code>presenter</code> 上设置输入变量，在 <code>router</code> 上设置 <code>delegates</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常是 <code>presenter</code> 需要原始模块中的数据，我喜欢将 <code>delegates</code> 存储在 <code>router</code> 上，因为如果导航模式发生更改，我根本就不需要更改 <code>presenter</code> 。 这只是个人喜好，但我喜欢代码中的风格。 在一篇文章中很难写下这些东西，所以我建议从 <a href="https://github.com/theswiftdev/tutorials" target="_blank" rel="noopener"><strong><em><code>github</code></em></strong></a> 下载完成的示例代码。</p><br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，在此 <code>VIPER体系结构</code> 教程中，我正在使用各种设计模式。 有人说这没有灵丹妙药，但我相信我发现了一种非常了不起的方法，可以利用我的优势在短时间内构建高质量的应用程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 <code>VIPVM架构</code> 与 <code>MVVM</code> 与 <code>Promises</code> 结合在一起，可以将每个零件放在正确的位置。 工程过度？ 也许。 对我来说，这是值得的开销。 你怎么看待这件事？ </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VIPER体系结构：我们的最佳实践，像老板一样构建应用程序</title>
      <link href="/VIPER%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E5%83%8F%E8%80%81%E6%9D%BF%E4%B8%80%E6%A0%B7%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/VIPER%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E5%83%8F%E8%80%81%E6%9D%BF%E4%B8%80%E6%A0%B7%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Cheesecake Labs</code> 的开发团队使用 <code>VIPER</code> 进行 <code>iOS</code> 和 <code>Android</code> 移动应用程序开发已有一年多了，我们喜欢这种简洁的架构！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文使用 <code>VIPER</code> 样板中的代码示例总结了关于 <code>VIPER</code> 架构的最佳实践。 这里使用的代码示例在 <code>Swift</code> 中，但是提到的所有概念都可以应用于使用 <code>Java</code> 或 <code>Kotlin</code> 用 <code>VIPER</code> 开发的 <code>Android</code> 项目。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你仍然需要熟悉基本的 <code>VIPER</code> 概念以及该体系结构如何使你的代码更具组织性和可伸缩性，建议你阅读以下文章：</p><ul><li><a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52" target="_blank" rel="noopener"><strong><em><code>最常见的移动应用程序设计模式之间的比较</code></em></strong></a></li><li><a href="https://www.ckl.io/blog/ios-project-architecture-using-viper" target="_blank" rel="noopener"><strong><em><code>在iOS上使用VIPER的第一步的绝佳指南</code></em></strong></a></li><li><a href="https://cheesecakelabs.com/blog/using-viper-architecture-android/" target="_blank" rel="noopener"><strong><em><code>适用于Android的VIPER架构上的独特内容</code></em></strong></a></li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，你准备好学习有关如何使用 <code>VIPER</code> 构建应用程序的最佳实践吗？</p></br><h1 id="真正的VIPER模块解耦的项目结构"><a href="#真正的VIPER模块解耦的项目结构" class="headerlink" title="真正的VIPER模块解耦的项目结构"></a><strong>真正的VIPER模块解耦的项目结构</strong></h1><p><img src="http://q8wtfza4q.bkt.clouddn.com/va-stp1.png" alt="真正的VIPER模块解耦的项目结构" title="VIPER的iOS文件夹结构"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你会看到，我们将所有 <code>VIPER</code> 的模块保持尽可能的分离，从而使我们免于在项目扩展或规格更改时遇到的麻烦。 如果删除其中任何一个，则仅在引用该模型的路由器上会出现一些错误，而在 <code>Views</code> , <code>Presenters</code>, <code>Interactors</code>,<code>Data Managers</code> , <code>Entity</code> 上则不会。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;帮助你真正分离模块的一个关键点是将所有实体保留在单独的文件夹中，将它们链接到项目本身而不是任何特定模块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，使用数据管理器执行 <code>API</code> 请求和操作本地数据库是增加项目组织的一种极好的方法，但需要注意以下几点：</p><ul><li>将数据管理器保留在 <code>Utils</code> 文件夹中，将其与模块分开；</li><li>将类似实体（例如用户，个人档案和公司档案）的方法分组到一个 <code>Data Manager</code> 中，以避免为每个实体创建一个 <code>Data Manager</code> 的开销；</li><li>将每个 <code>Data Manager</code> 分为 <code>Local</code> 和 <code>API</code> 类，以使 <code>Interactors</code> 上的代码更具可读性：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainSearchInteractor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Properties</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">MainSearchInteractorOutput?</span></span><br><span class="line">    <span class="keyword">var</span> apiDataManager = <span class="type">ProfileApiDataManager</span>()</span><br><span class="line">    <span class="keyword">var</span> localDataManager = <span class="type">ProfileLocalDataManager</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainSearchInteractor</span>: <span class="title">MainSearchUseCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Code below show how interactor get data from API and then saves it on local DB with separate data managers</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">searchProducts</span><span class="params">(with searchTerm: String, onPage page: Int)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.apiDataManager.searchProducts(with: searchTerm, forPage: page) &#123; (products) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> products = products &#123;</span><br><span class="line">                <span class="keyword">self</span>.localDataManager.updateSearchResultFavorites(products) &#123; (products) <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">self</span>.output?.onFetchProductsSuccess(<span class="type">Array</span>(products), shouldAppend: page != <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.output?.onFetchProductsSuccess(<span class="literal">nil</span>, shouldAppend: page != <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="生成VIPER的文件"><a href="#生成VIPER的文件" class="headerlink" title="生成VIPER的文件"></a><strong>生成VIPER的文件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你已经使用 <code>VIPER</code> 进行过开发，那么你将无法创建一个简单的屏幕（在导航栏上具有三个标签）所需的所有 <code>20+</code> 个 <code>Swift</code> 文件。 但是，隧道尽头有一个亮点：这个令人惊叹的 <code>Xcode插件</code> ，只需单击三下，即可自动为一个模块生成所有 <code>VIPER</code> 文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你认为太多，请使用 <a href="https://github.com/strongself/Generamba" target="_blank" rel="noopener"><strong><em><code>Generamba</code></em></strong></a> ： <code>Generamba</code> ：一种代码生成器，旨在从终端创建 <code>VIPER</code> 模块，非常容易为其他任何类定制。</p></br><h1 id="用协议定义-contracts"><a href="#用协议定义-contracts" class="headerlink" title="用协议定义 contracts"></a><strong>用协议定义 contracts</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像对我们人类一样，<code>VIPER contracts</code> 是两方（模块组件）之间关于协议所产生的权利（方法）和义务（论据）的自愿协议。 在 <code>Cheesecake Labs</code> ，我们使用协议定义模块组件可以从同一模块上的其他组件调用的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，例如，在开始为新的 <code>View</code> 或 <code>Presenter</code> 编写代码之前，请考虑两个组件之间的信息流，并首先在 <code>Contract</code> 上声明其方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainSearchContract.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchView</span>: <span class="title">BaseView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showCustomError</span><span class="params">(<span class="number">_</span> message: String?)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateVisibility</span><span class="params">(onSearchController willBeActive: Bool)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showSearchResult</span><span class="params">(<span class="number">_</span> products: [Product]?, shouldAppend: Bool)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchPresentation</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onViewDidLoad</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onWillPresentSearchController</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onSearchTermChanged</span><span class="params">(to searchTerm: String)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductFavoriteChanged</span><span class="params">(<span class="number">_</span> product: Product, to isFavorite: Bool)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductSelected</span><span class="params">(<span class="number">_</span> product: Product)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onInfiniteScrollTriggered</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchUseCase</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">searchProducts</span><span class="params">(with searchTerm: String, onPage page: Int)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateProductFavorited</span><span class="params">(<span class="number">_</span> product: Product, to newValue: Bool)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchInteractorOutput</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onFetchProductsSuccess</span><span class="params">(<span class="number">_</span> products: [Product]?, shouldAppend: Bool)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onFetchProductsFailure</span><span class="params">(message: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MainSearchWireframe</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showProductScreen</span><span class="params">(delegate: ProductScreenDelegate, product: Product?)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面提到的 <code>Xcode插件</code> 还将创建具有所有协议的 <code>ModuleNameContract.swift</code> 文件，等待你声明必要的方法。 一旦定义了这些协议，就可以完全控制 <code>VIPER</code> 模块各组件之间的信息流。</p></br><h1 id="在路由器上自动进行模块初始化"><a href="#在路由器上自动进行模块初始化" class="headerlink" title="在路由器上自动进行模块初始化"></a><strong>在路由器上自动进行模块初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在显示 <code>VIPER</code> 模块的视图之前，你需要确保所有组件均已正确初始化。 我可以想到至少三种非常不同的方法，但是下面的流程是我们想出的最佳选择。 这里的王牌是每个路由器上都有一个静态函数，用于初始化自己的模块以及一些 <code>UIViewController</code> 和 <code>UIStoryboard</code> 扩展。 然后，如果 <code>模块A</code> 要提供 <code>模块B</code> ：</p><ul><li><code>模块A</code> 的路由器将调用 <code>模块B</code> 的静态函数来初始化其所有组件，并返回一个视图。</li><li><code>模块A</code> 的路由器显示 <code>模块B</code> 的视图。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就如此容易。 在自己的路由器上拥有模块初始化代码将消除大量的代码重复，特别是对于大型项目。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你需要一次创建这些扩展：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReusableView.swift</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ReusableView</span>: <span class="title">class</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ReusableView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> reuseIdentifier: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UIViewController.swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span>: <span class="title">ReusableView</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">// UIStoryboard.swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIStoryboard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">instantiateViewController</span><span class="params">()</span></span> -&gt; <span class="type">T</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">ReusableView</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiateViewController(withIdentifier: <span class="type">T</span>.reuseIdentifier) <span class="keyword">as</span>! <span class="type">T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，在每个 <code>VIPER模块</code> 的 <code>路由器</code> 上保留初始化代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainSearchRouter.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainSearchRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: Properties</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">UIViewController?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: Static methods</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setupModule</span><span class="params">()</span></span> -&gt; <span class="type">MainSearchViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">UIStoryboard</span>(name: <span class="type">MainSearchViewController</span>.storyboardName, bundle: <span class="literal">nil</span>).instantiateViewController() <span class="keyword">as</span> <span class="type">MainSearchViewController</span></span><br><span class="line">        <span class="keyword">let</span> presenter = <span class="type">MainSearchPresenter</span>()</span><br><span class="line">        <span class="keyword">let</span> router = <span class="type">MainSearchRouter</span>()</span><br><span class="line">        <span class="keyword">let</span> interactor = <span class="type">MainSearchInteractor</span>()</span><br><span class="line"></span><br><span class="line">        viewController.presenter =  presenter</span><br><span class="line"></span><br><span class="line">        presenter.view = viewController</span><br><span class="line">        presenter.router = router</span><br><span class="line">        presenter.interactor = interactor</span><br><span class="line"></span><br><span class="line">        router.view = viewController</span><br><span class="line"></span><br><span class="line">        interactor.output = presenter</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> viewController</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看来似乎有很多步骤，但有个好消息：前述插件对我们也能实现自动化！ 🙂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果要将 <code>UITabBarController</code> 或 <code>UIPageViewController</code> 装入 <code>VIPER</code> 架构，则需要采取一些其他步骤。 如果你需要任何帮助，请在此信息上发表评论，我会为你准备一个特定的 <code>Gist</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;亲爱的读者，如果你到目前为止已经提出了建议，那么你确实渴望获得知识。 因此，我将为你提供3条建议，以确保你完全了解路由器的职责：</p><ul><li>如果你需要在用户单击按钮时打开 <code>URL</code> ，请在路由器上调用 <code>UIApplication.shared.openURL（url）</code> ，因为你正在导航（即路由）到当前模块之外；</li><li>社交媒体共享也使用相同的概念：从 <code>Router</code> 调用 <code>UIActivityViewController</code> ，因为 <code>iOS</code> 会将用户从当前模块发送到 <code>View</code> 或 <code>app</code> ；</li><li>如果你仅要调用操作表来获得用户输入，那就是添加到当前模块中的UI组件。 因此，你可以从 <code>View</code> 中调用它，并从 <code>UIAlertController</code> 享受直接的回调。</li></ul></br><h1 id="使用-delegates-在-VIPER-模块之间发送数据"><a href="#使用-delegates-在-VIPER-模块之间发送数据" class="headerlink" title="使用 delegates 在 VIPER 模块之间发送数据"></a><strong>使用 delegates 在 VIPER 模块之间发送数据</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能已经遇到了这样的情况： <code>模块A</code> 上的一个字段填充有 <code>模块B</code> 的所选项目。因此，当用户单击该字段时， <code>模块A</code> 调用 <code>模块B</code> ，而 <code>模块B</code> 通过以下方式将所选项目返回给现有的 <code>模块A</code> ： <code>delegates</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代表们是在 <code>VIPER</code> 模块之间来回发送信息的绝佳方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Declare which messages can be sent to the delegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ProductScreenDelegate.swift</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ProductScreenDelegate</span> </span>&#123;</span><br><span class="line"><span class="comment">//Add arguments if you need to send some information</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductScreenDismissed</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductSelected</span><span class="params">(<span class="number">_</span> product: Product?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Call the delegate when you need to send him a message</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ProductPresenter.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: Properties</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">ProductView?</span></span><br><span class="line">    <span class="keyword">var</span> router: <span class="type">ProductWireframe?</span></span><br><span class="line">    <span class="keyword">var</span> interactor: <span class="type">ProductUseCase?</span></span><br><span class="line">    <span class="keyword">var</span> delegate: <span class="type">ProductScreenDelegate?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductPresenter</span>: <span class="title">ProductPresentation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//View tells Presenter that view disappeared</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onViewDidDisappear</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Presenter tells its delegate that the screen was dismissed</span></span><br><span class="line">        delegate?.onProductScreenDismissed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Implement the delegate protocol to do something when you receive the message</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ScannerPresenter.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScannerPresenter</span>: <span class="title">ProductScreenDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Presenter receives the message from the sender</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onProductScreenDismissed</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Presenter tells view what to do once product screen was dismissed</span></span><br><span class="line">        view?.startScanning()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Link the delegate from the Product presenter in order to proper initialize it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File ScannerRouter.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductRouter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setupModule</span><span class="params">(delegate: ProductScreenDelegate?)</span></span> -&gt; <span class="type">ProductViewController</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">let</span> presenter = <span class="type">ScannerPresenter</span>()</span><br><span class="line"></span><br><span class="line">        presenter.view = view</span><br><span class="line">        presenter.interactor = interactor</span><br><span class="line">        presenter.router = router</span><br><span class="line">        presenter.delegate = delegate <span class="comment">// Add this line to link the delegate</span></span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="避免使用-dictionaries-在VIPER组件之间传递数据"><a href="#避免使用-dictionaries-在VIPER组件之间传递数据" class="headerlink" title="避免使用 dictionaries 在VIPER组件之间传递数据"></a><strong>避免使用 dictionaries 在VIPER组件之间传递数据</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想 <code>100％</code> 兼容 <code>VIPER架构</code> ，最好使用 <code>POSO（普通老式Swift对象）</code> 在 <code>VIPER</code> 的组件之间发送信息。 但是在 <code>VIPER组件</code> 之间发送实体本身可以很好地工作，并且消除了创建 <code>POSO</code> 的开销。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，如果你不想在项目开始成长和变化时迷失键名，请避免使用字典发送此数据。</p><br><h1 id="专注于VIPER"><a href="#专注于VIPER" class="headerlink" title="专注于VIPER"></a><strong>专注于VIPER</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想充分利用此架构，请务必让你的团队与 <code>VIPER模块</code> 中每个组件的职责保持完全同步。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使在了解了每个特定组件的作用之后，我们的团队仍然面临一些疑问，这主要是受以前在 <code>MVC</code> 方面的经验影响。</p><ul><li>视图是处理 UI元素 的视图：它导入 <code>UIKit</code> 并从其模块中实现有关 <code>UI元素</code> 的所有逻辑。 例如， <code>TableView</code> 逻辑是在视图上实现的。 如果要使代码更具可读性，请在扩展名上拆分 <code>TableView</code> 逻辑。 如果要使你的项目更加简洁，请使用 <code>TableViewDataManager</code> 。</li><li><code>presenter</code> 不会导入 <code>UIKit</code> ，也不会处理 <code>UI元素</code> ，但是会以视图所需的格式准备数据，并根据视图中的 <code>UI事件</code> 做出决定。 不要在 <code>presenter</code> 上操纵任何 <code>UI元素</code> ，它不应处理它们。</li><li><code>Interactor</code> 也可以准备数据，但要用于数据库。 例如，一旦 <code>ApiDataManager</code> 提取了一些数据， <code>Interactor</code> 就可以在要求 <code>LocalDataManager</code> 保存数据之前进行一些排序或过滤。 但是请注意， <code>Interactor</code> 不了解 <code>视图</code> ，因此不知道应如何为视图准备数据。</li></ul></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;产品团队决定从你的项目中删除功能吗？ 还是你的小型项目开始变得庞大？ 使用正确的 <code>VIPER架构</code> ，避免将来出现麻烦！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动化 <code>VIPER文件</code> 创建和模块初始化将消除使用该工具的开销（乍看之下很复杂），但架构清晰而出色。 <code>Android开发人员</code> 也可以使用它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经看到，我们的 VIPER架构 方法实际上是由 <code>VIPRC模块</code> <strong><em>（View-Interactor-Presenter-Router-Contract）</em></strong> 组成的，而实体与模块以及数据管理器是分离的。 我知道 <code>VIPRC</code> 这个名字一点也不性感，但是它可以让你像老板一样构建应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS项目架构：使用VIPER</title>
      <link href="/iOS%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BD%BF%E7%94%A8VIPER/"/>
      <url>/iOS%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BD%BF%E7%94%A8VIPER/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发 <code>iOS</code> 应用时，请务必考虑应使用哪种 <code>iOS项目架构</code> 。 大多数开发人员使用 <code>Apple</code> 建议的模式：所谓的<code>MVC（模型-视图-控制器）架构</code>。 但是， <code>MVC</code> 本身已经建立了完善的缺陷。 一方面，由于其简单性，它甚至可以使最有经验的工程师将不属于视图或模型的任何代码放入控制器的逻辑中–在控制器中生成大量代码，并真正压缩视图和模型 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这篇文章中，我们将介绍 <code>VIPER</code> ，这是 <code>MVC</code> 的一种流行替代品，它可以帮助你克服其限制，同时保持代码模块化和组织良好，从而改善开发过程。</p><a id="more"></a></br><h1 id="什么是VIPER？"><a href="#什么是VIPER？" class="headerlink" title="什么是VIPER？"></a><strong>什么是VIPER？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>VIPER</code> 是 <code>View</code> ， <code>Interactor</code> ， <code>Presenter</code> ， <code>Entity</code> 和 <code>Router</code> 的反义词。 基本上，这是一种实施 <code>“单一责任原则”</code> 的方法，可以为你的 <code>iOS</code> 项目创建更简洁，更模块化的结构。 这种模式背后的思想是隔离应用程序的依赖关系，以平衡实体之间的职责委派。 这是通过使用以下体系结构来实现的：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/vu-stp1.png" alt="什么是VIPER？"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图说明了 <code>VIPER</code> 体系结构，其中每个块对应于具有特定任务，输入和输出的对象。 将这些块视为装配线中的工人：工人完成对某个对象的工作后，该对象将传递给下一个工人，直到完成产品为止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;块之间的连接表示对象之间的关系，以及它们之间传递的信息类型。 从一个实体到另一个实体的通信是通过协议进行的，我们将在本文中进一步说明。</p></br><h1 id="iOS项目架构"><a href="#iOS项目架构" class="headerlink" title="iOS项目架构"></a><strong>iOS项目架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到 <code>VIPER</code> 架构的真正目的，现在重要的是要多了解每个部分以及它们的职责。 为此，我们将开发一个基本应用程序（代码也可在 <a href="https://github.com/pedrohperalta/Articles-iOS-VIPER" target="_blank" rel="noopener"><strong><em><code>GitHub</code></em></strong></a> 上找到），该应用程序从 <code>REST API</code> 中获取文章列表，并在用户屏幕上显示这些文章。</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a><strong><em>View</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>iOS</code> 应用程序中的 <code>VIPER</code> <code>View</code> 是一个 <code>UIViewController</code> ，其中包含一个子视图，该子视图可以通过编程方式实现，也可以使用接口生成器 <code>（IB）</code> 来实现。 它的唯一责任是显示演示者要告诉的内容，并处理用户与屏幕的交互。 当用户触发任何需要处理的事件时， <code>View</code> 会简单地将其委托给 <code>Presenter</code> ，并等待响应以告知下一步应显示什么。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们的商品可视化应用程序的 <code>“View”</code> 在 <code>Swift</code> 中的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the view input methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesViewInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showArticlesData</span><span class="params">(articles: [Article])</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showNoContentScreen</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A view responsible for displaying a list</span></span><br><span class="line"><span class="comment"> * of articles fetched from some source.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlesViewController</span> : <span class="title">UIViewController</span>, <span class="title">ArticlesViewInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Reference to the Presenter's interface.</span></span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">ArticlesModuleInterface!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Once the view is loaded, it sends a command</span></span><br><span class="line"><span class="comment">     * to the presenter asking it to update the UI.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.presenter.updateView()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesViewInterface</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showArticlesData</span><span class="params">(articles: [Article])</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.articles = articles</span><br><span class="line">        <span class="keyword">self</span>.tableView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showNoContentScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Show custom empty screen.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a><strong><em>Presenter</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Presenter</code> 的工作就像 <code>VIPER</code> 模块主要部分之间的桥梁。 一种方式是，它接收来自 <code>View</code> 的输入事件，并通过向 <code>Interactor</code> 请求数据来对它们做出反应。 另一方面，它接收来自 <code>Interactor</code> 的数据结构，在该数据上应用视图逻辑以准备内容，最后告诉视图显示什么。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们的文章可视化应用程序的 <code>Presenter</code> 的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the commands sent from the View to the Presenter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesModuleInterface</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateView</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showDetailsForArticle</span><span class="params">(article: Article)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the commands sent from the Interactor to the Presenter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesInteractorOutput</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">articlesFetched</span><span class="params">(articles: [Article])</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Presenter is also responsible for connecting</span></span><br><span class="line"><span class="comment"> * the other objects inside a VIPER module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlesPresenter</span> : <span class="title">ArticlesModuleInterface</span>, <span class="title">ArticlesInteractorOutput</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Reference to the View (weak to avoid retain cycle).</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">ArticlesViewInterface!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the Interactor's interface.</span></span><br><span class="line">    <span class="keyword">var</span> interactor: <span class="type">ArticlesInteractorInput!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the Router</span></span><br><span class="line">    <span class="keyword">var</span> wireframe: <span class="type">ArticlesWireframe!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesModuleInterface</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.interactor.fetchArticles()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showDetailsForArticle</span><span class="params">(article: Article)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.wireframe.presentDetailsInterfaceForArticle(article)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesInteractorOutput</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">articlesFetched</span><span class="params">(articles: [Article])</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> articles.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.articles = articles</span><br><span class="line">            <span class="keyword">self</span>.view.showArticlesData(articles)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.view.showNoContentScreen()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Interactor"><a href="#Interactor" class="headerlink" title="Interactor"></a><strong><em>Interactor</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以将此对象视为特定模块内用例的集合。  <code>Interactor</code> 包含与实体相关的所有业务逻辑，并且应完全独立于用户界面 <code>（UI）</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的 <code>Article Visualization</code> 应用程序中，一个用例示例是从服务器获取文章列表。 进行请求，处理响应并将其转换为实体（在本例中为商品对象）是 <code>Interactor</code> 的责任。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦 <code>Interactor</code> 完成运行某些任务，它将通知 <code>Presenter</code> 获得的结果。 要牢记的一件重要事情是，发送给 <code>Presenter</code> 的数据不应实现任何业务逻辑，因此 <code>Interactor</code> 提供的数据应整洁并可以使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的文章可视化应用程序中， <code>Interactor</code> 将负责从 <code>API</code> 提取文章：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the Interactor's use case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesInteractorInput</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fetchArticles</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Interactor responsible for implementing</span></span><br><span class="line"><span class="comment"> * the business logic of the module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlesInteractor</span> : <span class="title">ArticlesInteractorInput</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Url to the desired API.</span></span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">"https://www.myendpoint.com"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the Presenter's output interface.</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">ArticlesInteractorOutput!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesInteractorInput</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fetchArticles</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Alamofire</span>.request(.<span class="type">GET</span>, url).responseArray &#123; (response: <span class="type">Response</span>) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> articlesArray = response.result.value</span><br><span class="line">            <span class="keyword">self</span>.output.articlesFetched(articlesArray!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a><strong><em>Entity</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Entity</code> 可能是 <code>VIPER</code> 结构中最简单的元素。 它封装了不同类型的数据，通常在其他 <code>VIPER</code> 组件中被视为有效负载。 需要注意的一件事是实体与数据访问层不同，后者应由交互器处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的 <code>Article Visualization</code>应用程序中， <code>Article</code> 类将是 <code>Entity</code> 的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> website: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> authors: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> imageUrl: <span class="type">String?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a><strong><em>Router</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>VIPER</code> 架构中的最后一个，也许是最特殊的元素是 <code>Router</code> ，它负责模块之间的导航逻辑，以及模块的发生方式（例如，定义用于呈现屏幕的动画，或者应如何完成两个屏幕之间的转换） ）。它从 <code>Presenters</code> 接收输入命令，说出应该路由到哪个屏幕。另外， <code>Router</code> 应负责将数据从一个屏幕传递到另一个屏幕。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Router</code> 应实施一个协议，该协议定义特定模块的所有导航可能性。很好，因为它可以仅查看 <code>Router</code> 的协议即可快速概览应用程序可以采用的所有路径。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>iOS</code> 框架的限制，只有 <code>ViewController</code> 可以在屏幕之间执行转换，因此 <code>Router</code> 必须包含对模块控制器或其任何子级的引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们的 <code>Router</code> 在“文章可视化”应用程序中的外观（请注意，该路由器被广泛称为 <code>“Wireframe”</code> ）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protocol that defines the possible routes from the Articles module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ArticlesWireframeInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">presentDetailsInterfaceForArticle</span><span class="params">(article: Article)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Router responsible for navigation between modules.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlesWireframe</span> : <span class="title">NSObject</span>, <span class="title">ArticlesWireframeInput</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Reference to the ViewController (weak to avoid retain cycle).</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> articlesViewController: <span class="type">ArticlesViewController!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reference to the Router of the next VIPER module.</span></span><br><span class="line">    <span class="keyword">var</span> detailsWireframe: <span class="type">DetailsWireframe!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: ArticlesWireframeInput</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">presentDetailsInterfaceForArticle</span><span class="params">(article: Article)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Create the Router for the upcoming module.</span></span><br><span class="line">        <span class="keyword">self</span>.detailsWireframe = <span class="type">DetailsWireframe</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sends the article data to the next module's Presenter.</span></span><br><span class="line">        <span class="keyword">self</span>.sendArticleToDetailsPresenter(<span class="keyword">self</span>.detailsWireframe.detailsPresenter, article: article)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Presents the next View.</span></span><br><span class="line">        <span class="keyword">self</span>.detailsWireframe.presentArticleDetailsInterfaceFromViewController(<span class="keyword">self</span>.articlesViewController)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: Private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">sendArticleToDetailsPresenter</span><span class="params">(detailsPresenter: DetailsPresenter, article: Article)</span></span> &#123;</span><br><span class="line">        detailsPresenter.article = article</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="什么时候应该使用VIPER？"><a href="#什么时候应该使用VIPER？" class="headerlink" title="什么时候应该使用VIPER？"></a><strong>什么时候应该使用VIPER？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在创建具有发展潜力的项目时，重要的是要考虑一个可以很好地扩展并允许许多开发人员同时无缝地进行工作的结构- <code>MVC</code> 结构可能不足以保持你的项目充分组织 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发人员发现自己调试大型类确实很常见，例如试图在大海捞针中找针。 通过 <code>VIPER</code> 建议的对象之间的松散耦合，你会注意到：</p><ul><li>通过崩溃报告更容易跟踪问题（由于“单一责任原则”）</li><li>添加新功能更容易</li><li>源代码将更加干净，紧凑和可重用</li><li>与其他开发团队的冲突更少</li><li>由于你的 <code>UI</code> 逻辑与业务逻辑是分开的，因此编写自动化测试（！）更容易。</li></ul></br><h1 id="什么时候不应该使用VIPER？"><a href="#什么时候不应该使用VIPER？" class="headerlink" title="什么时候不应该使用VIPER？"></a><strong>什么时候不应该使用VIPER？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于你要解决的每个问题，你都应使用最适合你需求的工具。 由于涉及的元素数量众多，因此该体系结构在启动新项目时会产生开销（尽管从长远来看，这在很大程度上会得到回报），因此 <code>VIPER</code> 对于不打算扩展的小型项目而言可能是一个过大的杀伤力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果团队不完全保持 <code>VIPER</code> 结构的一致性，那么你最终会遇到 <code>MVC-VIPER</code> 混合问题，这可能会令人头疼–因此在继续使用 <code>VIPER</code> 之前，请确保团队完全同步。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>VIPER</code> 是一种非常酷的 <code>iOS</code> 项目架构模式，例如 <code>MVP</code> 和 <code>MVVM</code> 。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS VIPER架构深入实践</title>
      <link href="/iOS%20VIPER%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/"/>
      <url>/iOS%20VIPER%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>VIPER</code> 架构编写可伸缩的 <code>iOS</code> 代码，并牢记一些 <code>MVVM</code> 和 <code>MVC</code> 技巧和协调器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件工程中，<a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener"><strong><em><code>设计模式（design pattern）</code></em></strong></a> 是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。</p><a id="more"></a></br><h1 id="Swift-设计模式和-iOS-架构"><a href="#Swift-设计模式和-iOS-架构" class="headerlink" title="Swift 设计模式和 iOS 架构"></a><strong>Swift 设计模式和 iOS 架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;软件设计模式基本上是关于如何解决特定（但通常是结合业务场景）情况的通用模板。 结构模式对整个代码库影响更大，它们是高级通用模板。 请记住一件事：</p><blockquote><p>架构没有好坏之分。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择的武器仅取决于情况，但你知道一切都是相对的。 让我们快速快速地了解所有 <code>iOS</code> 设计模式和体系结构，并开始学习 <a href="http://www.xuebaonline.com/iOS%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BD%BF%E7%94%A8VIPER/"><strong><em><code>VIPER</code></em></strong></a> 。 🐍</p></br><h2 id="Swift-设计模式"><a href="#Swift-设计模式" class="headerlink" title="Swift 设计模式"></a><strong><em>Swift 设计模式</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从基础开始吧？ 如果不熟悉 <code>UIKit</code> ，我们会发现发明了许多设计模式，也许你已经知道其中一些。 但是，嘿，由于我们没有太多时间，我想谈谈 <a href="http://www.xuebaonline.com/VIPER%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E5%83%8F%E8%80%81%E6%9D%BF%E4%B8%80%E6%A0%B7%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"><strong><em><code>VIPER</code></em></strong></a> ，让我们看看使用 <code>MVC</code> 模式构建 <code>UIKit</code> 应用程序的基本原理。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a><strong><em>MVC</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模型-视图-控制器（Massive-View-Controller）模式是一个基本概念。 通常，你有一个庞大的UIViewController子类，该子类控制所有视图并收集需要为最终用户显示的每个模型。 例如，你从控制器使用URLSession或Alamofire调用API终结点，进行响应数据验证和格式化，然后在视图控制器上实现表或集合视图委托，因此基本上所有应用程序逻辑都在该单一的，装满了悲惨的视图控制器中 类。 这会为你敲响钟声吗？ 🙄</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a><strong><em>MVVM</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;意识到问题之后，你可以做的第一件事就是将数据转换或绑定部分外包给单独的类。 这就是 <code>Miscrosoft</code> 的聪明人发明了 <code>Model-View-ViewModel</code> 体系结构模式的方式。 现在，你已经接近了一步，你的数据模型和视图可以在距离控制器域很远的闪亮新文件中的一个全新的高度上“聚在一起”。 但是，此模式不会清除视图控制器内部的所有剩余内容。 请记住，你仍然必须向视图控制器提供数据，处理所有不同的状态。</p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a><strong><em>MVP</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们从视图控制器中移走所有数据加载和演示文稿的东西，然后将它们放到神奇地称为 <code>Presenter</code> 的新类中，该怎么办？ 听起来不错，视图控制器可以拥有新的 <code>presenter</code> 实例，从此以后我们可以过上幸福的生活。 来吧，我们真的应该将其重命名为有史以来最有价值的模式！ 😉</p><h2 id="协调器模式"><a href="#协调器模式" class="headerlink" title="协调器模式"></a><strong><em>协调器模式</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还是应该简单地将其称为“逆模型视图展示者”模式？ 看起来，这很重要，协调员在这个演进过程中处于一个全新的高度，但是他们还有很多事情要做。 这违反了“单一职责”原则，因为现在你必须管理表示上下文，数据存储，路由以及协调器或子协调器中的所有 <code>differnet</code> 状态。但是，最后，你的视图控制器没有任何剩余的负担 它可以直接专注于工作，这是什么？ 🙃<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用与 <code>UIKit</code> 相关的内容呈现视图，并转发事件。</p></br><h1 id="VIPER架构"><a href="#VIPER架构" class="headerlink" title="VIPER架构"></a><strong>VIPER架构</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，不要仅仅因为有人滥用而认为VIPER不好。我认为这是一个令人惊讶的惊人建筑！你只需要适当地学习它，这很困难，因为缺少好的教程。每个人都在比较架构，但这不是人们应该做的。据我所知，<code>MVP</code> 适用于带有几个屏幕的小型应用程序，你永远不要对这些应用程序使用 <code>VIPER</code> 。如果你的应用不断增长，越来越多的组件加入游戏，那么真正的问题就开始了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你打算编写一个小型应用程序，则从 <code>MVC</code> 开始。稍后，你可以使用 <code>MVVM</code> 解决大型视图控制器的问题，但是如果你想将其进一步发展，可以始终使用MVP或协调器模式来保持可维护性。完全没问题，直到有一天你意识到代码中塞满了实用程序类，管理器，处理程序和所有废话对象。听起来很熟悉？ 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我之前提到的那样，没有糟糕的架构之类的东西。只有错误的选择，这导致我们难以维护的代码库。因此，让我指导你完成你想知道的最有用的设计模式，以编写真正可扩展的 <code>iOS</code> 应用程序：具有模块构建器的 <code>VIPER = VIPER（B）</code>。</p></br><h1 id="了解VIPER"><a href="#了解VIPER" class="headerlink" title="了解VIPER"></a><strong>了解VIPER</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>VIPER</code> 体系结构基于单一责任原则 <code>（S.O.L.I.D.）</code>，这使我们进入了干净体系结构的理论。 假设 <code>VIPERB</code> 模块的核心组件为以下组件：</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a><strong><em>View</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是接口层，表示 <code>UIKit</code> 文件，主要是 <code>UIViewController</code> 子类和所有其他内容。 视图不执行与业务逻辑相关的任何操作，只是演示者使用的演示和事件转发层。 由于视图只是纯视图控制器，因此你可以使用 <code>MVVM</code> 原理或数据管理器来使你的项目更加简洁。</p><h2 id="Interactor-互动者"><a href="#Interactor-互动者" class="headerlink" title="Interactor(互动者)"></a><strong><em>Interactor(互动者)</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;交互器负责从模型层检索数据，其实现完全独立于用户界面。 重要的是要记住，数据管理器（网络，数据库，传感器）不是 <code>VIPER</code> 的一部分，因此它们被视为独立的组件（服务），它们来自 <code>VIPER</code> 模块领域，可以作为交互器的依赖项注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Interactor</code> 可以准备或转换来自服务层的数据。 例如，它可以在要求正确的网络服务实现请求或保存数据之前进行一些排序或过滤。 但是请记住，交互器不了解视图，因此它不知道应如何为视图准备数据，这就是 <code>Presenter</code> 的作用。 🙄</p><h2 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a><strong><em>Presenter</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>UIKit</code> 独立类，以视图所需的格式准备数据并基于视图中的 <code>UI</code> 事件做出决定，这就是为什么有时将其称为事件处理程序的原因。 这是 <code>VIPER</code> 模块的核心类，因为它还与 <code>Interactor</code> 通信并调用路由器进行线框图（也就是提供一个新模块或关闭当前模块）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是唯一与几乎所有其他组件进行通信的类。 那只是演示者的工作，因此它不应该对 <code>UIKit</code> 或低级数据模型一无所知。 基本上，这是应用程序的核心，或者有人会说这是实现所有业务逻辑的地方。 💜</p><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a><strong><em>Entity</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;普通模型类，主要由交互器使用。 通常，我在 <code>VIPER</code> 模块结构之外（在服务层中）定义它们，因为这些实体在系统中共享。 我们可以按模块将它们分开，但是通常我不喜欢这种方法，因为例如。 所有 <code>CoreData</code> 模型都可以生成到一个地方。 如果使用 <code>Swagger</code> 或类似工具，则同样适用。</p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a><strong><em>Router</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>UIKit</code> 类的应用程序的导航逻辑。 例如，如果在 <code>iPad</code> 应用程序中使用相同的iPhone视图，则唯一可能改变的是路由器如何构建结构。 这使你可以保留所有其他内容，但路由器保持不变。 它还会监听来自演示者的导航流更改，因此，如果需要，它将显示正确的屏幕。 同样，如果你需要在路由器内部打开一个外部 <code>URL</code> 调用 <code>UIApplication.shared.openURL（url）</code> ，因为这也是一个路由操作，那么使用 <code>UIActivityViewControlle</code> r进行社交媒体共享的逻辑也相同。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样，如果你必须在 <code>VIPER</code> 模块之间传递数据，则感觉是在路由器中执行此操作的正确位置。 我通常使用委托模式在两个模块之间进行通信，因此我养成了在路由器中调用委托函数的习惯。 📲</p><h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a><strong><em>Builder</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有些人正在使用路由器来构建整个模块，但是我不喜欢这种方法。 这就是为什么我总是使用单独的模块构建器类的原因。 唯一的责任是通过对所有外部服务使用依赖注入来构建完整的模块。 它还可以构建同一模块的模拟或其他版本。 如果涉及单元测试，那将非常有帮助。 完全有道理。 👍</p><h2 id="并非一切都是-VIPER-模块"><a href="#并非一切都是-VIPER-模块" class="headerlink" title="并非一切都是 VIPER 模块"></a><strong><em>并非一切都是 VIPER 模块</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，如果要从 <code>UIView</code> 创建通用子类，请不要尝试将其填充到上面的组件中。 你应该在 <code>VIPER modules</code> 文件夹之外创建一个位置，并将其放置在该位置。 有些用例具有特定的类，最好不要进行 <code>VIPERized</code> ！ 😉</p><h2 id="服务和应用程序代码"><a href="#服务和应用程序代码" class="headerlink" title="服务和应用程序代码"></a><strong><em>服务和应用程序代码</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的应用程序通常有3个单独的层。 模块，服务和应用程序。 所有 <code>VIPER</code> 模块都位于 <code>“Modules”</code> 文件夹中。 与网络或数据相关的所有内容都转到 <code>“Services”</code> 文件夹（ <code>api服务</code> ，<code>核心数据服务</code>，<code>位置服务</code>等），然后根据当前环境在模块构建器中使用（例如，用于测试的模拟实现）。 其余所有东西（例如视图子类和其他与 <code>UI</code> 相关的对象，特定于应用程序的样式或设计方面的东西）都放在 <code>App</code> 目录中。</p></br><h1 id="如何编写VIPER代码？"><a href="#如何编写VIPER代码？" class="headerlink" title="如何编写VIPER代码？"></a><strong>如何编写VIPER代码？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开始使用该体系结构之前，我无法充分强调学习这种体系结构的重要性。 我认为，如果有人误解了 <code>VIPER</code> 并开始将视图逻辑放到演示者中，事情就会变得很糟糕。 如果你以前在 <code>VIPER</code> 方面有过糟糕的经验，请考虑一下这句话：不要怪工具，怪木匠。 🔨</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你遵循 <code>VIPER</code> 的规则，那么非常单一的组件将进入正确的位置。</p></blockquote><h2 id="模块生成"><a href="#模块生成" class="headerlink" title="模块生成"></a><strong><em>模块生成</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;永远不要开始手动创建 <code>VIPER</code> 模块，你应该始终使用代码生成器，因为（不幸的）每个模块都需要大量样板代码。乍一看似乎很不幸，但这才是该架构真正的力量所在。如果发生特定问题，开发人员团队的所有成员都将知道在哪里寻找。如果是视图问题，则必须修复视图；如果涉及导航问题，则是路由器问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现有许多代码生成器解决方案（其中一个著名的是 <code>Generamba</code> ），但是我制作了自己的小 <code>Swift</code> 工具来生成 <code>VIPER</code> 模块。这真是该死的轻量级，但确实非常有用（它利用模板来生成新模块），我称之为：<code>VIPERA</code> 。 （毒蛇蛇的匈牙利名字…哈哈😂）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你只需克隆/下载存储库并运行 <code>swift run install --with-templates</code> 即可使其工作。从现在开始，你只需运行<code>vipera MyModule</code> 即可基于默认模板生成新模块。作为第二个参数，你可以传递自己的模板目录名称（可以在<code>〜/ .vipera</code>文件夹下创建自己的模板，也可以更改默认模板）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本模板的结构非常简单，我没有为每一层创建子文件夹，而是在不同位置分离了接口和默认实现。这让我有点理智，因为大多数 <code>VIPER</code> 模板似乎只是由于项目结构而具有很大的威慑力。</p><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a><strong><em>命名约定</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几乎为每个 <code>VIPER</code> 组件都定义了协议。 每个协议都将以模块名称作为前缀，并且除了层名称（例如 <code>MyModuleRouter</code> ， <code>MyModulePresenter</code> ）外，它将没有任何其他后缀。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认实现用于基本方案，每个协议实现均遵循 <code>ModuleName + Default + Layer</code> 命名约定。 因此，例如 <code>MyModuleDefaultRouter</code> 或 <code>MyModuleDefaultPresenter</code> 。</p><h2 id="使用-delegates-进行模块间通信"><a href="#使用-delegates-进行模块间通信" class="headerlink" title="使用 delegates 进行模块间通信"></a><strong><em>使用 delegates 进行模块间通信</em></strong></h2><p>流程是这样的：</p><p><strong>Router / Presenter</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Presenter</code> 可以使用路由器协议定义发送路由器事件。</p><p><strong>Presenter / Interactor</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Interactor</code> 可以通过演示者的界面通知演示者，并且演示者可以使用 <code>Interactor</code> 协议内部定义的方法来调用交互者。</p><p><strong>Presenter / View</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;视图通常具有 <code>setter</code> 方法来更新其在视图协议上定义的内容。 它还可以通过演示者协议将传入或加载事件通知 <code>Presenter</code> 。</p><h2 id="模块之间的数据传输"><a href="#模块之间的数据传输" class="headerlink" title="模块之间的数据传输"></a><strong><em>模块之间的数据传输</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象一个列表，你选择一个项目并转到新的控制器场景。 为了使之成为可能，你必须在 <code>VIPER</code> 模块之间至少传递一个唯一的标识符。</p><p>通常这样做是这样的：</p><ul><li>该视图使用 <code>ID</code> 调用 <code>Presenter</code> 上的 <code>didSelect</code> 方法</li><li><code>Presenter</code> 使用 <code>routeFor（id）</code> 方法将 <code>ID</code> 转发到路由器</li><li>路由器调用构建器使用 <code>ID</code> 来构建新模块</li><li>生成器使用 <code>id</code> 生成新模块</li><li>路由器使用其视图显示新模块（控制器）</li><li>新模块将ID传递给需要它的每个人（路由器，演示者）</li><li>新模块的演示者获取ID</li><li>新模块的 <code>Interactor</code> 加载数据并将其提供给 <code>Presenter</code></li><li>新模块的 <code>Presenter</code> 为视图提供数据并进行展示</li><li>出现详细信息屏幕，其中包含适当的数据。</li></ul><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你以模态形式显示控制器，则还可以将原始路由器作为委托传递，因此可以在需要时正确关闭它。 😎</p></blockquote><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong><em>内存管理</em></strong></h2><p>长话短说：</p><ul><li><code>builder</code> 不持有任何对象。</li><li><code>Router</code> 对 <code>Views</code> 和 <code>Presenter</code> 保持弱引用。</li><li><code>Presenter</code> 强持有 <code>Router</code>和  <code>Interactor</code> </li><li><code>Interactor</code> 对<code>Presenter</code> 的 弱引用</li><li>该 <code>Views</code> 对 <code>Presenter</code> 强引用</li><li><code>UIKit</code> 持有 <code>views</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该在提供的示例中进行检查，没有泄漏-希望如此-在你返回或关闭模块后，所有内容都会顺利顺利地释放。 🤞</p></br><h1 id="结论：我应该学习VIPER吗？"><a href="#结论：我应该学习VIPER吗？" class="headerlink" title="结论：我应该学习VIPER吗？"></a><strong>结论：我应该学习VIPER吗？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管 <code>VIPER</code> 因其复杂性而备受批评，但我只能说值得努力学习正确的原理。 你会发现使用 <code>VIPER</code> 而不是忽略它会有更多的好处。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong><em>优点</em></strong></h2><ul><li><strong>简单性</strong> -适用于大型团队的复杂项目</li><li><strong>可扩展性</strong> -无缝同时工作</li><li><strong>可重用性</strong> -根据角色分离应用程序组件</li><li><strong>一致性</strong> -模块框架，关注点分离</li><li><strong>清晰度</strong> -单一职责（SOLID）</li><li><strong>可测试性</strong> -分离的小类，TDD，更好的代码覆盖率</li><li><strong>接口</strong> -模块独立性，定义明确的范围</li><li><strong>错误修复</strong> -更容易跟踪问题，查找错误和问题</li><li><strong>源代码控制</strong> -文件更小，冲突更少，代码更简洁</li><li><strong>容易</strong> -代码库看起来很相似，熟悉项目代码更快</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong><em>缺点</em></strong></h2><ul><li><strong>详细程度</strong> -每个模块很多文件</li><li><strong>复杂性</strong> -许多协议和委托</li><li><strong>On-boarding</strong> -缺乏适当的VIPER知识</li><li><strong>Engagement</strong> -VIPER很糟糕，因为它很复杂！</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我写了一篇后续文章，介绍了我在此过程中学到的VIPER最佳实践。👨💻</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> VIPER </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> VIPER </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 如何学习现代UIKit？</title>
      <link href="/Swift%20%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%8E%B0%E4%BB%A3UIKit%EF%BC%9F/"/>
      <url>/Swift%20%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%8E%B0%E4%BB%A3UIKit%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与我一起采取第一步，学习如何使用 <code>UIKit</code> 框架构建用户界面。 在 <code>Swift</code> 中以编程方式编写，不适用 <code>storyboards</code> 。</p></br><h1 id="UI-frameworks-in-2020"><a href="#UI-frameworks-in-2020" class="headerlink" title="UI frameworks in 2020"></a><strong>UI frameworks in 2020</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我总是告诉所有人，工作中最困难的部分是建立适当的用户界面。 提供最佳的用户体验可能是一项挑战，因为设计师必须遵循人机界面指南，设计出美观的设计，有时还要与客户打交道，以为最终用户找到最佳解决方案。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>Swift</code> 实现图形用户界面的可用选项有哪些？</p><a id="more"></a></br><h1 id="SwiftUI"><a href="#SwiftUI" class="headerlink" title="SwiftUI"></a><strong>SwiftUI</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果在 <code>2019年</code> 发布了<code>SwiftUI</code>，该框架仍然热脆，或者我应该说半熟吗？ 在 <code>WWDC</code> 宣布之后，很多人立即开始使用 <code>SwiftUI</code> ，我对最初的反馈感到非常不满意。 <code>SwiftUI</code> 是未来，这是肯定的。 我相信 <code>Apple</code> 会在框架上做出很多努力，以使其更好。 从概念上讲，它已经很不错了，实现很简单，但是我仍然面临的最大问题是，我还没有看到 <code>SwiftUI</code> 如何改善我的日常工作。 🤔</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声明性接口定义是当今的热门话题，但是我们真的需要它吗？ 我的意思是，基本原型制作速度非常快，但是，如果你必须解决复杂的问题（甚至是一些琐碎的问题，例如设置滚动视图的偏移），则必须与系统抗争或提出自己的 <code>UIViewRepresentable</code> 对象。</p><p><strong><em><code>The truth is: if you choose SwiftUI you still have to interact a LOT with UIKit as well.</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，人们有各种各样的需求。 由于 <code>Flutter</code> ＆ <code>React Native</code>，恕我直言 <code>SwiftUI</code> 在这里。 开发人员喜欢这些框架。 苹果必须想出一种新的解决方案来与他们抗衡，因为他们希望越来越多的有才华的 <code>Swift</code> 编码器能够在 <code>iOS</code> 应用程序上本机工作，而不是在混合应用程序上工作。 从新手的角度来看，选择 <code>SwiftUI</code> 确实很迷人。 即使在这个早期阶段，我仍然可以给你留下深刻的印象。</p><h2 id="是否可以学习-SwiftUI"><a href="#是否可以学习-SwiftUI" class="headerlink" title="是否可以学习 SwiftUI?"></a><strong><em>是否可以学习 SwiftUI?</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是的，绝对可以，如果你已经熟悉 <code>UIKit</code> ，那就去学习 <code>SwiftUI</code> 。 如果你完全没有 <code>UIKit</code> 的经验，你仍然可以精通 <code>SwiftUI</code> ，但是你可能会发现自己在寻找很多与 <code>UIKit</code> 相关的问题。 🔍</p><h2 id="你应该学习SwiftUI还是UIKit？"><a href="#你应该学习SwiftUI还是UIKit？" class="headerlink" title="你应该学习SwiftUI还是UIKit？"></a><strong><em>你应该学习SwiftUI还是UIKit？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，知道我所知道的我将从UIKit开始。 “和这个酷孩子在一起”确实很诱人，但是值得跳过整个课程吗？这也是我的想法：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要说的是 <code>SwiftUI</code> 的存在并没有以某种方式使 <code>UIKit</code> 变得过时：如果你打算在未来三年内获得 <code>iOS</code> 开发工作，那么知道如何使用 <code>UIKit</code> 将会是一项必然的要求。</p></blockquote></br><h1 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a><strong>UIKit</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>UIKit</code> 现在可在以下平台上使用：<code>iOS（iPadOS）</code>，<code>tvOS</code>，<code>macOS（Catalyst）</code>。 除了<code>watchOS</code> 以外，几乎所有这些都已包含在内。 该框架本身是一个巨大的框架，因为它包含了你可以在 <code>iOS</code> 上看到和使用的每个基本构建块。 它不仅是视图，还包括控制器，导航，响应器等等。</p><h2 id="你应该从哪里开始学习UIKit？"><a href="#你应该从哪里开始学习UIKit？" class="headerlink" title="你应该从哪里开始学习UIKit？"></a><strong><em>你应该从哪里开始学习UIKit？</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是否正在寻找现代 <code>UIKit</code> 教程？ 好吧，这可能非常困难，因为大多数书籍和课程都已过时。 但是，我必须推荐一个 <code>肖恩·艾伦（Sean Allen）</code> 真正有用的视频课程。 他正在构建一个完整的应用程序，向你教授网络基础知识，集合视图，搜索控制器的适当状态管理以及许多小型实践，如果你想开始作为 <code>iOS</code> 开发人员的职业，这些实践将非常有用。 这就像一个面试的外卖项目教程。 真的很有用！ 🎬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以选择加入我的行列，并每周学习UIKit的工作原理。 我将发布有关过去学习的所有最佳实践的文章。 这将是100％用最新版本的Swift编写的，没有 <code>storyboards</code> 或 <code>nibs</code> 。 这些将是更长的文章，每一次我将专注于对现实项目有用的实践课程。 有什么计划？</p><p><strong>我即将发布的UIKit教程*</strong></p><ul><li><p>如何使用UIKit启动iOS项目？</p><p>  项目设置，基本UIKit概念，AppDelegate，SceneDelegate</p></li><li><p>了解UIKit导航的工作方式</p><p>  UINavigationController，UITabBarController，UISplitViewController，UIPageViewController</p></li><li><p>关于UIViewController类的所有信息</p><p>  UIViewController生命周期，子类化，使用子视图控制器的合成</p></li><li><p>UIView基础知识，使用自定义视图</p><p> UIView生命周期，布局系统，自定义UIView子类，有关图层的一些知识</p></li><li><p>具有UILabel，UIButton，UIImageView的布局锚点</p><p>  了解如何通过使用布局锚点和基本的UIKit组件来构建屏幕</p></li><li><p>使用不同的数据源修改UITableView</p><p>  使用搜索字段，远程图像加载等。</p></li><li><p>UI堆栈，状态，警报，过渡，动画</p><p> UIAlertController，UIActivityIndi​​catorView和一些奇特的效果</p></li><li><p>使用UICollectionView构建复杂的用户界面</p><p>  合成布局，再加上我对基于SwiftUI的可重用单元格有了新的疯狂想法…</p></li><li><p>使用UIStackView和UIScrollView创建复杂的输入表单</p><p>  使用：UITextField，UISlider，UIStepper，UIDatePicker，UISegmentedControl，UISwitch</p></li><li><p>支持更大的屏幕，iPad，macOS（Catalyst）和黑暗模式</p><p>  Windows，适应性，拖放基础，触摸识别器</p></li></ul><p>*请注意：这只是一个基本框架，将来内容可能会有所不同。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我计划在今年晚些时候发布第一期。 当我准备好内容之后，每个星期你都应该期待有一篇新的 <code>UIKit</code> 文章，其中包含一些可以自己解决的小任务（也许你需要做一些研究工作）。</p></br><h1 id="你首选的学习方法是什么？"><a href="#你首选的学习方法是什么？" class="headerlink" title="你首选的学习方法是什么？"></a><strong>你首选的学习方法是什么？</strong></h1><ul><li><strong><em>图书</em></strong></li><li><strong><em><code>Swift playground books</code></em></strong></li><li><strong><em>视频课程</em></strong></li><li><strong><em>撸代码实践</em></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 唯一识别的视图</title>
      <link href="/Swift%20%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%9A%84%E8%A7%86%E5%9B%BE/"/>
      <url>/Swift%20%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%9A%84%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用基于字符串的 <code>UIView</code> 标识符而不是标签。 如果你厌倦了标记视图，请查看这些替代解决方案。</p></br><h1 id="第一种方法：accessibility-to-the-rescue"><a href="#第一种方法：accessibility-to-the-rescue" class="headerlink" title="第一种方法：accessibility to the rescue!"></a><strong>第一种方法：accessibility to the rescue!</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长话短说，我很讨厌用愚蠢的数字值标记视图，因此我寻求一种更好的替代解决方案来解决我的问题。 事实证明，有一个名为 <code>accessibilityIdentifier</code> 的属性可以完成这项工作。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.accessibilityIdentifier</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.accessibilityIdentifier = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">view</span><span class="params">(withId id: String)</span></span> -&gt; <span class="type">UIView?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.id == id &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> view <span class="keyword">in</span> <span class="keyword">self</span>.subviews &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> view = view.view(withId: id) &#123;</span><br><span class="line">                <span class="keyword">return</span> view</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对 <code>UIView</code> 类进行了简单的扩展，因此现在我可以使用适当的字符串值来唯一地标识视图层次结构中的任何视图对象。 这是一个很好的解决方案，现在我可以以一种非常不错的方式命名我的 <code>views</code> 。 免费将名称存储在 <code>accessibilityIdentifier</code> 下将对 <code>UI</code> 测试带来好处。 😉</p></br><h1 id="第二种方法：using-enums"><a href="#第二种方法：using-enums" class="headerlink" title="第二种方法：using enums"></a><strong>第二种方法：using enums</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要思想是为每个视图标识符都具有一个基于 <code>Int</code> 的枚举，因此基本上你可以使用 <code>tag</code> 属性存储枚举的 <code>rawValue</code> 。 它仍然不如上面的那个好，但是比依赖纯整数更安全。 😬</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ViewIdentifier</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> submitButton</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">ViewIdentifier?</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> value = newValue &#123;</span><br><span class="line">                <span class="keyword">self</span>.tag = value.rawValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ViewIdentifier</span>(rawValue: <span class="keyword">self</span>.tag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">view</span><span class="params">(withId id: ViewIdentifier)</span></span> -&gt; <span class="type">UIView?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.viewWithTag(id.rawValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;老实说，在我将第一个代码片段复制并粘贴到本文之后，我只是想出了第二种方法，但是到底是什么，也许有人会喜欢它。 😂</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> Uniquely identifying views </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> Uniquely identifying views </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS子类化样式</title>
      <link href="/iOS%E5%AD%90%E7%B1%BB%E5%8C%96%E6%A0%B7%E5%BC%8F/"/>
      <url>/iOS%E5%AD%90%E7%B1%BB%E5%8C%96%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何通过使用 <code>Swift</code> 中的 <code>UIKit</code> 框架中的自定义视图子类来设计和构建 <strong><em>可重用</em></strong> 的用户界面元素。</p></br><h1 id="问题：UI，UX，设计"><a href="#问题：UI，UX，设计" class="headerlink" title="问题：UI，UX，设计"></a><strong>问题：UI，UX，设计</strong></h1><p><strong><em><code>建立用户界面是工作中最难的部分！</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之：设计是找出适合特定问题的最佳解决方案的过程。图形设计通常是指在画布或纸上的物理图形。 <code>UX</code> 实际上就是用户与应用程序交互的方式，换句话说：“客户”旅程的整体虚拟体验。 <code>UI</code> 是他/她将通过触摸屏幕看到并与之交互的可见界面。 👆</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我不得不戴上设计师的帽子（甚至是开发者的帽子），我必须告诉你，在大多数情况下，弄清和实现适当的用户界面是最具挑战性的问题。如今的前端系统（移动，平板电脑甚至台式机应用程序）只是来自 <code>service</code> / <code>API</code>的一些 <code>JSON</code> 数据之上的漂亮叠加层。 🤷‍♂️</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么这么难？好吧，我相信，如果你想成为一名优秀的设计师，那么你也需要适当的工程思维。你必须能够观察整个系统（大图），构造一致的 <code>UI</code> 元素（实际上到处看起来都是一样的），基于功能规范计划所需的体验等等。成为艺术家，跳出思维框框，并能够向他人解释（描述）你的想法也是一个基本要求。 🤯</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在告诉我，哪个行业的工作最艰辛？是的，如今免费提供的每个人都是设计师，有些公司根本不雇用这类专家，而只是让开发人员完成工作。无论如何，让我们专注于如何通过使用 <code>Swift</code> 中的子类来创建漂亮且可重用的设计实现。 👍</p></br><h1 id="外观，主题和样式"><a href="#外观，主题和样式" class="headerlink" title="外观，主题和样式"></a><strong>外观，主题和样式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我几乎没有使用 <code>UIAppearance API</code> 。 这是个人喜好，但是我想直接在视图实例上设置设计属性，例如 <code>font</code>，<code>textColor</code>，<code>backgroundColor</code>。 尽管在某些情况下，我发现外观代理非常好，但是仍然存在一些问题。 也许这将随着 <code>iOS 13</code> 以及期待已久的 <code>dark mode</code> 的到来而改变。</p><blockquote><p><strong><em><code>Dear Apple please make an auto switch based on day / night cycles (you know like the sunset, sunrise option in the home app). 🌙</code></em></strong></p></blockquote><ul><li><strong><em>样式</em></strong> 是指定单个视图外观的属性的集合。</li><li><strong><em>主题</em></strong> 是应用于整个应用程序的一组外观相似的视图样式。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，我通常会创建一些预定义的样式元素集，最可能是字体，颜色，但有时还会是图标等。我喜欢采用以下结构：</p><p><strong>Fonts</strong></p><ul><li>title</li><li>heading</li><li>subheading</li><li>body</li><li>small</li></ul><p><strong>Colors</strong></p><ul><li>title</li><li>heading</li><li>background</li></ul><p><strong>Icons</strong></p><ul><li>back</li><li>share</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以有更多的元素，但是为了简单起见，让我们使用嵌套结构通过一个非常简单的 <code>Swift</code> 解决方案来实现这些元素：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fonts</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> title = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> heading = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">24</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> subheading = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> body = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> small = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Colors</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> title = <span class="type">UIColor</span>.blue</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> heading = <span class="type">UIColor</span>.black</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> background = <span class="type">UIColor</span>.white</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Icons</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> back = <span class="type">UIImage</span>(named: <span class="string">"BackIcon"</span>)!</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> share = <span class="type">UIImage</span>(named: <span class="string">"ShareIcon"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//usage example:</span></span><br><span class="line"><span class="type">App</span>.<span class="type">Fonts</span>.title</span><br><span class="line"><span class="type">App</span>.<span class="type">Colors</span>.background</span><br><span class="line"><span class="type">App</span>.<span class="type">Icons</span>.back</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，我得到了一个非常简单的语法，这很好，虽然这不会让我进行动态样式设置，所以我无法在浅色/深色主题之间切换，但是我真的不介意，因为在大多数情况下 这不是必需的。 😅</p><p><strong><em>Structs vs enums:</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我可以使用枚举代替具有静态属性的结构，但是在这种情况下，我喜欢这种方法的简单性。 我不想弄乱接受枚举的原始值或扩展名。 这只是个人喜好。</p><p><strong>如果你必须支持多个主题怎么办？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这不是什么大问题，你可以根据需要定义协议，并根据需要实施所需的主题协议。 真正的问题是，当你必须在主题之间切换时，因为必须刷新/重新加载整个UI。 ♻️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一些最佳做法，例如，可以使用 <code>NSNotificationCenter</code> 类来通知应用程序中的每个视图/控制器在发生主题更改时进行刷新。 另一个解决方案是简单地重新初始化应用程序的整个 <code>UI</code> ，因此这意味着你基本上从头开始使用全新的 <code>rootViewController</code> 。 😱</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，如果你需要这样的内容，请查看下面的链接，但是如果你只想在应用程序中支持暗模式，建议你等到第一个 <code>iOS 13 beta</code> 发布。 也许 <code>Apple</code> 会提供一些新颖的 <code>API</code> 来简化事情。</p></br><h1 id="自定义视图作为样式元素"><a href="#自定义视图作为样式元素" class="headerlink" title="自定义视图作为样式元素"></a><strong>自定义视图作为样式元素</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们有了定义字体，颜色和其他基本构建块的好方法，是时候将这些样式应用于实际的 <code>UI</code> 元素了。 当然，你可以使用 <code>UIAppearance API</code> ，但是例如，你不能简单地通过外观代理设置自定义字体。 😢</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一件事是我喜欢设计的一致性。 因此，如果标题是我的应用程序中某处的蓝色 <code>32pt</code> 粗体系统字体，我也希望该元素在其他地方都遵循相同的准则。 我通过为每个应用了自定义样式的单个 <code>view</code> 元素创建子类来解决此问题。 因此，例如：</p><ul><li>TitleLabel (blue color, 32pt system font)</li><li>HeadingLabel (blue color, 24pt system font)</li><li>StandardButton (blue background)</li><li>DestructiveButton (red background)</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你有子类，并且正在使用代码中的自动布局约束，则另一件好事是，你可以将所有约束创建逻辑直接放入子类本身。 让我给你看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleLabel</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.textColor = <span class="type">App</span>.<span class="type">Colors</span>.title</span><br><span class="line">        <span class="keyword">self</span>.font = <span class="type">App</span>.<span class="type">Fonts</span>.title</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">constraints</span><span class="params">(<span class="keyword">in</span> view: UIView)</span></span> -&gt; [<span class="type">NSLayoutConstraint</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="keyword">self</span>.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: <span class="number">16</span>),</span><br><span class="line">            <span class="keyword">self</span>.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -<span class="number">16</span>),</span><br><span class="line">            <span class="keyword">self</span>.centerYAnchor.constraint(equalTo: view.centerYAnchor),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我只需要设置一次 <code>font＆textColor</code> 属性，因此在完成视图初始化之后，我可以确保 <code>TitleLabel</code> 的每个实例看起来都完全相同。 用法也很简单，你只需要在接口构建器中设置类名，或者可以像这样简单地创建视图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadView method in a view controller...</span></span><br><span class="line"><span class="keyword">let</span> titleLabel = <span class="type">TitleLabel</span>()</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(titleLabel)</span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate(titleLabel.constraints(<span class="keyword">in</span>: <span class="keyword">self</span>.view))</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最喜欢这种方法的地方是我的约束将在正确的位置，因此它们不会膨胀我的视图控制器的 <code>loadView</code> 方法。 你还可以根据当前情况使用额外的参数创建多个约束变量，因此它可以针对每种情况进行扩展。 👍</p></br><h1 id="视图初始化很难"><a href="#视图初始化很难" class="headerlink" title="视图初始化很难"></a><strong>视图初始化很难</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该解决方案的缺点是，由于界面构建器的支持，视图初始化有点混乱。 你必须子类化每种视图类型（按钮，标签等），并一次又一次地复制并粘贴初始化方法。 我已经有一些有关此的文章，请查看下面的链接。 👇</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决这个问题，我通常以为自己的样式视图创建一个父类来结束。 这是我的标签的抽象基类的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以从现在开始，我只需要重写 <code>initialize</code> 方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleLabel</span>: <span class="title">Label</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.initialize()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = <span class="type">App</span>.<span class="type">Fonts</span>.title</span><br><span class="line">        <span class="keyword">self</span>.textColor = <span class="type">App</span>.<span class="type">Colors</span>.title</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看，它好多了，因为我不再需要处理所需的视图初始化方法，默认情况下，自动调整大小功能也将关闭。 ❤️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我从本课程中学到的最后一点是，如果涉及到 <code>UIKit</code> 框架，则不必担心类和面向对象的编程。 如果在正确的地方使用面向协议的编程（也就是函数式编程），那将是很好的选择，但是由于 <code>UIKit</code> 确实是一个 <code>OOP</code> 框架，所以我相信遵循这些范式而不是选择某些笨拙的方式还是更好的。 🤪</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> 子类化样式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 子类化样式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 选择和播放视频</title>
      <link href="/Swift%20%E9%80%89%E6%8B%A9%E5%92%8C%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/"/>
      <url>/Swift%20%E9%80%89%E6%8B%A9%E5%92%8C%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用视频选择器控制器和 <code>AVPlayer</code> 类（完全用 <code>Swift 5</code> 编写）来记录或选择视频文件。</p></br><h1 id="让我们挑选一些视频！"><a href="#让我们挑选一些视频！" class="headerlink" title="让我们挑选一些视频！"></a><strong>让我们挑选一些视频！</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你还记得我以前有关 <a href="http://www.xuebaonline.com/Swift%205%E4%BD%BF%E7%94%A8UIImagePickerController%E6%8B%BE%E5%8F%96%E5%9B%BE%E5%83%8F/"><strong><em><code>《iOS中图像拾取》</code></em></strong></a> 的教程，那么你知道我已经在 <code>UIKit</code> 的基础上建立了一个可重用的选择器类。 如果你不知道 <code>UIImagePickerController</code> 类的工作方式，请先阅读该教程，因为它为你提供了有关基础知识的出色概述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，你需要在 <code>Info.plist</code> 文件中添加一些密钥，因为你想访问一些个人数据。 你知道：隐私非常重要。 🤫</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;<span class="type">NSCameraUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to take pictures &amp; videos.&lt;/string&gt;</span><br><span class="line">&lt;key&gt;<span class="type">NSPhotoLibraryUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to use your picture &amp; video library.&lt;/string&gt;</span><br><span class="line">&lt;key&gt;<span class="type">NSMicrophoneUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to record sound.&lt;/string&gt;</span><br><span class="line">&lt;key&gt;<span class="type">NSPhotoLibraryAddUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to save pictures &amp; videos to your library.&lt;/string&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于我们不会捕获无声视频，因此我们还必须添加“隐私-麦克风使用说明”字段。 准备，开始，行动！ 🎬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我不会对你说谎，但是这次我有点懒，所以我们的 <code>VideoPicker</code> 类和 <code>ImagePicker</code> 类是90％。 你可以创建一个抽象类，无论如何，我将向你展示最终代码，然后我们可以讨论它们之间的区别。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">VideoPickerDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didSelect</span><span class="params">(url: URL?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoPicker</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> pickerController: <span class="type">UIImagePickerController</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> presentationController: <span class="type">UIViewController?</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">VideoPickerDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(presentationController: <span class="type">UIViewController</span>, delegate: <span class="type">VideoPickerDelegate</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.pickerController = <span class="type">UIImagePickerController</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presentationController = presentationController</span><br><span class="line">        <span class="keyword">self</span>.delegate = delegate</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.pickerController.delegate = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController.allowsEditing = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController.mediaTypes = [<span class="string">"public.movie"</span>]</span><br><span class="line">        <span class="keyword">self</span>.pickerController.videoQuality = .typeHigh</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(<span class="keyword">for</span> type: UIImagePickerController.SourceType, title: String)</span></span> -&gt; <span class="type">UIAlertAction?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="type">UIImagePickerController</span>.isSourceTypeAvailable(type) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIAlertAction</span>(title: title, style: .<span class="keyword">default</span>) &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.pickerController.sourceType = type</span><br><span class="line">            <span class="keyword">self</span>.presentationController?.present(<span class="keyword">self</span>.pickerController, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(from sourceView: UIView)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="literal">nil</span>, message: <span class="literal">nil</span>, preferredStyle: .actionSheet)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .camera, title: <span class="string">"Take video"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .savedPhotosAlbum, title: <span class="string">"Camera roll"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .photoLibrary, title: <span class="string">"Video library"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        alertController.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"Cancel"</span>, style: .cancel, handler: <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="type">UIDevice</span>.current.userInterfaceIdiom == .pad &#123;</span><br><span class="line">            alertController.popoverPresentationController?.sourceView = sourceView</span><br><span class="line">            alertController.popoverPresentationController?.sourceRect = sourceView.bounds</span><br><span class="line">            alertController.popoverPresentationController?.permittedArrowDirections = [.down, .up]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presentationController?.present(alertController, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">pickerController</span><span class="params">(<span class="number">_</span> controller: UIImagePickerController, didSelect url: URL?)</span></span> &#123;</span><br><span class="line">        controller.dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.delegate?.didSelect(url: url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">VideoPicker</span>: <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pickerController(picker, didSelect: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: <span class="keyword">Any</span>])</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url = info[.mediaURL] <span class="keyword">as</span>? <span class="type">URL</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.pickerController(picker, didSelect: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //uncomment this if you want to save the video file to the media library</span></span><br><span class="line"><span class="comment">//        if UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(url.path) &#123;</span></span><br><span class="line"><span class="comment">//            UISaveVideoAtPathToSavedPhotosAlbum(url.path, self, nil, nil)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController(picker, didSelect: url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">VideoPicker</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅有一些小的变化。 第一个是 <code>mediaTypes</code> 属性，你这次可以使用 <code>“public.movie”</code> 值。 另外，你还应该在 <code>pickerController</code> 上设置 <code>videoQuality</code> 属性，因为 <code>4k</code> 始终优于 <code>320</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;委托是最后一点改变的事情。 选择器完成工作后，你可以获取 <code>.mediaURL</code> 属性，该属性是获取媒体文件（也就是捕获/选定的视频文件）的 <code>URL</code> 。 如果记录了一个新文件，你也可以将其保存到媒体库中，这只是两行额外的代码。</p><p>恭喜，播放时间到了！ 📹</p></br><h1 id="使用AVPlayer和UIView播放视频文件"><a href="#使用AVPlayer和UIView播放视频文件" class="headerlink" title="使用AVPlayer和UIView播放视频文件"></a><strong>使用AVPlayer和UIView播放视频文件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当网页的标题背景中有一些主题很好的视频时，这不是很好吗？好吧，通过使用 <code>AVFoundation</code> ， <code>UIKit</code> 和一些底层魔术，你可以在 <code>iOS</code> 中获得完全相同的东西。不用担心，这并不困难。 😬</p><p>你可以使用常规的 <code>UIView</code> 子类，然后将其默认层替换为 <code>AVPlayerLayer</code> 。这样你就可以在视图中直接播放视频。同样， <code>AVPlayer</code> 只是一个简单的控制器对象，可以管理媒体文件的播放和定时。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最困难的部分是检查媒体文件的状态更改。例如，当我第一次尝试录制新视频时，播放器视图的回报在第二秒后不断停止。我必须搜索答案，因为我根本不是 <code>AVFoundation</code> 专家，但是事实证明，你应该注意 <code>rate</code> 属性，因为系统正在尝试缓冲视频，这可能会引起一些问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，我能够将一个相当不错的 <code>VideoView</code> 与一些不错的附加功能放在一起，例如不断循环播放视频或在填充/适合纵横比内容模式之间进行选择。我并不是在告诉你这是 <code>100％</code> 的防弹解决方案，但这是一个很好的起点，而且在某些情况下还绰绰有余。 👻</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Repeat</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> once</span><br><span class="line">        <span class="keyword">case</span> loop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">layerClass</span>: <span class="title">AnyClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AVPlayerLayer</span>.<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> playerLayer: <span class="type">AVPlayerLayer</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.layer <span class="keyword">as</span>! <span class="type">AVPlayerLayer</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> player: <span class="type">AVPlayer?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.playerLayer.player</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.playerLayer.player = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="keyword">var</span> contentMode: <span class="type">UIView</span>.<span class="type">ContentMode</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> <span class="keyword">self</span>.contentMode &#123;</span><br><span class="line">            <span class="keyword">case</span> .scaleAspectFit:</span><br><span class="line">                <span class="keyword">self</span>.playerLayer.videoGravity = .resizeAspect</span><br><span class="line">            <span class="keyword">case</span> .scaleAspectFill:</span><br><span class="line">                <span class="keyword">self</span>.playerLayer.videoGravity = .resizeAspectFill</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">self</span>.playerLayer.videoGravity = .resize</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> `<span class="keyword">repeat</span>`: <span class="type">Repeat</span> = .once</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> url: <span class="type">URL?</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="keyword">self</span>.url <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.teardown()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.setup(url: url)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(*, unavailable)</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(*, unavailable)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.teardown()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">(url: URL)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player = <span class="type">AVPlayer</span>(playerItem: <span class="type">AVPlayerItem</span>(url: url))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player?.currentItem?.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                              forKeyPath: <span class="string">"status"</span>,</span><br><span class="line">                                              options: [.old, .new],</span><br><span class="line">                                              context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player?.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"rate"</span>, options: [.old, .new], context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                               selector: #selector(<span class="keyword">self</span>.itemDidPlayToEndTime(<span class="number">_</span>:)),</span><br><span class="line">                                               name: .<span class="type">AVPlayerItemDidPlayToEndTime</span>,</span><br><span class="line">                                               object: <span class="keyword">self</span>.player?.currentItem)</span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                               selector: #selector(<span class="keyword">self</span>.itemFailedToPlayToEndTime(<span class="number">_</span>:)),</span><br><span class="line">                                               name: .<span class="type">AVPlayerItemFailedToPlayToEndTime</span>,</span><br><span class="line">                                               object: <span class="keyword">self</span>.player?.currentItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.player?.pause()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player?.currentItem?.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"status"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player?.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"rate"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>,</span><br><span class="line">                                                  name: .<span class="type">AVPlayerItemDidPlayToEndTime</span>,</span><br><span class="line">                                                  object: <span class="keyword">self</span>.player?.currentItem)</span><br><span class="line"></span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>,</span><br><span class="line">                                                  name: .<span class="type">AVPlayerItemFailedToPlayToEndTime</span>,</span><br><span class="line">                                                  object: <span class="keyword">self</span>.player?.currentItem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.player = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">itemDidPlayToEndTime</span><span class="params">(<span class="number">_</span> notification: NSNotification)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span>.<span class="keyword">repeat</span> == .loop <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.player?.seek(to: .zero)</span><br><span class="line">        <span class="keyword">self</span>.player?.play()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">itemFailedToPlayToEndTime</span><span class="params">(<span class="number">_</span> notification: NSNotification)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.teardown()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          of object: <span class="keyword">Any</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> keyPath == <span class="string">"status"</span>, <span class="keyword">let</span> status = <span class="keyword">self</span>.player?.currentItem?.status, status == .failed &#123;</span><br><span class="line">            <span class="keyword">self</span>.teardown()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">            keyPath == <span class="string">"rate"</span>,</span><br><span class="line">            <span class="keyword">let</span> player = <span class="keyword">self</span>.player,</span><br><span class="line">            player.rate == <span class="number">0</span>,</span><br><span class="line">            <span class="keyword">let</span> item = player.currentItem,</span><br><span class="line">            !item.isPlaybackBufferEmpty,</span><br><span class="line">            <span class="type">CMTimeGetSeconds</span>(item.duration) != <span class="type">CMTimeGetSeconds</span>(player.currentTime())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">self</span>.player?.play()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我为你制作了一个示例项目，说实话，我的视图控制器很简单。 它演示了图像拾取和视频捕获功能。 ❤️</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIImagePickerController </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIImagePickerController </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 5使用UIImagePickerController拾取图像</title>
      <link href="/Swift%205%E4%BD%BF%E7%94%A8UIImagePickerController%E6%8B%BE%E5%8F%96%E5%9B%BE%E5%83%8F/"/>
      <url>/Swift%205%E4%BD%BF%E7%94%A8UIImagePickerController%E6%8B%BE%E5%8F%96%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>Swift 5</code> 中的 <code>UIImagePickerController</code> 类从照片库或直接从相机获取图像。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还在寻找视频选择器吗？ 🍿查看我的另一篇有关在 <a href="http://www.xuebaonline.com/Swift%20%E9%80%89%E6%8B%A9%E5%92%8C%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/"><strong><em><code>《iOS中选择和播放视频文件》</code></em></strong></a> 的文章。</p></blockquote></br><h1 id="适用于iOS的可重用图像选择器类"><a href="#适用于iOS的可重用图像选择器类" class="headerlink" title="适用于iOS的可重用图像选择器类"></a><strong>适用于iOS的可重用图像选择器类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在本教程中，我们将创建一个在 <code>UIKit</code> 之上构建的可重用类，以使图像选择对于你的应用程序而言更加愉悦，所有内容均以 <code>Swift 5</code> 编写。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文的灵感来自于我以前尝试以面向协议的方式解决图像拾取问题，但是如今该文章有些过时，而且我不再使用该技术。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;人们总是从过去中学到东西，所以这次我不使用面向协议的方法，而只是使用 <code>ImagePicker</code> 类。 没有单例，没有额外的库，只有一个可以在适当位置实例化的小型帮助程序类可以完成它的工作。 🌄</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我只专注于选择编辑后的图像，如果你想使用实时照片或电影，则始终可以自定义 <code>ImagePicker</code> 类，或创建一个抽象类并为每种媒体类型实现子类。 我也会这样做。 😅</p></blockquote><p>因此，让我们深入研究。</p></br><h1 id="获取隐私权限"><a href="#获取隐私权限" class="headerlink" title="获取隐私权限"></a><strong>获取隐私权限</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，隐私非常重要，因此你必须在应用程序 <code>Info.plist</code> 文件中添加两个重要的键，否则最终将导致可怕的崩溃！ ⚠️</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp1.jpg" alt="Info.plist"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于你要获取一些私人数据，因此必须向用户（和 <code>Apple</code> ）提供说明消息，说明该应用为何要求访问相机和照片库。  <code>NSCameraUsageDescription</code> 用于相机， <code>NSPhotoLibraryUsageDescription</code> 键用于照片库访问。 这两个值都应该是一个简单的字符串，该字符串将向用户解释你为什么需要他/她的裸照。 谨慎很重要！ 🔒</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;<span class="type">NSCameraUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to take pictures.&lt;/string&gt;</span><br><span class="line">&lt;key&gt;<span class="type">NSPhotoLibraryUsageDescription</span>&lt;/key&gt;</span><br><span class="line">&lt;string&gt;<span class="type">This</span> app wants to use your photos.&lt;/string&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，如果你想使用直接从相机拍摄的照片，但又不想访问照片库，则只需添加适当的密钥即可。 就是这样，现在我们准备进行一些实际的编码。 ⌨️</p></br><h1 id="剖析-UIImagePickerController"><a href="#剖析-UIImagePickerController" class="headerlink" title="剖析 UIImagePickerController"></a><strong>剖析 UIImagePickerController</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIPickerController</code> 的结构非常简单。 基本上，它是一个常规的视图控制器，你只需设置一些额外的属性即可使其工作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pickerController = <span class="type">UIImagePickerController</span>()</span><br><span class="line">pickerController.delegate = <span class="keyword">self</span></span><br><span class="line">pickerController.allowsEditing = <span class="literal">true</span></span><br><span class="line">pickerController.mediaTypes = [<span class="string">"public.image"</span>, <span class="string">"public.movie"</span>]</span><br><span class="line">pickerController.sourceType = .camera</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许编辑是一个标志，指示在选择和拍照后是否应显示调整大小和裁剪界面，如果为 <code>true</code> ，则应使用 <code>.editedImage</code> 而不是 <code>.originalImage</code> 键（在选择器委托中），以从中获取正确的图像。图片信息字典。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本上有两种媒体类型可用：图像和电影。你可以通过在选择器上调用类方法来获取每种源类型的可用媒体类型字符串： <code>UIImagePickerController.availableMediaTypes（for：.camera）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共有3种可用的源类型：<code>.camera</code>（即相机），还有另外两个选项可从照片库中获取图片。 <code>.photoLibrary</code> 枚举例将为你提供完全访问权限，但如果选择 <code>.savedPhotosAlbum</code> ，则只能限制相机胶卷的选择范围。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该委托应同时实现 <code>UIImagePickerControllerDelegate</code> 和 <code>UINavigationControllerDelegate</code> 协议，但是通常我的导航控制器委托只是一个空的实现。如果你需要额外的导航相关逻辑，则可能还需要在其中创建一些方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;噢，让我们把所有东西放在一起…</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ImagePickerDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didSelect</span><span class="params">(image: UIImage?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ImagePicker</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> pickerController: <span class="type">UIImagePickerController</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> presentationController: <span class="type">UIViewController?</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">ImagePickerDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(presentationController: <span class="type">UIViewController</span>, delegate: <span class="type">ImagePickerDelegate</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.pickerController = <span class="type">UIImagePickerController</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presentationController = presentationController</span><br><span class="line">        <span class="keyword">self</span>.delegate = delegate</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.pickerController.delegate = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController.allowsEditing = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.pickerController.mediaTypes = [<span class="string">"public.image"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(<span class="keyword">for</span> type: UIImagePickerController.SourceType, title: String)</span></span> -&gt; <span class="type">UIAlertAction?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="type">UIImagePickerController</span>.isSourceTypeAvailable(type) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIAlertAction</span>(title: title, style: .<span class="keyword">default</span>) &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.pickerController.sourceType = type</span><br><span class="line">            <span class="keyword">self</span>.presentationController?.present(<span class="keyword">self</span>.pickerController, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(from sourceView: UIView)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="literal">nil</span>, message: <span class="literal">nil</span>, preferredStyle: .actionSheet)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .camera, title: <span class="string">"Take photo"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .savedPhotosAlbum, title: <span class="string">"Camera roll"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.action(<span class="keyword">for</span>: .photoLibrary, title: <span class="string">"Photo library"</span>) &#123;</span><br><span class="line">            alertController.addAction(action)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        alertController.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"Cancel"</span>, style: .cancel, handler: <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="type">UIDevice</span>.current.userInterfaceIdiom == .pad &#123;</span><br><span class="line">            alertController.popoverPresentationController?.sourceView = sourceView</span><br><span class="line">            alertController.popoverPresentationController?.sourceRect = sourceView.bounds</span><br><span class="line">            alertController.popoverPresentationController?.permittedArrowDirections = [.down, .up]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.presentationController?.present(alertController, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">pickerController</span><span class="params">(<span class="number">_</span> controller: UIImagePickerController, didSelect image: UIImage?)</span></span> &#123;</span><br><span class="line">        controller.dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.delegate?.didSelect(image: image)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImagePicker</span>: <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pickerController(picker, didSelect: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: <span class="keyword">Any</span>])</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = info[.editedImage] <span class="keyword">as</span>? <span class="type">UIImage</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.pickerController(picker, didSelect: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.pickerController(picker, didSelect: image)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImagePicker</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不需要从源类型中进行选择，那么事情就非常简单了，你只需展示你的选择器视图控制器，处理委托中的所有内容即可。 但是，如果你需要从输入源中进行选择，那会涉及更多的逻辑，尤其是在 <code>iPad</code> 上。 📱</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我正在使用 <code>UIAlertController</code> 来组成源类型选择对话框。 我试图添加3个动作（基于选择源类型），但前提是该源类型在给定设备上可用（例如，<code>.camera</code> 在模拟器中不可用）。 你可以通过以下方式检查可用性：<code>UIImagePickerController.isSourceTypeAvailable（type）</code> 。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIAlertController</code> 在 <code>iPad</code> 上需要一些额外的东西，这就是为什么我要在本方法中设置 <code>popoverPresentationController</code> 属性的原因。 通常只需设置 <code>sourceView</code> 和 <code>sourceRect</code> 属性即可，但是你也可以自定义箭头方向。 ⬅️➡️⬆️⬇️</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检查设备是否为 ··· 并设置正确的源代码视图并根据需要进行调整一直是你的任务，否则你的应用将在 <code>iPad</code> 上崩溃。 另一件事是，在选择器完成工作后，你必须弹出 ··· ！ ⚠️</p></br><h1 id="如何使用图像选择器类？"><a href="#如何使用图像选择器类？" class="headerlink" title="如何使用图像选择器类？"></a><strong>如何使用图像选择器类？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，现在你可以拍照了。 我做了一个简单的视图控制器，向你展示了一个真正的快速示例。 你只需要一个 <code>UIImageView</code> 和一个 <code>UIButton</code> 。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp2-1.jpg" alt="UIImageView"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，这是示例视图控制器的代码。 没什么了不起的，我只是将控制器作为 <code>ImagePicker</code> 的 <code>presentationController</code> 进行传递，因此它可以在此之上呈现 <code>UIImagePickerController</code> 。 我将代表从表示控制器中分离出来，因为有时会派上用场。 🤷‍♂️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> imagePicker: <span class="type">ImagePicker!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imagePicker = <span class="type">ImagePicker</span>(presentationController: <span class="keyword">self</span>, delegate: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">showImagePicker</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.imagePicker.present(from: sender)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">ImagePickerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didSelect</span><span class="params">(image: UIImage?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下， <code>ImagePickerDelegate</code> 委托是我能想到的最简单的委托。 它只是给出选择的图像，因此你可以使用它。 但是，在某些情况下，你可能需要图像选择器提供一些附加信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想进一步采取这种方法，则可以创建定义基本功能的抽象类或协议，并在此基础上实现各种媒体选择器控制器以满足你的需求。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UIImagePickerController </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIImagePickerController </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中的UITableView教程</title>
      <link href="/Swift%E4%B8%AD%E7%9A%84UITableView%E6%95%99%E7%A8%8B/"/>
      <url>/Swift%E4%B8%AD%E7%9A%84UITableView%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本指南是供初学者通过 <code>Swift</code> 中的自动布局以编程方式学习 <code>UITableView</code> 类的基础的。</p></br><h1 id="如何以代码方式创建表视图？"><a href="#如何以代码方式创建表视图？" class="headerlink" title="如何以代码方式创建表视图？"></a><strong>如何以代码方式创建表视图？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们直接进入编码部分，但首先：启动 <code>Xcode</code> ，创建一个新的 <code>iOS</code> 单视图应用程序项目，像往常一样输入该项目的名称和详细信息，使用 <code>Swift</code> ，最后立即打开 <code>ViewController.swift</code> 文件。 现在抓住键盘！ ⌨️</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本教程中，我不会使用 <code>Interface Builder</code> ，那么我们如何以代码方式创建视图？ 有一个称为 <code>loadView</code> 的方法，你应该在其中将自定义视图添加到视图层次结构中。 你可以选择+单击Xcode中的方法名称并阅读有关 <code>loadView</code> 方法的讨论，但让我总结一下整个过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将使用弱属性来保存对表格视图的引用。 接下来，我们重写 <code>loadView</code> 方法并调用 <code>super</code> ，以使用视图对象（如果有控制器的话，在 <code>nib or a storyboard</code> 文件中）加载控制器的 <code>self.view</code> 属性。 之后，我们将全新的视图分配给本地属性，关闭系统提供的布局，然后将表视图插入到视图层次结构中。 最后，我们使用锚创建一些实际的约束，并保存指向弱属性的指针。 简单！ 🤪</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tableView: <span class="type">UITableView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> tableView = <span class="type">UITableView</span>(frame: .zero, style: .plain)</span><br><span class="line">        tableView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(tableView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">        <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor.constraint(equalTo: tableView.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: tableView.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.leadingAnchor.constraint(equalTo: tableView.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.trailingAnchor.constraint(equalTo: tableView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.tableView = tableView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;始终使用自动布局锚来指定视图约束，如果你不知道如何使用它们，请查看 <a href="http://www.xuebaonline.com/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/"><strong><em><code>《Swift使用布局锚点添加约束》</code></em></strong></a>，学习此 <code>API</code> 仅需15分钟，并且你不会后悔。 对于任何 <code>iOS</code> 开发者来说，这都是一个非常有用的工具！ 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会问：我应该使用弱属性还是强属性作为视图引用？ 我会说，在大多数情况下，如果你不压制 <code>self.view</code> ，则应使用弱项！ 视图层次结构将通过强大的参考来保存你的自定义视图，因此不需要愚蠢的保留周期和内存泄漏。 相信我！ 🤥</p></br><h1 id="UITableView-DataSource"><a href="#UITableView-DataSource" class="headerlink" title="UITableView DataSource"></a><strong>UITableView DataSource</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，我们有一个空的表格视图，让我们显示一些单元格！ 为了用真实数据填充表格视图，我们必须遵守 <code>UITableViewDataSource</code> 协议。 通过简单的委托模式，我们可以为 <code>UITableView</code> 类提供各种信息，因此它将知道需要多少节和行，应该为每行显示哪种单元格以及更多的小细节。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一件事是，<code>UITableView</code> 是一个非常有效的类。 它会重用当前屏幕上未显示的所有单元格，因此，如果你需要处理数百或数千个项目，它将消耗比 <code>UIScrollView</code> 更少的内存。 为了支持这种行为，我们必须使用重用标识符注册我们的单元格类，因此基础系统将知道特定位置需要哪种单元格。 ⚙️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">String</span>] = [</span><br><span class="line">        <span class="string">"👽"</span>, <span class="string">"🐱"</span>, <span class="string">"🐔"</span>, <span class="string">"🐶"</span>, <span class="string">"🦊"</span>, <span class="string">"🐵"</span>, <span class="string">"🐼"</span>, <span class="string">"🐷"</span>, <span class="string">"💩"</span>, <span class="string">"🐰"</span>,</span><br><span class="line">        <span class="string">"🤖"</span>, <span class="string">"🦄"</span>, <span class="string">"🐻"</span>, <span class="string">"🐲"</span>, <span class="string">"🦁"</span>, <span class="string">"💀"</span>, <span class="string">"🐨"</span>, <span class="string">"🐯"</span>, <span class="string">"👻"</span>, <span class="string">"🦖"</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.tableView.register(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"UITableViewCell"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"UITableViewCell"</span>, <span class="keyword">for</span>: indexPath)</span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.items[indexPath.item]</span><br><span class="line">        cell.textLabel?.text = item</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的视图控制器文件中添加几行代码后，表格视图现在可以显示一个漂亮的表情符号列表！ 我们正在使用 <code>UIKit</code> 的内置 <code>UITableViewCell</code> 类，如果你很好地使用 <code>“iOS-system-like”</code> 的单元格设计，那么它将非常方便。 通过告诉我们的节中有多少项（目前只有一个节），我们还符合数据源协议，并在 <code>indexPath</code> 委托方法的行中为行配置了我们的单元格。 😎</p></br><h1 id="自定义UItableViewCell"><a href="#自定义UItableViewCell" class="headerlink" title="自定义UItableViewCell"></a><strong>自定义UItableViewCell</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UITableViewCell</code> 可以提供一些基本元素来显示数据（标题，详细信息，不同样式的图像），但是通常你需要自定义设计的单元格。 这是自定义单元格子类的基本模板，在代码之后，我将解释所有方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>, reuseIdentifier: <span class="type">String?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    override func awakeFromNib() &#123;</span></span><br><span class="line"><span class="comment">        super.awakeFromNib()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>如果要以编程方式使用默认的UITableViewCell</code> ，但使用不同的样式（在初始化单元格后没有设置 <code>cellStyle</code> 的选项），则 <code>init（style：reuseIdentifier</code>） 方法是重写单元格样式属性的好地方。 例如，如果你需要一个 <code>.value1</code> 样式的单元格，只需将参数直接传递给超级调用即可。 这样，你可以使用 <code>4</code> 种预定义的单元格样式。</p><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还必须实现 <code>init（coder :)</code>，所以你应该创建一个通用的 <code>initialize（）</code> 函数，在其中你可以在视图层次结构中添加自定义视图，就像我们在上面的 <code>loadView</code> 方法中所做的那样。 如果使用的是 <code>xib</code> 文件和 <code>IB</code> ，则可以使用 <code>awakeFromNib</code> 方法通过标准 <code>@IBOutlet</code> 属性为视图添加额外的样式（或向层次结构中添加额外的视图）。 👍</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要讨论的最后一个方法是 <code>prepareForReuse</code> 。 正如我之前提到的，单元格被重用，因此，如果要重置某些属性（例如单元格的背景），可以在此处进行操作。 在单元将被重用之前将调用此方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们创建两个新的单元格子类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>, reuseIdentifier: <span class="type">String?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(style: .subtitle, reuseIdentifier: reuseIdentifier)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// nothing to do here :)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel?.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel?.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.imageView?.image = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的自定义单元格将具有大的图像背景，并在视图的中心添加一个带有自定义大小的系统字体的标题标签。 另外，我已将 S<code>wift logo</code> 作为 <code>asset</code> 添加到项目中，因此我们可以得到一个不错的演示图像。 🖼</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> coverView: <span class="type">UIImageView!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> titleLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCell</span>.<span class="type">CellStyle</span>, reuseIdentifier: <span class="type">String?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> coverView = <span class="type">UIImageView</span>(frame: .zero)</span><br><span class="line">        coverView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(coverView)</span><br><span class="line">        <span class="keyword">self</span>.coverView = coverView</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> titleLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        titleLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(titleLabel)</span><br><span class="line">        <span class="keyword">self</span>.titleLabel = titleLabel</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.coverView.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.coverView.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.coverView.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.coverView.trailingAnchor),</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.contentView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.titleLabel.centerXAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.titleLabel.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.titleLabel.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.coverView.image = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，让我们开始使用这些新单元格。 我什至会告诉你如何为给定单元格设置自定义高度，以及如何正确处理单元格选择，但是首先我们需要了解另一个委托协议。 🤝</p></br><h1 id="UITableViewDelegate-使用"><a href="#UITableViewDelegate-使用" class="headerlink" title="UITableViewDelegate 使用"></a><strong>UITableViewDelegate 使用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UITableViewDelegate</code> 负责很多事情，但是现在，我们将只讨论一些有趣的方面，例如如何处理单元格选择以及为表格中的每个项目提供自定义单元格高度。 示例代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.tableView.register(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"UITableViewCell"</span>)</span><br><span class="line">            <span class="keyword">self</span>.tableView.register(<span class="type">DetailCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"DetailCell"</span>)</span><br><span class="line">            <span class="keyword">self</span>.tableView.register(<span class="type">CustomCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"CustomCell"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">            <span class="keyword">self</span>.tableView.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"CustomCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">CustomCell</span></span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.items[indexPath.item]</span><br><span class="line">        cell.titleLabel.text = item</span><br><span class="line">        cell.coverView.image = <span class="type">UIImage</span>(named: <span class="string">"Swift"</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">128</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        tableView.deselectRow(at: indexPath, animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.items[indexPath.item]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: item, message: <span class="string">"is in da house!"</span>, preferredStyle: .alert)</span><br><span class="line">        <span class="keyword">let</span> action = <span class="type">UIAlertAction</span>(title: <span class="string">"Ok"</span>, style: .<span class="keyword">default</span>) &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;</span><br><span class="line">        alertController.addAction(action)</span><br><span class="line">        <span class="keyword">self</span>.present(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我正在 <code>viewDidLoad</code> 方法中注册全新的自定义单元格类。 我还更改了 <code>cellForRowAt indexPath</code> 方法中的代码，因此我们可以使用 <code>CustomCell</code> 类代替 <code>UITableViewCells</code> 。 不必担心强制转换，如果此时出现问题，你的应用程序应该崩溃。 🙃</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在这里使用两种委托方法。 在第一个中，我们必须返回一个数字，系统将使用该高度作为单元格。 如果要在每行中使用不同的单元格高度，则也可以通过检查 <code>indexPath</code> 属性或类似属性来实现。 第二个是选择的处理程序。 如果有人点击某个单元格，则将调用此方法，你可以执行一些操作。</p></br><h1 id="带标题和页脚的-Section"><a href="#带标题和页脚的-Section" class="headerlink" title="带标题和页脚的 Section"></a><strong>带标题和页脚的 Section</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表格视图中可能有多个部分，我不会赘述，因为它非常简单。 你只需要使用 <code>indexPaths</code> 即可获取/设置/返回每个节和单元格的正确数据。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tableView: <span class="type">UITableView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> placeholderView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">    <span class="keyword">var</span> isPullingDown = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> `<span class="keyword">default</span>`</span><br><span class="line">        <span class="keyword">case</span> subtitle</span><br><span class="line">        <span class="keyword">case</span> custom</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> style = <span class="type">Style</span>.<span class="keyword">default</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">String</span>: [<span class="type">String</span>]] = [</span><br><span class="line">        <span class="string">"Originals"</span>: [<span class="string">"👽"</span>, <span class="string">"🐱"</span>, <span class="string">"🐔"</span>, <span class="string">"🐶"</span>, <span class="string">"🦊"</span>, <span class="string">"🐵"</span>, <span class="string">"🐼"</span>, <span class="string">"🐷"</span>, <span class="string">"💩"</span>, <span class="string">"🐰"</span>,<span class="string">"🤖"</span>, <span class="string">"🦄"</span>],</span><br><span class="line">        <span class="string">"iOS 11.3"</span>: [<span class="string">"🐻"</span>, <span class="string">"🐲"</span>, <span class="string">"🦁"</span>, <span class="string">"💀"</span>],</span><br><span class="line">        <span class="string">"iOS 12"</span>: [<span class="string">"🐨"</span>, <span class="string">"🐯"</span>, <span class="string">"👻"</span>, <span class="string">"🦖"</span>],</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> tableView = <span class="type">UITableView</span>(frame: .zero, style: .plain)</span><br><span class="line">        tableView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(tableView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor.constraint(equalTo: tableView.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: tableView.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.leadingAnchor.constraint(equalTo: tableView.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.trailingAnchor.constraint(equalTo: tableView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.tableView = tableView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.tableView.register(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"UITableViewCell"</span>)</span><br><span class="line">        <span class="keyword">self</span>.tableView.register(<span class="type">DetailCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"DetailCell"</span>)</span><br><span class="line">        <span class="keyword">self</span>.tableView.register(<span class="type">CustomCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"CustomCell"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.tableView.delegate = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.tableView.separatorStyle = .singleLine</span><br><span class="line">        <span class="keyword">self</span>.tableView.separatorColor = .lightGray</span><br><span class="line">        <span class="keyword">self</span>.tableView.separatorInset = .zero</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.navigationItem.rightBarButtonItem = .<span class="keyword">init</span>(barButtonSystemItem: .refresh, target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.toggleCells))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">toggleCells</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>.style &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">self</span>.style = .subtitle</span><br><span class="line">        <span class="keyword">case</span> .subtitle:</span><br><span class="line">            <span class="keyword">self</span>.style = .custom</span><br><span class="line">        <span class="keyword">case</span> .custom:</span><br><span class="line">            <span class="keyword">self</span>.style = .<span class="keyword">default</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">self</span>.tableView.reloadData()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - helpers</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">key</span><span class="params">(<span class="keyword">for</span> section: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> keys = <span class="type">Array</span>(<span class="keyword">self</span>.items.keys).sorted &#123; first, last -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> first == <span class="string">"Originals"</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> first &lt; last</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> key = keys[section]</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">items</span><span class="params">(<span class="keyword">in</span> section: Int)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> key = <span class="keyword">self</span>.key(<span class="keyword">for</span>: section)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.items[key]!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">item</span><span class="params">(at indexPath: IndexPath)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> items = <span class="keyword">self</span>.items(<span class="keyword">in</span>: indexPath.section)</span><br><span class="line">        <span class="keyword">return</span> items[indexPath.item]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.items.keys.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.items(<span class="keyword">in</span>: section).<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.item(at: indexPath)</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"CustomCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">CustomCell</span></span><br><span class="line">        cell.titleLabel.text = item</span><br><span class="line">        cell.coverView.image = <span class="type">UIImage</span>(named: <span class="string">"Swift"</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, titleForHeaderInSection section: Int)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.key(<span class="keyword">for</span>: section)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">128</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, didSelectRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        tableView.deselectRow(at: indexPath, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> item = <span class="keyword">self</span>.item(at: indexPath)</span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: item, message: <span class="string">"is in da house!"</span>, preferredStyle: .alert)</span><br><span class="line">        <span class="keyword">let</span> action = <span class="type">UIAlertAction</span>(title: <span class="string">"Ok"</span>, style: .<span class="keyword">default</span>) &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;</span><br><span class="line">        alertController.addAction(action)</span><br><span class="line">        <span class="keyword">self</span>.present(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管上面的代码片段中添加了一个有趣的内容。 你可以为每个部分都有一个自定义标题，只需添加 <code>titleForHeaderInSection</code> 数据源方法即可。 是的，看起来像狗屎一样，但这与 <code>UI / UX</code> 无关。 😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果你对部分标题的布局不满意，可以创建一个自定义类并使用它来代替内置类。 这是执行自定义节标题视图的方法。 这是可重用视图的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeaderView</span>: <span class="title">UITableViewHeaderFooterView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> titleLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(reuseIdentifier: <span class="type">String?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(reuseIdentifier: reuseIdentifier)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> titleLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        titleLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(titleLabel)</span><br><span class="line">        <span class="keyword">self</span>.titleLabel = titleLabel</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.titleLabel.centerXAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.titleLabel.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.contentView.backgroundColor = .black</span><br><span class="line">        <span class="keyword">self</span>.titleLabel.font = <span class="type">UIFont</span>.boldSystemFont(ofSize: <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">self</span>.titleLabel.textAlignment = .center</span><br><span class="line">        <span class="keyword">self</span>.titleLabel.textColor = .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只剩下几件事要做，你必须注册标题视图，就像你为单元格所做的一样。 完全相同，只是页眉和页脚视图有一个单独的注册“池”。 最后，你必须实现两个其他但相对简单（和熟悉）的委托方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This goes to viewDidLoad, but I don't want to embedd that much code... :)</span></span><br><span class="line"><span class="comment">// self.tableView.register(HeaderView.self, forHeaderFooterViewReuseIdentifier: "HeaderView")</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">32</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, viewForHeaderInSection section: Int)</span></span> -&gt; <span class="type">UIView?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view = tableView.dequeueReusableHeaderFooterView(withIdentifier: <span class="string">"HeaderView"</span>) <span class="keyword">as</span>! <span class="type">HeaderView</span></span><br><span class="line">        view.titleLabel.text = <span class="keyword">self</span>.key(<span class="keyword">for</span>: section)</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>页脚的工作原理与页眉完全相同，只需支持相应的数据源和委托方法即可。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据行或节的索引或任何特定的业务需求，你甚至可以在同一张表视图中具有多个单元格。 我不会在这里进行演示，因为我有一个更好的解决方案，用于混合和重用 <a href="https://gitlab.com/corekit/CoreKit" target="_blank" rel="noopener"><strong><em><code>CoreKit</code></em></strong></a> 框架中的单元格。  🤓</p></br><h1 id="Section-titles-amp-indexes"><a href="#Section-titles-amp-indexes" class="headerlink" title="Section titles &amp; indexes"></a><strong>Section titles &amp; indexes</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，如果你的大脑还没有融化，我将向你展示另外两个对于初学者来说可能很有趣的小东西。 第一个基于两种其他数据源方法，对于长列表而言，这是一个非常令人愉快的添加。 （我更喜欢搜索栏！）🤯</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sectionIndexTitles</span><span class="params">(<span class="keyword">for</span> tableView: UITableView)</span></span> -&gt; [<span class="type">String</span>]? &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要在上面实现这些方法，则可以在表视图的右侧为各节提供一个小的索引视图，因此最终用户将能够在各节之间快速跳转。 就像在官方联系人应用程序中一样。 📕</p></br><h1 id="Selection-vs-highlight"><a href="#Selection-vs-highlight" class="headerlink" title="Selection vs highlight"></a><strong>Selection vs highlight</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你用手指按住单元格时，单元格高亮。 如果你从单元格中松开手指，则将选择该单元格。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要过于复杂。 你只需在自定义单元格类中实现两个方法即可使所有工作正常进行。 我更喜欢立即取消选择我的单元格（如果某些数据选择器布局未使用它们）。 这是代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setSelected</span><span class="params">(<span class="number">_</span> selected: Bool, animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.coverView.backgroundColor = selected ? .red : .clear</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setHighlighted</span><span class="params">(<span class="number">_</span> highlighted: Bool, animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.coverView.backgroundColor = highlighted ? .blue : .clear</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，这非常简单，但是大多数初学者都不知道该怎么做。 此外，他们通常会在重用逻辑发生之前忘记重置单元格，因此列表会不断弄乱单元格状态。 不必太担心这些问题，它们会消失，因为你将对 <code>UITableView API</code> 更有经验。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UITableView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UITableView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift结合Xib文件自定义UIView</title>
      <link href="/Swift%E7%BB%93%E5%90%88Xib%E6%96%87%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89UIView/"/>
      <url>/Swift%E7%BB%93%E5%90%88Xib%E6%96%87%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89UIView/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是否想学习如何加载 <code>xib</code> 文件以创建自定义视图对象？ 好吧，这个 <code>UIKit</code> 教程只适合你用 <code>Swift</code> 编写。</p><p><strong><em>使用界面生成器创建自定义视图。🤷‍♂️</em></strong></p></br><h1 id="加载-Xib-文件"><a href="#加载-Xib-文件" class="headerlink" title="加载 Xib 文件"></a><strong>加载 <code>Xib</code> 文件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>xib</code> 文件的内容是一件非常容易的事。 你可以使用以下两种方法来加载文件的内容（也称为视图层次结构）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view = <span class="type">UINib</span>(nibName: <span class="string">"CustomView"</span>, bundle: .main).instantiate(withOwner: <span class="literal">nil</span>, options: <span class="literal">nil</span>).first <span class="keyword">as</span>! <span class="type">UIView</span></span><br><span class="line"><span class="comment">// let view = Bundle.main.loadNibNamed("CustomView", owner: nil, options: nil)!.first as! UIView // does the same as above</span></span><br><span class="line">view.frame = <span class="keyword">self</span>.view.bounds</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(view)</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码片段将简单地从 <code>xib</code> 文件中实例化视图对象。 你可以在视图层次结构中拥有多个根对象，但是这次让我们选择第一个并使用它。 我假设在 <code>99％</code> 的情况下，这是获取定制设计视图所需的条件。 你还可以使用上述任何解决方案扩展 <code>UIView</code> 对象，以创建通用视图加载器。 以后再说吧…😊</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法非常简单且便宜，但是有一个小缺点。 你无法获取视图的命名指针（出口），而只能获取根对象。 如果你将设计元素放到屏幕上，那很好，但是如果你需要显示动态数据，那么你可能还希望伸手去拿基础视图。 😃</p></br><h1 id="Outlets-amp-Actions-自定义视图"><a href="#Outlets-amp-Actions-自定义视图" class="headerlink" title="Outlets &amp; Actions 自定义视图"></a><strong><code>Outlets &amp; Actions</code> 自定义视图</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，从 <code>xib</code> 文件加载自定义视图的正确方法如下所示：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你的自定义视图对象中，你实例化 <code>xib</code> 文件的方式与我在此处告诉你的方式完全相同。 👆唯一的区别是你不需要使用方法返回的对象数组，而必须通过接口构建器连接视图对象，使用文件所有者作为参考点，再加上自定义容器视图出口， 它将包含你需要的一切。 🤨</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note: view object is from my previous tutorial, with autoresizing masks disabled</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this is going to be our container object</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> containerView: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// other usual outlets</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.initialize()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first: load the view hierarchy to get proper outlets</span></span><br><span class="line">        <span class="keyword">let</span> name = <span class="type">String</span>(describing: type(of: <span class="keyword">self</span>))</span><br><span class="line">        <span class="keyword">let</span> nib = <span class="type">UINib</span>(nibName: name, bundle: .main)</span><br><span class="line">        nib.instantiate(withOwner: <span class="keyword">self</span>, options: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next: append the container to our view</span></span><br><span class="line">        <span class="keyword">self</span>.addSubview(<span class="keyword">self</span>.containerView)</span><br><span class="line">        <span class="keyword">self</span>.containerView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.containerView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.containerView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.containerView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.containerView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，这里的 <code>initialize</code> 方法只是将 <code>self</code> 的所有者加载到 <code>nib</code> 文件中。 加载过程完成后，将使用 <code>xib文件</code> 中的适当值填充出口指针。 我们需要做的最后一件事。 甚至 <code>xib文件</code> 中的视图都 <code>“以编程方式”</code> 连接到我们的自定义视图对象，但从视觉上看并不是这样。 因此，我们必须将容器视图添加到视图层次结构中。 🤐</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xu-stp1.jpg" alt="xib文件"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要使用自定义视图对象，只需在视图控制器内部从该对象创建一个新实例，最后随意将其添加为子视图！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建议使用自动布局。😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> customView: <span class="type">CustomView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> customView = <span class="type">CustomView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(customView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            customView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.topAnchor),</span><br><span class="line">            customView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.bottomAnchor),</span><br><span class="line">            customView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.leadingAnchor),</span><br><span class="line">            customView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.customView = customView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.customView.textLabel.text = <span class="string">"Lorem ipsum"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，现在你有了一个可以正常工作的自定义 <code>UIView</code> 对象，该对象可以加载 <code>xib</code> 文件以使用其内容。  🤪</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一件事。 如果你不喜欢以编程方式处理视图，或者只是不想弄乱 <code>loadView</code> 方法，只需将其完全删除即可。 接下来，将 <code>@IBOutlet</code> 关键字放在自定义视图类变量之前。 使用 <code>IB</code> 打开情节提要，然后将新的 <code>UIView</code> 元素拖放到控制器上并连接自定义视图插座。 💫</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xu-stp2.png" alt="xib文件"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们来谈谈 <code>IBAction</code> ，它们的工作原理与你期望使用控制器时完全相同。 你可以简单地将按钮连接到自定义视图，然后将操作委派给自定义视图类。 如果要将触摸或特定操作转发给控制器，则应使用委托模式或使用简单的块。 😎</p></br><h1 id="所有权-容器视图"><a href="#所有权-容器视图" class="headerlink" title="所有权/容器视图"></a><strong>所有权/容器视图</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以从视图实例中省略所有 <code>xib</code> 加载机制。 我们可以创建一组扩展，以便拥有一个漂亮的视图加载器，并带有来自 <code>xib</code> 文件的自定义视图类。 这样，你就不再需要容器视图，文件所有者也可以从游戏中删除，这与 <code>Apple</code> 创建的表和集合的可重用单元格大致相同。 🍎</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你应该知道，以这种方式你将无法再以编程方式使用默认的 <code>UIView</code> 初始化方法，因为xib文件将负责初始化过程。 同样，如果你尝试使用情节提要或 <code>xib</code> 文件中的这种自定义视图，则将无法使用出口，因为不会加载视图类的对应 <code>xib</code> 。 否则，如果你尝试多次加载它，则会陷入无限循环，最终你的应用程序将崩溃。 😈</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UINib</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">instantiate</span><span class="params">()</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.instantiate(withOwner: <span class="literal">nil</span>, options: <span class="literal">nil</span>).first</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nib: <span class="type">UINib</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UINib</span>(nibName: <span class="type">String</span>(describing: <span class="keyword">self</span>), bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">instantiate</span><span class="params">(autolayout: Bool = <span class="literal">true</span>)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="comment">// generic helper function</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">instantiateUsingNib</span>&lt;T: UIView&gt;<span class="params">(autolayout: Bool)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> view = <span class="keyword">self</span>.nib.instantiate() <span class="keyword">as</span>! <span class="type">T</span></span><br><span class="line">            view.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">            <span class="keyword">return</span> view</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingNib(autolayout: autolayout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage (inside a view controller for example)</span></span><br><span class="line"><span class="comment">// let view = CustomView.instantiate()</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像这次使用表或集合视图单元格一样，你必须在视图对象而不是文件所有者上设置自定义视图类。 你必须连接网点，基本上你已完成了所有工作。 🤞</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xu-stp3.png" alt="xib文件"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从现在开始，你应该始终在自定义视图对象上使用实例化方法。 好消息是该函数是通用的，返回正确的实例类型，并且高度可重用。 哦，顺便说一句。 我已经提到了坏消息…🤪</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过重写 <code>awakeAfter</code> 还有另一种技术，但是我不再依赖该解决方案了。 在大多数情况下，你只需将“文件的所有者”设置为自定义视图，然后使用一个容器，这是一个安全的选择。 如果你有特殊需要，则可能需要第二种方法，但是请谨慎使用。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自定义UIView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UICollectionView data source and delegates</title>
      <link href="/UICollectionView%20data%20source%20and%20delegates/"/>
      <url>/UICollectionView%20data%20source%20and%20delegates/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个快速的 <code>UIKit</code> 教程中，我将向你展示如何在不使用 <code>Interface Builder</code> 而是仅使用 <code>Swift</code> 的情况下创建简单的 <code>UICollectionView</code> 。</p></br><h1 id="UICollectionViewCell-纯代码实现"><a href="#UICollectionViewCell-纯代码实现" class="headerlink" title="UICollectionViewCell 纯代码实现"></a><strong><code>UICollectionViewCell</code> 纯代码实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要向单元格中添加视图，则应使用 <code>init（frame :)</code> 方法，并在那里设置视图层次结构。 而不是 <code>awakeFromNib</code> ，你也应该在 <code>init</code> 方法中设置视图的样式。 你可以在常规的 <code>prepareForReuse</code> 方法中重置所有内容。 如你所见，有时使用锚点值得完全抛弃 <code>IB</code> 。 🎉</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> identifier: <span class="type">String</span> = <span class="string">"Cell"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> textLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        textLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(textLabel)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerXAnchor.constraint(equalTo: textLabel.centerXAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.centerYAnchor.constraint(equalTo: textLabel.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.textLabel = textLabel</span><br><span class="line">        <span class="keyword">self</span>.reset()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line">        <span class="keyword">self</span>.reset()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.textLabel.textAlignment = .center</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="UICollectionView-纯代码创建"><a href="#UICollectionView-纯代码创建" class="headerlink" title="UICollectionView 纯代码创建"></a><strong><code>UICollectionView</code> 纯代码创建</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅使用 <code>Swift</code> 代码创建集合视图控制器仅需要几行。 你可以实现 <code>loadView</code> 并在那里创建你的 <code>UICollectionView</code> 对象。 将其的弱引用存储在控制器内部，其余部分相同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data: [<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">0</span>..&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> collectionView = <span class="type">UICollectionView</span>(frame: .zero, collectionViewLayout: <span class="type">UICollectionViewFlowLayout</span>())</span><br><span class="line">        collectionView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(collectionView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.view.topAnchor.constraint(equalTo: collectionView.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.bottomAnchor.constraint(equalTo: collectionView.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.leadingAnchor.constraint(equalTo: collectionView.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.view.trailingAnchor.constraint(equalTo: collectionView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView = collectionView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView.dataSource = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.delegate = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.register(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="type">Cell</span>.identifier)</span><br><span class="line">        <span class="keyword">self</span>.collectionView.alwaysBounceVertical = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.backgroundColor = .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.data.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="type">Cell</span>.identifier, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">self</span>.data[indexPath.item]</span><br><span class="line">        cell.textLabel.text = <span class="type">String</span>(data)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegateFlowLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        sizeForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.bounds.width, height: <span class="number">44</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        insetForSectionAt section: Int)</span></span> -&gt; <span class="type">UIEdgeInsets</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIEdgeInsets</span>(top: <span class="number">0</span>, <span class="keyword">left</span>: <span class="number">0</span>, bottom: <span class="number">0</span>, <span class="keyword">right</span>: <span class="number">0</span>) <span class="comment">//.zero</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumInteritemSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumLineSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那很简单。 <code>Anchors</code> 确实非常强大， <code>Interface Builder</code> 很有帮助，但是有时从代码创建视图只是更快。 选择是你的，但请不要担心对用户界面进行编码！ 😅</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
          <category> UICollectionView </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UICollectionView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中UIColor最佳实践</title>
      <link href="/Swift%E4%B8%ADUIColor%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/Swift%E4%B8%ADUIColor%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解什么是颜色模型，如何将十六进制值转换为 <code>UIColor</code> 并返回，如何生成随机颜色，以及在哪里可以找到漂亮的调色板。</p></br><h1 id="什么是色彩模型和色彩空间？"><a href="#什么是色彩模型和色彩空间？" class="headerlink" title="什么是色彩模型和色彩空间？"></a><strong>什么是色彩模型和色彩空间？</strong></h1><p>色彩模型是描述颜色的方法。</p><ul><li>RGB-红色+绿色+蓝色</li><li>HSB-色相+饱和度+亮度</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有其他几种颜色模型，但是如果你要处理 <code>iOS</code> 颜色，则应该熟悉上面的两种。 通常，你将使用 <code>RGBA</code> 和 <code>HSBA</code> 颜色模型，这些颜色模型基本上与上面的扩展相同，其中字母A代表字母 <code>Alpha</code> 。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色彩空间是可以在介质中显示或复制的一组颜色（无论是存储，打印还是显示）。 例如，<code>sRGB</code> 是红色，绿色和蓝色的一组特定强度，它定义了可以通过混合红色，绿色和蓝色的这些范围来再现的颜色。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从理论上已经足够，让我们做一些色彩魔术吧！ 💫💫💫</p><a id="more"></a></br><h1 id="如何在-Swift-中使用-RGBA-和-HSBA-值处理-UIColor-对象？"><a href="#如何在-Swift-中使用-RGBA-和-HSBA-值处理-UIColor-对象？" class="headerlink" title="如何在 Swift 中使用 RGBA 和 HSBA 值处理 UIColor 对象？"></a><strong>如何在 <code>Swift</code> 中使用 <code>RGBA</code> 和 <code>HSBA</code> 值处理 <code>UIColor</code> 对象？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还记得旧的 <code>Windows</code> 时代的旧 <code>Paint</code> 程序吗？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我经常使用 <code>Microsoft Paint</code> ，并且喜欢它。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那时，在没有任何 <code>CS</code> 知识的情况下，我一直想知道必须选择的0到255之间的数字。 如果你使用 <code>RGB</code> 颜色，通常会以相同的方式定义颜色，除了在 <code>iOS</code> 中，值介于0和1之间，但这只是 <code>255</code> 的一部分的不同表示。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，你可以使用相同的逻辑使用 <code>RGB</code> 代码制作颜色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIColor</span>(red: <span class="type">CGFloat</span>(<span class="number">128</span>)/<span class="type">CGFloat</span>(<span class="number">255</span>),</span><br><span class="line">        green: <span class="type">CGFloat</span>(<span class="number">128</span>)/<span class="type">CGFloat</span>(<span class="number">255</span>),</span><br><span class="line">        blue: <span class="type">CGFloat</span>(<span class="number">128</span>)/<span class="type">CGFloat</span>(<span class="number">255</span>),</span><br><span class="line">        alpha: <span class="number">1</span>)</span><br><span class="line"><span class="comment">// this is just about the same gray color but it's more readable</span></span><br><span class="line"><span class="type">UIColor</span>(red: <span class="number">0.5</span>, green: <span class="number">0.5</span>, blue: <span class="number">0.5</span>, alpha: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，你也可以使用HSB值，几乎相同的逻辑适用于这些值，除了色相从 <code>0&#39;</code> 到 <code>360</code>（由于实际的色轮）之外，但是饱和度和亮度以“百分比百分比”格式 <code>0-100</code> 进行测量 ，因此，如果将它们映射到浮点值，则必须考虑这些数字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIColor</span>(hue: <span class="type">CGFloat</span>(<span class="number">120</span>)/<span class="type">CGFloat</span>(<span class="number">360</span>), saturation: <span class="number">0.5</span>, brightness: <span class="number">0.5</span>, alpha: <span class="number">1</span>)</span><br><span class="line"><span class="type">UIColor</span>(hue: <span class="number">0.3</span>, saturation: <span class="number">0.5</span>, brightness: <span class="number">0.5</span>, alpha: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在让我们扭转这种情况，让我向你展示如何在扩展的帮助下从实际的 <code>UIColor</code> 实例取回这些组件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> rgba: (red: <span class="type">CGFloat</span>, green: <span class="type">CGFloat</span>, blue: <span class="type">CGFloat</span>, alpha: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> r: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> g: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> b: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> a: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)</span><br><span class="line">        <span class="keyword">return</span> (r, g, b, a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> hsba: (hue: <span class="type">CGFloat</span>, saturation: <span class="type">CGFloat</span>, brightness: <span class="type">CGFloat</span>, alpha: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> h: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> s: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> b: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> a: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.getHue(&amp;h, saturation: &amp;s, brightness: &amp;b, alpha: &amp;a)</span><br><span class="line">        <span class="keyword">return</span> (h, s, b, a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，这里是如何从 <code>UIColor</code> 读取红色，绿色蓝色斜线色调饱和度亮度和 <code>alpha</code> 分量的方法。 通过这个小巧的扩展名，你可以简单地获取组件值并通过其专有名称使用它们。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIColor</span>.yellow.rgba.red</span><br><span class="line"><span class="type">UIColor</span>.yellow.hsba.hue</span><br></pre></td></tr></table></figure></br><h1 id="如何在-Swift-中将-UIColor-对象的十六进制颜色转换为-RGB-，反之亦然？"><a href="#如何在-Swift-中将-UIColor-对象的十六进制颜色转换为-RGB-，反之亦然？" class="headerlink" title="如何在 Swift 中将 UIColor 对象的十六进制颜色转换为 RGB ，反之亦然？"></a><strong>如何在 <code>Swift</code> 中将 <code>UIColor</code> 对象的十六进制颜色转换为 <code>RGB</code> ，反之亦然？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iOS开发人员101课程，第一个问题：</p><ul><li>我该如何从十六进制字符串创建UIColor？</li><li>如何将十六进制颜色转换为UIColor？</li><li>如何使用十六进制字符串制作UIColor？</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，也许这些不是第一个问题，但是绝对是常见问题。 答案很简单：通过扩展。 对于你的需求，我有一个非常好的解决方案，它将处理大多数情况，例如仅使用1、2、3或6个十六进制值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(hex: <span class="type">Int</span>, alpha: <span class="type">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> red = <span class="type">CGFloat</span>((hex &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>) / <span class="number">255.0</span></span><br><span class="line">        <span class="keyword">let</span> green = <span class="type">CGFloat</span>((hex &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>) / <span class="number">255.0</span></span><br><span class="line">        <span class="keyword">let</span> blue = <span class="type">CGFloat</span>((hex &amp; <span class="number">0xFF</span>)) / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(red: red, green: green, blue: blue, alpha: alpha)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(hex string: <span class="type">String</span>, alpha: <span class="type">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> hex = string.trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines).uppercased()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hex.hasPrefix(<span class="string">"#"</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> index = hex.index(hex.startIndex, offsetBy: <span class="number">1</span>)</span><br><span class="line">            hex = <span class="type">String</span>(hex[index...])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hex.<span class="built_in">count</span> &lt; <span class="number">3</span> &#123;</span><br><span class="line">            hex = <span class="string">"\(hex)\(hex)\(hex)"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hex.range(of: <span class="string">"(^[0-9A-Fa-f]&#123;6&#125;$)|(^[0-9A-Fa-f]&#123;3&#125;$)"</span>, options: .regularExpression) != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> hex.<span class="built_in">count</span> == <span class="number">3</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> startIndex = hex.index(hex.startIndex, offsetBy: <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">let</span> endIndex = hex.index(hex.startIndex, offsetBy: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> redHex = <span class="type">String</span>(hex[..&lt;startIndex])</span><br><span class="line">                <span class="keyword">let</span> greenHex = <span class="type">String</span>(hex[startIndex..&lt;endIndex])</span><br><span class="line">                <span class="keyword">let</span> blueHex = <span class="type">String</span>(hex[endIndex...])</span><br><span class="line"></span><br><span class="line">                hex = redHex + redHex + greenHex + greenHex + blueHex + blueHex</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> startIndex = hex.index(hex.startIndex, offsetBy: <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> endIndex = hex.index(hex.startIndex, offsetBy: <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">let</span> redHex = <span class="type">String</span>(hex[..&lt;startIndex])</span><br><span class="line">            <span class="keyword">let</span> greenHex = <span class="type">String</span>(hex[startIndex..&lt;endIndex])</span><br><span class="line">            <span class="keyword">let</span> blueHex = <span class="type">String</span>(hex[endIndex...])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> redInt: <span class="type">CUnsignedInt</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> greenInt: <span class="type">CUnsignedInt</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> blueInt: <span class="type">CUnsignedInt</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span>(string: redHex).scanHexInt32(&amp;redInt)</span><br><span class="line">            <span class="type">Scanner</span>(string: greenHex).scanHexInt32(&amp;greenInt)</span><br><span class="line">            <span class="type">Scanner</span>(string: blueHex).scanHexInt32(&amp;blueInt)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(red: <span class="type">CGFloat</span>(redInt) / <span class="number">255.0</span>,</span><br><span class="line">                      green: <span class="type">CGFloat</span>(greenInt) / <span class="number">255.0</span>,</span><br><span class="line">                      blue: <span class="type">CGFloat</span>(blueInt) / <span class="number">255.0</span>,</span><br><span class="line">                      alpha: <span class="type">CGFloat</span>(alpha))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(red: <span class="number">0.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.0</span>, alpha: <span class="number">0.0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hexValue: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> color = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> color.cgColor.numberOfComponents &lt; <span class="number">4</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="built_in">c</span> = color.cgColor.components!</span><br><span class="line">            color = <span class="type">UIColor</span>(red: <span class="built_in">c</span>[<span class="number">0</span>], green: <span class="built_in">c</span>[<span class="number">0</span>], blue: <span class="built_in">c</span>[<span class="number">0</span>], alpha: <span class="built_in">c</span>[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> color.cgColor.colorSpace!.model != .rgb &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#FFFFFF"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">c</span> = color.cgColor.components!</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: <span class="string">"#%02X%02X%02X"</span>, <span class="type">Int</span>(<span class="built_in">c</span>[<span class="number">0</span>]*<span class="number">255.0</span>), <span class="type">Int</span>(<span class="built_in">c</span>[<span class="number">1</span>]*<span class="number">255.0</span>), <span class="type">Int</span>(<span class="built_in">c</span>[<span class="number">2</span>]*<span class="number">255.0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是如何与多种输入形式一起使用的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"#cafe00"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"cafe00"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"c"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"ca"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="string">"caf"</span>),</span><br><span class="line">    <span class="type">UIColor</span>(hex: <span class="number">0xcafe00</span>),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> values = colors.<span class="built_in">map</span> &#123; $<span class="number">0</span>.hexValue &#125;</span><br><span class="line"><span class="built_in">print</span>(values) <span class="comment">//["#CAFE00", "#CAFE00", "#CCCCCC", "#CACACA", "#CCAAFF", "#CAFE00"]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我已经尝试过复制 <code>CSS</code> 规则的行为，因此，如果像 <code>#ffffff</code> 这样的后继字符串（你可以仅使用f，因为＃是可选的），你将可以减少字符的自由度。 你还可以提供整数，这只是一个简单的“重载”便捷初始化方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样，<code>.hexValue</code> 将返回 <code>UIColor</code> 实例的字符串表示形式。 👏👏👏</p></br><h1 id="如何在-Swift-中生成随机的-UIColor-？"><a href="#如何在-Swift-中生成随机的-UIColor-？" class="headerlink" title="如何在 Swift 中生成随机的 UIColor ？"></a><strong>如何在 <code>Swift</code> 中生成随机的 <code>UIColor</code> ？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于初学者来说，这也是一个非常普遍的问题，我真的不想通过深入的说明在这里浪费时间，<code>arc4random（）</code>只是在做它的工作，输出是一种很好的随机生成的颜色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> random: <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">max</span> = <span class="type">CGFloat</span>(<span class="type">UInt32</span>.<span class="built_in">max</span>)</span><br><span class="line">        <span class="keyword">let</span> red = <span class="type">CGFloat</span>(arc4random()) / <span class="built_in">max</span></span><br><span class="line">        <span class="keyword">let</span> green = <span class="type">CGFloat</span>(arc4random()) / <span class="built_in">max</span></span><br><span class="line">        <span class="keyword">let</span> blue = <span class="type">CGFloat</span>(arc4random()) / <span class="built_in">max</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>(red: red, green: green, blue: blue, alpha: <span class="number">1.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="如何在-Swift-中用单色创建一个-1x1-像素的大-UIImage-对象？"><a href="#如何在-Swift-中用单色创建一个-1x1-像素的大-UIImage-对象？" class="headerlink" title="如何在 Swift 中用单色创建一个 1x1 像素的大 UIImage 对象？"></a><strong>如何在 <code>Swift</code> 中用单色创建一个 <code>1x1</code> 像素的大 <code>UIImage</code> 对象？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我正在使用此技巧来设置 <code>UIButton</code> 对象的背景颜色。 原因是状态管理。 如果按下按钮，则背景图像将变暗，因此用户将获得视觉反馈。 但是，通过直接设置 <code>UIButton</code> 实例的背景颜色将无法正常工作，并且事件上的颜色也不会发生任何变化。 👆</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> imageValue: <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(origin: .zero, size: <span class="type">CGSize</span>(width: <span class="number">1</span>, height: <span class="number">1</span>))</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(rect.size)</span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()!</span><br><span class="line">        context.setFillColor(<span class="keyword">self</span>.cgColor)</span><br><span class="line">        context.fill(rect)</span><br><span class="line">        <span class="keyword">let</span> newImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> newImage!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码段将根据源颜色生成一个 <code>1x1</code> 像素的图像对象。 你可以使用它，但这是带有按钮背景的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setBackgroundImage(<span class="type">UIColor</span>.red.imageValue, <span class="keyword">for</span>: .normal)</span><br></pre></td></tr></table></figure></br><h1 id="在线调色板"><a href="#在线调色板" class="headerlink" title="在线调色板"></a><strong>在线调色板</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你找不到合适的颜色吗？ 没问题，这些链接将帮助你选择合适的链接并获得一些启发。 另外，如果你正在寻找平面UI颜色或材料设计颜色，这些是应该首先前往的正确链接。</p><ul><li><a href="https://www.w3schools.com/colors/colors_names.asp" target="_blank" rel="noopener"><strong><em><code>HTML Color Names</code></em></strong></a></li><li><a href="http://colorhunt.co/" target="_blank" rel="noopener"><strong><em><code>Color Hunt</code></em></strong></a></li><li><a href="https://flatuicolors.com/" target="_blank" rel="noopener"><strong><em><code>Flat UI Colors</code></em></strong></a></li><li><a href="http://www.flatuicolorpicker.com/" target="_blank" rel="noopener"><strong><em><code>flatuicolorpicker</code></em></strong></a></li><li><a href="https://www.materialui.co/colors" target="_blank" rel="noopener"><strong><em><code>Material Design Colors</code></em></strong></a></li></ul><blockquote><p><strong><em><code>提示:</code></em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很重要的事情：亲爱的设计师，请永远不要尝试对 <code>iOS</code> 应用程序使用 <code>material design principles</code> 。 谢谢。</p></blockquote></br><h1 id="在线转换颜色"><a href="#在线转换颜色" class="headerlink" title="在线转换颜色"></a><strong>在线转换颜色</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，有一些很棒的在线颜色转换器工具，如果你正在寻找一个很棒的工具，则应该首先尝试这些工具。</p><ul><li><a href="uicolor.xyz"><strong><em><code>uicolor.xyz</code></em></strong></a></li><li><a href="rgb.to"><strong><em><code>rgb.to</code></em></strong></a></li><li><a href="colorizer.org"><strong><em><code>colorizer.org</code></em></strong></a></li></ul></br><h1 id="管理-UIColors"><a href="#管理-UIColors" class="headerlink" title="管理 UIColors"></a><strong>管理 <code>UIColors</code></strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你的应用程序目标是 <code>iOS 11+</code> ，则可以使用 <code>asset catalogs</code> 来组织你的调色板，但是如果你需要低于 <code>iOS 11</code> ，我建议你使用带有静态 <code>UIColor</code> 属性的枚举或结构。 如今，我通常在做这样的事情。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> green: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> <span class="type">UIColor</span>(hex: <span class="number">0x4cd964</span>) &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> yellow: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> <span class="type">UIColor</span>(hex: <span class="number">0xffcc00</span>) &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> red: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> <span class="type">UIColor</span>(hex: <span class="number">0xff3b30</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">App</span>.<span class="type">Color</span>.yellow</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，我将结构中的字体，颜色等分组在一起，但这只是一种处理方式。 你也可以使用 <a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener"><strong><em><code>R.swift</code></em></strong></a> 之类的东西或你喜欢的任何东西。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，我想我已经涵盖了有关UIColor的大多数基本问题。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIColor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS自定义转场(By Swift)</title>
      <link href="/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA(By%20Swift)/"/>
      <url>/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA(By%20Swift)/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，你将学习如何使用自定义转场和百分比驱动的交互来替换 <code>Push</code> ，<code>pop</code> 和模式动画。</p></br><h1 id="UIKit自定义过渡API-理论知识"><a href="#UIKit自定义过渡API-理论知识" class="headerlink" title="UIKit自定义过渡API-理论知识"></a><strong>UIKit自定义过渡API-理论知识</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在进行 <a href="https://developer.apple.com/videos/play/wwdc2013/218/" target="_blank" rel="noopener"><strong><code>自定义转换</code></strong></a> 的过程中涉及许多类和委托，让我们快速地完成这些项目，然后再进行一些编码。</p></br><h2 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a><strong><em>UIViewControllerTransitioningDelegate</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个视图控制器都可以有一个过渡委托，在该委托实现中，你可以提供自定义动画和交互控制器。 这些对象将负责实际的动画处理，并且可以在此委托中将代码“注入” <code>UIKit</code> 框架。 💉💉💉</p><a id="more"></a></br><h2 id="UINavigationControllerDelegate"><a href="#UINavigationControllerDelegate" class="headerlink" title="UINavigationControllerDelegate"></a><strong><em>UINavigationControllerDelegate</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导航控制器委托还具有两种方法，用于自定义推送和弹出动画。 它与视图控制器的过渡委托几乎相同，但是稍后你将看到它的作用。 💥</p></br><h2 id="UINavigationController-Operation"><a href="#UINavigationController-Operation" class="headerlink" title="UINavigationController.Operation"></a><strong><em>UINavigationController.Operation</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导航控制器操作只是一个枚举，其中包含导航动画的“方向”。 通常按下或弹出。</p><blockquote><p><strong><code>提示:</code></strong> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以模态方式呈现和关闭某些内容与在导航堆栈中推送和弹出视图控制器并不完全相同。 稍后再详细介绍。</p></blockquote></br><h2 id="UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerAnimatedTransitioning"></a><strong><em>UIViewControllerAnimatedTransitioning</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些对象由过渡委托返回，因此基本上这是实现精美的自定义视图动画的地方。 😉</p></br><h2 id="UIViewControllerContextTransitioning"><a href="#UIViewControllerContextTransitioning" class="headerlink" title="UIViewControllerContextTransitioning"></a><strong><em>UIViewControllerContextTransitioning</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该上下文封装了有关过渡的所有信息，你可以从该对象获取参与的视图，控制器以及更多其他信息。 过渡上下文可供你在动画期间使用。</p></br><h2 id="UIPercentDrivenInteractiveTransition"><a href="#UIPercentDrivenInteractiveTransition" class="headerlink" title="UIPercentDrivenInteractiveTransition"></a><strong><em>UIPercentDrivenInteractiveTransition</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个视图控制器和另一个视图控制器之间驱动交互式动画的对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，这是一种神奇的功能，使你能够神奇地用手指从屏幕边缘向后（如果你改变主意了）来回滑动导航控制器。 📱</p></br><h1 id="编码自定义过渡动画"><a href="#编码自定义过渡动画" class="headerlink" title="编码自定义过渡动画"></a><strong>编码自定义过渡动画</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们做一些实际的编码！ 我将向你展示如何在导航堆栈内的视图控制器之间制作基本的淡入淡出动画。 首先，我们将从推动画开始。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">FadePushAnimator</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> toViewController = transitionContext.viewController(forKey: .to)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        transitionContext.containerView.addSubview(toViewController.view)</span><br><span class="line">        toViewController.view.alpha = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> duration = <span class="keyword">self</span>.transitionDuration(using: transitionContext)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class="line">            toViewController.view.alpha = <span class="number">1</span></span><br><span class="line">        &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，创建自定义过渡动画非常简单。 你只需要实现两个委托方法。 其中一个将返回动画的持续时间，而另一个将包含实际的过渡。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过渡上下文提供了一个自定义 <code>containterView</code> 对象，你可以在动画中使用它，也可以像我之前提到的那样从该对象中获取参与的视图和控制器。 现在，让我们反转该动画。 👈</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">FadePopAnimator</span>: <span class="title">CustomAnimator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> fromViewController = transitionContext.viewController(forKey: .from),</span><br><span class="line">            <span class="keyword">let</span> toViewController = transitionContext.viewController(forKey: .to)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transitionContext.containerView.insertSubview(toViewController.view, belowSubview: fromViewController.view)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> duration = <span class="keyword">self</span>.transitionDuration(using: transitionContext)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class="line">            fromViewController.view.alpha = <span class="number">0</span></span><br><span class="line">        &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，你只需要实现导航控制器的委托方法即可替换内置的UIKit系统动画。 🛠</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainViewController</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(<span class="number">_</span> navigationController: UINavigationController,</span></span></span><br><span class="line"><span class="function"><span class="params">                              animationControllerFor operation: UINavigationController.Operation,</span></span></span><br><span class="line"><span class="function"><span class="params">                              from fromVC: UIViewController,</span></span></span><br><span class="line"><span class="function"><span class="params">                              to toVC: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> operation &#123;</span><br><span class="line">        <span class="keyword">case</span> .push:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">FadePushAnimator</span>()</span><br><span class="line">        <span class="keyword">case</span> .pop:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">FadePopAnimator</span>()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，你不必制作两个单独的类（ <code>pop</code> 和 <code>push</code> ），也可以通过操作并在单个动画 <code>tarnsitioning</code> 类中实现动画。</p></br><h1 id="Percent-Driven-Interactive-Transition"><a href="#Percent-Driven-Interactive-Transition" class="headerlink" title="Percent Driven Interactive Transition"></a><strong>Percent Driven Interactive Transition</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，现在你知道了如何实现自定义过渡，但现在该使其具有交互性了！ 该过程非常简单，你只需要一个手势识别器和适当的委托方法即可使事情正常进行。 ⌨️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> interactionController: <span class="type">UIPercentDrivenInteractiveTransition?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.view.backgroundColor = .lightGray</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> edge = <span class="type">UIScreenEdgePanGestureRecognizer</span>(target: <span class="keyword">self</span>,</span><br><span class="line">                                                    action: #selector(<span class="keyword">self</span>.handleEdgePan(<span class="number">_</span>:)))</span><br><span class="line">        edge.edges = .<span class="keyword">left</span></span><br><span class="line">        <span class="keyword">self</span>.view.addGestureRecognizer(edge)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.navigationController?.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">handleEdgePan</span><span class="params">(<span class="number">_</span> gesture: UIScreenEdgePanGestureRecognizer)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> translate = gesture.translation(<span class="keyword">in</span>: gesture.view)</span><br><span class="line">        <span class="keyword">let</span> percent = translate.x / gesture.view!.bounds.size.width</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> gesture.state &#123;</span><br><span class="line">        <span class="keyword">case</span> .began:</span><br><span class="line">            <span class="keyword">self</span>.interactionController = <span class="type">UIPercentDrivenInteractiveTransition</span>()</span><br><span class="line">            <span class="keyword">self</span>.navigationController?.popViewController(animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">case</span> .changed:</span><br><span class="line">            <span class="keyword">self</span>.interactionController?.update(percent)</span><br><span class="line">        <span class="keyword">case</span> .ended:</span><br><span class="line">            <span class="keyword">let</span> velocity = gesture.velocity(<span class="keyword">in</span>: gesture.view)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> percent &amp;gt; <span class="number">0.5</span> || velocity.x &amp;gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.interactionController?.finish()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.interactionController?.cancel()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.interactionController = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DetailViewController</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(<span class="number">_</span> navigationController: UINavigationController,</span></span></span><br><span class="line"><span class="function"><span class="params">                              interactionControllerFor animationController: UIViewControllerAnimatedTransitioning)</span></span></span><br><span class="line">        -&gt; <span class="type">UIViewControllerInteractiveTransitioning?</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.interactionController</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在将要弹出的控制器内部，你可以拥有导航控制器的委托的所有权，并使用左屏幕边缘平移手势识别器实现交互式过渡控制器。 整个代码通常进入 <code>UIPercentDrivenInteractiveTransition</code> 的新子类中，但是为了简单起见，这次我们将跳过该部分，并使用这个非常简单的解决方案。  😅</p></br><h1 id="Navigation-vs-modal-presentation"><a href="#Navigation-vs-modal-presentation" class="headerlink" title="Navigation vs modal presentation"></a><strong>Navigation vs modal presentation</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的，让我们快速介绍另一件事：为视图控制器自定义模式演示动画。 自定义导航堆栈动画和模式表示样式之间存在微小差异。 如果要自定义视图控制器转换，通常会执行以下操作。 👍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">(<span class="keyword">for</span> segue: UIStoryboardSegue, sender: <span class="keyword">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepare(<span class="keyword">for</span>: segue, sender: sender)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> controller = segue.destination <span class="keyword">as</span>? <span class="type">ModalViewController</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        controller.transitioningDelegate = <span class="keyword">self</span></span><br><span class="line">        controller.modalPresentationStyle = .custom</span><br><span class="line">        controller.modalPresentationCapturesStatusBarAppearance = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用我们已经拥有的相同对象的过渡委托来了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DetailViewController</span>: <span class="title">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forPresented presented: UIViewController,</span></span></span><br><span class="line"><span class="function"><span class="params">                             presenting: UIViewController,</span></span></span><br><span class="line"><span class="function"><span class="params">                             source: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FadePushAnimator</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forDismissed dismissed: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FadePopAnimator</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你运行代码并提供模态视图控制器，则可以正常工作。 当你尝试关闭显示的视图控制器时，会发生此问题。 整个应用程序将转为死亡黑屏（BSOD）。 🖥</p><p><strong><em><code>(pop != dismiss) &amp;&amp; (push != present)</code></em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你必须修改pop动画才能支持模态解雇动画。 简而言之：问题在于放置视图和内存管理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">FadePopAnimator</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TransitionType</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> navigation</span><br><span class="line">        <span class="keyword">case</span> modal</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> type: <span class="type">TransitionType</span></span><br><span class="line">    <span class="keyword">let</span> duration: <span class="type">TimeInterval</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(type: <span class="type">TransitionType</span>, duration: <span class="type">TimeInterval</span> = <span class="number">0.25</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.type = type</span><br><span class="line">        <span class="keyword">self</span>.duration = duration</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.duration</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> fromViewController = transitionContext.viewController(forKey: .from)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.type == .navigation, <span class="keyword">let</span> toViewController = transitionContext.viewController(forKey: .to) &#123;</span><br><span class="line">            transitionContext.containerView.insertSubview(toViewController.view, belowSubview: fromViewController.view)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> duration = <span class="keyword">self</span>.transitionDuration(using: transitionContext)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class="line">            fromViewController.view.alpha = <span class="number">0</span></span><br><span class="line">        &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最简单的解决方案是引入一个新属性，以便你可以基于该标志来决定是否弹出视图控制器。 现在，你也可以安全地将相同的动画器用于模态显示的视图控制器。 😬</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，导航栏将始终使用淡入淡出的动画，但遗憾的是无法自定义。 另外，我进行了自定义的模态演示，并且所有内容都在使用交互式过渡。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，如果你不想手动实现自定义动画效果，则可以使用 <a href="https://github.com/lkzhao/Hero" target="_blank" rel="noopener"><strong><em><code>Hero</code></em></strong></a> 优雅的过渡库。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自定义转场 </tag>
            
            <tag> transition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift UICollectionView使用指南</title>
      <link href="/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/Swift%20UICollectionView%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何使用 <code>UICollectionView</code> ，具有高度可重用性的 <code>UIKit</code> 组件和一些 <code>MVVM</code> 模式，而不会费力地进行索引路径计算。</p></br><h1 id="UICollectionView类的剖析"><a href="#UICollectionView类的剖析" class="headerlink" title="UICollectionView类的剖析"></a><strong>UICollectionView类的剖析</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不熟悉 <code>UICollectionView</code> ，建议立即熟悉此类。 它们是 <code>Apple</code> 和其他第三方开发人员提供的许多应用程序的基本构建块。 就像 <code>UITableView</code> 一样。 结合 <code>IB</code> 和 <code>Swift</code> 代码快速了解和使用它们。 💻</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp1.png" alt="UICollectionView"></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将仅使用强大的 <code>UICollectionView</code> 类来构建 <code>Apple Music</code> 目录，例如从零开始的外观。 标头，水平和垂直滚动，圆形图像，因此，基本上，构建强大的用户界面所需的几乎所有内容。 🤘🏻</p></br><h1 id="如何使用Xcode中的Interface-Builder（IB）创建-UICollectionView-？"><a href="#如何使用Xcode中的Interface-Builder（IB）创建-UICollectionView-？" class="headerlink" title="如何使用Xcode中的Interface Builder（IB）创建 UICollectionView ？"></a><strong>如何使用Xcode中的Interface Builder（IB）创建 UICollectionView ？</strong></h1><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要使用 <code>IB</code> ！</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你仍然想使用 <code>IB</code> ，这是绝对入门的真正快速教程：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp2.png" alt="IB"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建第一个基于 <code>UICollectionView</code> 的屏幕的主要步骤如下：</p><ul><li>将 <code>UICollectionView</code> 对象拖到你的视图控制器</li><li>在集合视图上设置适当的约束</li><li>设置数据源和集合视图的委托</li><li>在控制器内部对单元布局进行原型设计</li><li>在单元格内的视图中添加约束</li><li>设置原型单元格类和重用标识符</li><li>做一些编码：</li></ul></br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">            flowLayout.itemSize = <span class="type">CGSize</span>(width: <span class="keyword">self</span>.collectionView.bounds.width, height: <span class="number">120</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> collectionView: UICollectionView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">"MyCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">MyCell</span></span><br><span class="line">        cell.textLabel.text = <span class="type">String</span>(indexPath.row + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(indexPath.item + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，数据源将提供有关如何填充集合视图的所有必需数据，并且委托将处理用户事件，例如在单元格上轻按。 你应该对数据源和委托方法有清楚的了解，因此请稍候片刻。 ⌨️</p></br><h1 id="如何在-Swift-5-中使用代码设置创建-UICollectionView"><a href="#如何在-Swift-5-中使用代码设置创建-UICollectionView" class="headerlink" title="如何在 Swift 5 中使用代码设置创建 UICollectionView?"></a><strong>如何在 <code>Swift 5</code> 中使用代码设置创建 <code>UICollectionView</code>?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能已经注意到，单元格是集合视图的核心组件。 它们是从可重用的视图派生的，这意味着，如果你有1000个元素的列表，则不会为每个元素创建一千个单元格，而只有少数几个可以填充屏幕大小，并且当你向下滚动列表时 这些项目将被重复使用以显示你的元素。 这仅仅是出于内存方面的考虑，因此与 <code>UIScrollView</code> 不同， <code>UICollectionView</code> （和 <code>UITableView</code> ）类是一个非常聪明且高效的类，但这也是每次显示之前都必须准备（重置内容）单元格的原因。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化也由系统处理，但是值得一提的是，如果使用 <code>Interface Builder</code> ，则应该在 <code>awakeFromNib</code> 方法内进行自定义，但是如果使用代码，则 <code>init（frame :)</code> 是你的地方。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> textLabel = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        textLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(textLabel)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            textLabel.topAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.topAnchor),</span><br><span class="line">            textLabel.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.bottomAnchor),</span><br><span class="line">            textLabel.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.leadingAnchor),</span><br><span class="line">            textLabel.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.contentView.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.textLabel = textLabel</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.contentView.backgroundColor = .lightGray</span><br><span class="line">        <span class="keyword">self</span>.textLabel.textAlignment = .center</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Interface Builder is not supported!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Interface Builder is not supported!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel.text = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们必须实现负责管理集合视图的视图控制器，因为我们没有使用 <code>IB</code> ，所以必须在 <code>loadView</code> 方法内部使用自动布局锚点（如单元格中的 <code>textLabel</code> ）手动创建它。 在视图层次结构准备就绪后，我们还设置了数据源并委托并注册了我们的单元格类以供进一步重用。 请注意，如果你使用 <code>IB</code> ，则此操作由系统自动完成，但是如果你喜欢代码，则必须通过调用适当的注册方法来完成。 你可以注册 <code>nibs</code> 和 <code>classes</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> collectionView = <span class="type">UICollectionView</span>(frame: .zero, collectionViewLayout: <span class="type">UICollectionViewFlowLayout</span>())</span><br><span class="line">        collectionView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(collectionView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            collectionView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.topAnchor),</span><br><span class="line">            collectionView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.bottomAnchor),</span><br><span class="line">            collectionView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.leadingAnchor),</span><br><span class="line">            collectionView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.collectionView = collectionView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView.backgroundColor = .white</span><br><span class="line">        <span class="keyword">self</span>.collectionView.dataSource = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView.register(<span class="type">MyCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"MyCell"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> collectionView: UICollectionView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">"MyCell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">MyCell</span></span><br><span class="line">        cell.textLabel.text = <span class="type">String</span>(indexPath.row + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(indexPath.row + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegateFlowLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        sizeForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.bounds.size.width - <span class="number">16</span>, height: <span class="number">120</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumLineSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        minimumInteritemSpacingForSectionAt section: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        insetForSectionAt section: Int)</span></span> -&gt; <span class="type">UIEdgeInsets</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIEdgeInsets</span>.<span class="keyword">init</span>(top: <span class="number">8</span>, <span class="keyword">left</span>: <span class="number">8</span>, bottom: <span class="number">8</span>, <span class="keyword">right</span>: <span class="number">8</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，你应该注意流布局委托方法。 你可以使用这些方法为布局系统提供支持。 流布局将基于这些数字和大小显示所有单元格。  <code>sizeForItemAt</code> 负责单元格的大小，<code>minimumInteritemSpacingForSectionAt</code> 是水平填充，<code>minimumLineSpacingForSectionAt</code> 是垂直填充，<code>insetForSectionAt</code> 是集合视图部分的边距。</p></br><h1 id="section-headers-and-footers"><a href="#section-headers-and-footers" class="headerlink" title="section headers and footers"></a><strong>section headers and footers</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在本节中，我将同时使用 <code>storyboards</code>，<code>nibs</code> 和一些 <code>Swift</code> 代码。 由于某些原因，这是我通常的方法。 虽然我很喜欢用代码进行约束，但大多数人更喜欢视觉编辑器，因此所有单元格都在笔尖内部创建。 为什么是笔尖？ 因为如果你有多个集合视图，这几乎是在它们之间共享单元格的唯一好方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以像创建 <code>section headers</code> 一样完全地创建 <code>section footers</code> ，因此这就是我这次只关注 <code>section headers</code> 的原因，因为从字面上看，你只需要更改一个字即可使用 <code>section footers</code> 。 ⚽️</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp3.png" alt="footers"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你只需要创建两个 <code>xib</code> 文件，一个用于单元格，一个用于头文件。 请注意，你可以使用完全相同的集合视图单元格来在 <code>section</code> 标题中显示内容，但这是一个演示，因此让我们处理两个不同的项目。 你甚至不必从 <code>IB</code> 设置重用标识符，因为我们必须在源代码中注册我们的可重用视图，因此只需设置单元类并连接你的 <code>outlets</code> 即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单元格的注册和 <code>section headers and footers</code> 的注册略有不同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cellNib = <span class="type">UINib</span>(nibName: <span class="string">"Cell"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.collectionView.register(cellNib, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sectionNib = <span class="type">UINib</span>(nibName: <span class="string">"Section"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.collectionView.register(sectionNib, forSupplementaryViewOfKind: <span class="type">UICollectionView</span>.elementKindSectionHeader, withReuseIdentifier: <span class="string">"Section"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现 <code>section header</code> 的数据源如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        viewForSupplementaryElementOfKind kind: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                        at indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionReusableView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> kind == <span class="type">UICollectionView</span>.elementKindSectionHeader <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UICollectionReusableView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> view = collectionView.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: <span class="string">"Section"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">Section</span></span><br><span class="line"></span><br><span class="line">    view.textLabel.text = <span class="type">String</span>(indexPath.section + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供流布局委托的大小也非常简单，但是有时我并没有得到 <code>Apple</code> 的命名约定。 一旦必须切换一种类型，而其他时候则有针对特定类型的确切方法。 🤷‍♂️</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                    layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                    referenceSizeForHeaderInSection section: Int)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.bounds.size.width, height: <span class="number">64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 <code>iOS9</code> 开始，可以将 <code>section headers and footers</code> 固定在集合视图可见范围的顶部或底部。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">    flowLayout.sectionHeadersPinToVisibleBounds = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，现在你知道了如何使用集合视图构建基本布局。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复杂的情况怎么样，例如在同一集合视图中使用多种单元格呢？ 索引路径会使事情变得很混乱，所以这就是为什么我基于一种技术来重新发明更好的方法，该技术如何使用 <code>Apple</code> 在 <code>WWDC 2014</code> 上展示的 <a href="https://developer.apple.com/videos/wwdc2014" target="_blank" rel="noopener"><strong><code>集合视图来构建高级用户界面</code></strong></a> 。</p></br><h1 id="基于-CollectionView-的-UI-Framework"><a href="#基于-CollectionView-的-UI-Framework" class="headerlink" title="基于 CollectionView 的 UI Framework"></a><strong>基于 <code>CollectionView</code> 的 <code>UI Framework</code></strong></h1><blockquote><p>CollectionView + ViewModel pattern = ❤️ .</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将快速解释这些组件，然后，你将学习如何使用它们来构建起初我所谈论的 <code>Apple</code> 音乐风格的布局。 🎶</p><h2 id="网格系统"><a href="#网格系统" class="headerlink" title="网格系统"></a><strong><em>网格系统</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集合视图的第一个问题是大小计算。你必须提供集合视图中每个单元的大小（宽度和高度）。</p><ul><li>如果在集合视图中所有内容都具有固定的大小，则只需在流布局本身上设置大小属性</li><li>如果你需要每个项目的动态尺寸，则可以实施流布局委托。 <code>UICollectionViewDelegateFlowLayout</code>（为什么在名称中间使用委托词？？？）并返回布局系统的确切大小</li><li>如果你需要更多控制权，则可以创建一个从 <code>CollectionView（Flow）Layout</code> 派生的新布局子类，并在那里进行所有尺寸计算</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很好，但是你仍然必须弄乱索引路径，特征集合，框架等，以使简单的2、4，n列布局适用于所有设备。这就是为什么我创建了一个非常基本的网格系统进行尺寸计算的原因。使用我的网格类，你可以设置列数并获取x列数的大小，就像在基于 <code>Web</code> 的 <code>CSS</code> 网格系统中一样。 🕸</p><h2 id="单元格重用"><a href="#单元格重用" class="headerlink" title="单元格重用"></a><strong><em>单元格重用</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单元格的注册和重用应该并且可以以类型安全的方式自动化。 你只想使用单元，而根本不关心重用标识符和单元注册。 我做了一些辅助方法，以使进步更加愉快。 重用标识符是从单元格类的名称派生的，因此你不必担心。 大多数开发人员都使用这种做法。</p><h2 id="View-model"><a href="#View-model" class="headerlink" title="View model"></a><strong><em>View model</em></strong></h2><blockquote><p><strong><code>view model = cell (view) + data (model)</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用实际数据填充“模板”单元应该是视图模型的任务。 这就是 <code>MVVM</code> 发挥作用的地方。 我做了一个通用的基本视图模型类，应该将其子类化。 借助协议，你可以在单个集合视图中使用各种单元，而不必担心行和节的计算，并且你可以专注于一项简单的任务：将视图与模型联系起来。 😛</p><h2 id="Section"><a href="#Section" class="headerlink" title="Section"></a><strong><em>Section</em></strong></h2><blockquote><p><strong><code>section = header + footer + cells</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要强调的是，你不想弄乱索引路径，只想将数据放在一起就可以了。 过去，我对“不必要的索引路径计算”进行了充分的努力，因此，我将 <code>section</code> 对象作为一个简单的容器来包装标题，页脚和该部分中的所有项目。 结果？ 通用数据源类，可以与多个单元格一起使用，而无需任何行或节索引计算。 👏👏👏</p><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a><strong><em>数据源</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，为了使我上面提到的所有事情都能起作用，我需要实现集合视图委托，数据源和流布局委托方法。 这就是我的源代码类的诞生。 一切都在这里实现，我正在使用各部分，通过视图模型对网格系统进行建模以建立集合视图。 但是，从理论上讲，足够了，让我们在实践中进行观察。 👓</p></br><h1 id="CollectionView-框架创建示例"><a href="#CollectionView-框架创建示例" class="headerlink" title="CollectionView 框架创建示例"></a><strong>CollectionView 框架创建示例</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何使任何列表或网格布局轻松自如？ 好吧，作为第一步，只需将我的 <code>CollectionView</code> 框架添加为依赖项。 它已经支持<code>Xcode 11</code> ，因此你可以直接从文件菜单使用 <code>Swift</code> 软件包管理器来集成此软件包。</p><blockquote><p><strong><code>提示：</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需在 <code>AppDelegate</code> 文件中添加 <code>@_exported import CollectionView</code> 行，那么你不必担心逐个文件导入框架。</p></blockquote><h2 id="创建-Cell"><a href="#创建-Cell" class="headerlink" title="创建 Cell"></a><strong><em>创建 Cell</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此步骤与常规设置相同，除了你的单元必须是我的 <code>Cell</code> 类的子类。 添加你自己的单元并像往常一样执行所有操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumCell</span>: <span class="title">Cell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> textLabel: <span class="type">UILabel!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> detailTextLabel: <span class="type">UILabel!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">self</span>.textLabel.textColor = .black</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel.textColor = .darkGray</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="number">8</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.reset()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.textLabel.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.detailTextLabel.text = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.image = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-Model"><a href="#创建-Model" class="headerlink" title="创建 Model"></a><strong><em>创建 Model</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需选择一个模型对象。 可以是任何东西，但是我的方法是使用 <code>Model</code> 后缀创建新的结构或类。 这样，我知道模型正在引用可重用组件文件夹中的集合视图模型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlbumModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> artist: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> image: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-ViewModel"><a href="#创建-ViewModel" class="headerlink" title="创建 ViewModel"></a><strong><em>创建 ViewModel</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，不用在委托内部或在某些地方的 <code>configure</code> 方法中配置单元格，而是为单元格和将通过视图表示的数据模型创建一个真实的视图模型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumViewModel</span>: <span class="title">ViewModel</span>&lt;<span class="title">AlbumCell</span>, <span class="title">AlbumModel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">updateView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view?.textLabel.text = <span class="keyword">self</span>.model.artist</span><br><span class="line">        <span class="keyword">self</span>.view?.detailTextLabel.text = <span class="keyword">self</span>.model.name</span><br><span class="line">        <span class="keyword">self</span>.view?.imageView.image = <span class="type">UIImage</span>(named: <span class="keyword">self</span>.model.image)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">(grid: Grid)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">            (<span class="keyword">self</span>.collectionView.traitCollection.userInterfaceIdiom == .phone &amp;&amp;</span><br><span class="line">             <span class="keyword">self</span>.collectionView.traitCollection.verticalSizeClass == .compact) ||</span><br><span class="line">            <span class="keyword">self</span>.collectionView?.traitCollection.userInterfaceIdiom == .pad</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> grid.size(<span class="keyword">for</span>: <span class="keyword">self</span>.collectionView, ratio: <span class="number">1.2</span>, items: grid.columns / <span class="number">4</span>, gaps: grid.columns - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> grid.columns == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> grid.size(<span class="keyword">for</span>: <span class="keyword">self</span>.collectionView, ratio: <span class="number">1.1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid.size(<span class="keyword">for</span>: <span class="keyword">self</span>.collectionView, ratio: <span class="number">1.2</span>, items: grid.columns / <span class="number">2</span>, gaps: grid.columns - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置数据源"><a href="#设置数据源" class="headerlink" title="设置数据源"></a><strong><em>设置数据源</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，使用你的真实数据并使用视图模型填充你的集合视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> grid = <span class="type">Grid</span>(columns: <span class="number">1</span>, margin: <span class="type">UIEdgeInsets</span>(all: <span class="number">8</span>))</span><br><span class="line"><span class="keyword">self</span>.collectionView.source = .<span class="keyword">init</span>(grid: grid, [</span><br><span class="line">    [</span><br><span class="line">        <span class="type">HeaderViewModel</span>(.<span class="keyword">init</span>(title: <span class="string">"Albums"</span>))</span><br><span class="line">        <span class="type">AlbumViewModel</span>(<span class="keyword">self</span>.album)</span><br><span class="line">    ],</span><br><span class="line">])</span><br><span class="line"><span class="keyword">self</span>.collectionView.reloadData()</span><br></pre></td></tr></table></figure><h2 id="🍺🤘🏻🎸"><a href="#🍺🤘🏻🎸" class="headerlink" title="🍺🤘🏻🎸"></a>🍺🤘🏻🎸</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恭喜，你已完成第一个 <code>collection</code> 视图。 仅需几行代码，你便拥有了 <code>ROCK SOLID</code>代码，可在大多数情况下为你提供帮助！ 😎</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/ug-stp4.png" alt="collection"></p></br><h1 id="垂直滚动内的水平滚动"><a href="#垂直滚动内的水平滚动" class="headerlink" title="垂直滚动内的水平滚动"></a><strong>垂直滚动内的水平滚动</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们制作一个包含集合视图的单元格并使用与上述相同的方法怎么办？ 包含 <code>collectionview</code> 的 <code>collection</code> 视图… <code>UICollectionViewception</code> !!! 😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全有可能并且确实很容易做到，为视图模型提供数据的将是一个集合视图源对象，你已经完成了。 示例应用程序中还包括轻松，神奇和超好实现的内容。</p></br><h1 id="带有圆角图片的-Section"><a href="#带有圆角图片的-Section" class="headerlink" title="带有圆角图片的 Section"></a><strong>带有圆角图片的 Section</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多个部分？这也是小菜一碟，如果你阅读了我先前有关 <a href="http://www.xuebaonline.com/UICollectionView%20Cells%EF%BC%9A%E5%9C%86%E5%BD%A2%E5%9B%BE%E5%83%8F%E3%80%81%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC/"><strong><code>设置圆形Collection视图单元</code></strong></a> 的文章，你将知道该如何做，但是请从gitlab中查看源代码，并亲自进行操作。</p></br><h1 id="Callbacks-amp-amp-Actions"><a href="#Callbacks-amp-amp-Actions" class="headerlink" title="Callbacks &amp;&amp; Actions"></a><strong>Callbacks &amp;&amp; Actions</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户事件可以非常容易地处理，因为视图模型可以具有委托或回调块，这仅取决于你喜欢哪一个。 该示例包含一个 <code>onSelect</code> 处理程序，该处理程序超级好并且内置于框架中。 😎</p></br><h1 id="重新计算动态单元大小"><a href="#重新计算动态单元大小" class="headerlink" title="重新计算动态单元大小"></a><strong>重新计算动态单元大小</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我也有一个关于<a href="http://www.xuebaonline.com/Swift%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%85%83%E6%A0%BC/"><strong><code>UICollection视图自动调整大小单元格</code></strong></a> 的文章。 在制作完网格系统并开始使用视图模型之后，我自己可以轻松计算出单元格的高度，大约需要两行额外的代码。 我相信这是值得的，因为就自动旋转而言，自定尺寸的单元格有点麻烦。</p></br><h1 id="支持旋转，自适应"><a href="#支持旋转，自适应" class="headerlink" title="支持旋转，自适应"></a><strong>支持旋转，自适应</strong></h1><p>不必担心太多，你可以根据需要简单地更改网格或检查视图模型中的特征集合。 我想说几乎所有事情都可以立即完成。 那就是它的美，可以随意做任何你想做的事情，并以自己喜欢的方式使用它。 📦</p></br><h1 id="如果我告诉你…又一件事：SwiftUI"><a href="#如果我告诉你…又一件事：SwiftUI" class="headerlink" title="如果我告诉你…又一件事：SwiftUI"></a><strong>如果我告诉你…又一件事：SwiftUI</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你喜欢这种方法很酷，但是如果我告诉你还有更多方法呢？ 你是否想在所有地方都使用相同的模式？ 我的意思是在 <code>iOS</code> ，<code>tvOS</code>，<code>macOS</code>甚至 <code>watchOS</code> 上。  我已经在 <code>CoreKit</code> 框架中创建了所有内容。 还支持 <code>UITableViews</code> ， <code>WKInterfaceTables</code> 。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我真的相信苹果今年会采用类似的方式处理下一代<code>UIKit / AppKit / UXKit</code>框架（当然是用<code>Swift</code>编写的）。 我不是在谈论视图模型模式，而是在每个平台上思考相同的<code>API</code>。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自适应布局 </tag>
            
            <tag> UICollectionView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UICollectionView Cells：圆形图像、支持旋转</title>
      <link href="/UICollectionView%20Cells%EF%BC%9A%E5%9C%86%E5%BD%A2%E5%9B%BE%E5%83%8F%E3%80%81%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC/"/>
      <url>/UICollectionView%20Cells%EF%BC%9A%E5%9C%86%E5%BD%A2%E5%9B%BE%E5%83%8F%E3%80%81%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何通过旋转支持为包装在 <code>UICollectionView</code> 单元格内的 <code>UIImageView</code> 项制作圆角。</p></br><h1 id="UICollectionView-中的圆形单元格"><a href="#UICollectionView-中的圆形单元格" class="headerlink" title="UICollectionView 中的圆形单元格"></a><strong>UICollectionView 中的圆形单元格</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现目标相对容易，但是如果你不知道后台发生了什么，那可能会比你最初想的要难。 因此，让我们创建一个新项目，添加带有 <code>UICollectionViewController</code> 的情节提要，将 <code>UIImageView</code> 拖动到单元格内，调整其大小，添加一些约束，设置单元格标识符。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp1.png" alt="UICollectionViewController"></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它看起来应该像上面的图像。 对于我们的示例应用程序而言，没有什么特别的简单的 <code>UI</code> 。 现在搜索一些随机图像，将其添加到项目中，让我们进行一些实际的编码。 首先，我将向你展示单元子类内部的小技巧。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.layoutIfNeeded()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.setCircularImageView()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setCircularImageView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="type">CGFloat</span>(roundf(<span class="type">Float</span>(<span class="keyword">self</span>.imageView.frame.size.width / <span class="number">2.0</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你能看见它吗？ 是的，你应该重写 <code>bounds</code> 属性。 下一步，我们必须为控制器类编写一些用于收集视图的基本数据源，并为旋转方法提供适当的支持。 🤓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">"Cell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></span><br><span class="line"></span><br><span class="line">        cell.imageView.image = <span class="type">UIImage</span>(named: <span class="string">"Example.jpg"</span>)</span><br><span class="line">        cell.imageView.backgroundColor = .lightGray</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">traitCollectionDidChange</span><span class="params">(<span class="number">_</span> previousTraitCollection: UITraitCollection?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span></span><br><span class="line">            <span class="keyword">let</span> previousTraitCollection = previousTraitCollection,</span><br><span class="line">            <span class="keyword">self</span>.traitCollection.verticalSizeClass != previousTraitCollection.verticalSizeClass ||</span><br><span class="line">            <span class="keyword">self</span>.traitCollection.horizontalSizeClass != previousTraitCollection.horizontalSizeClass</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">        <span class="keyword">self</span>.collectionView?.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillTransition</span><span class="params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillTransition(to: size, with: coordinator)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line"></span><br><span class="line">        coordinator.animate(alongsideTransition: &#123; context <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">        &#125;, completion: &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.collectionView?.visibleCells.forEach &#123; cell <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> cell = cell <span class="keyword">as</span>? <span class="type">Cell</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                cell.setCircularImageView()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UICollectionViewDelegateFlowLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        layout collectionViewLayout: UICollectionViewLayout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        sizeForItemAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGSize</span>(width: collectionView.frame.size.width/<span class="number">3.0</span> - <span class="number">8</span>,</span><br><span class="line">                      height: collectionView.frame.size.width/<span class="number">3.0</span> - <span class="number">8</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，如果没有重写的 <code>bounds</code> 属性，则该示例在左侧看起来像这样。 😢</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/uc-stp2.jpg" alt="UICollectionViewController2"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好笑吧？ 右侧的图像是带有超出范围的实际结果，这是预期的行为。 如果你不覆盖边界并且不为可见视图重设 <code>cornerRadius</code> 属性，那么滚动和旋转将真的很奇怪。 你可能会问：但是为什么呢？ 🤔</p></br><h1 id="Layers-springs-amp-struts-说明"><a href="#Layers-springs-amp-struts-说明" class="headerlink" title="Layers, springs &amp; struts 说明"></a><strong>Layers, springs &amp; struts</strong> 说明</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Apple</code> 在 <code>UIKit</code> 中仍然具有基于 <code>“ Springs＆Struts”</code> 的代码。 这意味着框架和边界计算正在底层系统中进行，并且约束系统也在努力工作以找出适当的措施。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当有一个 <code>init（frame :)</code> 方法或一个必需的 <code>init（coder :)</code> 方法时，这些布局会糟透了。 我真的很喜欢 <code>Interface Builder</code> ，但是直到我们没有一个好的工具来创建出色的用户界面， <code>IB</code> 才可能是潜在错误的另一层。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果仅使用自动布局约束或布局锚从代码创建单元，则甚至不会出现此问题！ 这是因为IB根据你在设计原型时提供的框架来创建单元。 但是，如果你忘记了 <code>init（frame :)</code> ，而只是创建了一个新的 <code>UIImageView</code> 实例并让自动布局完成了艰苦的工作，则布局系统将解决所有其他问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> imageView = <span class="type">UIImageView</span>()</span><br><span class="line">        imageView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.addSubview(imageView)</span><br><span class="line">        <span class="keyword">self</span>.imageView = imageView</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.topAnchor)</span><br><span class="line">        <span class="keyword">self</span>.imageView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.bottomAnchor)</span><br><span class="line">        <span class="keyword">self</span>.imageView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.leadingAnchor)</span><br><span class="line">        <span class="keyword">self</span>.imageView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.trailingAnchor)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="type">CGFloat</span>(roundf(<span class="type">Float</span>(<span class="keyword">self</span>.imageView.frame.size.width/<span class="number">2.0</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，你必须编写更多代码，在控制器类中手动注册单元格类，并且还必须重写单元格中的 <code>layoutSubviews</code> 方法，但是它将按预期执行。 🙄</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.collectionView?.register(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，在注册以编程方式创建的单元格之后，你将有一种很好的方式来显示圆形图像。 使用这种技术非常棘手，但是在每种情况下它肯定都有效。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自适应布局 </tag>
            
            <tag> UICollectionView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift支持旋转的自适应单元格</title>
      <link href="/Swift%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%85%83%E6%A0%BC/"/>
      <url>/Swift%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%85%83%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何在Swift中为表格视图和集合视图制作自定义大小的单元格，以支持方向更改和动态字体类型。</p></br><h1 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a><strong>UITableView</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们从 <code>iOS</code> 的标准单视图模板开始。 命名项目，然后直接转到 <code>Main.storyboard</code> 文件。 选择你的 <code>ViewController</code> ，将其删除并创建一个新的 <code>UITableViewController</code> <code>scene</code> 。</p><a id="more"></a><p><img src="http://q8wtfza4q.bkt.clouddn.com/sc-stp1.jpg" alt="Main.storyboard"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将表视图控制器场景设置为初始视图控制器，并使用相应的类创建 <code>TableViewController.swift</code> 文件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dataSource: [<span class="type">String</span>] = [</span><br><span class="line">        <span class="string">"Donec id elit non mi porta gravida at eget metus."</span>,</span><br><span class="line">        <span class="string">"Integer posuere erat a ante venenatis dapibus posuere velit aliquet. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus."</span>,</span><br><span class="line">        <span class="string">"Duis mollis, est non commodo luctus, nisi erat porttitor ligula, eget lacinia odio sem nec elit. Vestibulum id ligula porta felis euismod semper. Nullam id dolor id nibh ultricies vehicula ut id elit. Nullam quis risus eget urna mollis ornare vel eu leo."</span>,</span><br><span class="line">        <span class="string">"Maecenas faucibus mollis interdum."</span>,</span><br><span class="line">        <span class="string">"Donec ullamcorper nulla non metus auctor fringilla. Aenean lacinia bibendum nulla sed consectetur. Cras mattis consectetur purus sit amet fermentum."</span>,</span><br><span class="line">        <span class="string">"Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Maecenas faucibus mollis interdum."</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TableViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dataSource.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"Cell"</span>, <span class="keyword">for</span>: indexPath) <span class="keyword">as</span>! <span class="type">TableViewCell</span></span><br><span class="line"></span><br><span class="line">        cell.dynamicLabel?.text = <span class="keyword">self</span>.dataSource[indexPath.row]</span><br><span class="line">        cell.dynamicLabel.font  = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该设置实际上是自我描述的。 你已经有了一个字符串数组作为数据源，以及 <code>UITableViewDataSource</code> 协议的必需实现。</p><p>唯一缺少的是 <code>TableViewCell</code> 类:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> dynamicLabel: <span class="type">UILabel!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，创建类本身，然后使用界面构建器选择表视图控制器场景并将标签拖到原型单元中。 将原型单元格的类设置为 <code>TableViewCell</code> 。 可重复使用的标识符可以简单地是 <code>“ Cell”</code>。 将 <code>dynamicLabel</code> 插座连接到视图。 将标签的上，下，前，尾约束赋予父视图，默认值为8。选择标签，将字体设置为主体样式，并将 <code>lines</code> 属性设置为零。 就是这么简单。 😂</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sc-stp2.jpg" alt="TableViewCell"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在你已经准备好了。 你只需要在表格视图上设置估计的行高。 在 <code>TableViewController</code> 类内部，更改 <code>viewDidLoad</code> 方法，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">44</span></span><br><span class="line">    <span class="keyword">self</span>.tableView.rowHeight = <span class="type">UITableView</span>.automaticDimension</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>EstimateRowHeight</code> 属性将告诉系统 <code>tableview</code> 应该尝试动态计算每个单元格的高度。 你还应该将 <code>rowHeight</code> 属性更改为自动尺寸，如果不这样做，则系统将使用静态单元格高度-你可以在单元格上设置的界面生成器高度。 现在构建并运行。 你将拥有一个带有自定义尺寸单元格的绝佳表格视图。 你甚至可以旋转设备，它将在两个方向上都能正常工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你在 <code>iOS</code> 辅助功能设置下更改了文字大小，表格视图将反映这些更改，因此它将使布局适应新值。 表格视图的字体大小将使 <code>comcorint</code> 更改为滑块值。 你可能想要订阅 <code>UIContentSizeCategory.didChangeNotification</code> 以便检测大小更改并重新加载 <code>UI</code> 。 此功能称为动态类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>.tableView, selector: #selector(<span class="type">UITableView</span>.reloadData), name: <span class="type">UIContentSizeCategory</span>.didChangeNotification,, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></br><h1 id="UICollectionView"><a href="#UICollectionView" class="headerlink" title="UICollectionView"></a><strong>UICollectionView</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，我们完成了简单的部分。 现在，让我们尝试通过集合视图实现相同的功能。 <code>UICollectionView</code> 是一个通用类，旨在创建自定义布局，因为这种通用行为，你将无法从界面生成器创建自定义单元格。 你必须通过代码来完成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开始之前，我们仍然可以使用 <code>IB</code> 。 创建一个新的集合视图控制器场景，然后将一个推键从上一个表视图单元格拖到这个新的控制器上。 最后，将整个内容嵌入导航控制器中。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/sc-stp3.jpg" alt="UICollectionView"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该单元将与我们用于表视图的单元完全相同，但是它是 <code>UICollectionViewCell</code> 的子类，并且我们将直接从代码构造布局。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionViewCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> dynamicLabel: <span class="type">UILabel!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="keyword">self</span>.bounds)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line">        label.backgroundColor = <span class="type">UIColor</span>.darkGray</span><br><span class="line">        label.numberOfLines = <span class="number">0</span></span><br><span class="line">        label.preferredMaxLayoutWidth = frame.size.width</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.contentView.addSubview(label)</span><br><span class="line">        <span class="keyword">self</span>.dynamicLabel = label</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            <span class="keyword">self</span>.contentView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.topAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.bottomAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.leadingAnchor),</span><br><span class="line">            <span class="keyword">self</span>.contentView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.dynamicLabel.trailingAnchor),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.dynamicLabel.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .body)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setPreferred</span><span class="params">(width: CGFloat)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.dynamicLabel.preferredMaxLayoutWidth = width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们为单元格提供了一个子类，现在让我们创建视图控制器类。 在 <code>viewDidLoad</code> 方法内部，你必须在集合视图上设置 <code>EstimatedItemSize</code> 属性。 如果输入的尺寸错误，自动旋转将无法正常工作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.navigationItem.rightBarButtonItem = <span class="type">UIBarButtonItem</span>(barButtonSystemItem: .refresh, target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.toggleColumns))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.register(<span class="type">CollectionViewCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView?.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">        flowLayout.itemSize = <span class="type">CGSize</span>(width: <span class="number">64</span>, height: <span class="number">64</span>)</span><br><span class="line">        flowLayout.minimumInteritemSpacing = <span class="number">10</span></span><br><span class="line">        flowLayout.minimumLineSpacing = <span class="number">20</span></span><br><span class="line">        flowLayout.sectionInset = <span class="type">UIEdgeInsets</span>(top: <span class="number">10</span>, <span class="keyword">left</span>: <span class="number">10</span>, bottom: <span class="number">10</span>, <span class="keyword">right</span>: <span class="number">10</span>)</span><br><span class="line">        flowLayout.estimatedItemSize = <span class="type">CGSize</span>(width: <span class="keyword">self</span>.preferredWith(forSize: <span class="keyword">self</span>.view.bounds.size), height: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.reloadData()</span><br><span class="line"></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>.collectionView!, selector: #selector(<span class="type">UICollectionView</span>.reloadData), name: <span class="type">UIContentSizeCategory</span>.didChangeNotification, object: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在旋转方法内部，必须使集合视图布局无效，并在发生过渡时重新计算可见的单元格大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">traitCollectionDidChange</span><span class="params">(<span class="number">_</span> previousTraitCollection: UITraitCollection?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span></span><br><span class="line">        <span class="keyword">let</span> previousTraitCollection = previousTraitCollection,</span><br><span class="line">        <span class="keyword">self</span>.traitCollection.verticalSizeClass != previousTraitCollection.verticalSizeClass ||</span><br><span class="line">        <span class="keyword">self</span>.traitCollection.horizontalSizeClass != previousTraitCollection.horizontalSizeClass</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">    <span class="keyword">self</span>.collectionView?.reloadData()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillTransition</span><span class="params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewWillTransition(to: size, with: coordinator)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">    <span class="keyword">self</span>.estimateVisibleCellSizes(to: size)</span><br><span class="line"></span><br><span class="line">    coordinator.animate(alongsideTransition: &#123; context <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    &#125;, completion: &#123; context <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.collectionView?.collectionViewLayout.invalidateLayout()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有两种辅助方法可以计算估计的项目大小的首选宽度并重新计算可见的单元格大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preferredWith</span><span class="params">(forSize size: CGSize)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> columnFactor: <span class="type">CGFloat</span> = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.twoColumns &#123;</span><br><span class="line">        columnFactor = <span class="number">2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (size.width - <span class="number">30</span>) / columnFactor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">estimateVisibleCellSizes</span><span class="params">(to size: CGSize)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> collectionView = <span class="keyword">self</span>.collectionView <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> flowLayout = <span class="keyword">self</span>.collectionView?.collectionViewLayout <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> &#123;</span><br><span class="line">        flowLayout.estimatedItemSize = <span class="type">CGSize</span>(width: <span class="keyword">self</span>.preferredWith(forSize: size), height: <span class="number">64</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    collectionView.visibleCells.forEach(&#123; cell <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cell = cell <span class="keyword">as</span>? <span class="type">CollectionViewCell</span> &#123;</span><br><span class="line">            cell.setPreferred(width: <span class="keyword">self</span>.preferredWith(forSize: size))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果进行适当的计算，甚至可以包含多列。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我只有一件事无法解决，但这只是一条日志消息。 如果向后旋转设备，则某些单元格将不可见，布局引擎将无法对这些单元格进行快照。</p><p><strong><em>快照尚未渲染的视图将导致快照为空。 确保在快照之前或屏幕更新后快照至少已渲染一次视图。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你可以通过某种方式使此消息消失 <code>OS_ACTIVITY_MODE = disable</code> 。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自适应布局 </tag>
            
            <tag> UITableView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift使用布局锚点添加约束</title>
      <link href="/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/"/>
      <url>/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Auto Layout</code> 经常引起抱怨的是，语法以编程方式创建约束的方式多么繁琐和难以理解。 幸运的是，<code>iOS 9</code> 做了很多改进。 <code>堆栈视图</code> 消除了我们在典型布局中创建许多约束的需要。 相比较而言，布局锚点和布局指南的引入却被忽略了，但同样有用。 从《 Apple自动版面指南》中：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以编程方式创建约束时，你有三个选择：可以使用 <code>layout anchors</code> ，可以使用 <code>NSLayoutConstraint</code> 类，或者可以使用可视格式语言。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将再次看一下布局指南，但是现在这里是我关于使用布局锚点在代码中轻松创建约束的说明：</p><a id="more"></a></br><h1 id="创建约束"><a href="#创建约束" class="headerlink" title="创建约束"></a><strong>创建约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先提醒一下使用 <code>NSLayoutConstraint</code> 类方法创建约束的方式。 假设我们有一个堆栈视图，我们想要固定到视图控制器顶级视图的左右边距：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLayoutConstraint</span>(item: stackView,</span><br><span class="line">  attribute: .leading,</span><br><span class="line">  relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">  toItem: view,</span><br><span class="line">  attribute: .leadingMargin,</span><br><span class="line">  multiplier: <span class="number">1</span>,</span><br><span class="line">  constant: <span class="number">0</span>).isActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="type">NSLayoutConstraint</span>(item: stackView,</span><br><span class="line">  attribute: .trailing,</span><br><span class="line">  relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">  toItem: view,</span><br><span class="line">  attribute: .trailingMargin,</span><br><span class="line">  multiplier: <span class="number">1</span>,</span><br><span class="line">  constant: <span class="number">0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以将堆栈视图固定在顶部布局指南下方，以免被导航栏隐藏：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLayoutConstraint</span>(item: stackView,</span><br><span class="line">attribute: .top,</span><br><span class="line">relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">toItem: topLayoutGuide,</span><br><span class="line">attribute: .bottom,</span><br><span class="line">multiplier: <span class="number">1</span>,</span><br><span class="line">constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为我们可以同意，这既不美观也不容易理解（ <code>Objective-C</code> 版本更糟）。 在我看来，使用 <strong><em>Visual Format Language</em></strong> 并不是更好：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> views: [<span class="type">String</span>: <span class="type">AnyObject</span>] =</span><br><span class="line">  [<span class="string">"stackView"</span> : stackView,</span><br><span class="line">   <span class="string">"topLayoutGuide"</span> : topLayoutGuide]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="type">NSLayoutConstraint</span>.constraints(</span><br><span class="line">  withVisualFormat: <span class="string">"|-[stackView]-|"</span>,</span><br><span class="line">  options: [],</span><br><span class="line">  metrics: <span class="literal">nil</span>,</span><br><span class="line">  views: views)</span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate(h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="type">NSLayoutConstraint</span>.constraints(</span><br><span class="line">  withVisualFormat: <span class="string">"V:|[topLayoutGuide]-[stackView]"</span>,</span><br><span class="line">  options: [],</span><br><span class="line">  metrics: <span class="literal">nil</span>,</span><br><span class="line">  views: views)</span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate(v)</span><br></pre></td></tr></table></figure></br><h1 id="使用-Layout-Anchors-创建约束"><a href="#使用-Layout-Anchors-创建约束" class="headerlink" title="使用 Layout Anchors 创建约束"></a><strong>使用 <code>Layout Anchors</code> 创建约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布局锚点使创建约束更加容易。 从文档中：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>NSLayoutAnchor</code> 类是用于使用流畅的 <code>API</code> 创建 <code>NSLayoutConstraint</code> 对象的工厂类。 使用这些约束可以使用“自动布局”以编程方式定义你的布局。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布局锚点是 <code>UIView</code>（或<code>UILayoutGuide</code> ）上的属性。 每个属性都是 <code>NSLayoutAnchor</code> 的子类，其方法可直接为其他相同类型的布局锚创建约束。 <code>UIView</code> 具有十二种不同的布局锚点属性，可用于创建水平，垂直或基于大小的约束：</p><h2 id="水平约束"><a href="#水平约束" class="headerlink" title="水平约束"></a><strong><em>水平约束</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于创建水平约束的  <code>NSLayoutXAxisAnchor</code> 类型的布局锚点：</p><ul><li><code>centerXAnchor</code></li><li><code>leadingAnchor</code> 和 <code>trailingAnchor</code></li><li><code>leftAnchor</code> 和 <code>rightAnchor</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，创建约束以使两个视图居中对齐：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">myView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.centerXAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.centerXAnchor].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><p><strong><em>请注意如何从一个视图上的锚点开始并为另一个视图上的锚点创建约束。</em></strong></p><h2 id="垂直约束"><a href="#垂直约束" class="headerlink" title="垂直约束"></a><strong><em>垂直约束</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于创建垂直约束的 <code>NSLayoutYAxisAnchor</code> 类型的布局锚点：</p><ul><li><code>centerYAnchor</code></li><li><code>bottomAnchor</code> 和 <code>topAnchor</code></li><li><code>firstBaselineAnchor</code> 和 <code>lastBaselineAnchor</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，要在间距恒定的两个视图的顶部和底部锚点之间创建约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swift</span><br><span class="line">myView.bottomAnchor.constraint(equalTo: view.topAnchor,</span><br><span class="line">       constant: 8).isActive&#x3D;true</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.bottomAnchor constraintEqualToAnchor:<span class="keyword">self</span>.view.topAnchor</span><br><span class="line">      constant:<span class="number">8.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="基于-Size-的约束"><a href="#基于-Size-的约束" class="headerlink" title="基于 Size 的约束"></a><strong><em>基于 Size 的约束</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>NSLayoutDimension</code> 类型的布局锚，用于创建基于 <code>Size</code> 的约束：</p><ul><li><code>heightAnchor</code> 和 <code>widthAnchor</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，为视图创建宽度约束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">myView.widthAnchor.constraint(equalToConstant: <span class="number">50.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.widthAnchor constraintEqualToConstant:<span class="number">50.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个示例，使用 <code>multiplier</code> 使一个视图的高度是另一个视图的高度的两倍：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">myView.heightAnchor.constraint(equalTo: otherView.heightAnchor,</span><br><span class="line">       multiplier: <span class="number">2.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">[<span class="keyword">self</span>.myView.heightAnchor constraintEqualToAnchor:<span class="keyword">self</span>.otherView.heightAnchor </span><br><span class="line">      multiplier:<span class="number">2.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="视图边距"><a href="#视图边距" class="headerlink" title="视图边距"></a><strong><em>视图边距</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIView</code> 没有用于创建堆栈视图约束时使用的前，后边距的布局锚。 相反，<code>iOS 9</code> 添加了两个新属性， <code>layoutMarginGuide</code> 和可读 <code>readableContentGuide</code> ，它们又具有布局锚点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，要将子视图的前沿约束到父视图的前面：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="keyword">let</span> margins = view.layoutMarginsGuide    </span><br><span class="line">myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line"><span class="type">UILayoutGuide</span> *margins = <span class="keyword">self</span>.view.layoutMarginsGuide;</span><br><span class="line">[<span class="keyword">self</span>.myView.leadingAnchor constraintEqualToAnchor:</span><br><span class="line">      margins.leadingAnchor].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="顶部和底部布局"><a href="#顶部和底部布局" class="headerlink" title="顶部和底部布局"></a><strong><em>顶部和底部布局</em></strong></h2><blockquote><p><strong><code>提示:</code></strong> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顶部和底部布局指南已由 <code>iOS 11</code> 中的 <code>“Safe Area Layout Guide ”</code> 代替。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你要相对于顶部或底部 <code>UIKit</code> 工具栏定位内容时，视图控制器具有 <code>topLayoutGuide</code> 和 <code>bottomLayoutGuide</code> 属性。 从 <code>iOS 9</code> 开始，这两个属性均符合 <code>UILayoutSupport</code>  协议，该协议为 <code>bar</code> 提供了 <code>bottomAnchor</code> ， <code>topAnchor</code> 和 <code>heightAnchor</code> 属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，要将视图放置在顶部布局指南底部下方8个点处：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">    myView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor,</span><br><span class="line">       constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">    [<span class="keyword">self</span>.stackView.topAnchor constraintEqualToAnchor:<span class="keyword">self</span>.topLayoutGuide.bottomAnchor</span><br><span class="line">       constant:<span class="number">8.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><h2 id="控件组合布局"><a href="#控件组合布局" class="headerlink" title="控件组合布局"></a><strong><em>控件组合布局</em></strong></h2><p><strong>那么我们如何使用布局锚创建堆栈视图约束？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们获得父视图的 <code>leading</code> 和 <code>trailing</code> 边距：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> margins = view.layoutMarginsGuide</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建 <code>leading</code> 和 <code>trailing</code>  水平约束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = <span class="literal">true</span></span><br><span class="line">stackView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我们使用视图控制器的 <code>topLayoutGuide</code> 属性将堆栈视图固定在导航栏下方的8点处：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor,</span><br><span class="line">          constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Objective-C</code> 版本稍微冗长一些，但仍有很大改进：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UILayoutGuide</span> *margins = <span class="keyword">self</span>.view.layoutMarginsGuide;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.stackView.leadingAnchor</span><br><span class="line">      constraintEqualToAnchor:margins.leadingAnchor].active = <span class="type">YES</span>;</span><br><span class="line">[<span class="keyword">self</span>.stackView.trailingAnchor</span><br><span class="line">      constraintEqualToAnchor:margins.trailingAnchor].active = <span class="type">YES</span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.stackView.topAnchor</span><br><span class="line">      constraintEqualToAnchor:<span class="keyword">self</span>.topLayoutGuide.bottomAnchor</span><br><span class="line">      constant:<span class="number">8.0</span>].active = <span class="type">YES</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与以前的代码相比，我发现更容易理解这些约束的意图。</p></br><h1 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a><strong>了解更多</strong></h1><ul><li><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ProgrammaticallyCreatingConstraints.html" target="_blank" rel="noopener"><strong><code>Programmatically Creating Constraints (Apple Auto Layout Guide)</code></strong></a></li><li><a href="https://developer.apple.com/videos/play/wwdc2015/219/" target="_blank" rel="noopener"><strong><code>WWDC 2015 Session 219 Mysteries of Auto Layout, Part 2</code></strong></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自动化布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift掌握iOS自动布局锚点</title>
      <link href="/Swift%E6%8E%8C%E6%8F%A1iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9/"/>
      <url>/Swift%E6%8E%8C%E6%8F%A1iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;寻找使用布局锚点的最佳实践吗？ 让我们学习如何使用 <code>Swift</code> 以正确的方式使用 <code>iOS</code> 自动布局系统。</p><h1 id="以代码方式创建视图和约束"><a href="#以代码方式创建视图和约束" class="headerlink" title="以代码方式创建视图和约束"></a><strong>以代码方式创建视图和约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我想回顾一下 <code>UIViewController</code> 生命周期方法，你可能对其中一些方法很熟悉。 它们按以下顺序被调用：</p><ul><li><code>loadView</code></li><li><code>viewDidLoad</code></li><li><code>viewWillAppear</code></li><li><code>viewWillLayoutSubviews</code></li><li><code>viewDidLayoutSubviews</code></li><li><code>viewDidAppear</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在自动布局之前，你必须在 <code>viewDidLayoutSubviews</code> 方法内进行布局计算，但是由于这是专业的自动布局教程，因此我们仅关注 <code>loadView</code> 和 <code>viewDidLoad</code> 方法。 🤓</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些是使用自动布局创建视图层次结构的基本规则：</p><ul><li>永远不要自己手动计算帧！</li><li>使用 <code>.zero</code> 初始化视图 <code>frame</code></li><li>将 <code>translatesAutoresizing</code>, <code>MaskIntoConstraints</code> 设置为 <code>false</code></li><li>使用 <code>addSubview</code> 将视图添加到视图层次结构</li><li>创建并激活你的布局约束 <code>NSLayoutConstraint.activate</code></li><li>使用 <code>loadView</code> 代替 <code>viewDidLoad</code> 创建具有约束的视图</li><li>通过使用弱引用来管理内存管理</li><li>在 <code>viewDidLoad</code> 中设置所有其他属性，例如背景色等。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理论足够，下面是一个简短的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> testView: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">        testView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(testView)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            testView.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            testView.widthAnchor.constraint(equalTo: testView.heightAnchor),</span><br><span class="line">            testView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">            testView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.testView = testView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView.backgroundColor = .red</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很简单吧？ 只需几行代码，你就可以得到一个大小固定的中心对齐视图，并带有专用的类属性引用。 如果通过接口构建器创建完全相同的对象，则调用 <code>loadView</code> 方法，但是你必须设置对该视图的 <code>@IBOutlet</code> 引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没关系，请随意选择。 有时我喜欢和 <code>IB</code> 一起玩，但是在大多数情况下，我更喜欢编程的做事方式。 😛</p></br><h1 id="常见的UIKit自动布局约束用例"><a href="#常见的UIKit自动布局约束用例" class="headerlink" title="常见的UIKit自动布局约束用例"></a><strong>常见的UIKit自动布局约束用例</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我只使用布局锚。 你可能会浪费时间使用 <code>visual format language</code> ，但这绝对是死胡同。 因此，请记住我的话：仅使用锚点或堆栈视图，请勿使用其他任何视图！ 😇</p><p>这是我用来创建漂亮布局的最常见模式。 😉</p><h2 id="设置固定宽度或高度"><a href="#设置固定宽度或高度" class="headerlink" title="设置固定宽度或高度"></a><strong><em>设置固定宽度或高度</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个是最简单的一个：将视图的高度或宽度设置为固定点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.widthAnchor.constraint(equalToConstant: <span class="number">320</span>),</span><br><span class="line">testView.heightAnchor.constraint(equalToConstant: <span class="number">240</span>),</span><br></pre></td></tr></table></figure><h2 id="设定长宽比"><a href="#设定长宽比" class="headerlink" title="设定长宽比"></a><strong><em>设定长宽比</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置视图的纵横比只是将宽度限制为高度，反之亦然，你可以通过 <code>multiplier</code> 简单地定义倍数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">testView.widthAnchor.constraint(equalTo: testView.heightAnchor, multiplier: <span class="number">16</span>/<span class="number">9</span>),</span><br></pre></td></tr></table></figure><h2 id="水平和垂直居中"><a href="#水平和垂直居中" class="headerlink" title="水平和垂直居中"></a><strong><em>水平和垂直居中</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将视图居中放置在另一个视图中是一件很简单的事情，为此需要特定的锚点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">testView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br></pre></td></tr></table></figure><h2 id="伸展-用边距填充内部视图"><a href="#伸展-用边距填充内部视图" class="headerlink" title="伸展 | 用边距填充内部视图"></a><strong><em>伸展 | 用边距填充内部视图</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里唯一棘手的部分是，对于常量，尾部约束和底部约束的行为与顶部和前部约束略有不同。 通常，你必须使用负值，但经过几次尝试，你将在这里理解逻辑。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.topAnchor, constant: <span class="number">32</span>),</span><br><span class="line">testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.leadingAnchor, constant: <span class="number">32</span>),</span><br><span class="line">testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.trailingAnchor, constant: -<span class="number">32</span>),</span><br><span class="line">testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.bottomAnchor, constant: -<span class="number">32</span>),</span><br></pre></td></tr></table></figure><h2 id="比例宽度或高度"><a href="#比例宽度或高度" class="headerlink" title="比例宽度或高度"></a><strong><em>比例宽度或高度</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不想使用常量值，可以使用 <code>multiplier</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testView.widthAnchor.constraint(equalTo: <span class="keyword">self</span>.view.widthAnchor, multiplier: <span class="number">1</span>/<span class="number">3</span>),</span><br><span class="line">testView.heightAnchor.constraint(equalTo: <span class="keyword">self</span>.view.heightAnchor, multiplier: <span class="number">2</span>/<span class="number">3</span>),</span><br></pre></td></tr></table></figure><h2 id="使用-safe-area-layout"><a href="#使用-safe-area-layout" class="headerlink" title="使用 safe area layout"></a><strong><em>使用 safe area layout</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用最新的 <code>iPhone</code> ，你将需要一些指南，以确保你安全无虞。 这就是视图具有 <code>safeAreaLayoutGuide</code> 属性的原因。 调出安全区域指南后，即可获得所有常用锚。 💪</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor),</span><br><span class="line">testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.leadingAnchor),</span><br><span class="line">testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.trailingAnchor),</span><br><span class="line">testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor),</span><br></pre></td></tr></table></figure></br><h1 id="带有动画的布局约束"><a href="#带有动画的布局约束" class="headerlink" title="带有动画的布局约束"></a><strong>带有动画的布局约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有约束的动画很容易，你不应该相信别人会说什么。 我制定了一些规则和示例，可以帮助你理解为约束的常量值设置动画效果以及切换各种约束的基本原理。 👍</p><p><strong>规则</strong>：</p><ul><li>将标准 <code>UIView</code> 动画与 <code>layoutIfNeeded</code> 一起使用</li><li>始终先停用约束</li><li>遵守停用的约束</li><li>玩得开心！ 😛</li></ul><p>约束动画示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> testView: <span class="type">UIView!</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> topConstraint: <span class="type">NSLayoutConstraint!</span></span><br><span class="line">    <span class="keyword">var</span> bottomConstraint: <span class="type">NSLayoutConstraint!</span></span><br><span class="line">    <span class="keyword">var</span> heightConstraint: <span class="type">NSLayoutConstraint!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">        testView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(testView)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> topConstraint = testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor)</span><br><span class="line">        <span class="keyword">let</span> bottomConstraint = testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor)</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            topConstraint,</span><br><span class="line">            testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.leadingAnchor),</span><br><span class="line">            testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.trailingAnchor),</span><br><span class="line">            bottomConstraint,</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> heightConstraint = testView.heightAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.heightAnchor, multiplier: <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView = testView</span><br><span class="line">        <span class="keyword">self</span>.topConstraint = topConstraint</span><br><span class="line">        <span class="keyword">self</span>.bottomConstraint = bottomConstraint</span><br><span class="line">        <span class="keyword">self</span>.heightConstraint = heightConstraint</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView.backgroundColor = .red</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> tap = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.tapped))</span><br><span class="line">        <span class="keyword">self</span>.view.addGestureRecognizer(tap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">tapped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.topConstraint.constant != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.topConstraint.constant = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.topConstraint.constant = <span class="number">64</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.bottomConstraint.isActive &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.deactivate([<span class="keyword">self</span>.bottomConstraint])</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate([<span class="keyword">self</span>.heightConstraint])</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.deactivate([<span class="keyword">self</span>.heightConstraint])</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate([<span class="keyword">self</span>.bottomConstraint])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: <span class="number">0.25</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.view.layoutIfNeeded()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，还算不错：适应性强并且支持多种设备屏幕尺寸。 🤔</p></br><h1 id="如何为iOS创建自适应布局？"><a href="#如何为iOS创建自适应布局？" class="headerlink" title="如何为iOS创建自适应布局？"></a><strong>如何为iOS创建自适应布局？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果公司内置的 <code>iOS</code> 应用程序中都难以适应自适应布局。 如果你查看使用收藏夹视图制作的应用程序（例如照片），则在每个设备上的布局都可以。 但是，还有其他一些-我认为-在更大的屏幕上是可怕的经历。 <code>#just use collectionview</code> 所有内容。 🤐</p><h2 id="支持旋转"><a href="#支持旋转" class="headerlink" title="支持旋转"></a><strong><em>支持旋转</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自适应布局的第一步是支持多种设备方向。 你可以查看我以前有关iOS自动布局的文章，其中有很多关于旋转支持，在自动布局区域内使用图层等方面的好文章。</p><h2 id="特征集合"><a href="#特征集合" class="headerlink" title="特征集合"></a><strong><em>特征集合</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步是调整特征集合。  <code>UITraitCollection</code> 可以为你分组所有特定于环境的特征，例如尺寸类别，显示比例，用户界面 <code>idom</code> 等。 大多数时候，你将不得不检查垂直和水平尺寸类别。 有设备尺寸类别的参考以及 <code>Apple</code> 所做的所有可能的变化，请参阅下面的外部资源部分。 😉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的这个小段 <code>Swift</code> 代码示例演示了如何检查尺寸类别，以便为紧凑型和常规屏幕设置不同的布局。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> testView: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> regularConstraints: [<span class="type">NSLayoutConstraint</span>] = []</span><br><span class="line">    <span class="keyword">var</span> compactConstraints: [<span class="type">NSLayoutConstraint</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> testView = <span class="type">UIView</span>(frame: .zero)</span><br><span class="line">        testView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(testView)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.regularConstraints = [</span><br><span class="line">            testView.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            testView.widthAnchor.constraint(equalTo: testView.heightAnchor),</span><br><span class="line">            testView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">            testView.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.compactConstraints = [</span><br><span class="line">            testView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor),</span><br><span class="line">            testView.leadingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.leadingAnchor),</span><br><span class="line">            testView.trailingAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.trailingAnchor),</span><br><span class="line">            testView.bottomAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.bottomAnchor),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.activateCurrentConstraints()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView = testView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">activateCurrentConstraints</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.deactivate(<span class="keyword">self</span>.compactConstraints + <span class="keyword">self</span>.regularConstraints)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.traitCollection.verticalSizeClass == .regular &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate(<span class="keyword">self</span>.regularConstraints)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>.activate(<span class="keyword">self</span>.compactConstraints)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.testView.backgroundColor = .red</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - rotation support</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .allButUpsideDown</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .portrait</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - trait collections</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">traitCollectionDidChange</span><span class="params">(<span class="number">_</span> previousTraitCollection: UITraitCollection?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.activateCurrentConstraints()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设备检测"><a href="#设备检测" class="headerlink" title="设备检测"></a><strong><em>设备检测</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以通过 <code>UIDevice</code> 类检查用户界面 <code>idom</code> （是 <code>iPhone</code> 还是 <code>iPad</code> ？），以基于该设备设置例如字体大小。 📱</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIDevice</span>.current.userInterfaceIdiom == .pad</span><br></pre></td></tr></table></figure><h2 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a><strong><em>屏幕尺寸</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定你的环境的另一个选项是检查屏幕的大小。 你可以检查原始像素数或以 <code>points</code> 为单位的相对大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iPhone X</span></span><br><span class="line"><span class="type">UIScreen</span>.main.nativeBounds   <span class="comment">// 1125x2436</span></span><br><span class="line"><span class="type">UIScreen</span>.main.bounds         <span class="comment">// 375x812</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常我会尽力遵守这些规则。 我真的不记得一个场景，在这种情况下，我需要的不只是上面列出的所有内容。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
            <tag> 自动化布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS自动化布局编程</title>
      <link href="/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80%E7%BC%96%E7%A8%8B/"/>
      <url>/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个出色的 <code>iOS Auto Layout</code> 教程中，我将教你如何支持旋转，使用约束，使用图层以及设置拐角半径的动画。</p><br><h1 id="支持旋转"><a href="#支持旋转" class="headerlink" title="支持旋转"></a><strong>支持旋转</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你的应用程序要支持多种设备方向，则应在视图控制器内部实现以下方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .portrait</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .portrait</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，你可以更改返回值以不仅支持纵向，还支持横向模式。 这很容易，但是，如果你的控制器嵌入在导航或选项卡栏控制器内部，则旋转将停止工作。 在这种情况下，你必须继承 <code>UINavigationController</code> 的子类，并且必须从顶视图控制器返回正确的值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NavigationController</span>: <span class="title">UINavigationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> shouldRotate = <span class="keyword">self</span>.topViewController?.shouldAutorotate &#123;</span><br><span class="line">            <span class="keyword">return</span> shouldRotate</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldAutorotate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> orientation = <span class="keyword">self</span>.topViewController?.supportedInterfaceOrientations &#123;</span><br><span class="line">            <span class="keyword">return</span> orientation</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.supportedInterfaceOrientations</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> orientation = <span class="keyword">self</span>.topViewController?.preferredInterfaceOrientationForPresentation &#123;</span><br><span class="line">            <span class="keyword">return</span> orientation</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preferredInterfaceOrientationForPresentation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果具有 <code>UITabBarController</code> ，则适用相同的逻辑，但必须使用 <code>selectedIndex</code> 并基于所选视图控制器返回属性，而不是顶视图控制器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabBarController</span>: <span class="title">UITabBarController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> shouldAutorotate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewController = <span class="keyword">self</span>.viewControllers?[<span class="keyword">self</span>.selectedIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> viewController.shouldAutorotate</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldAutorotate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewController = <span class="keyword">self</span>.viewControllers?[<span class="keyword">self</span>.selectedIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> viewController.supportedInterfaceOrientations</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.supportedInterfaceOrientations</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> preferredInterfaceOrientationForPresentation: <span class="type">UIInterfaceOrientation</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewController = <span class="keyword">self</span>.viewControllers?[<span class="keyword">self</span>.selectedIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> viewController.preferredInterfaceOrientationForPresentation</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preferredInterfaceOrientationForPresentation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，你的嵌入式控制器就可以控制支持的方向。 哦，顺便说一句，你可以使用此方法更改状态栏样式。</p></br><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a><strong>约束</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了 <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/" target="_blank" rel="noopener"><code>了解约束</code></a> 和 <a href="https://www.raywenderlich.com/160527/auto-layout-tutorial-ios-11-getting-started" target="_blank" rel="noopener"><code>Auto Layout engine</code></a> 的当前状态，我们应该回到过去并从头开始。</p><h2 id="Springs-and-struts"><a href="#Springs-and-struts" class="headerlink" title="Springs and struts"></a><strong><em>Springs and struts</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还记得第一部 <code>iPhone</code> 吗？ 一屏统治一切！ <code>320x480</code>，没有限制，没有适应性，只有帧和边界。 在固定大小的画布上放置视图绝对是理所当然的，这是一个示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> squareFrame: <span class="type">CGRect</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> midX = <span class="keyword">self</span>.view.bounds.midX</span><br><span class="line">        <span class="keyword">let</span> midY = <span class="keyword">self</span>.view.bounds.midY</span><br><span class="line">        <span class="keyword">let</span> size: <span class="type">CGFloat</span> = <span class="number">64</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGRect</span>(x: midX-size/<span class="number">2</span>, y: midY-size/<span class="number">2</span>, width: size, height: size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.frame = <span class="keyword">self</span>.squareFrame</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>viewDidLayoutSubviews</code> 方法可以非常方便地支持旋转，如果边界矩形发生变化，我每次都必须重新计算视图的框架。 你可能会想，这很容易，但是如果你必须支持许多设备尺寸会怎样？</p><blockquote><p><strong><em>算一算！</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于单个对象，进行计算非常容易，但是通常你在屏幕上有多个视图。 这些视图可以相互联系，简单的数学技巧可以使你完全陷入帧计算的混乱之中，你还会喜欢数学吗？ 肯定有更好的办法！</p></br><h1 id="Auto-Layout"><a href="#Auto-Layout" class="headerlink" title="Auto Layout"></a><strong>Auto Layout</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;苹果通过<code>iOS6</code>为我们带来了布局技术的圣杯。 它是先前系统的完美继承者。 每个人都很快采用了它，这就是为什么苹果工程师在下一版本中完全删除了基于框架的布局<code>API</code>的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了开玩笑之外，这是一个新时代的开始，越来越多的设备诞生了，并且由于自动版式的限制，维护视图非常容易。 现在，我们应该使用布局约束来重构前面的示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        square.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">self</span>.view.addConstraints([</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .width, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="literal">nil</span>, attribute: .width, multiplier: <span class="number">1.0</span>, constant: <span class="number">64</span>),</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .height, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="literal">nil</span>, attribute: .height, multiplier: <span class="number">1.0</span>, constant: <span class="number">64</span>),</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .centerX, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="keyword">self</span>.view, attribute: .centerX, multiplier: <span class="number">1.0</span>, constant: <span class="number">0</span>),</span><br><span class="line">            <span class="type">NSLayoutConstraint</span>(item: square, attribute: .centerY, relatedBy: .<span class="built_in">equal</span>, toItem: <span class="keyword">self</span>.view, attribute: .centerY, multiplier: <span class="number">1.0</span>, constant: <span class="number">0</span>),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，我们不需要手动计算视图的框架，但是以编程方式创建约束并不是那么方便。 这就是为什么 <code>Apple</code> 制定了限制格式 <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html" target="_blank" rel="noopener"><code>Visual Format Language</code></a>。</p><blockquote><p><strong><code>VFL = WTF?</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，这个<code>VFL</code>非常糟糕，我什至不想演示它，但是无论如何…</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        square.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> views: [<span class="type">String</span>:<span class="type">Any</span>] = [<span class="string">"view"</span>: <span class="keyword">self</span>.view, <span class="string">"subview"</span>: square]</span><br><span class="line">        <span class="keyword">let</span> vertical = <span class="type">NSLayoutConstraint</span>.constraints(withVisualFormat: <span class="string">"V:[view]-(&lt;=1)-[subview(==64)]"</span>, options: .alignAllCenterX, metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> horizontal = <span class="type">NSLayoutConstraint</span>.constraints(withVisualFormat: <span class="string">"H:[view]-(&lt;=1)-[subview(==64)]"</span>, options: .alignAllCenterY, metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line">        <span class="keyword">self</span>.view.addConstraints(vertical)</span><br><span class="line">        <span class="keyword">self</span>.view.addConstraints(horizontal)</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>God forbid the engineer who invented this black magic. :)</code></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如你所见，我们肯定存在约束方面的问题。 创建所有约束很糟糕，至少要花很多行代码。 当然，你可以使用神奇的界面生成器，但是如果只是拖动线，那么有趣的地方在哪里呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以编程方式创建约束并不比计算框架好，它会导致你达到相同的复杂度甚至更糟，这就是为什么这么多第三方框架活跃起来并最终由<code>Apple</code>发出问题的原因。</p><blockquote><p><strong><code>提示:</code></strong><br>我有一篇<a href="http://www.xuebaonline.com/Swift%E6%8E%8C%E6%8F%A1iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9/"><code>关于掌握自动布局锚点</code></a>的出色文章，如果你想熟悉锚点，强烈建议阅读。 📖</p></blockquote></br><h1 id="锚点-Anchors"><a href="#锚点-Anchors" class="headerlink" title="锚点(Anchors)"></a><strong>锚点(Anchors)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.xuebaonline.com/Swift%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%9A%E7%82%B9%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F/"><code>锚点(Anchors)</code></a>的诞生是因为“自动布局”存在一些构造缺陷。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>NSLayoutAnchor</code> 类是用于使用流畅的 <code>API</code> 创建 <code>NSLayoutConstraint</code> 对象的工厂类。 使用这些约束可以使用“自动布局”以编程方式定义你的布局。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> square: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> square = <span class="type">UIView</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(square)</span><br><span class="line">        square.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            square.widthAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            square.heightAnchor.constraint(equalToConstant: <span class="number">64</span>),</span><br><span class="line">            square.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerXAnchor),</span><br><span class="line">            square.centerYAnchor.constraint(equalTo: <span class="keyword">self</span>.view.centerYAnchor),</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">self</span>.square = square</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.square.backgroundColor = .yellow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>锚点是用于自动布局约束的最佳方法。</em></strong></p></br><h1 id="自适应布局-Adaptive-layout"><a href="#自适应布局-Adaptive-layout" class="headerlink" title="自适应布局(Adaptive layout)"></a><strong>自适应布局(Adaptive layout)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果查看 <code>Apple</code> 提供的内置应用程序的当前状态，你会发现只有其中一些是响应式/自适应的。 通常，使用集合视图的应用更容易适应更大的屏幕或不同的设备方向。</p><p><strong><em>始终使用 <code>collection views</code>。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了只是屏幕中心的一个视图之外，你都应该使用集合视图来构建用户界面。 它将为你提供可重用性，更低的内存开销，滚动以及更多好处。 如果你使用的是我的 <code>CollectionView</code> 微型框架，则甚至不必计算愚蠢的索引位置。</p></br><h1 id="基于图层的自动化布局"><a href="#基于图层的自动化布局" class="headerlink" title="基于图层的自动化布局"></a><strong>基于图层的自动化布局</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动布局很棒，但有时你必须直接处理图层。 现在在这种情况下，你仍然必须进行一些计算。 如果要处理视图子类，则可以轻松覆盖 <code>bounds</code> 属性并更新 <code>didSet</code> 块中的框架。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.gradientLayer.frame = <span class="keyword">self</span>.bounds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个选项是在视图控制器中重写 <code>viewDidLayoutSubviews</code> 方法，并根据新边界设置图层的框架。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.gradientView.gradientLayer.frame = <span class="keyword">self</span>.gradientView.bounds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你还可以使用普通的键值监听来观察对象的 <code>bounds</code> 属性，并根据该属性来更新图层的框架。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// somewhere in the init method</span></span><br><span class="line"><span class="keyword">self</span>.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"bounds"</span>, options: .new, context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: <span class="keyword">Any</span>?, change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> keyPath == <span class="string">"bounds"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.gradientLayer.frame = <span class="keyword">self</span>.bounds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"bounds"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="带有动画的圆角设置"><a href="#带有动画的圆角设置" class="headerlink" title="带有动画的圆角设置"></a><strong>带有动画的圆角设置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，如果要在使用基于约束的布局时为视图设置动画，则必须执行类似的操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.widthConstraint.constant = <span class="number">64</span></span><br><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.view.layoutIfNeeded()</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，如果要为视图的拐角半径设置动画，则可以始终使用传统方式，并在边界更改上设置图层的 <code>cornerRadius</code> 属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，自<code>iOS 10</code>以来，我们有了这个精美的新 <code>UIViewPropertyAnimator API</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="number">16</span></span><br><span class="line"><span class="type">UIViewPropertyAnimator</span>(duration: <span class="number">2.5</span>, curve: .easeInOut) &#123;</span><br><span class="line">    <span class="keyword">self</span>.imageView.layer.cornerRadius = <span class="number">32</span></span><br><span class="line">&#125;.startAnimation()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这非常简单，你甚至可以应用 <code>cornerMask</code> 来仅对某些角进行倒圆。 基于图层的布局示例位于本文提供的源代码中，以及每种自动布局技术的完整示例。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> UIKit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>产品开发的幕后花絮</title>
      <link href="/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E7%9A%84%E5%B9%95%E5%90%8E%E8%8A%B1%E7%B5%AE/"/>
      <url>/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E7%9A%84%E5%B9%95%E5%90%8E%E8%8A%B1%E7%B5%AE/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍产品专业人员用来定义问题，创建概念和选择最佳解决方案的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与关于设计师职务的争论类似，对于设计师是否应该编码，这是一个永无止境的讨论。 首先，我们谈论的是根本不同的心态。 尽管开发人员对技术流程的思考更多，但设计人员专注于用户执行的一系列操作，因为他们的目的是提出解决客户问题的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，产品设计师（或UX设计师，但正如我之前提到的那样，我不喜欢该职位）通常不做任何编码，仅因为我们从事的活动是专职职责。 设计师的大部分工作实际上甚至没有建立图形用户界面，而是进行了大量的交流和研究。 🔍</p><a id="more"></a></br><h1 id="我们有一个问题"><a href="#我们有一个问题" class="headerlink" title="我们有一个问题"></a><strong>我们有一个问题</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，当我拿到设计图时，该过程已经开始。 我们的产品经理来找我解决问题。 有几种定义问题的方法，例如根据数据分析或竞争对手的活动做出的假设； 技术改进为我们提供了更多空间； 或客户的直接要求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步（也是最重要的一步）是了解问题。 假设我们盯着分析，看到用户在流程的某个特定点下降，放弃它而没有完成任务。 问题是：为什么？ 提供解决方案之前，你需要确定要解决的问题。 你需要了解动机，目标，需求以及用户当前解决问题的方式。</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接来自客户的想法可以对你的系统进行非常好的改进，但是你需要谨慎。 系统越大，用户对系统一无所知的机会就越大，这可能导致错误的假设。 他们可能不知道某些“隐藏”的细节，但是如果知道的话，他们会问一个完全不同的问题。 用户对现有系统的信念称为心理模型。 这仅表示他们基于对当前工具的了解，相信他们可以或不能使用你的工具。 心理模型可能会因教育或经验而改变，因此在你开始编写代码之前，你可能需要了解他们为什么想要特定的东西。 也许解决方案不是他们想要的，但是你可以给他们更好的解决方案。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有几种方法可以收集有关原因的信息，而我最喜欢的两个是调查和访谈。 你可以收集所有听众提出的一些高级问题，然后发送表格。 找到适合你的问卷调查的最佳平台并不总是容易的：虽然一个渠道可以为你提供大量的答案，但另一个渠道将是死路一条。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间安排也很重要：你应该注意听众的时间表。 当他们太忙甚至不工作时，他们将没有时间或精力来帮助你。 进行良好调查的秘诀还有很多，但重点是你需要耐心，尝试几种方法来吸引受众，直到找到最适合你的案例。</p></br><h1 id="与用户的真正联系：用户访谈"><a href="#与用户的真正联系：用户访谈" class="headerlink" title="与用户的真正联系：用户访谈"></a><strong>与用户的真正联系：用户访谈</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我喜欢的另一种做法是进行用户访谈。 听起来就是这样：你与用户（最好是一对一）坐下并与他们交谈。 你需要再次准备问题，但是调查虽然可以帮助你了解很多事情，但是面试仅可以帮助你解决一些问题，但范围更广。 重要的是进行实际对话而不是询问客户：你收集的问题是面试的基础，但是当客户回答时，你可以侧身甚至完全劫持讨论（只要你谈论的是你所遇到的问题） 都想解决）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你随身携带一个记事本，这将很有帮助，这样你就可以在伴侣写下最重要的要点时全神贯注于对话。 如果你的客户同意，你可以记录下采访，以便稍后再听并写下你自己的笔记。 🗒</p><blockquote><p><strong><code>提示:</code></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重要的是要观察到广泛的用户，尤其是在组中有多种用户的情况下。 如果你只关注一个小组，那么你可能会满足这对夫妇的需求，而拒绝其他人。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我对问题有满意的答案时，我可以通过创建草图或基本模型来开始实际的“设计”工作。在这一点上，我并没有将重点放在外观或精度上，我只是尝试为我的想法建立一些视觉支持。有时，我什至没有构建整个功能或页面，而只是构建一个特定的部分，例如复杂的控制器，模式，表单等等。我还尝试至少提出2-3个概念。这将帮助我与团队交流思想：那是我参与开发人员的地方，因为下一步是了解技术限制。当然，如果我们无法为用户找出有史以来最好的UI元素，那也没关系。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在收集了我们需要的所有信息之后（包括用户的必备信息，开发人员的约束以及可能的其他因素，例如设计，完整性和一致性准则等），我们的工作重点变得更加狭窄。这是我开始在像素完美的UI上工作的地方。我创建了可点击的原型，因此可以为团队提供一个快照，以显示实际软件的外观和工作方式，更重要的是，它们将成为可用性测试的核心：是的，我们将回头再回头。</p></br><h1 id="可用性测试简介"><a href="#可用性测试简介" class="headerlink" title="可用性测试简介"></a><strong>可用性测试简介</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户测试类似于访谈，你一次要与1位用户交谈，但是你可以提出任务而不是提问。你应该准备要执行的3-4个任务，就像它们已经存在时在系统中通常会执行的操作一样。这是验证你的工作，查看用户是否真的能够通过你的特定概念解决他们的问题的好方法。你如何进行这些会议的方式可能会因项目，概念因人员而异，但是以下一些重点可以派上用场：</p><ul><li>你测试用户界面而不是用户。无论他们做错了什么，不是他们的错，这是你的界面的缺陷。他们应该知道，你也知道。</li><li>不要给出详细的说明，而要编写高级任务，类似于现实生活中的任务。即使他们受过使用你的软件的教育，也不会一直有人陪他们走走。为了模拟这一点，你也不能通过原型指导他们。</li><li>包括与任务不直接相关的选项。如果你使用一些原型制作工具，它可能会以某种方式突出显示可点击元素。如果唯一可点击的东西是测试的控制器，他们将很容易找到解决方法。但是，如果有几个不同的可操作项目，它们将能够环顾四周，打开和关闭物品，并且一旦达成交易便会迷失方向。即使你感觉“来吧，就在那里，为什么不找到它”，也应该抵制胆量并保持沉默。对你来说也许很清楚，但对他们来说却是一个谜。这些测试的目的是发现谜语，而不是证明你的想法合理。</li><li>提醒参与者在整个会议过程中大声思考，以便你了解他们为什么做自己的事情。与面试期间一样，你应该创建笔记并可能记录会话。会议结束后，你还可以与用户聊天。你可以回去问一下，如果他们在会议期间没有解释，为什么他们要做特定的事情。你甚至可以在这一点上询问他们的意见，但绝不能在会议期间提出。放弃有关UI的想法可能会使你偏离测试目标，因此请保持专注并保持参与者的专注。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些会议的结果将帮助你了解概念的弱点，或者只是帮助你选择最佳的概念。 你可以重新考虑一些事情，然后再进行测试，然后再继续。 测试和迭代的次数取决于你的时间和预算：根据 <code>Jacob Nielsen</code> 的说法，如果与5个用户一起测试，最好的方法是考虑未发现的问题的数量和会话的成本，因为一段时间后，用户会反复发现其他已经存在的问题 裸露。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适当招募参与者也很重要。 如果你要为会计师构建应用程序，则可能不会获得机械师的宝贵反馈。 同样，如果你要改善现有服务，则最好与已经使用该服务的人联系，而不是与新员工交谈（除非你尝试弄清楚新手将如何与新功能交互）。</p><br><h1 id="要避免的常见错误"><a href="#要避免的常见错误" class="headerlink" title="要避免的常见错误"></a><strong>要避免的常见错误</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一种称为设计批判的做法，在这种做法中，大量的团队成员（设计师，开发人员，质量保证人员，产品经理等）坐在一起讨论设计。 你提出自己的想法，其他人则可以基于对一致性，技术约束，所有问题或简单的可用性假设的关注而提出问题并提出更改建议。 这可能真的很有帮助：当你花很长时间尝试解决问题时，可能会遇到困难。 睁开眼睛和其他角度可以帮助你摆脱困境，无论如何都要进行一些头脑风暴总是好的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，团队经常将<code>DC</code>会话与适当的可用性验证混淆。 为什么不能仅用它们代替<code>UX</code>研究有以下几个原因：</p><ul><li><strong><em>详细说明</em></strong> &nbsp;&nbsp;&nbsp;&nbsp;在可用性测试期间，你将执行任务并查看其他人如何与你的原型进行交互，而设计评论则是关于你自己讲述整个故事。你按照流程进行操作，并告诉团队正在发生什么以及为什么。这样很容易理解，但是如果仅<code>UI</code>没有解释，则可能会失败。</li><li><strong><em>领域知识</em></strong> &nbsp;&nbsp;&nbsp;&nbsp;即使你只是在从事合同项目，与你一起工作的团队也具有丰富的领域知识。你知道系统的工作原理，知道后台发生了什么，如何传输数据，调用了什么<code>API</code>……用户不知道这种事情，你也不是你的用户。</li><li><strong><em>主观性</em></strong> &nbsp;&nbsp;&nbsp;&nbsp;虽然你可能喜欢某些东西，但其他人可能不喜欢。另外，尽管你认为某些事情很清楚，但其他人可能不理解。当你说“我认为这可行”时，这只是你的观点，其他人可能会基于他们的观点对此进行争论。意见分歧可以帮助你取得进展，但是，如果保持不变，这是一个标志，你应该查看用户的反应方式，而不是争夺你的意见。</li><li><strong><em>自我</em></strong>  &nbsp;&nbsp;&nbsp;&nbsp;我并不是说它总是存在，但是这些讨论很容易变成有争议的论据，每个人都试图说服他人。我对此不够强调：你没有为自己设计（或编写代码），而是为用户设计。如果团队中的某个人有一个更好的主意，或者只是发现了一个错误，请高兴地为你提供改善产品的机会。这不是单人表演，而是团队失败或胜利。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，要在没有任何实际数据的情况下通过一次演示来证明自己要困难得多。当你的设计基于推测时，可能很难捍卫一个想法，因为你无法用事实来支持它。其他人可能有不同的假设，从这一点出发，论点立足或落在参与者的说服力上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这并不意味着这些会议根本没有用，它们无法替代研究，因为它们以不同的方式帮助你。我也认为争论通常是好的，因为我们可以了解很多彼此的观点。我要说的是不确定性使事情变得困难，因为你只有在发表作品后才能看到结果。最好的办法是定期与团队进行研究并进行同步，以便在技术上仍可行的情况下，确保要构建的内容能够很好地为用户服务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你创建的所有内容都会带来用户体验。 UX不是你设计的，而是工作的必然结果。请记住这一点。 🙏</p></br><h1 id="设计师应该编码吗？-开发人员应该设计吗？"><a href="#设计师应该编码吗？-开发人员应该设计吗？" class="headerlink" title="设计师应该编码吗？ 开发人员应该设计吗？"></a><strong>设计师应该编码吗？ 开发人员应该设计吗？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为存在这个永恒的问题是因为图形<code>UI</code>设计本身通常并不困难。 <code>UI</code>设计工具（例如<code>Sketch</code>或<code>Figma</code>）非常简单，即使没有经验也很容易使用，而无需谈论网络上成千上万的优质教程和资源。图形用户界面设计是一项技能，而成为专家意味着你还拥有许多其他有价值的技能，这些技能最终将定义你。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于设计师和开发人员的思维方式之间存在核心差异，因此我更喜欢将研究与设计结合起来，而不是将设计与编码结合起来。如果你对自己的系统技术知识有偏见，可能很难找到问题的抽象解决方案。这就是为什么我在多个学科的协作以及不同观点的结合中看到真正价值的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，以视觉方式呈现你的作品仍然是有益的，因为它可以帮助你发现潜在的盲点和缺失的边缘情况，还可以帮助连接点并查看整体图片，最后但并非最不重要的一点：它要快得多在设计工具中进行修复而不是在实际代码中进行修复。因此，虽然我不说开发人员应该设计，但某些设计技能可以很好地补充你的工作流程。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 用户体验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 用户体验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作为Swift开发人员，如何提供更好的用户体验？</title>
      <link href="/%E4%BD%9C%E4%B8%BASwift%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%9F/"/>
      <url>/%E4%BD%9C%E4%B8%BASwift%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过一些可访问性提示来学习用户体验设计的基础知识，你可以立即使用这些提示为每个人构建更好的移动应用程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 很有趣，但是你曾经尝试过 <code>UX</code> 吗？ 当然有 你使用的所有内容都会带来用户体验。 遵循这样的逻辑：你创建并将要由他人使用的所有内容也将导致 <code>UX</code> 。 但是到底是什么，设计师和开发人员在哪里适合呢？ 让我们找出答案。</p><a id="more"></a></br><h1 id="用户体验设计"><a href="#用户体验设计" class="headerlink" title="用户体验设计"></a><strong>用户体验设计</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于所有不同类型的设计师，都有大量的文章，我也可以编写自己的文章，但现在暂时跳过。 我唯一要提及的是，我个人不喜欢 <code>“用户体验设计师”</code> 这个称呼，因为它可能会引起误解。 几乎没有设计专业人员经验的公司都希望你神奇地找出最好的 <code>UX</code> ：“因为那是你的工作，对吧？ 错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><em>用户体验是任何使用工具的人都在发生的现象。</em></strong> 任何工具。你是否在Twitter上发帖？它是 <code>UX</code> 。你是否在 <code>iPad</code> 上阅读邮件？它是 <code>UX</code> 。你是否喝用旧金属咖啡机制作的咖啡？用户体验。你是否刚刚从宜家购买了新椅子，并且必须将其放在一起？相同。你是否只是坐在崭新的椅子上享受一杯咖啡？仍然是 <code>UX</code> 。 ☕️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我可以设计这些东西吗？我可以说你会从头到尾按照此特定顺序进行所有这些操作，并且你会喜欢吗？不。我可以映射这种情况的可能方式吗？是的开始了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户体验“设计”是了解需求（你想每天早上在舒适的椅子上上班前喝咖啡），然后提供满足需求的工具。当然，我希望你尽可能轻松地实现自己的目标，因此，我将尝试了解你现在的处事方式以及如何更改这些处境以改善你的处境。然后，我将找出一种方法并定义“预期的用户体验”，并为你进行设置。到达那里后，你将获得真实的用户体验，这可能与我们期望的有很大不同。<strong><em>用户体验设计的目标是使期望的用户体验尽可能接近实际用户体验。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，舒适性不是 <code>UX</code> 的唯一方面。无论你创建什么内容，都希望使其易于理解，可学习，令人难忘，一致，可访问且安全。</p><p><strong>如果看起来也不错，那很好。</strong></p></br><h1 id="UX-舒适：辅助功能简介"><a href="#UX-舒适：辅助功能简介" class="headerlink" title="UX != 舒适：辅助功能简介"></a><strong>UX != 舒适：辅助功能简介</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如前所述，构建良好的用户界面具有挑战性。假设你正在开发应用程序，网站，服务或其他任何东西，并且希望使用框架的帮助。网路上有许多使用者介面框架和范本，因此你会很容易找到适合你的介面。可能要格外小心，为你的用户找到合适的产品。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可访问性（简称<code>a11y</code>）是 <code>UX</code> 最重要的方面之一。世界人口的10-20％患有一种或多种残疾。根据此摘要，英国，美国和加拿大的网络用户中有 <code>7％</code> 有灵活性问题；其中<code>8％</code>有某种色盲；并且其中<code>3-4％</code>的人看不清自己的阅读能力，而且随着时间的流逝越来越多。人们经常说a11y是有特殊需求的用户，但是我们不是都有我们自己的“特殊”自定义偏好吗？我们整理工作表以轻松实现所有功能，将应用程序按特定顺序分组在<code>iPhone</code>上，我们打开黑暗模式以获得更好的阅读体验和爱侣般的功耗… <code>A11y</code>并没有太大不同，并且移动设备很多辅助功能注意事项实际上非常简单：将信息最小化以适合小屏幕；使用明确的措辞，尤其是在可诉诸事项上；提供合理的触摸目标尺寸和间距；将控制器放置在易于访问的位置；使用正确的背景-前景对比（有类似的工具可以帮助你）；不仅依赖颜色：使用绿色，黄色和红色点进行状态反馈对你来说可能是一个简单明了的主意，但是对于某些人来说，它们只是灰色阴影（这是一个很酷的浏览器扩展程序，可以帮助你了解其他人看到）；手势应尽可能简单，如果你可以添加变通功能以通过屏幕菜单甚至键盘操作来模拟手势，则效果会更好，因为越来越多的移动设备也支持键盘。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，<code>iOS</code>具有强大的<code>a11y</code>支持，我也非常推荐这篇关于<code>SwiftUI</code>可访问性的文章。长话短说：通过采用<code>SwiftUI</code>，你将在正确的道路上为所有<code>iOS</code>用户提供可访问的<code>UI</code>（当然，与设计无关）。 <code>UIKit</code>也并非没有选项，但我将保留<code>Tib</code>的技术部分。 🙂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有更多的原则，但是下面列出的是一个好的开始。你可以将它们应用到<code>Web</code>应用程序中，因为无论如何都需要使其可移动。但是，即使你已做好一切准备，你仍然可能会出错。让我给你看一个例子。</p></br><h1 id="视觉设计的力量"><a href="#视觉设计的力量" class="headerlink" title="视觉设计的力量"></a><strong>视觉设计的力量</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设你在一个网页上，其中加载了“无限”元素列表以进行滚动（例如新闻源）。页面底部有一个固定的页脚，其中包含一些持久性和动态（隐藏）操作。你可以从页面中选择项目，然后在页脚中通过批量操作按钮“全部删除”。容易吧？ 👌</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在假设你不能使用触摸或鼠标，只能使用物理键盘。你可以按<code>Tab</code>键进行导航，从一个<code>UI</code>元素跳到另一个<code>UI</code>元素，但是列表仅加载越来越多的数据，因此你无法到达页脚，这意味着你无法进行操作。当然，修复起来很容易，只需将“加载滚动”选项替换为“加载更多”按钮，即可集中精力跳转到页脚，而无需加载更多项目。但是，如果你错过了它，则可能会阻止某些用户执行操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从另一个角度来看这个例子。选择要删除的项目，然后出现“全部删除”按钮，取消选择它们后它消失，因此可以连接各个点。但是，如果你没有看到此视觉反馈，该怎么办？如果只有屏幕阅读器告诉你“全部删除”按钮处于焦点，该怎么办？你是否知道仅适用于所选项目，还是希望它清除所有数据？如你所见，你使用的副本也很重要。当你看到“全部删除”已连接到所选项目时，“仅删除所选内容”对于那些只能依靠耳朵听的人也很清楚。虽然基本的UI对大多数用户都适用，但可访问的UI对所有人都更好。因此，别忘了照顾它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编码前设计UI可以帮助你解决这些情况，因此你不必浪费时间实施有缺陷的UI的多个版本。最受欢迎的框架都具有用于设计工具（例如<code>Sketch</code>或<code>Figma</code>）的组件库，因此你不会费劲将代码与设计进行匹配。大型公司非常注重维护和记录自己的自定义框架和<code>UI</code>库（共称为设计系统），以实现更快的工作流和更一致的<code>UI</code>，从而满足所有<code>UX</code>要求。但我会保留此内容以备将来之用。 😉</p></br><h1 id="用户界面之外的用户体验"><a href="#用户界面之外的用户体验" class="headerlink" title="用户界面之外的用户体验"></a><strong>用户界面之外的用户体验</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经讨论了工具的“触感”，现在让我们来看看幕后。他们说，最好的UX是看不见的，我敢说，至少在我们要执行任务时，我们都更喜欢简单而不是美观或娱乐。你的用户界面有多酷，服务是否不好，或者没有给用户他们想要的东西都没有关系。但是，如果你提供的工具运行良好，并且可以帮助用户有效地完成工作，则他们可能不太在乎界面的外观（请记住将 <code>iOS6</code> 换成 <code>iOS7</code> 😏）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，<code>UI</code>的简单性意味着后台的复杂性。只需考虑一下搜索引擎：这是一个非常简单的用户体验，你只需在搜索字段（甚至是浏览器的网址栏）中输入内容，然后魔术般地出现在屏幕上。在这里，你无需关心美观，有趣的动画或其他任何内容，而只关心速度和准确性：你想找到东西，现在就想要。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道看到加载动画超过3秒钟是多么令人沮丧。实际上，有研究表明，如果加载时间超过3秒，用户将放弃你的网站，这可能会令人震惊。毋庸置疑，视觉设计师对此无能为力。这是<code>UX</code>高度依赖开发人员的工作的众多情况之一，这是巨大的责任！我们所有人都希望轻松完成工作，但是有时候选择短路径意味着我们的用户将不得不走更长的路。我知道在项目束缚我们的过程中有很多因素（期限，遗留代码，依赖项等），但是如果你有机会提出问题的解决方案，请不要犹豫，因为这样做更容易。你的用户稍后会感谢你。 😊</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 用户体验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 用户体验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭秘 WordPress Hook 系统</title>
      <link href="/%E6%8F%AD%E7%A7%98%20WordPress%20Hook%20%E7%B3%BB%E7%BB%9F/"/>
      <url>/%E6%8F%AD%E7%A7%98%20WordPress%20Hook%20%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你一直在使用 <code>WordPress</code> 开发网站（包括插件和主题开发），那么你可能已经听说过以下术语：<code>挂钩</code>，<code>操作</code>和<code>过滤器</code>。 这些是 <code>WordPress</code> 使用的 <a href="https://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="noopener"><code>事件驱动架构模式(英文：Event-driven architecture)</code></a> 的一部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是 <code>WordPress</code> 开发的新手还是发现难以理解基本概念？ 我不能推荐足够高的 <a href="https://www.sitepoint.com/author/scodrington/" target="_blank" rel="noopener"><code>Simon Codrington</code></a> 的 <code>WordPress</code> 插件开发简介教程。 他在解释 <code>动作</code> 和 <code>过滤器</code> 方面做得很出色。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本教程中，我将揭开 <code>WordPress</code> 钩子系统的神秘面纱，不遗余力。 事不宜迟，让我们开始吧。</p><a id="more"></a></br><h1 id="挂钩，动作，过滤器。-这些是什么？"><a href="#挂钩，动作，过滤器。-这些是什么？" class="headerlink" title="挂钩，动作，过滤器。 这些是什么？"></a><strong>挂钩，动作，过滤器。 这些是什么？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>“挂钩”</code>基本上是由 <code>WordPress</code> 核心，主题和插件在 <code>PHP</code> 执行或解释的各个阶段触发的事件。 当这些事件被触发时，挂钩或附加到它们的所有函数和/或类方法均以其正确顺序执行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>挂钩</code>有两种形式，<code>动作</code>和<code>过滤器</code>。 前者用于在流程执行的各个阶段添加和删除功能部件，而后者则用于修改各种功能部件和实现的行为。 如果你仍然不了解，请不要担心。 当我们开始在下面看到一些代码示例时，你将看到。</p></br><h1 id="WordPress中Hook系统的重要性"><a href="#WordPress中Hook系统的重要性" class="headerlink" title="WordPress中Hook系统的重要性"></a><strong>WordPress中Hook系统的重要性</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>钩子系统</code> 在 <code>WordPress</code> 中的重要性仅仅是可扩展性。 它使添加和删除功能以及调整/修改 <code>WordPress</code> 核心，插件和主题中功能的实现成为可能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你编写可扩展的插件和主题时，其他开发人员无需编辑核心源代码就可以改进和扩展它们。</p></br><h1 id="深入研究WordPress挂钩系统"><a href="#深入研究WordPress挂钩系统" class="headerlink" title="深入研究WordPress挂钩系统"></a><strong>深入研究WordPress挂钩系统</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>WordPress</code> 执行的各个阶段，通常会使用 <code>do_actions（）</code>和<code>a pply_filters（）</code> <code>PHP</code> 函数来触发大量事件。 这些事件可以通过 <code>add_action（）</code>和 <code>add_filter（）</code>进行订阅或挂接。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意使用“普通”一词。 还有其他触发事件的方法。 我们将在本教程的第二部分中对此进行探讨。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是插件中操作的示例。 在我的 <code>ProfilePress</code> 用户注册插件中成功注册用户后，将触发此操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fires after a user registration is completed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param int $form_id ID of the registration form.</span></span><br><span class="line"><span class="comment"> * @param mixed $user_data array of registered user info.</span></span><br><span class="line"><span class="comment"> * @param int $user_id ID of the registered user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">do_action( 'pp_after_registration', $form_id, $user_data, $user_id );</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>WordPress</code> 执行期间，将处理与该操作关联的所有功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过滤器挂钩的一个示例是 <code>WordPress</code> 核心中的 <code>the_content</code> ，它过滤每个帖子内容。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Filter the post content.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 0.71</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> string $content Content of the current post.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   $content = apply_filters( <span class="string">'the_content'</span>, $content );</span><br></pre></td></tr></table></figure></br><h1 id="做个笔记"><a href="#做个笔记" class="headerlink" title="做个笔记"></a><strong>做个笔记</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>do_action（）</code>中，第一个参数是动作挂钩的名称，后续参数是可供挂钩到动作的函数使用的变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>apply_filters（）</code>中，第一个参数是过滤器挂钩的名称，第二个参数是修改或应用连接到过滤器的函数的数据或值。 后面的参数是挂钩到过滤器的函数可用的变量/值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不用担心，当我们检查代码示例时，所有这些将更有意义。</p><br><h1 id="动作挂钩示例"><a href="#动作挂钩示例" class="headerlink" title="动作挂钩示例"></a><strong>动作挂钩示例</strong></h1><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a><strong><em>实例1</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;试一下我的 <code>ProfilePress</code> 插件的 <code>pp_after_registration</code> 操作； 假设我们要实现一项功能，使用户在注册后会立即收到一条 <code>SMS</code>（通过称为 <code>Dolio</code> 的消息传递服务），欢迎他们访问你的网站。 我们的函数挂钩可以采用以下形式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'pp_after_registration'</span>, <span class="string">'send_users_welcome_sms'</span>, <span class="number">20</span>, <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send_users_welcome_sms</span><span class="params">( $form_id, $user_data, $user_id )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $service_locator;</span><br><span class="line"></span><br><span class="line">    $username    = $user_data[<span class="string">'username'</span>];</span><br><span class="line">    $firstName   = $user_data[<span class="string">'first_name'</span>];</span><br><span class="line">    $lastName    = $user_data[<span class="string">'last_name'</span>];</span><br><span class="line">    $phoneNumber = $user_data[<span class="string">'phone_number'</span>];</span><br><span class="line"></span><br><span class="line">    $text = <span class="string">&lt;&lt;&lt;SMS_CONTENT</span></span><br><span class="line"><span class="string">Hello <span class="subst">$firstName</span> <span class="subst">$lastName</span>, Welcome to SitePoint. "\r\n"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">User ID: <span class="subst">$user_id</span> "\r\n"</span></span><br><span class="line"><span class="string">Username: <span class="subst">$username</span> "\r\n"</span></span><br><span class="line"><span class="string">Password: The password you sign up with "\r\n"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SMS_CONTENT;</span></span><br><span class="line"></span><br><span class="line">    $dolio = $service_locator-&gt;get( <span class="string">'dolio_sdk'</span> );</span><br><span class="line">    $dolio-&gt;phone_number( $phoneNumber );</span><br><span class="line">    $dolio-&gt;sms_content( $text );</span><br><span class="line">    $dolio-&gt;send();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中 <code>add_action</code> 的第三个参数是挂钩优先级，该挂钩优先级指定了挂钩到 <code>pp_after_registration</code> 动作的函数的执行顺序。 将其保留为空将默认为10。而第四个参数指定函数挂钩将接受的参数数量。 如果为空，则默认为1。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我省略了第四个参数，因此默认为1，则<code>$ user_data</code>和<code>$ user_id</code>变量将为<code>null</code>，因为我们只告诉函数仅接受一个参数。</p><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a><strong><em>实例2</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WordPress</code> 包含以下动作挂钩- <code>wp_head</code> 和 <code>wp_footer</code> ，它们分别在<code>head</code>标签和前端的<code>body</code>标签之前触发。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些挂钩可用于在那些关键位置显示脚本和数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看看一些代码示例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下代码使用 <code>wp_head</code> 将 <code>Google</code> 的站点验证元标记添加到 <code>WordPress</code> 前端的标头中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'wp_head'</span>, <span class="string">'google_site_verification'</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">google_site_verification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;meta name="google-site-verification" content="ytl89rlFsAzH7dWLs_U2mdlivbrr_jgV4Gq7wClHDUJ8" /&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有挂钩函数都将是匿名的，而不是命名函数，以避免不必要的函数名称重复。 例如，上面的 <code>Google</code> 网站验证元标记的代码将变为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'wp_head'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;meta name="google-site-verification" content="ytl89rlFsAzH7dWLs_U2mdlivbrr_jgV4Gq7wClHDUJ8" /&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的代码使用 <code>wp_footer</code> 在 <code>WordPress</code> 前端的页脚区域中添加 <code>JavaScript</code> 。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_action( <span class="string">'wp_footer'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;script type="text/javascript" src="http://example.com/wp-content/plugins/site-specific-plugin/hello-bar.js"&gt;&lt;/script&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><em>动作钩子代码示例足够多，让我们看看过滤器。</em></strong></p></br><h1 id="滤钩示例"><a href="#滤钩示例" class="headerlink" title="滤钩示例"></a><strong>滤钩示例</strong></h1><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a><strong><em>示例1</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们正在开发一个广告插入器插件，该插件将以编程方式在每个帖子内容前后插入广告，因此我们需要 <code>the_content</code> 过滤器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下代码在每个帖子内容前后都包含“我们喜欢 <code>SitePoint</code> ”文字。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_filter( <span class="string">'the_content'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">( $content )</span> </span>&#123;</span><br><span class="line">        $text = sprintf( <span class="string">'&lt;div class="notice alert"&gt;%s&lt;/div&gt;'</span>, __( <span class="string">'We love SitePoint'</span>, <span class="string">'sp'</span> ) );</span><br><span class="line">        $content = $text . $content . $text;</span><br><span class="line">        <span class="keyword">return</span> $content;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：<code>$text</code> 变量的内容与&lt;div class =“ notice alert”&gt;我们喜欢SitePoint &lt;/ div&gt;一样，尽管它已经国际化，所以可以本地化。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，函数参数 <code>$content</code> 是提供帖子内容的变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们在帖子内容前后添加自定义文本，将结果数据保存到 <code>$content</code> 中，然后返回。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：所有滤镜挂钩函数都必须在操作或修改后返回变量参数。</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a><strong><em>示例2</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将看到的另一个过滤器示例是 <code>the_title</code> 。 以下是 <code>wp-includes/post-template.php</code> 的158行中的定义方式。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Filter the post title.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 0.71</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> string $title The post title.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> int    $id    The post ID.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">return</span> apply_filters( <span class="string">'the_title'</span>, $title, $id );</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的代码通过在其后面附加 <code>-WeLoveSitePoint</code> 来仅修改 ID 为 5978的帖子的标题。 这要归功于 <code>$id</code> 参数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_filter( <span class="string">'the_title'</span>, <span class="function"><span class="keyword">function</span> <span class="params">( $title, $id )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( $id == <span class="string">'5978'</span> ) &#123;</span><br><span class="line">            $title .= <span class="string">' - WeLoveSitePoint'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $title;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">10</span>, <span class="number">2</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WordPress</code> 之所以继续成为领先的内容管理系统的原因是其可扩展性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>WordPress Hook</code> 系统使 <code>WordPress</code> 可以转换为功能强大的 <code>Web</code> 应用程序，无论是 <code>WooCommerce</code> 的电子商务商店，<code>bbPress</code> 的论坛还是 <code>BuddyPress</code> 的社交网站。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> Modules And Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中的模块和挂钩</title>
      <link href="/Swift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E6%8C%82%E9%92%A9/"/>
      <url>/Swift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E6%8C%82%E9%92%A9/</url>
      
        <content type="html"><![CDATA[<p>了解如何使用以 <code>Swift</code> 编写的松耦合模块插件系统通过新功能扩展应用程序。</p><h1 id="模块（插件）如何工作？"><a href="#模块（插件）如何工作？" class="headerlink" title="模块（插件）如何工作？"></a><strong>模块（插件）如何工作？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你可以创建可以在不知彼此的情况下一起工作的对象，那会很酷吗？ 想象一下，你正在构建一个动态表单。 根据一些内部条件，将使用来自启用模块的数据来构成字段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，你拥有模块 <code>A</code> ，<code>B</code> ，<code>C</code> ，其中 <code>A</code> 为您提供字段 <code>1、2、3</code>，<code>B</code> 模块负责字段4、5，而 <code>C</code> 是字段6的提供者。现在，如果您关闭 <code>B</code>， 您应该只能看到字段1、2、3和6。如果已打开所有内容，则应该看到从1到6的所有字段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以将完全相同的模式应用于许多事物。 试想一下最大的插件生态系统之一。 <code>WordPress</code> 使用 <a href="https://www.sitepoint.com/wordpress-hook-system/" target="_blank" rel="noopener"><code>钩子(英文：hooks)</code></a> 来扩展核心功能。 这些都是基于我上面刚刚提到的概念。 这是 <a href="https://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="noopener"><code>事件驱动的体系结构设计模式(英文：Event-driven architecture)</code></a> 的一部分。 现在的问题是，我们如何使用 <code>Swift</code> 实现类似的东西？ 🤔</p><a id="more"></a></br><h1 id="钩子系统的实现"><a href="#钩子系统的实现" class="headerlink" title="钩子系统的实现"></a><strong>钩子系统的实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们从带有调用点的协议开始。 模块管理器将调用此方法，以按名称调用正确的钩子函数。 我们将传递参数字典，因此我们的钩子可以有参数。 我们在这里使用 <code>Any</code> 类型作为值，因此你可以在给定键下将任何内容作为参数发送。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123; <span class="literal">nil</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们使用基于表单示例的简化版本来实现我们的模块。 🤓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 1"</span>, <span class="string">"Field 2"</span>, <span class="string">"Field 3"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 4"</span>, <span class="string">"Field 5"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 6"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们需要一个模块管理器，可以使用模块数组对其进行初始化。 该管理器将负责在每个模块上调用正确的调用方法，并将以类型安全的方式处理返回的响应。 我们将立即实现两个 <code>invoke</code> 方法版本。 一个用于合并结果，另一个用于返回挂钩的第一个结果。</p><p><strong>你可以尝试实现一个可以使用 <code>&amp;&amp;</code> 运算符合并 <code>Bool</code> 值的版本。</strong></p><p>这是我们使用两种通用方法的模块管理器实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ModuleManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span>  modules: [<span class="type">Module</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invokeAllHooks</span>&lt;T&gt;<span class="params">(<span class="number">_</span> name: String, type: T.<span class="keyword">Type</span>, params: [String: <span class="keyword">Any</span>] = [:])</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">self</span>.modules.<span class="built_in">map</span> &#123; module <span class="keyword">in</span></span><br><span class="line">            module.invoke(name: name, params: params)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.compactMap &#123; $<span class="number">0</span> <span class="keyword">as</span>? [<span class="type">T</span>] &#125;.flatMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invokeHook</span>&lt;T&gt;<span class="params">(<span class="number">_</span> name: String, type: T.<span class="keyword">Type</span>, params: [String: <span class="keyword">Any</span>] = [:])</span></span> -&gt; <span class="type">T?</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> module <span class="keyword">in</span> <span class="keyword">self</span>.modules &#123;</span><br><span class="line">            <span class="keyword">let</span> result = module.invoke(name: name, params: params)</span><br><span class="line">            <span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result <span class="keyword">as</span>? <span class="type">T</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <code>invokeAllHooks</code> 方法将通用类型的数组合并在一起。 这是我们可以使用基础钩子方法收集他所有表单字段的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manager1 = <span class="type">ModuleManager</span>(modules: [<span class="type">A</span>(), <span class="type">B</span>(), <span class="type">C</span>()])</span><br><span class="line"><span class="keyword">let</span> form1 = manager1.invokeAllHooks(<span class="string">"example_form"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(form1) <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager2 = <span class="type">ModuleManager</span>(modules: [<span class="type">A</span>(), <span class="type">C</span>()])</span><br><span class="line"><span class="keyword">let</span> form2 = manager2.invokeAllHooks(<span class="string">"example_form"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(form2) <span class="comment">// 1, 2, 3, 6</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>invokeHook</code> 方法，你可以实现类似的行为，例如责任链设计模式。 响应程序链的工作方式非常相似，<code>Apple</code> 几乎在每个平台上都使用响应程序来处理 <code>UI</code> 事件。 让我通过更新模块 <code>B</code> 向你展示它的工作方式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(name: String, params: [String: <span class="keyword">Any</span>])</span></span> -&gt; <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> name &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_form"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleFormHook()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"example_responder"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.exampleResponderHook()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleFormHook</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        [<span class="string">"Field 4"</span>, <span class="string">"Field 5"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">exampleResponderHook</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">"Hello, this is module B."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们在两个管理器上使用 <code>invokeHook</code> 方法触发新的 <code>example_responder</code> 挂钩，我们将看到结果完全不同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = manager1.invokeHook(<span class="string">"example_responder"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value) <span class="comment">// Hello, this is module B.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = manager2.invokeHook(<span class="string">"example_responder"</span>, type: <span class="type">String</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value) <span class="comment">// this won't be called at all...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第一种情况下，由于我们在其中一个模块中为此钩子实现了一个实现，因此将显示返回值，因此可以进行打印。 在第二种情况下，没有模块可以处理该事件，因此不会执行条件内的块。 告诉你，就像一个响应链。 😜</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用模块或插件是将代码的某些部分解耦的有效方法。 我真的很喜欢钩子函数，因为它们可以为应用程序中的几乎所有内容提供扩展点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将其与动态模块加载器混合使用，你将在 <code>Vapor</code> 之上拥有一个完全可扩展的下一代后端解决方案。 你可以独立于模块使用已编译的核心系统，以后可以仅升级整个组件的某些部分而无需接触其他部分。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> Modules And Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift初始化模式</title>
      <link href="/Swift%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终指南，如何在指定的，方便的，可使用的初始化工具等帮助下初始化你的 <code>Swift</code> 数据类型。</p><h1 id="什么是初始化？"><a href="#什么是初始化？" class="headerlink" title="什么是初始化？"></a><strong>什么是初始化？</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" target="_blank" rel="noopener"><code>初始化(英文: Initialization)</code></a> 是准备使用的类，结构或枚举实例的过程。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个过程是通过初始化程序来处理的，初始化程序只是一种特殊的函数，通常为它们保留 <code>init</code> 关键字-因此您不必使用 <code>func</code> 关键字-通常您不会从初始化程序中返回任何值 。</p><a id="more"></a></br><h1 id="初始化属性"><a href="#初始化属性" class="headerlink" title="初始化属性"></a><strong>初始化属性</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类和结构必须在创建该类或结构的实例时将其所有存储的属性设置为适当的初始值。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先想象一个非常简单的结构，它只有两个属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，上面的规则说我们必须初始化所有属性，因此让我们通过创建第一个 <code>init</code> 方法来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像其他所有 <code>Swift</code> 函数一样。 现在我们可以创建我们的第一点了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，如果它们是变量而不是常量，则不必初始化隐式解包的可选属性和可选属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相同的逻辑适用于类，你可以通过将 <code>struct</code> 关键字更改为 <code>class</code> 来尝试。 但是结构是值类型，类是引用类型，这种差异将为我们提供两种类型的独特功能。</p></br><h1 id="成员初始化（仅适用于结构）"><a href="#成员初始化（仅适用于结构）" class="headerlink" title="成员初始化（仅适用于结构）"></a><strong>成员初始化（仅适用于结构）</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于 <code>struct</code> 的好处是，如果你不提供自己的 <code>init</code> 方法，则编译器将免费生成一个逐成员的 <code>init</code> 。 但是有很多问题。 生成的方法将包含除具有默认值的常量以外的所有属性（也为可选属性），并且它将具有内部访问类型，因此在其他模块中将不可见。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果任何结构的存储属性都是私有的，则该结构类型的默认成员初始化器被视为私有的。 同样，如果结构的任何存储属性是文件专用的，则初始化程序是文件专用的。 否则，初始化程序的访问级别为 <code>internal</code> 。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> key: <span class="type">Int!</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span> = <span class="string">"zero"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, key: <span class="number">0</span>) <span class="comment">// provided by the memberwise init</span></span><br></pre></td></tr></table></figure></br><h1 id="初始化失败"><a href="#初始化失败" class="headerlink" title="初始化失败"></a><strong>初始化失败</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时情况可能会出错，并且你不想创建坏的或无效的对象，例如，你想从有效点列表中过滤掉 <code>origo</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>?(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123; <span class="comment">// ? marks that this could fail</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>) <span class="comment">// nil</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>) <span class="comment">// valid point</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过 <code>rawValues</code> 初始化从 <code>RawRepresentable</code> 协议传递的枚举，这也是一个失败的初始化模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> red</span><br><span class="line">    <span class="keyword">case</span> blue</span><br><span class="line">    <span class="keyword">case</span> yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c1 = <span class="type">Color</span>(rawValue: <span class="string">"orange"</span>) <span class="comment">// nil, no such case</span></span><br><span class="line"><span class="keyword">let</span> c2 = <span class="type">Color</span>(rawValue: <span class="string">"red"</span>) <span class="comment">// .red</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以使用 <code>init！</code> 而不是<code>init ?</code> ，这将创建实例的隐式展开的可选类型。 请注意，类也可以具有失败的初始化器。</p></br><h1 id="初始化纯Swift类"><a href="#初始化纯Swift类" class="headerlink" title="初始化纯Swift类"></a><strong>初始化纯Swift类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你知道类是 <code>Swift</code> 编程语言中的本机类型。 你甚至不必导入 <code>Foundation</code> 框架即可创建全新的类。 这是由纯 <code>Swift</code> 类表示的完全相同的 <code>Point</code> 对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次我们不得不自己提供 <code>init</code> 方法，因为类没有成员初始化器。 它们是引用类型和继承逻辑，因此为它们生成成员初始化方法会更加复杂。</p></br><h1 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a><strong>默认初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 <code>Swift</code> 类，如果为所有存储的属性提供默认值，即使是可选属性，也将免费获得内部默认初始化程序。 实际上，它看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>()</span><br></pre></td></tr></table></figure><p>或者，如果我们遵循前面的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> key: <span class="type">Int!</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span> = <span class="string">"zero"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这感觉太不对了。 为什么一个点具有键和标签属性？ 拥有一个可能具有额外属性的子对象会很好。 现在该通过类继承来重构此代码了。</p></br><h1 id="指定的初始值设定项-Designated-initializer"><a href="#指定的初始值设定项-Designated-initializer" class="headerlink" title="指定的初始值设定项(Designated initializer)"></a><strong>指定的初始值设定项(Designated initializer)</strong></h1><blockquote><p><strong><em>提示：</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.codingexplorer.com/designated-initializers-convenience-initializers-swift/" target="_blank" rel="noopener"><code>指定的初始化器(Designated initializer)</code></a> 是类的主要初始化器。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换句话说，它没有用便捷关键字标记。 一个类也可以具有多个指定的初始化器。 因此，让我们继续我们的 <code>Point</code> 类，它将成为 <code>NamedPoint</code> 类的超类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123; <span class="comment">// this is the designated initializer</span></span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedPoint</span>: <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>, label: <span class="type">String?</span>) &#123; <span class="comment">// designated</span></span><br><span class="line">        <span class="keyword">self</span>.label = label</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(point: <span class="type">Point</span>, label: <span class="type">String?</span>) &#123; <span class="comment">// also designated</span></span><br><span class="line">        <span class="keyword">self</span>.label = label</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: point.x, y: point.y) <span class="comment">// delegating up</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">NamedPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>, label: <span class="string">"first"</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="type">NamedPoint</span>(point: <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>), label: <span class="string">"second"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定的初始值设定项必须始终从其直接超类调用指定的初始值设定项，因此你必须委托链。 但是首先，我们必须按照初始化的第一条规则来初始化所有属性。 因此，这意味着 <code>Swift</code> 语言具有两个阶段的初始化过程。</p><p><strong><em>两阶段初始化</em></strong></p><ul><li>每个存储的属性由引入它的类分配一个初始值。</li><li>每个类都有机会自定义其存储的属性。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，根据这些规则，首先我们必须初始化 <code>label</code> 属性，然后进行委托，然后才有机会做其他事情。</p></br><h1 id="便捷初始化"><a href="#便捷初始化" class="headerlink" title="便捷初始化"></a><strong>便捷初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它们是用于简化初始化的初始化程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，例如在前面的例子中，如果我们可以为 <code>x</code> 和 <code>y</code> 等于数字的点设置一个初始化器。 在某些情况下，这将非常方便。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(z: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(x: z, y: z) <span class="comment">// we're calling the designated init</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">Point</span>(z: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;便捷初始化程序必须调用同一类中另一个 <code>&quot;convenience&quot;</code> 初始化程序，但是您不必写出关键字，实际上，这些 <code>init</code> 方法略有不同，你可以从一个到另一个进行调出，这就是为什么它看起来一样的原因。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(z: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(x: z, y: z)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="type">Point</span>(z: <span class="number">1</span>)</span><br></pre></td></tr></table></figure></br><h1 id="必需的初始值设定项-Required-initializer"><a href="#必需的初始值设定项-Required-initializer" class="headerlink" title="必需的初始值设定项(Required initializer)"></a><strong>必需的初始值设定项(Required initializer)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你在类中标记了一个必需的初始化器，则所有直接类（必须在每个级别中都标记为必需）也必须实现该类的子类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedPoint</span>: <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.label = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">NamedPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure></br><h1 id="覆盖初始化器"><a href="#覆盖初始化器" class="headerlink" title="覆盖初始化器"></a><strong>覆盖初始化器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中，默认情况下不会为子类继承初始化器。 如果要为父类已经具有的子类提供相同的初始化程序，则必须使用 <code>override</code> 关键字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedPoint</span>: <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.label = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="type">NamedPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong><em>初始化继承有两个规则，这是第一个…</em></strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你的子类没有定义任何指定的初始值设定项，它将自动继承其所有超类指定的初始值设定项。</span><br><span class="line"></span><br><span class="line">***...还有第二个：***</span><br><span class="line">&#96;&#96;&#96;提示:&#96;&#96;&#96;\</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你的子类提供了其所有超类指定的初始值设定项的实现（通过按规则1继承它们，或通过提供自定义实现作为其定义的一部分），则它会自动继承所有超类便利的初始值设定项。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;br&gt;</span><br><span class="line"></span><br><span class="line"># **取消初始化**</span><br><span class="line"></span><br><span class="line">&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在取消分配类实例之前，将立即调用反初始化程序。</span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此，如果你想在类终止时进行一些手动清理，这就是你要寻找的方法。 在大多数情况下，你不必担心内存管理，因为 &#96;&#96;&#96;ARC&#96;&#96;&#96; 会为你完成。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; Swift</span><br><span class="line">class Point &#123;</span><br><span class="line">   let x: Int</span><br><span class="line">   let y: Int</span><br><span class="line"></span><br><span class="line">   init(x: Int, y: Int) &#123;</span><br><span class="line">       self.x &#x3D; x</span><br><span class="line">       self.y &#x3D; y</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   deinit &#123;</span><br><span class="line">       print(&quot;Point is clenaed up.&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1: Point? &#x3D; Point(x: 1, y: 1)</span><br><span class="line">p1 &#x3D; nil &#x2F;&#x2F;deinit is being called </span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 初始化模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift带闭包的懒惰初始化</title>
      <link href="/Swift%E5%B8%A6%E9%97%AD%E5%8C%85%E7%9A%84%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/Swift%E5%B8%A6%E9%97%AD%E5%8C%85%E7%9A%84%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何创建具有模块化和可读性的对象。</p><h1 id="使用初衷"><a href="#使用初衷" class="headerlink" title="使用初衷"></a><strong>使用初衷</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>iOS</code> 之旅的开始，我遵循了 <code>YouTube</code> 上的教程。 我看到一些使用如下所示的方法来创建 <code>UI</code> 对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> makeBox: <span class="type">UIView</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> view = <span class="type">UIView</span>()</span><br><span class="line"> <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为学习者，我复制了练习并使用了它。 但是，有一天，有人问我：“为什么要添加 <code>{}</code> ，为什么 <code>（）</code> 末尾存在？ 它是计算属性吗？” 我无法回答。</p><a id="more"></a></br><h1 id="学习的目标"><a href="#学习的目标" class="headerlink" title="学习的目标"></a><strong>学习的目标</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有三个目标。 首先，了解如何使用上述非常规方式初始化对象。 其次，了解何时在 <code>Swift</code> 中使用惰性 <code>var</code> 。 最后，如何最终正确使用它。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a><strong><em>先决条件</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了充分理解文章中的内容，我强烈建议您熟悉以下主题。</p><ul><li><a href="https://blog.bobthedeveloper.io/no-fear-closure-in-swift-3-with-bob-72a10577c564?gi=bfa929c89fa9" target="_blank" rel="noopener"><code>Closures</code></a></li><li><a href="https://blog.bobthedeveloper.io/swift-retention-cycle-in-closures-and-delegate-836c469ef128" target="_blank" rel="noopener"><code>Capture List and retention cycle [weak self]</code></a></li><li>Descent Object Oriented Programming</li></ul></br><h1 id="创建UI组件"><a href="#创建UI组件" class="headerlink" title="创建UI组件"></a><strong>创建UI组件</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我解释上述非常规方法之前，让我们先回顾一下你的过去。 为了在 <code>Swift</code> 中创建一个按钮，你可能已经做了类似的事情。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine Size</span></span><br><span class="line"><span class="keyword">let</span> buttonSize = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="comment">// Create Instance</span></span><br><span class="line"><span class="keyword">let</span> bobButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">bobButton.backgroundColor = .black</span><br><span class="line">bobButton.titleLabel?.text = <span class="string">"Bob"</span></span><br><span class="line">bobButton.titleLabel?.textColor = .white</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设你必须创建其他三个按钮，你可能必须复制上面的代码，然后将名称从 <code>bobButton</code> 更改为 <code>bobbyButton</code> 。这非常繁琐。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New Button</span></span><br><span class="line"><span class="keyword">let</span> bobbyButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">bobbyButton.backgroundColor = .black</span><br><span class="line">bobbyButton.titleLabel?.text = <span class="string">"Bob"</span></span><br><span class="line">bobbyButton.titleLabel?.textColor = .white</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使事情变得容易一些，你可以：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/xcode-edit-all.gif" alt="带闭包的懒惰初始化" title="这也适用于键盘快捷键：ctrl-cmd-e"></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用快捷键：ctrl-cmd-e，完成上述操作。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不想重复这样创建，则可以创建一个函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createButton</span><span class="params">(enterTitle: String)</span></span> -&gt; <span class="type">UIButton</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = enterTitle</span><br><span class="line"> <span class="keyword">return</span> button</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createButton(enterTitle: <span class="string">"Yoyo"</span>) <span class="comment">//  👍</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，在 <code>iOS</code> 开发中，很少有自定义按钮看起来相似的情况。 因此，一个函数可能需要更多的参数，包括背景颜色，标题，边框半径，阴影等。 你的功能可能最终看起来像：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createButton</span><span class="params">(title: String, borderWidth: Double, backgrounColor, ...)</span></span> -&gt; <span class="type">Button</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使你向函数添加默认参数，上面的代码也不是理想的选择。 它降低了可读性。 因此，最好还是保留上面乏味的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有什么方法可以使它减少乏味和更有条理？ 当然。 我们已经调查了你的过去—现在该加紧步伐，展望你的未来。</p></br><h1 id="引入非常规方式"><a href="#引入非常规方式" class="headerlink" title="引入非常规方式"></a><strong>引入非常规方式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以非常规的方式创建UI组件之前，让我们首先回答最初问题: <code>{}</code> 是什么意思，它是计算属性吗？</p><p><strong><em>不，这只是一个封闭块。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，让我们演示如何使用闭包创建对象。 我们将设计一个名为 <code>Human</code> 的结构。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"> <span class="keyword">init</span>() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Born 1996"</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，这就是创建带闭包的对象的方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createBob = &#123; () -&gt; <span class="type">Human</span> <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">let</span> human = <span class="type">Human</span>()</span><br><span class="line"> <span class="keyword">return</span> human</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> babyBob = createBob() <span class="comment">// "Born 1996"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>仅说明一下，createBob</code> 是一个类型为 <code>（）-&gt; Human</code> 的闭包。 您已经通过调用 <code>createBob（）</code> 创建了一个名为 <code>babyBob</code> 的实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，你必须创建两个常量： <code>createBob</code> 和 <code>babyBob</code> 。 如果你想在一个语句中做所有事情怎么办？ </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bobby = &#123; () -&gt; <span class="type">Human</span> <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">let</span> human = <span class="type">Human</span>()</span><br><span class="line"> <span class="keyword">return</span> human</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，闭包块通过在末尾添加 <code>（）</code> 来执行自身，而 <code>bobby</code> 现在附加了一个 <code>Human</code> 对象。 很好的东西。</p><p><strong><em>你已经了解了如何使用闭包块初始化对象。</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们来创建一个 <code>UI</code> 对象，该对象应该与上面的示例相似。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bobView = &#123; () -&gt; <span class="type">UIView</span> <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">let</span> view = <span class="type">UIView</span>()</span><br><span class="line"> view.backgroundColor = .black</span><br><span class="line"> <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;太好了，我们可以缩短它的时间。 实际上，我们不需要指定封闭块的类型。 相反，我们要做的就是指定实例的类型，例如 <code>bobView</code> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bobbyView: <span class="type">UIView</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> view = <span class="type">UIView</span>()</span><br><span class="line"> view.backgroundColor = .black</span><br><span class="line"> <span class="keyword">return</span> view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 能够基于关键字 <code>return</code> 推断出闭包块是 <code>（）-&gt; UIView</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，看看。 上面的示例应该看起来与我担心的“非常规方式”相同。</p></br><h1 id="闭包初始化的好处"><a href="#闭包初始化的好处" class="headerlink" title="闭包初始化的好处"></a><strong>闭包初始化的好处</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们讨论了创建对象的乏味以及使用函数引起的问题。 在你的脑海中，你肯定在想：“为什么我应该改用闭包？”</p><h2 id="容易复制"><a href="#容易复制" class="headerlink" title="容易复制"></a><strong><em>容易复制</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我不喜欢使用 <code>Storyboard</code> ，我喜欢复制和粘贴 <code>UI</code> 对象。 实际上，我的计算机中有一个“库”。 让我们假设库中有一个如下所示的按钮。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = <span class="number">1</span></span><br><span class="line"> button.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要做的就是复制整行，然后将 <code>myButton</code> 的名称更改为 <code>newButton</code> 以供使用。 如果不使用闭包方法，则可能不得不将 <code>button</code> 的名称更改为 <code>newButton</code> 7–8次。 我们可以使用上面的 <code>Xcode</code> 快捷方式，但为什么不使其更简单。</p><h2 id="代码更整洁"><a href="#代码更整洁" class="headerlink" title="代码更整洁"></a><strong><em>代码更整洁</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于将对象组合在一起，看代码更加直观。 比较一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init with Closure</span></span><br><span class="line"><span class="keyword">let</span> leftCornerButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = <span class="number">1</span></span><br><span class="line"> button.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">let</span> rightCornerButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line"> <span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = <span class="number">1</span></span><br><span class="line"> button.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p><em><code>比较</code></em></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init With Fingers</span></span><br><span class="line"><span class="keyword">let</span> leftCornerButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">leftCornerButton.backgroundColor = .black</span><br><span class="line">leftCornerButton.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line">leftCornerButton.titleLabel?.textColor = .white</span><br><span class="line">leftCornerButton.layer.cornerRadius = <span class="number">1</span></span><br><span class="line">leftCornerButton.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rightCornerButton = <span class="type">UIButton</span>(frame: buttonSize)</span><br><span class="line">rightCornerButton.backgroundColor = .black</span><br><span class="line">rightCornerButton.titleLabel?.text = <span class="string">"Button"</span></span><br><span class="line">rightCornerButton.titleLabel?.textColor = .white</span><br><span class="line">rightCornerButton.layer.cornerRadius = <span class="number">1</span></span><br><span class="line">rightCornerButton.layer.masksToBounds = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管使用闭包创建对象要多加几行，但我感到有点不知所措，因为我只需要向按钮添加属性，而不必向 <code>rightCornerButton</code> 或 <code>leftCornerButton</code> 添加属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，如果按钮的名称更具描述性，那么创建带有闭包块的对象通常需要较少的行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你已经实现了第一个目标。 恭喜你</p><h2 id="延迟初始化应用"><a href="#延迟初始化应用" class="headerlink" title="延迟初始化应用"></a><strong><em>延迟初始化应用</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你已经走了很长一段路。 现在该实现本教程的第二个目标。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能在下面看到了类似的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntenseMathProblem</span> </span>&#123;</span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> complexNumber: <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="comment">// imagine it requires a lot of CPU</span></span><br><span class="line">  <span class="number">1</span> * <span class="number">1</span></span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性允许您执行的操作是，仅当你尝试访问 <code>complexNumber</code> 属性时，才会计算 <code>complexNumber</code> 属性。 例如:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> problem = <span class="type">IntenseMathProblem</span></span><br><span class="line">problem()  <span class="comment">// No value for complexNumber</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前， <code>complexNumber</code> 没有值。 但是，一旦你访问该媒体资源，</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">problem().complexNumber <span class="comment">// Now returns 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性变量经常用于对数据库进行排序并从任何后端服务中获取数据，因为你绝对不想在创建对象时对所有内容进行计算和排序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，你的手机会崩溃，因为该物体过大且RAM无法处理。</p></br><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面只是 <code>lazy var</code> 的一个应用。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong><em>排序</em></strong></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortManager</span> </span>&#123;</span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> sortNumberFromDatabase: [<span class="type">Int</span>] = &#123;</span><br><span class="line">  <span class="comment">// Sorting logic</span></span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a><strong><em>图像压缩</em></strong></h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompressionManager</span> </span>&#123;</span><br><span class="line"> <span class="built_in">lazy</span> <span class="keyword">var</span> compressedImage: <span class="type">UIImage</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> image = <span class="type">UIImage</span>()</span><br><span class="line">  <span class="comment">// Compress the image</span></span><br><span class="line">  <span class="comment">// Logic</span></span><br><span class="line">  <span class="keyword">return</span> image</span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="懒加载规则"><a href="#懒加载规则" class="headerlink" title="懒加载规则"></a><strong>懒加载规则</strong></h1><ul><li>你不能将lazy与let一起使用，因为它没有初始值，并且在以后访问它时才可以达到。</li><li>你不能将其与计算属性一起使用，因为当你修改与惰性属性有关系的任何变量时，总是会重新计算计算属性（需要CPU）。</li><li>惰性仅对结构或类的成员有效</li></ul></br><h1 id="懒加载能捕获"><a href="#懒加载能捕获" class="headerlink" title="懒加载能捕获"></a><strong>懒加载能捕获</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如果你已阅读上一篇有关<a href="https://blog.bobthedeveloper.io/swift-retention-cycle-in-closures-and-delegate-836c469ef128" target="_blank" rel="noopener"><code>“封闭和委托中的循环引用”</code></a>的文章，您可能会感到奇怪。 让我们测试一下。 创建一个名为 <code>BobGreet</code> 的类。 它具有两个属性：名称为 <code>String</code> 的名称和问候语也为 <code>String</code> 的问候语，但使用闭包块进行了初始化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BobGreet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Bob the Developer"</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> greeting: <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, \(self.name)"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I'm gone, bruh 🙆‍"</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;封闭块可能对 <code>BobGuest</code> 强引用，但让我们尝试取消分配。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bobGreet: <span class="type">BobGreet?</span> = <span class="type">BobGreet</span>()</span><br><span class="line">bobGreet?.greeting</span><br><span class="line">bobGreet = <span class="literal">nil</span> <span class="comment">// I'm gone, bruh 🙆‍</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无需担心 <code>[unown self]</code> 闭包块没有对该对象的引用。 取而代之的是，它只是在封闭块内复制自身。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 懒加载模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift Lazy属性初始化</title>
      <link href="/Swift%20Lazy%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/Swift%20Lazy%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Swift中什么是惰性存储属性？ 你应该如何以及何时使用它？ 快速入门指南，需要记住的一些关键点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先回顾一下在 <code>Swift</code> 中声明和初始化存储属性的最常用方法：</p><h1 id="直接分配"><a href="#直接分配" class="headerlink" title="直接分配"></a><strong>直接分配</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过直接分配初始值来对常量和变量存储的属性进行初始化的最简单形式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constant</span></span><br><span class="line"><span class="keyword">let</span> fontSize: <span class="type">CGFloat</span> = <span class="number">24.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// variable</span></span><br><span class="line"><span class="keyword">var</span> spacing: <span class="type">CGFloat</span> = <span class="number">16.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Optional</span></span><br><span class="line"><span class="keyword">var</span> title: <span class="type">String?</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，默认情况下，可选参数初始化为 <code>nil</code> 。 我喜欢将恒定的魔术数字（如 <code>fontSize</code> ）收集到一个结构中，使它们成为静态的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">ViewMetrics</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> fontSize: <span class="type">CGFloat</span> = <span class="number">24.0</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">titleLabel.font = <span class="type">ViewMetrics</span>.fontSize</span><br></pre></td></tr></table></figure></br><h1 id="使用初始化器"><a href="#使用初始化器" class="headerlink" title="使用初始化器"></a><strong>使用初始化器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你没有将初始值分配给存储属性作为其定义的一部分，则必须在初始化程序中进行设置。 引用《 Swift编程语言》指南：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类和结构必须在创建该类或结构的实例时将其所有存储的属性设置为适当的初始值。 存储的属性不能处于不确定状态。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(title: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.title = title</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当属性始终采用相同的初始值时，最好在声明属性时进行设置，而不要在初始化程序中进行设置。</p></br><h1 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a><strong>使用闭包</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当初始值需要更多设置时，闭包是一个不错的选择。 我发现闭包样式比许多初始化程序代码更可取，因为它使设置接近属性声明。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button: <span class="type">UIButton</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> button = <span class="type">UIButton</span>(type: .system)</span><br><span class="line">  button.titleLabel?.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="type">ViewMetrics</span>.fontSize)</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化包含属性的类型时，将调用一次闭包。 闭包的返回值分配给该属性。 不要忘记尾随（）来执行关闭。</p></br><h1 id="懒加载方式"><a href="#懒加载方式" class="headerlink" title="懒加载方式"></a><strong>懒加载方式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当初始值创建起来开销相对较大时时，通常会使用惰性初始化。 仅在确定需要时才创建值。 如果你是从 <code>Objective-C</code> 转到 <code>Swift</code> 的，那么您可能会熟悉使用 <code>getter</code> 仅在首次使用属性时才对其进行延迟初始化的技术：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">NSNumberFormatter</span> *)decimalFormatter &#123;</span><br><span class="line">  <span class="keyword">if</span> (_decimalFormatter == <span class="literal">nil</span>) &#123;</span><br><span class="line">    _decimalFormatter = [[<span class="type">NSNumberFormatter</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [_decimalFormatter setNumberStyle:<span class="type">NSNumberFormatterDecimalStyle</span>];        </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _decimalFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么 <code>Swift</code> 中的惰性属性呢？ <code>Swift</code> 属性没有后备实例变量（如 <code>_decimalFormatter</code> ）。 要在 <code>Swift</code> 中延迟初始化属性，请添加 <code>lazy</code> 关键字：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> decimalFormatter: <span class="type">NumberFormatter</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> formatter = <span class="type">NumberFormatter</span>()</span><br><span class="line">  formatter.numberStyle = .decimal</span><br><span class="line">  <span class="keyword">return</span> formatter</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，惰性属性始终为 <code>var</code> 。 当访问属性时，可以在初始化完成后调用该闭包。</p></br><h1 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a><strong>访问属性</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性属性初始化的另一个常见用法是，当初始值取决于初始化实例的属性或方法时。 例如，使用闭包设置对象，此堆栈视图可以作为 <code>let constant</code> 属性使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stackView: <span class="type">UIStackView</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> stackView = <span class="type">UIStackView</span>()</span><br><span class="line">  stackView.spacing = <span class="type">ViewMetrics</span>.spacing</span><br><span class="line">  <span class="keyword">return</span> stackView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请记住，在初始化期间调用了闭包，因此你尚不能使用 <code>self</code> 来访问实例的任何属性或方法。 如果你需要访问 <code>self</code> ，则必须将 <code>let</code> 替换为 <code>lazy var</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spacing: <span class="type">CGFloat</span> = <span class="number">16.0</span>  &#123;</span><br><span class="line">  <span class="keyword">didSet</span> &#123;</span><br><span class="line">    stackView.spacing = spacing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> stackView: <span class="type">UIStackView</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> stackView = <span class="type">UIStackView</span>()</span><br><span class="line">  stackView.spacing = spacing</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> stackView</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，在对象初始化之后执行关闭操作，因此你可以通过 <code>self</code> 完全访问实例属性和方法。 这是声明诸如用户界面组件之类的便捷方式。 将任何常见配置移至单独的方法或类扩展：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buttonFontSize: <span class="type">CGFloat</span> = <span class="number">18.0</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> redButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">UILabel</span>.colorButton(title: <span class="string">"Red"</span>, color: .red, fontSize: buttonFontSize)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> blueButton: <span class="type">UIButton</span> = &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">UILabel</span>.colorButton(title: <span class="string">"Blue"</span>, color: .blue, fontSize: buttonFontSize)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></br><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a><strong>要点</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要记住的一些关键点并不明显，并且经常引起混乱（至少对我而言）：</p><ul><li>引用闭包内的其他实例属性或方法时，无需编写self。</li><li>闭包不会逃逸，因此你无需使用 <code>weak self</code> 避免形成循环引用。</li><li>初始化之前，如果属性可以被多个线程访问，请小心。 无法保证只有在设置初始值之前有多个线程同时访问该属性时才将其初始化一次。</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 懒加载模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中的懒加载模式</title>
      <link href="/Swift%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解如何在 <code>Swift</code> 中使用惰性属性来提高性能，避免使用可选参数或只是为了使初始化过程更加简洁。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在程式设计中, 惰性初始是一种拖延战术。在第一次需求出现以前，先延迟创建物件、计算值或其它昂贵程序。这通常是以一个旗号来实现，用旗号来标示是否完成其程式。每次请求对象时，会先测试此旗号。如果已完成，直接传回，否则当场执行。<br>对于此想法更一般的论述，可见惰性求值。对指令式语言，这个模式可能潜藏着危险，尤其是使用共享状态的程式习惯。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以设计模式的观点来说，惰性初始通常会和工厂方法模式合作，这结合了三种构想：</p><ul><li>使用一个工厂去得到一个类别的实例（工厂方法模式）。</li><li>将实例存在一个集合中，所以下次要求一个实例却有相同参数时，可以得到同一个实例（可和单例模式来做比较）。</li><li>在第一次时，使用惰性初始来实例化物件（惰性初始模式）。</li></ul><a id="more"></a></br><h1 id="懒惰的终极指南"><a href="#懒惰的终极指南" class="headerlink" title="懒惰的终极指南"></a><strong>懒惰的终极指南</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果仅在某个时间点需要某个属性，则可以在其前面加上 <code>lazy</code> 关键字，以便在初始化过程中将其 <code>“excluded”</code> ，并且将按需分配其默认值。 这对于创建成本高昂或需要更多时间创建的类型很有用。 这是一个懒惰公主的小故事。 👸💤</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepingBeauty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zzz...sleeping..."</span>)</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"sleeping beauty is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Castle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> princess = <span class="type">SleepingBeauty</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"castle is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a new castle..."</span>)</span><br><span class="line"><span class="keyword">let</span> castle = <span class="type">Castle</span>()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此代码段的输出如下所示，但是你可以看到公主睡了很长时间，她也“堵住了”城堡。 🏰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a new castle...</span><br><span class="line">zzz...sleeping...</span><br><span class="line">sleeping beauty is ready!</span><br><span class="line">castle is ready!</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以通过添加 <code>lazy</code> 关键字来加快处理速度，因此你的英雄将有时间杀死龙，我们的公主可以睡在她的床上直到需要她为止。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepingBeauty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zzz...sleeping..."</span>)</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"sleeping beauty is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Castle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> princess = <span class="type">SleepingBeauty</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"castle is ready!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a new castle..."</span>)</span><br><span class="line"><span class="keyword">let</span> castle = <span class="type">Castle</span>()</span><br><span class="line">castle.princess</span><br></pre></td></tr></table></figure><p>好多了！ 现在城堡立即为战斗做好了准备，因此王子可以唤醒他所爱的人，并且……他们从此过着幸福的生活。 故事结局。👸 ❤️ 🤴</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a new castle...</span><br><span class="line">castle is ready!</span><br><span class="line">zzz...sleeping...</span><br><span class="line">sleeping beauty is ready!</span><br></pre></td></tr></table></figure><p>希望你喜欢童话故事，但让我们做一些真正的编码吧！ 🤓</p></br><h1 id="避免懒加载可选属性"><a href="#避免懒加载可选属性" class="headerlink" title="避免懒加载可选属性"></a><strong>避免懒加载可选属性</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你在前面的示例中所看到的，可以使用惰性属性来提高 <code>Swift</code> 代码的性能。 您也可以消除对象中的可选项。 如果你要处理 <code>UIView</code> 派生类，这将很有用。 例如，如果你的视图层次结构需要 <code>UILabel</code> ，则通常必须将该属性声明为可选属性或隐式展开的可选存储属性。 让我们通过使用惰性和消除邪恶的可选要求的方式来重新制作此示例。 😈</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadView()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.label)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.label.textColor = .black</span><br><span class="line">        <span class="keyword">self</span>.label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况还不错，但是我仍然更喜欢将我的视图声明为隐式展开的可选对象。 💀</p></br><h1 id="使用懒加载闭包"><a href="#使用懒加载闭包" class="headerlink" title="使用懒加载闭包"></a>使用懒加载闭包</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以使用 <a href="http://www.xuebaonline.com/Swift%E5%B8%A6%E9%97%AD%E5%8C%85%E7%9A%84%E6%87%92%E6%83%B0%E5%88%9D%E5%A7%8B%E5%8C%96/"><code>懒加载闭包(lazy closure)</code></a> 将一些代码包装在其中。 与存储的属性相比，懒惰的主要优点是，只有对该变量执行读取操作时，才执行块。 您还可以使用常规存储属性填充 <a href="http://www.xuebaonline.com/Swift%20Lazy%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/"><code>惰性属性(lazy property)</code></a> 的值。 让我们在实践中看一下。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.textColor = .black</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想整理一下init方法，这是一个不错的做法。 你可以将所有对象自定义逻辑放在闭包内。 闭包在读取时自动执行（自我执行的闭包），因此当你调用self.label时，你的代码块将被执行并贴紧：视图将准备就绪。</p><blockquote><p><strong><em>提示：</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你不能在存储的属性中使用 <code>self</code> ，但是可以使用 <code>lazy closure</code> 来使用 <code>self</code> 。 注意：如果你不想造成引用循环和内存泄漏，则应始终使用 <code>[unown self]</code> 。 ♻️</p></blockquote></br><h1 id="使用工厂模式进行-Lazy-initialization"><a href="#使用工厂模式进行-Lazy-initialization" class="headerlink" title="使用工厂模式进行 Lazy initialization"></a><strong><em>使用工厂模式进行 Lazy initialization</em></strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我已经有几篇关于 <code>Swift</code> 中 <a href="http://www.xuebaonline.com/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><code>工厂设计模式</code></a> 的文章，所以现在我只想向你展示如何使用工厂方法和结合了 <code>lazy property</code> 的静态工厂。</p></br><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong><em>工厂方法</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不喜欢自动执行的闭包，则可以将代码移出工厂方法，并将其与惰性变量一起使用。 像这样简单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = <span class="keyword">self</span>.createCustomLabel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">createCustomLabel</span><span class="params">()</span></span> -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"called"</span>)</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.textColor = .black</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，工厂方法的工作方式类似于你的惰性属性的私有初始化程序。 让我们更进一步，以便可以稍微提高可重用性…</p><h2 id="静态工厂方式"><a href="#静态工厂方式" class="headerlink" title="静态工厂方式"></a><strong><em>静态工厂方式</em></strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想在应用程序的多个部分中重复使用这些初始化代码，则将它们初始化为 <a href="http://www.xuebaonline.com/tags/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"><code>静态工厂(static factory)</code></a> 可能是一个好习惯。 例如，这非常适合初始化自定义视图。 另外，创建自定义视图实际上并不是视图控制器任务，因此本示例中的职责更加分离。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> label: <span class="type">UILabel</span> = <span class="type">UILabel</span>.createCustomLabel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">createCustomLabel</span><span class="params">()</span></span> -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        label.textColor = .black</span><br><span class="line">        label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">16</span>, weight: .bold)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;免费获得你可以享受静态工厂属性/方法的优点，例如缓存或返回特定的子类型。 挺整洁的！ 👍</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;惰性变量是优化代码的一种非常方便的方法，但是它们只能在结构和类上使用。 n你不能将它们用作计算属性，这意味着它们在你每次尝试访问它们时都不会返回闭包块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个重要的事情是，惰性属性不是线程安全的，因此你必须谨慎使用它们。 另外，你并不总是希望消除隐式解包的可选值，有时候崩溃只是更好的选择！ 🐛</p><blockquote><p><strong><em>提示：</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;别偷懒！</p></blockquote><p>…但是请随时使用惰性属性！ 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 懒加载模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift对象池设计模式</title>
      <link href="/Swift%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本快速教程中，我将解释并向你展示如何使用 <code>Swift</code> 编程语言实现对象池设计模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="对象池"><code>对象池（英语：object pool pattern）</code></a>是一种设计模式。一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的效能提升。从池子中取得对象的时间是可预测的，但新建一个实例所需的时间是不确定。</p><a id="more"></a></br><h1 id="Swift-中的通用对象池"><a href="#Swift-中的通用对象池" class="headerlink" title="Swift 中的通用对象池"></a><strong>Swift 中的通用对象池</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象池模式是一种创新的设计模式。其背后的主要思想是，首先创建一组对象（一个池），然后从该池中获取和释放对象，而不是不断创建和释放它们。 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么？性能改进。例如， <code>Dispatch</code> 框架使用对象池模式为开发人员提供预先创建的队列，因为创建队列（带有关联线程）是相对昂贵的操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象池模式的另一个用例是 <code>worker</code> 。例如，您必须从Web上下载数百个图像，但是您只想同时下载5个图像，则可以使用5个工作对象池来完成。分配少量的工作程序（实际上将完成下载任务）可能要比为每个图像下载请求创建一个新的工作程序便宜得多。 🖼</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么这种模式的缺点呢？有一些。例如，如果池中有工作程序，则它们可能包含状态或敏感的用户数据。你也必须非常小心。重设所有内容。同样，如果你在多线程环境中运行，则还必须使池成为线程安全的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个简单的通用线程安全对象池类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> lockQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"pool.lock.queue"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> semaphore: <span class="type">DispatchSemaphore</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> items = [<span class="type">T</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> items: [<span class="type">T</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.semaphore = <span class="type">DispatchSemaphore</span>(value: items.<span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">self</span>.items.reserveCapacity(items.<span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">self</span>.items.append(contentsOf: items)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">acquire</span><span class="params">()</span></span> -&gt; <span class="type">T?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.semaphore.wait(timeout: .distantFuture) == .success, !<span class="keyword">self</span>.items.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.lockQueue.sync &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>.items.remove(at: <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">release</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.lockQueue.sync &#123;</span><br><span class="line">            <span class="keyword">self</span>.items.append(item)</span><br><span class="line">            <span class="keyword">self</span>.semaphore.signal()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pool = <span class="type">Pool</span>&lt;<span class="type">String</span>&gt;([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(a ?? "</span>n/a<span class="string">") acquired"</span>)</span><br><span class="line"><span class="keyword">let</span> b = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(b ?? "</span>n/a<span class="string">") acquired"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(c ?? "</span>n/a<span class="string">") acquired"</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .<span class="keyword">default</span>).asyncAfter(deadline: .now() + .seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> item = b &#123;</span><br><span class="line">        pool.release(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"No more resource in the pool, blocking thread until..."</span>)</span><br><span class="line"><span class="keyword">let</span> x = pool.acquire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(x ?? "</span>n/a<span class="string">") acquired again"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在示例中，实现仅几行。 你具有通用池项的线程安全数组，一个调度信号量（如果池中没有可用对象将阻塞该信号量）以及两个方法以实际使用对象池。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在示例中，你可以看到，如果池中没有剩余的对象，则当前队列将被阻塞，直到资源被释放并可以使用为止。 所以要当心，不要意外阻塞主线程！ 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 对象池设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift外观设计模式</title>
      <link href="/Swift%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观设计模式是复杂子系统上的简化界面。 展示一个使用 <code>Swift</code> 的快速实例。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="外观模式"><code>外观模式（Facade pattern）</code></a> ，是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。</p><a id="more"></a><p><img src="http://q8wtfza4q.bkt.clouddn.com/fp-stp1.png" alt="外观设计模式"></p><ul><li><p>结构</p><ul><li><p>Facade</p><p>  这个外观类为子系统中Packages 1、2、3提供一个共同的对外接口</p></li><li><p>Clients</p><p>  客户对象通过一个外观接口读写子系统中各接口的数据资源。</p></li><li><p>Packages</p><p>  客户可以通过外观接口读取的内部库。</p></li></ul></li></ul></br><h1 id="什么是外观设计模式"><a href="#什么是外观设计模式" class="headerlink" title="什么是外观设计模式"></a><strong>什么是外观设计模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观设计模式名字的由来是源于建筑结构的术语。</p><blockquote><p>one exterior side of a building, usually the front</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件开发中，此定义可以转换为外部所有内容，隐藏所有内部部分。 因此，外观的主要目的是在一些更复杂的丑陋外观上提供漂亮的API。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，如果你有两个或多个单独的子系统需要一起工作以完成某种任务，则外观设计模式会很方便。 它可以隐藏底层的复杂性，再加上如果隐藏方法内部发生任何更改，则外观的界面仍然可以保持不变。 👍</p></br><h1 id="外观设计模式实例"><a href="#外观设计模式实例" class="headerlink" title="外观设计模式实例"></a><strong>外观设计模式实例</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我让我们想象一个带有切换按钮的应用程序，该按钮可以打开或关闭特定设置。 如果用户点击它，我们将更改默认存储中的基础设置值，此外，我们还希望播放声音作为给定输入的额外反馈。 这是三个不同的东西组合在一起。 🎶</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toggleSettings</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// change underlying settings value</span></span><br><span class="line">    <span class="keyword">let</span> settingsKey = <span class="string">"my-settings"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> originalValue = <span class="type">UserDefaults</span>.standard.bool(forKey: settingsKey)</span><br><span class="line">    <span class="keyword">let</span> newValue = !originalValue</span><br><span class="line"></span><br><span class="line">    <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(newValue, forKey: settingsKey)</span><br><span class="line">    <span class="type">UserDefaults</span>.standard.synchronize()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// positive feedback sound</span></span><br><span class="line">    <span class="type">AudioServicesPlaySystemSound</span>(<span class="number">1054</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update UI</span></span><br><span class="line">    <span class="keyword">self</span>.switchButton.setOn(newValue, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恭喜，我们已经创建了最简单的外观！ 如果你对这段代码熟悉，则意味着您过去已经使用了 <code>Facade</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，事情可能会更加复杂，例如，如果你有一个 <code>Web</code> 服务，并且需要上传一些数据和附件文件，那么你还可以编写一个 <code>Facade</code> 来隐藏子系统的底层复杂性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观设计模式确实很容易创建，有时你甚至不会注意到正在使用外观模式，但是它们对于隐藏，解耦或简化事物非常有用。 😉</p></br><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><br><ul><li><p><a href="https://www.appcoda.com/design-pattern-structural/" target="_blank" rel="noopener"><code>Design Patterns in Swift #3: Facade and Adapter</code></a></p></li><li><p><a href="https://rubygarage.org/blog/swift-design-patterns" target="_blank" rel="noopener"><code>Top 5 Design Patterns in Swift for iOS App Development</code></a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 外观设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Swift中处理非可选选项</title>
      <link href="/%E5%9C%A8Swift%E4%B8%AD%E5%A4%84%E7%90%86%E9%9D%9E%E5%8F%AF%E9%80%89%E9%80%89%E9%A1%B9/"/>
      <url>/%E5%9C%A8Swift%E4%B8%AD%E5%A4%84%E7%90%86%E9%9D%9E%E5%8F%AF%E9%80%89%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可选参数可以说是 <code>Swift</code> 最重要的功能之一，也是将其与 <code>Objective-C</code> 之类的语言区分开来的关键。 通过被迫处理可能为 <code>nil</code> 的情况，我们倾向于编写更具可预测性和较少错误的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有时可选参数可能会使你处于一个很难处理的局面，在程序员看来，你知道（或至少在假设之下）某个变量在使用时始终为 <code>non-nil</code> ，即使它是 可选类型。 就像在视图控制器中处理视图时一样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tableView: <span class="type">UITableView?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        tableView = <span class="type">UITableView</span>(frame: view.bounds)</span><br><span class="line">        view.addSubview(tableView!)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewModelDidUpdate</span><span class="params">(<span class="number">_</span> viewModel: ViewModel)</span></span> &#123;</span><br><span class="line">        tableView?.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下， <code>Swift</code> 程序员会在与制表符和空格几乎相同的程度上存在分歧。 有人说：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“由于它是可选的，因此你应该始终正确地解开它，使用 <code>let</code> 或 <code>guard let</code> 。”</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而其他人会朝完全不同的方向说：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“由于你知道变量将不会为 <code>nil</code> ，请强制将其解包（使用！）。 崩溃比处于不确定状态要好。”</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本上，我们在这里谈论的是是否进行 <a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener" title="防御性编程"><code>防御性编程(英文：defensive programming)</code></a>。 我们是否试图从不确定的状态中恢复，还是仅仅放弃并崩溃？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我必须对这个问题给出一个二元的答案，那么我肯定会选择后者。 未定义状态会导致很难发现错误，可能会导致不必要的代码执行，而采用防御性编程只会导致难以推理的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，我宁愿不必给出二进制答案，而是研究一些可用于以更细微的方式解决此问题的技术。 </p></br><h1 id="真的可选吗？"><a href="#真的可选吗？" class="headerlink" title="真的可选吗？"></a><strong>真的可选吗？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变量和属性是可选的，但实际上是程序逻辑所必需的，实际上是体系结构缺陷的征兆。 如果需要某些东西，到没有它会使你处于不确定状态-它不是可选的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管在某些情况下（例如与某些系统 <code>API</code> 进行交互时），确实很难避免使用可选项–在许多情况下，我们可以使用某些技术来摆脱可选项。</p></br><h1 id="懒加载-lazy-比非可选的-non-optionally-optional-要好"><a href="#懒加载-lazy-比非可选的-non-optionally-optional-要好" class="headerlink" title="懒加载(lazy)比非可选的(non-optionally optional)要好"></a><strong>懒加载(lazy)比非可选的(non-optionally optional)要好</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种避免使用属性的可选选项的方法，即通过使用惰性属性来避免在创建父对象之后需要创建值的属性（例如，视图控制器中的视图-应该在 <code>loadView()</code> 或 <code>viewDidLoad()</code> 中创建）。 惰性属性可以是非可选的，但仍不需要在其父级的初始值设定项中创建。 它将在首次访问时创建。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从之前更新 <code>TableViewController</code> ，以对其表视图使用对属性进行懒加载：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> tableView = <span class="type">UITableView</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        tableView.frame = view.bounds</span><br><span class="line">        view.addSubview(tableView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewModelDidUpdate</span><span class="params">(<span class="number">_</span> viewModel: ViewModel)</span></span> &#123;</span><br><span class="line">        tableView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有可选项，没有不确定的状态！ 🎉</p></br><h1 id="适当的依赖项管理要比非可选的可选项好"><a href="#适当的依赖项管理要比非可选的可选项好" class="headerlink" title="适当的依赖项管理要比非可选的可选项好"></a><strong>适当的依赖项管理要比非可选的可选项好</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可选项的另一个常见用法是打破 <a href="https://en.wikipedia.org/wiki/Circular_dependency" target="_blank" rel="noopener" title="循环依赖关系"><code>循环依赖关系(circular dependencies)</code></a> 。 有时您可能会遇到 <code>A</code> 依赖于 <code>B</code> ，但 <code>B</code> 也依赖于 <code>A</code> 的情况。类似于此设置：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> commentManager: <span class="type">CommentManager?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userDidPostComment</span><span class="params">(<span class="number">_</span> comment: Comment)</span></span> &#123;</span><br><span class="line">        user.totalNumberOfComments += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">logOutCurrentUser</span><span class="params">()</span></span> &#123;</span><br><span class="line">        user.logOut()</span><br><span class="line">        commentManager?.clearCache()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> userManager: <span class="type">UserManager?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">composer</span><span class="params">(<span class="number">_</span> composer: CommentComposer</span></span></span><br><span class="line"><span class="function"><span class="params">                  didPostComment comment: Comment)</span></span> &#123;</span><br><span class="line">        userManager?.userDidPostComment(comment)</span><br><span class="line">        handle(comment)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clearCache</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cache.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我们在上面看到的，我们在 <code>UserManager</code> 和 <code>CommentManager</code> 之间具有循环依赖关系，其中它们都不假定彼此拥有所有权，但是它们在逻辑上仍然相互依赖。 那只是等待发生的错误！ 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决上述问题，我们改为让 <code>CommentComposer</code> 充当中间人，并负责通知 <code>UserManager</code> 和 <code>CommentManager</code> 已做出评论：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentComposer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> commentManager: <span class="type">CommentManager</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> userManager: <span class="type">UserManager</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> textView = <span class="type">UITextView</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(commentManager: <span class="type">CommentManager</span>,</span><br><span class="line">         userManager: <span class="type">UserManager</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.commentManager = commentManager</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">postComment</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> comment = <span class="type">Comment</span>(text: textView.text)</span><br><span class="line">        commentManager.handle(comment)</span><br><span class="line">        userManager.userDidPostComment(comment)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，<code>UserManager</code> 可以拥有对 <code>CommentManager</code> 的强引用，而没有循环引用（或依赖)：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> commentManager: <span class="type">CommentManager</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(commentManager: <span class="type">CommentManager</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.commentManager = commentManager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userDidPostComment</span><span class="params">(<span class="number">_</span> comment: Comment)</span></span> &#123;</span><br><span class="line">        user.totalNumberOfComments += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再次删除了所有可选内容，并提供了可预测的代码！ 🎉</p></br><h1 id="崩溃"><a href="#崩溃" class="headerlink" title="崩溃"></a><strong>崩溃</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的示例中，我们看到了一些示例，在这些示例中我们可以调整代码以通过删除可选选项来消除不确定性。 但是，有时候这是不可能的。 假设你正在加载包含应用程序配置的本地 <code>JSON</code> 文件。 这本质上是一项可能会失败的操作，因此我们将需要添加一些错误处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果配置无法加载，则继续执行程序会使应用程序处于未定义状态，因此在这种情况下可能会引发崩溃。 这样，我们可以获得崩溃报告，并希望我们的 <code>tests &amp; QA</code> 检查流程能够早于解决此问题并将其传递给用户。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，我们如何崩溃？ 最简单的解决方案是简单地使用 <code>! operator</code> ，强制解开可选选项，如果它包含 <code>nil</code> 则导致崩溃：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = loadConfiguration()!</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管这种方法很简单，但缺点是很大。 如果此代码开始崩溃，我们将得到的错误消息是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: unexpectedly found <span class="literal">nil</span> <span class="keyword">while</span> unwrapping an <span class="type">Optional</span> value</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;错误消息不会告诉我们错误的原因和发生位置，也没有提供解决方法的线索。 相反，让我们结合使用 <code>guard</code> 语句和 <code>preconditionFailure()</code> 函数，以自定义消息退出。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> configuration = loadConfiguration() <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">preconditionFailure</span>(<span class="string">"Configuration couldn't be loaded. "</span> +</span><br><span class="line">                        <span class="string">"Verify that Config.JSON is valid."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用以上方法崩溃时，我们将获得更多有用的错误消息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: <span class="type">Configuration</span> couldn’t be loaded. <span class="type">Verify</span> that <span class="type">Config1</span>.<span class="type">JSON</span> <span class="keyword">is</span> valid.: file ~/<span class="type">DemoApp</span>/<span class="type">Sources</span>/<span class="type">AppDelegate</span>.swift, line <span class="number">17</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以采取明确的措施来解决该问题，并且我们确切知道它在代码库中的位置！ 🚀</p></br><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a><strong>更多</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进行上面的 <code>guard-let-preconditionFailure</code> 操作可能会有些乏味，并且确实会使代码难于遵循。 我们真的不想在代码中留出如此大的空间，这样的特殊情况-我们要专注于我们的逻辑。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的解决方案是 <code>Require</code> 。 它在 <code>Optional</code> 上添加了一个简单的 <code>require()</code> 方法，可以完成上述操作，但是使调用站点更加整洁。 使用 <code>Require</code> 时，上述配置加载代码如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = loadConfiguration().require(hint: <span class="string">"Verify that Config.JSON is valid"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果失败，它将给我们以下错误消息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: <span class="type">Required</span> value was <span class="literal">nil</span>. <span class="type">Debugging</span> hint: <span class="type">Verify</span> that <span class="type">Config1</span>.<span class="type">JSON</span> <span class="keyword">is</span> valid: file ~/<span class="type">DemoApp</span>/<span class="type">Sources</span>/<span class="type">AppDelegate</span>.swift, line <span class="number">17</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Require</code> 的另一个优点是，它还将引发 <code>NSException</code> 以及调用 <code>preconditionFailure</code> ，这将使崩溃报告工具（如 <code>Crashlytics</code> ）能够提取崩溃的所有元数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想在代码中使用  <a href="https://github.com/JohnSundell/Require" target="_blank" rel="noopener" title="Require"><code>Require</code></a> ，它是 <a href="https://github.com/JohnSundell/Require" target="_blank" rel="noopener" title="Require"><code>GitHub</code></a> 上的开源代码。</p></br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，这些是我在 <code>Swift</code> 中处理非可选可选内容的技巧：</p><ul><li>懒加载(lazy)比非可选的(non-optionally optional)要好</li><li>适当的依赖项管理要比非可选的可选项好</li><li>当您需要使用非可选的可选选项时，正常崩溃</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 迭代器设计模式 </tag>
            
            <tag> optionals </tag>
            
            <tag> non-optional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Swift中创建自定义集合</title>
      <link href="/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/"/>
      <url>/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建对象或值的集合时，我们通常使用标准库提供的数据结构-例如 <code>Array</code> ，<code>Dictionary</code> 和 <code>Set</code> 。 尽管这三个案例涵盖了大多数用例，但有时创建自定义包装器集合可以使你使代码更可预测，并且更不易出错。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此次，让我们看看作为应用程序开发人员的我们如何在 <code>Swift</code> 中定义此类自定义集合，以及结合枚举的强大功能，如何让我们为自己创建一些非常漂亮的 <code>API</code> 。</p><a id="more"></a></br><h1 id="删除可选"><a href="#删除可选" class="headerlink" title="删除可选"></a><strong>删除可选</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像我们在 <a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%A4%84%E7%90%86%E9%9D%9E%E5%8F%AF%E9%80%89%E9%80%89%E9%A1%B9/" title="在Swift中处理非可选的可选内容"><code>“在Swift中处理非可选的可选内容”</code></a> 中介绍的那样，减少了在实际需要的值真正需要时使用可选的需求，这确实可以帮助我们避免错误并简化我们的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，集合的问题在于，你通常无法保证它们是否包含一定的值，因此，你往往会遇到很多可选内容和逻辑，这些可选内容和逻辑要求以一种或另一种方式将它们拆开。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们正在为一家杂货店构建应用程序，并且我们希望拥有一个用户界面，该界面可让用户按类别显示所有产品。 要为此类UI创建模型，我们可以使用 <code>Dictionary</code> ，其使用 <code>Category</code> 作为其键类型，并使用 <code>[Product]</code> 作为其值类型，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> products: [<span class="type">Category</span> : [<span class="type">Product</span>]] = [</span><br><span class="line">    .dairy: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Milk"</span>, category: .dairy),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Butter"</span>, category: .dairy)</span><br><span class="line">    ],</span><br><span class="line">    .vegetables: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Cucumber"</span>, category: .vegetables),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Lettuce"</span>, category: .vegetables)</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管上述方法有效，但要求我们编写这样的代码，以便例如仅显示所有 <code>Product</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> dairyProducts = products[.dairy] &#123;</span><br><span class="line">    <span class="keyword">guard</span> !dairyProducts.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        renderEmptyView()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render(dairyProducts)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    renderEmptyView()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很好，但是可能会更好。 但是，插入新产品变得更加麻烦：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> products = [<span class="type">Category</span> : [<span class="type">Product</span>]]()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> product: Product)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> productsInCategory = products[product.category] &#123;</span><br><span class="line">            productsInCategory.append(product)</span><br><span class="line">            products[product.category] = productsInCategory</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            products[product.category] = [product]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好消息是，通过创建我们自己的自定义集合，我们可以使上述两个示例变得更好更清晰。 而且，更好的消息是-借助 <code>Swift</code> 的面向协议的设计-创建这样的集合实际上非常容易！</p></br><h1 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a><strong>创建集合</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 标准库中的所有集合都遵循 <code>Collection</code> 协议，而 <code>Collection</code> 协议又继承自 <code>Sequence</code> 协议。 通过使自定义集合符合这两个协议，它可以完全免费地利用所有标准集合操作（例如，迭代和过滤）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从定义自定义 <code>ProductCollection</code> 的基础开始，这将使我们能够以更好的方式处理产品和类别。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProductCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">DictionaryType</span> = [<span class="type">Category</span> : [<span class="type">Product</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Underlying, private storage, that is the same type of dictionary</span></span><br><span class="line">    <span class="comment">// that we previously was using at the call site</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> products = <span class="type">DictionaryType</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable our collection to be initialized with a dictionary</span></span><br><span class="line">    <span class="keyword">init</span>(products: <span class="type">DictionaryType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.products = products</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们将通过实现协议要求使其符合 <code>Collection</code> 。 我们要做的大多数事情就是简单地将调用转发到基础 <code>products</code> 字典，然后让它进行“繁重的工作”：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span>: <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Required nested types, that tell Swift what our collection contains</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">DictionaryType</span>.<span class="type">Index</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">DictionaryType</span>.<span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The upper and lower bounds of the collection, used in iterations</span></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123; <span class="keyword">return</span> products.startIndex &#125;</span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123; <span class="keyword">return</span> products.endIndex &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Required subscript, based on a dictionary index</span></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Index</span>) -&gt; <span class="type">Iterator</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> products[index] &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method that returns the next index when iterating</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Index)</span></span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> products.index(after: i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码使用的是 <code>Swift 4</code> ，这归功于对通用约束的改进（使我们可以更仔细地研究这些改进以及如何在以后的文章中使用类型约束），从而使自定义集合的定义变得更加简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们有了一个自定义集合，可以将其用作内置集合之一。 例如，我们可以遍历它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (category, productsInCategory) <span class="keyword">in</span> products &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者在其上使用诸如 <code>map</code> 的操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> categories = productCollection.<span class="built_in">map</span> &#123; $<span class="number">0</span>.key &#125;</span><br></pre></td></tr></table></figure></br><h1 id="自定义集合-API"><a href="#自定义集合-API" class="headerlink" title="自定义集合 API"></a><strong>自定义集合 API</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们已经为我们的系列奠定了基础，让我们开始向其中添加一些 <code>API</code> ，使我们能够使我们的产品处理代码更好。 我们将从一个自定义的下标重载开始，该重载使我们无需处理可选项就可以获取或设置一系列产品：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(category: <span class="type">Category</span>) -&gt; [<span class="type">Product</span>] &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> products[category] ?? [] &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; products[category] = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还添加一个便捷的 <code>API</code> ，以轻松地将新 <code>product</code> 插入我们的收藏夹：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> product: Product)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> productsInCategory = <span class="keyword">self</span>[product.category]</span><br><span class="line">        productsInCategory.append(product)</span><br><span class="line">        <span class="keyword">self</span>[product.category] = productsInCategory</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们可以返回原始的 <code>product</code> 处理代码，并将其更新为更好的代码。 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dairyProducts = products[.dairy]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dairyProducts.isEmpty &#123;</span><br><span class="line">    renderEmptyView()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    render(dairyProducts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> products = <span class="type">ProductCollection</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(product: Product)</span></span> &#123;</span><br><span class="line">        products.insert(product)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="通过-Key-值获取"><a href="#通过-Key-值获取" class="headerlink" title="通过 Key 值获取"></a><strong>通过 Key 值获取</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，到了关键时候！ 由于我们的自定义集合基本上只是字典的包装，因此我们可以轻松地添加对使用字典文字进行初始化的支持。 这样做将使我们能够编写如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> products: <span class="type">ProductCollection</span> = [</span><br><span class="line">    .dairy: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Milk"</span>, category: .dairy),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Butter"</span>, category: .dairy)</span><br><span class="line">    ],</span><br><span class="line">    .vegetables: [</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Cucumber"</span>, category: .vegetables),</span><br><span class="line">        <span class="type">Product</span>(name: <span class="string">"Lettuce"</span>, category: .vegetables)</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;太酷了！ 这不仅对减少生产代码中的冗长有用，而且还将使在我们的测试中设置产品集合模拟更加简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要做的就是遵守    <code>ExpressibleByDictionaryLiteral</code> ，它要求我们实现一个带有文字的初始化程序，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductCollection</span>: <span class="title">ExpressibleByDictionaryLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Key</span> = <span class="type">Category</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Value</span> = [<span class="type">Product</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(dictionaryLiteral elements: (<span class="type">Category</span>, [<span class="type">Product</span>])...) &#123;</span><br><span class="line">        <span class="keyword">for</span> (category, productsInCategory) <span class="keyword">in</span> elements &#123;</span><br><span class="line">            products[category] = productsInCategory</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用自定义集合可能是一种非常强大的工具，可以以一种更加可预测且易于使用的方式来处理一组值。 当您处理多个值时，它不一定总是您的首选解决方案，但在正确的情况下，它确实可以帮助你编写更简洁的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在调试时，了解诸如集合之类的事物的工作方式也非常有帮助，或者使你了解如何优化与集合相关的代码。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 迭代器设计模式 </tag>
            
            <tag> Collection </tag>
            
            <tag> Collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift迭代器设计模式</title>
      <link href="/Swift%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用一些 <a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88/" title="自定义序列"><code>自定义序列</code></a>（符合 <code>Swift</code> 标准库中的 <code>IteratorProtocol</code> ），学习迭代器设计模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在面向对象编程里，<a href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="迭代器模式">迭代器模式</a> 是一种设计模式，是一种最简单也最常见的设计模式。它可以让用户透过特定的接口访问容器中的每一个元素而不用了解底层的实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，我将重点介绍迭代器设计模式。 该模式在 <a href="https://developer.apple.com/documentation/swift/swift_standard_library" target="_blank" rel="noopener" title="Swift标准库"><code>Swift标准库</code></a> 中大量使用，如果你需要创建迭代器，有一些协议可以为你提供支持，但是老实说：我从来没有直接实现过这种模式。 😅</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实是，在99％的用例中，你将永远不必处理这种模式，因为对 <code>Swift</code> 中直接内置的迭代器提供了惊人的支持。 始终使用序列，数组，字典而不是直接实现此模式，但是很高兴知道事情是如何进行的。 🙃</p><a id="more"></a></br><h1 id="什么是迭代器设计模式？"><a href="#什么是迭代器设计模式？" class="headerlink" title="什么是迭代器设计模式？"></a><strong>什么是迭代器设计模式？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顾名思义，该模式使你可以迭代一组元素。 这是其中一种定义：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供一种在不暴露其基础表示的情况下顺序访问聚合对象的元素的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长话短说，迭代器为你提供了一个界面，无论你在后台如何实现这些集合，都可以使你对集合进行迭代。 这是上面使用字符串迭代器的理论的快速示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">StringIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStringIterator</span>: <span class="title">StringIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> values: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> index: <span class="type">Int?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> values: [<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.values = values</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">for</span> index: Int?)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = index, index &lt; <span class="keyword">self</span>.values.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="literal">nil</span>, !<span class="keyword">self</span>.values.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = <span class="keyword">self</span>.nextIndex(<span class="keyword">for</span>: <span class="keyword">self</span>.index) &#123;</span><br><span class="line">            <span class="keyword">self</span>.index = index</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.values[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Iterable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">StringIterator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataArray</span>: <span class="title">Iterable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> dataSource: [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataSource = [<span class="string">"🐶"</span>, <span class="string">"🐔"</span>, <span class="string">"🐵"</span>, <span class="string">"🦁"</span>, <span class="string">"🐯"</span>, <span class="string">"🐭"</span>, <span class="string">"🐱"</span>, <span class="string">"🐮"</span>, <span class="string">"🐷"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">StringIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ArrayStringIterator</span>(<span class="keyword">self</span>.dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="type">DataArray</span>()</span><br><span class="line"><span class="keyword">let</span> iterator = data.makeIterator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> next = iterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如你所见，它们有两个主要协议和一个非常简单的实现。 现在，我们的 <code>DataArray</code> 类的行为就像一个真实的数组，可以通过使用循环来迭代基础元素。 让我们抛开理论，通过使用实际的 <code>Swift标准库组件</code> 从上面重新实现示例。 😉</p></br><h1 id="Swift-中的自定义序列"><a href="#Swift-中的自定义序列" class="headerlink" title="Swift 中的自定义序列"></a><strong>Swift 中的自定义序列</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 具有内置的序列协议，可帮助你创建迭代器。 在 <code>Swift</code> 中实现自己的序列就是通过创建自定义迭代器对象来隐藏基础数据结构。 你只需存储当前索引，并在每次调用下一个函数时根据该索引返回下一个元素。 😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Emojis</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> animals: [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">EmojiIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">EmojiIterator</span>(<span class="keyword">self</span>.animals)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EmojiIterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> values: [<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> index: <span class="type">Int?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> values: [<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.values = values</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">for</span> index: Int?)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = index, index &lt; <span class="keyword">self</span>.values.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="literal">nil</span>, !<span class="keyword">self</span>.values.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index = <span class="keyword">self</span>.nextIndex(<span class="keyword">for</span>: <span class="keyword">self</span>.index) &#123;</span><br><span class="line">            <span class="keyword">self</span>.index = index</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.values[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emojis = <span class="type">Emojis</span>(animals: [<span class="string">"🐶"</span>, <span class="string">"🐔"</span>, <span class="string">"🐵"</span>, <span class="string">"🦁"</span>, <span class="string">"🐯"</span>, <span class="string">"🐭"</span>, <span class="string">"🐱"</span>, <span class="string">"🐮"</span>, <span class="string">"🐷"</span>])</span><br><span class="line"><span class="keyword">for</span> emoji <span class="keyword">in</span> emojis &#123;</span><br><span class="line">    <span class="built_in">print</span>(emoji)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，<a href="https://developer.apple.com/documentation/swift/sequence" target="_blank" rel="noopener" title="Sequence protocol"><code>Sequence protocol</code></a> 与第一个示例中使用的自定义可迭代协议的通用对应项。   <a href="https://developer.apple.com/documentation/swift/iteratorprotocol" target="_blank" rel="noopener" title="IteratorProtocol"><code>IteratorProtocol</code></a> 有点像之前使用的字符串迭代器协议，但是更加迅捷，当然也更通用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，这很棒。 最后，你知道如何创建自定义序列。 如果你想隐藏数据结构并提供通用的可迭代接口，那么这很好。 想象一下，如果你将要开始使用字典而不是使用数组来存储命名的表情符号而没有用于包装它们的迭代器，将会发生什么。 🤔</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我想谈谈 <code>Swift标准库</code> 中还有另外一个超级有用的东西。 没错，一个抽象级别的应用，我们看这里：</p></br><h1 id="Swift-中的自定义集合"><a href="#Swift-中的自定义集合" class="headerlink" title="Swift 中的自定义集合"></a><strong>Swift 中的自定义集合</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://developer.apple.com/documentation/swift/collection" target="_blank" rel="noopener" title="Collections"><code>Collections</code></a> 是序列之外的第一步。 它们内部的元素可以通过下标访问，它们还定义了 <code>startIndex</code> 和 <code>endIndex</code> ，而且集合中的各个元素可以多次访问。 听起来不错？ 👍</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时创建 <a href=""自定义集合类型""><code>自定义集合类型</code></a> 可能很有用。 例如，如果你想消除可选值。 想象一下分类的收藏夹机制，对于每个类别，您都有一系列的收藏夹，因此你必须处理空的和不存在的案例。 使用自定义集合，你可以将多余的代码隐藏在自定义数据结构中，并为应用程序的其余部分提供一个简洁的界面。 😍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">FavoriteType</span> = [<span class="type">String</span>: [<span class="type">String</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> list: <span class="type">FavoriteType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Favorites</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.list = <span class="type">FavoriteType</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Favorites</span>: <span class="title">Collection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">FavoriteType</span>.<span class="type">Index</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">FavoriteType</span>.<span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.startIndex</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.endIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Index</span>) -&gt; <span class="type">Iterator</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list[index]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Index)</span></span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list.index(after: i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">String</span>) -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.list[index] ?? []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> value: String, category: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> values = <span class="keyword">self</span>.list[category] &#123;</span><br><span class="line">            <span class="keyword">guard</span> !values.<span class="built_in">contains</span>(value) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            values.append(value)</span><br><span class="line">            <span class="keyword">self</span>.list[category] = values</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.list[category] = [value]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> value: String, category: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> values = <span class="keyword">self</span>.list[category] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        values = values.<span class="built_in">filter</span> &#123; $<span class="number">0</span> == value &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> values.isEmpty &#123;</span><br><span class="line">            <span class="keyword">self</span>.list.removeValue(forKey: category)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.list[category] = values</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Favorites</span>.shared.add(<span class="string">"apple"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.add(<span class="string">"pear"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.add(<span class="string">"apple"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Favorites</span>.shared[<span class="string">"fruits"</span>]</span><br><span class="line"></span><br><span class="line"><span class="type">Favorites</span>.shared.remove(<span class="string">"apple"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.remove(<span class="string">"pear"</span>, category: <span class="string">"fruits"</span>)</span><br><span class="line"><span class="type">Favorites</span>.shared.list</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我知道，这是一个非常简单的示例，但它说明了为什么集合比纯序列更高级。 此外，在下面的链接中，有很好的演示，演示了精心编写的收藏集。 随时了解有关隐藏在Swift标准库中（不是那么深）的这些超级协议和自定义数据类型的更多信息。 🤐</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 迭代器设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift适配器设计模式</title>
      <link href="/Swift%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用真实示例和 <code>Swift</code> 中的适配器设计模式，将不兼容的对象转换为目标接口或类。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设计模式中，<a href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="适配器模式">适配器模式</a>（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。</p><a id="more"></a><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h1><p>有两种类型的适配器模式：</p><ul><li><p><strong>对象适配器模式</strong></p><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。</p><p>  <img src="http://q8wtfza4q.bkt.clouddn.com/adp-stp1.png" alt="对象适配器模式" title="对象适配器模式"></p></li></ul><br><ul><li><strong>类适配器模式</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种适配器模式下，适配器继承自已实现的类（一般多重继承）。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/adp-stp2.png" alt="类适配器模式" title="类适配器模式"></p><br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适配器是一种结构设计模式，允许具有不兼容接口的对象一起工作。 换句话说，它转换对象的接口以使其适应不同的对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，适配器可以将一件事转换为另一件事，有时也称为包装器，因为它可以包装对象并在其周围提供一个新接口。 就像特定接口或旧类的软件加密狗一样。 </p><br><h1 id="适配器设计模式的实现"><a href="#适配器设计模式的实现" class="headerlink" title="适配器设计模式的实现"></a><strong>适配器设计模式的实现</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建适配器实际上是一件非常容易的事情。 你只需要创建一个新对象，将旧对象“装箱”到其中，并在新类或结构上实现所需的接口即可。 换句话说，包装器对象将是我们的适配器，通过包装另一个适配器对象来实现目标接口。</p><h2 id="Adaptee"><a href="#Adaptee" class="headerlink" title="Adaptee"></a><strong>Adaptee</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们正在适应特定目标的对象（例如，老式的USB-A端口）。</p><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a><strong>Adapter</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个包装原始对象并产生由某些目标接口指定的新要求的对象（这完成了实际工作，也就是上面的小软件狗）。</p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a><strong>Target</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们要与（我们的 <code>USB-C</code> 插座）适配器一起使用的对象。</p><br><h1 id="如何在Swift中使用适配器模式？"><a href="#如何在Swift中使用适配器模式？" class="headerlink" title="如何在Swift中使用适配器模式？"></a><strong>如何在Swift中使用适配器模式？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要在代码中集成第三方库，则可以使用适配器，但是其接口与你的要求不匹配。 例如，你可以围绕整个 <code>SDK</code>或后端 <code>API</code> 端点创建包装器，以创建一个公分母。 👽</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我的示例中，我将使用适配器类包装 <code>EKEvent</code> 对象，以实现全新的协议。 📆</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> EventKit</span><br><span class="line"></span><br><span class="line"><span class="comment">// our target protocol</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> startDate: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> endDate: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adapter (wrapper class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> dateFormatter: <span class="type">DateFormatter</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        dateFormatter.dateFormat = <span class="string">"yyyy. MM. dd. HH:mm"</span></span><br><span class="line">        <span class="keyword">return</span> dateFormatter</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> event: <span class="type">EKEvent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(event: <span class="type">EKEvent</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.event = event</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// actual adapter implementation</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">EventAdapter</span>: <span class="title">Event</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.event.title</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> startDate: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dateFormatter.string(from: event.startDate)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> endDate: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dateFormatter.string(from: event.endDate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let's create an EKEvent adaptee instance</span></span><br><span class="line"><span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()</span><br><span class="line">dateFormatter.dateFormat = <span class="string">"MM/dd/yyyy HH:mm"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> calendarEvent = <span class="type">EKEvent</span>(eventStore: <span class="type">EKEventStore</span>())</span><br><span class="line">calendarEvent.title = <span class="string">"Adapter tutorial deadline"</span></span><br><span class="line">calendarEvent.startDate = dateFormatter.date(from: <span class="string">"07/30/2018 10:00"</span>)</span><br><span class="line">calendarEvent.endDate = dateFormatter.date(from: <span class="string">"07/30/2018 11:00"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// now we can use the adapter class as an Event protocol, instead of an EKEvent</span></span><br><span class="line"><span class="keyword">let</span> adapter = <span class="type">EventAdapter</span>(event: calendarEvent)</span><br><span class="line"><span class="comment">// adapter.title</span></span><br><span class="line"><span class="comment">// adapter.startDate</span></span><br><span class="line"><span class="comment">// adapter.endDate</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个用例是当你必须使用几个现有的最终类或结构，但它们缺少某些功能，并且你想在它们之上构建一个新的目标接口时。 有时，实现包装程序来处理这种混乱情况是一个不错的选择。 🤷‍♂️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是适配器设计模式的全部内容。 通常，用 <code>Swift</code> 或任何其他编程语言实现它确实很容易，但是它非常有用，有时是不可避免的。 孩子们，请记住：不要在加密狗上太用力！😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 适配器设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift关于Dependency Injection (DI)</title>
      <link href="/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/"/>
      <url>/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 为我们许多人打开了函数式编程的世界。 但这仍然是面向对象的语言，而不是功能的语言。 我们的主要工具 <code>Cocoa frameworks</code> 是面向对象的。 因此，我们自己可能仍然会继续编写面向对象的代码。 这样做的问题是实际上很难编写设计良好的面向对象的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有很多不同的设计原则，例如 <code>SOLID</code> ，<code>KISS</code> ，<code>DRY</code> 等（ <code>YAGNI</code> ， <code>RAP</code> ，<code>CQS</code> ），甚至更多的设计模式。 至少对于我来说，有这么多不同的原理和模式这一事实意味着，即使有可能，良好的面向对象设计也很难。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖注入本身不是我刚才提到的 <code>SOLID</code> 原则的一部分。 但这与他们所有人息息相关。 不幸的是，依赖注入的概念被许多误解所包围。</p><a id="more"></a><blockquote><p>维基百科为我们提供了非常复杂的定义：<br>“在软件工程中，依赖性注入是一种软件设计模式，可实现控制反转以解决依赖性。”  - <code>Wikipedia</code></p></blockquote><blockquote><p>还有几句话……相反，一些开发人员说依赖注入只是传递一个实例变量。<br>“依赖注入实际上只是传递一个实例变量。”  - <code>James Shore</code></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他人则认为这是某种奇巧淫技，需要使用复杂而缓慢的框架，或者它仅与测试有关，只会使代码更难以理解。 我会说所有这些都是对依赖注入的误解。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将尽我所能使其更加清晰，并展示我对依赖注入的了解。 我将尝试展示如何进行依赖注入。 不仅如此，我们不应该这样做。</p></br><h1 id="为什么要依赖注射？"><a href="#为什么要依赖注射？" class="headerlink" title="为什么要依赖注射？"></a><strong>为什么要依赖注射？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，让我们看看依赖注入首先要解决的问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编程中，我们总是必须处理不同种类和级别的抽象。他们无处不在。接口，方法，闭包，甚至是具体的类型和变量名称-它们都是抽象的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了实现良好的代码设计，使用适当的抽象非常重要，因为它们会使我们的代码松散耦合。这意味着我们代码的不同组件可以替换为其他实现，而不会影响其他组件。当我们的代码松散耦合时，它变得更容易测试，更容易扩展，更容易重用，更容易并行开发。所有这些使维护变得更容易。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;松耦合代码是依赖注入的主要目标。它使我们能够编写松耦合的代码。因此，它使测试，扩展和重用代码变得更加容易。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多时候，仅在单元测试中讨论依赖注入。实际上，它极大地提高了可测试性，尤其是在 <code>Swift</code> 中。但是实际情况要广泛得多。如果我们的最终目标不仅是对某些类进行单元测试，还需要松散的耦合并使代码可维护，那么我们将需要付出更多的努力，而不仅仅是传递实例变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管从本质上讲，依赖注入实际上是关于传递实例变量，或者说将依赖传递给它们的使用者更好。这是第一步，也是每个第一步中最重要的一步。但这只是一个故事的一部分。还有第二步，甚至第三步。这些步骤使仅传递变量和依赖注入之间有所不同。</p></br><h1 id="依赖注射模式"><a href="#依赖注射模式" class="headerlink" title="依赖注射模式"></a><strong>依赖注射模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们从第一步开始。 有几种模式可以将依赖关系传递给消费者：</p><ul><li>构造函数注入</li><li>属性注入</li><li>方法注入</li><li>环境语境</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看看来自 <code>Cocoa frameworks</code> 的示例的使用。</p></br><h1 id="CONSTRUCTOR注入"><a href="#CONSTRUCTOR注入" class="headerlink" title="CONSTRUCTOR注入"></a><strong>CONSTRUCTOR注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是从 <strong><code>CoreData</code></strong> 注入构造函数的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NSPersistentStore</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(</span><br><span class="line">        persistentStoreCoordinator root: <span class="type">NSPersistentStoreCoordinator?</span>, </span><br><span class="line">        configurationName name: <span class="type">String?</span>, </span><br><span class="line">        <span class="type">URL</span> url: <span class="type">NSURL</span>, </span><br><span class="line">        options: [<span class="type">NSObject</span>: <span class="type">AnyObject</span>]?</span><br><span class="line">    )</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> persistentStoreCoordinator: <span class="type">NSPersistentStoreCoordinator?</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，持久性存储协调器的实例与其他一些参数一起传递给 <code>NSPersistentStore</code> 的构造函数。 然后，对协调器的引用将被存储，并且在运行时无法更改。</p><blockquote><p>通过构造函数注入，我们将依赖项作为构造函数参数传递并将其存储在只读属性中。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管在 <code>Cocoa frameworks</code> 中没有太多构造函数注入的示例，但这是注入依赖关系的首选方法。 因为它是最容易实现的，所以可以确保始终存在依赖项，并且在运行时不会更改依赖项，这使它更加安全。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在某些情况下，构造函数注入是不可能的或不合适的。 在这些情况下，我们应该使用属性注入。</p></br><h1 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a><strong>属性注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何 <code>iOS</code> 应用程序中到处都有这种模式。 例如，委托模式通常使用属性注入来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">public</span> <span class="keyword">var</span> transitioningDelegate: <span class="type">UIViewControllerTransitioningDelegate?</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，这里的视图控制器公开了用于转换委托的可写属性，如果要覆盖 <code>dafault</code> 行为，我们可以随时更改它。</p><blockquote><p>使用属性注入，消费者通过可写属性获得其依赖关系，该属性也具有一些默认值。</p></blockquote></br><h1 id="本地和外部默认设置"><a href="#本地和外部默认设置" class="headerlink" title="本地和外部默认设置"></a><strong>本地和外部默认设置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果存在良好的本地默认依赖关系，则应使用属性注入。 “本地”表示在同一模块中定义。 nil也是理想的本地默认值，它只是使依赖项成为可选项。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当实现来自单独的模块时，它是外来的。然后，我们不应将其用作默认值。而且我们不应该将属性注入用于这种依赖性。相反，我们应该使用构造函数注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象一下，传递委托的默认实现不是在 <code>UIKit</code> 中定义的，而是在其他框架中定义的。然后，即使我们从不使用此 <code>API</code> ，也始终需要链接到该框架。 <code>UIKit</code> 与该框架紧密结合。它拖延了这种无用的依赖性。我们自己的代码也会发生同样的情况，这将使重用变得更加困难。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与构造函数注入属性注入进行比较可能更容易理解，并且使我们的 <code>API</code> 看起来更灵活。但是与此同时，它可能更难以实现，并使我们的代码更脆弱。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要适当的默认实现或以适当的方式处理可选值，这可能会导致带有可选包装的可选代码混乱。其次，我们不能将属性定义为不可变的。因此，如果我们不想在设置后就对其进行更改，则需要确保在运行时而不是在编译时进行更改。另外，我们可能需要同步对其进行访问，以防止出现线程问题。由于这些原因，如果我们可以使用构造函数注入，那么我们应该首选属性注入。</p></br><h1 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a><strong>方法注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一个模式，方法注入，就像将参数传递给方法一样简单。 例如，这里是 <code>NSCoding</code> 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">NSCoding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encodeWithCoder</span><span class="params">(aCoder: NSCoder)</span></span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次将该方法称为不同的实例，甚至可以将 <code>NSCoder</code> 的实现作为参数传递。</p><blockquote><p>使用方法注入依赖关系作为参数传递给方法。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当依赖关系随每个方法调用而变化时，或者当依赖关系是暂时的并且不需要在方法范围之外保持对它的引用时，通常使用方法注入。</p><h1 id="AMBIENT-CONTEXT"><a href="#AMBIENT-CONTEXT" class="headerlink" title="AMBIENT CONTEXT"></a><strong>AMBIENT CONTEXT</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一种模式-环境上下文-在 <code>Cocoa</code> 中很难找到。 <code>NSURLCache</code> 可能是最接近的示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NSURLCache</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">setSharedURLCache</span>(<span class="title">cache</span>: <span class="title">NSURLCache</span>)</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">class</span> <span class="title">func</span> <span class="title">sharedURLCache</span>() -&gt; <span class="title">NSURLCache</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在这里我们可以将 <code>NSURLCach</code> 的任何子类设置为共享实例，然后使用静态 <code>getter</code> 访问它。 这是它与不可写的单例的主要区别。</p><blockquote><p>使用静态方法或具有某些默认值的静态可写属性来实现AMBIENT CONTEXT。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此模式仅应用于表示一些跨领域关注点的真正通用依赖项，例如日志记录，无性，访问时间和日期等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>AMBIENT CONTEXT</code> 有其自身的优势。 它使依赖关系始终可访问，并且不会污染 <code>API</code>。 非常适合跨领域的关注。 但是在其他情况下，它并不能证明其缺点。 它使依赖关系隐式化，并表示可能不是您想要的全局可变状态。</p><p>因此，如果依赖性不是真正通用的，那么我们应该考虑使用其他DI模式。</p><h1 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a><strong><em>关注点分离</em></strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会注意到，所有这些模式都非常简单，它们共享一个共同的原则-关注点分离。我们从依赖的使用者中消除了几项责任：使用什么具体实现，如何配置它以及如何管理其生命周期。这使我们可以轻松地在不同的上下文或测试中替换依赖关系，更改其生存期策略，例如使用共享或单独的实例，或更改依赖关系的构造方式。所有这些都无需改变其消费者。这使消费者不再依赖于它们，从而使它们更易于重用，扩展，开发和测试。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些模式的明显副作用是，现在我们代码的每个用户都需要提供其定义。但是他们如何得到它们？如果他们直接创建它们，那么它们将与那些依赖关系紧密地联系在一起。因此，我们只是将问题移到另一个地方。这个问题将我们带到了所谓的“合成根”（Compound Root）问题上。</p></br><h1 id="COMPOSITION-ROOT"><a href="#COMPOSITION-ROOT" class="headerlink" title="COMPOSITION ROOT"></a><strong>COMPOSITION ROOT</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>COMPOSITION ROOT</code> 是将应用程序不同层的组件连接在一起的地方。 拥有复合根的主要目的是将配置逻辑与我们其余的代码分开，并以通用的方式在定义明确的位置进行配置。 拥有一段代码，单个职责就是配置其他组件。 创建依赖关系并将其注入到构造函数或属性中只能在“合成根目录”中完成。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/di-stp1.png" alt="COMPOSITION ROOT"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 理想情况下，应用程序中应该有一个<code>COMPOSITION ROOT</code>，并且它应该靠近应用程序入口点。 就像这张图一样。 但是不必使用单个方法或类来实现。 它可以包含所需的多个类和方法，直到它们在同一组件层中在一起为止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是VIPER示例应用程序中 <code>COMPOSITION ROOT</code> 的示例实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDependencies</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        configureDependencies()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">configureDependencies</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Root Level Classes</span></span><br><span class="line">        <span class="keyword">let</span> coreDataStore = <span class="type">CoreDataStore</span>()</span><br><span class="line">        <span class="keyword">let</span> clock = <span class="type">DeviceClock</span>()</span><br><span class="line">        <span class="keyword">let</span> rootWireframe = <span class="type">RootWireframe</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// List Module Classes</span></span><br><span class="line">        <span class="keyword">let</span> listPresenter = <span class="type">ListPresenter</span>()</span><br><span class="line">        <span class="keyword">let</span> listDataManager = <span class="type">ListDataManager</span>()</span><br><span class="line">        <span class="keyword">let</span> listInteractor = <span class="type">ListInteractor</span>(dataManager: listDataManager, clock: clock)</span><br><span class="line">        ...    </span><br><span class="line">        listInteractor.output = listPresenter</span><br><span class="line">        listPresenter.listInteractor = listInteractor</span><br><span class="line">        listPresenter.listWireframe = listWireframe</span><br><span class="line">        listWireframe.addWireframe = addWireframe</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们有一些根类，仅管理窗口根视图控制器的根线框以及一些待办事项列表的单独组件，例如演示者，交互器，线框。 然后，我们将它们全部连接在一起。 它全部在一类中实现。 我们使用此类的唯一地方是应用程序委托：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> appDependencies = <span class="type">AppDependencies</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        application: UIApplication, </span></span></span><br><span class="line"><span class="function"><span class="params">        didFinishLaunchingWithOptions launchOptions: [NSObject : AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        appDependencies.installRootViewControllerIntoWindow(window!)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们首先创建依赖项类，它将配置所有组件并将它们连接在一起。 然后，我们只调用一个在窗口中设置根视图控制器的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，将通过一个调用在此处创建整个对象图，并且稍后将在运行时创建的唯一对象是视图控制器和视图。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，关于DI的文章或讨论中通常不会讨论不幸的成分根。 但这可能是依赖注入的最重要部分之一。 如果我们能够做到这一点，我们已经走了很长一段路。</p><blockquote><p>正确实现DI的最大挑战是将所有具有依赖项的类移至Composition Root。 - Mark Seeman</p></blockquote><h1 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a><strong>反模式</strong></h1><p>但是，由于在尝试正确实现某些模式时经常会发生这种情况，因此我们很容易以反模式结束。 因此，现在让我们进入黑暗的一面，看看什么是常见的DI反模式。</p><h1 id="控制怪胎"><a href="#控制怪胎" class="headerlink" title="控制怪胎"></a><strong>控制怪胎</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个是控制狂。 那就是当我们根本不使用DI的时候。 依赖项的使用者何时控制创建依赖项的方式和时间。 每当使用者在 <code>Composition Root</code> 之外的任何地方使用构造函数直接或间接获得依赖项时，都会发生这种情况。 例如，在其自己的构造函数中或仅在需要时使用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repository: <span class="type">RecipesRepository</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.repository = <span class="type">CoreDataRecipesRepository</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这是否意味着根本不允许我们使用构造函数？ 当然不是。 这取决于我们构建的依赖类型。</p><h1 id="稳定和波动的依赖"><a href="#稳定和波动的依赖" class="headerlink" title="稳定和波动的依赖"></a><strong>稳定和波动的依赖</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它们有两种-稳定的和易变的。当涉及到稳定的依赖关系时，我们不必担心直接在其使用者内部构造它们。但是我们应该避免对不稳定的依赖项这样做。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是易失性依赖项？需要某种特定环境设置（例如数据库或网络访问）的任何依赖项。实现不确定性行为的依赖项是易变的，例如，如果它们使用随机数，依赖于时间或实现加密，则它们是易变的。当我们期望依赖项将被替换或者由于它是并行开发而尚未准备就绪时，它也是易变的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;易失性依赖项的症状是它们禁用了一些宽松的耦合好处。如果依赖关系不允许我们并行测试，扩展，重用或开发我们的代码，则应将其视为易变的。否则，它是一个稳定的依赖项。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，首先，我们需要了解依赖项是易失性还是​​稳定的，并在其易失性时使用“依赖项注入”模式注入它。</p><h1 id="Bastard-注入"><a href="#Bastard-注入" class="headerlink" title="Bastard 注入"></a><strong>Bastard 注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一个反模式称为 <code>Bastard</code> 注入。 当我们有让我们为测试提供依赖关系的构造函数以及在生产中使用默认实现的另一个构造函数时，就会发生这种情况。 在 <code>Swift</code> 中，我们可以使用以下示例中的默认参数轻松地做到这一点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repository: <span class="type">RecipesRepository</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(repository: <span class="type">RecipesRepository</span> = <span class="type">CoreDataRecipesRepository</span>()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.repository = repository</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从某一方面来看，这种模式提高了可测试性。 这种反模式的问题是使用默认的外部默认值-在其他模块中定义。 这使我们的代码可测试，但与另一个模块紧密耦合。 如果默认实现是本地的，则此反模式的影响会小得多。 也许最好将其重构为属性注入。 但是，当默认实现是外部实现时，我们应该使用构造函数注入，并且不要为此参数提供默认值。 相反，我们应该在 <code>“Composition Root”</code> 中提供它。 这样我们就不会失去任何灵活性，而是避免与另一个模块紧密耦合。</p><h1 id="服务定位器"><a href="#服务定位器" class="headerlink" title="服务定位器"></a><strong>服务定位器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我要讨论的最后一个反模式是服务定位器。 服务定位器是某些服务的通用名称，我们可以查询以前在其中注册的不同对象。 这是最棘手的反模式，因为它可以使我们感到一切都很好。 许多开发人员甚至根本不认为它是反模式。 但是 <code>Service Locator</code> 实际上与依赖注入相反。</p><p>让我们看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locator = <span class="type">ServiceLocator</span>.sharedInstance</span><br><span class="line"></span><br><span class="line">locator.register( &#123; <span class="type">CoreDataRecipesRepository</span>() &#125;, </span><br><span class="line">                    forType: <span class="type">RecipesRepository</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> repository: <span class="type">RecipesRepository</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> locator = <span class="type">ServiceLocator</span>.sharedInstance</span><br><span class="line">        <span class="keyword">self</span>.repository = locator.resolve(<span class="type">RecipesRepository</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此示例中，我们提供了一些可以使用静态属性访问的服务。然后，对于我们的依赖关系类型，我们注册一个产生一些具体实例的工厂。然后，我们在需要时向此服务询问我们的依赖关系，而不是使用构造函数或属性注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;似乎 <code>Service Locator</code> 提供了依赖注入的所有好处。它提高了可扩展性和可测试性，因为我们可以注册依赖的另​​一种实现而无需更改其使用者。它将配置与使用分开，还支持并行开发。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是它没有几个主要缺点。它使依赖项隐式而不是显式，从而隐藏了真实类的复杂性。为了能够使用此类，我们现在需要了解其内部详细信息。我们没有看到它的依赖关系，只会在运行时或通过检查其实现或文档来找到它们的依赖关系。借助服务定位器，我们的代码也与之紧密结合。这完全破坏了可重用性，并使代码的可维护性降低。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于这些原因，我倾向于认为 <code>Service Locator</code> 是一种反模式。而不是使用它，我们应该显式定义依赖项，使用 <code>DI</code> 模式注入它们，并使用 <code>Composition Root</code> 将它们连接在一起。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，让我们总结一下到那时为止我们已经讨论过的内容。我们讨论了依赖注入用于实现松散耦合，这使我们的代码更易于维护。我们讨论了不同的 <code>DI</code> 模式，其中应该优先选择构造函数注入。我们讨论了什么是本地和外部依赖关系以及什么是稳定和易失性依赖关系。我们还讨论了应避免的常见 <code>DI</code> 反模式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这一点上，我们使用 <code>DI</code> 模式将依赖关系明确化，并将所有配置移到了 <code>Composition Root</code> 中，这已经是我们实现目标的一大步-松散耦合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们的代码还没有完全耦合。下一步是使用抽象对依赖关系进行建模。让我们记住 <code>SOLID</code> 原则之一。</p></br><h1 id="依赖反转原理（DIP）"><a href="#依赖反转原理（DIP）" class="headerlink" title="依赖反转原理（DIP）"></a><strong>依赖反转原理（DIP）</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖反转原则说，高级代码不应依赖于低级代码，它们都应依赖于抽象，而抽象不应依赖于细节。关键是该类及其依赖项应处于相同的抽象级别。如果我们有一些服务，它不应该依赖于具体的API存储库或数据库存储库，因为它们属于较低层。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，我们不应依赖通过 <code>Alamofire</code> 实现的 <code>API</code> 存储库或通过 <code>CoreData</code> 或 <code>Realm</code> 实现的数据库存储库。因为这将使我们的代码与特定的实现紧密结合。相反，我们应该依靠更高级别的抽象。服务和存储库都应依赖于该抽象。因此，较高和较低级别之间的依赖性方向是相反的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们应该遵循这一原则来松散耦合代码。依赖注入不仅是我们之前讨论的模式。它要求同时应用模式和依赖倒置原则。没有这些，我们将无法获得松耦合的所有好处。</p><blockquote><p><strong><em>DI = DI patterns + DIP</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常说，松散耦合是通过针对接口而不是针对实现进行编程来实现的。</p><blockquote><p><strong><em>编程到接口而不是实现（设计模式：可重用的面向对象软件的元素</em></strong>）</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是依赖倒置原则说它不是关于接口，而是关于抽象。 松耦合并不意味着到处都有接口或协议。 因为并非总是接口是好的和可重用的抽象。</p><blockquote><p><strong><em>编程为 <del>接口</del> 抽象</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口（或协议）只是一种我们可以用来对抽象进行建模的语言构造。 这是我们的代码与之通信的一种方式。 但这并不能保证良好和可重用的抽象，这是松散耦合的关键。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基类有时可以和协议一样好的抽象。 当然，大多数时候我们可能会使用协议对抽象进行建模。 但是在各处引入协议时要小心。 它可能是不需要的独立级别。 在Swift协议中，有时会比较麻烦。</p><blockquote><p><strong><em>Interfaces are not abstractions - Mark Seeman</em></strong> </p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/di-stp2.png" alt="Interfaces&amp;&amp;abstractions"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你在构造函数中传递依赖项或使用属性或方法注入时-您应将其作为抽象传递（同样，不必使用协议）。 如果使用 <code>ambinet</code>上下文，则相同。 它不仅是一些共享的静态实例，还应该是抽象的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，依赖注入和松散耦合不仅可以通过依赖注入模式来实现，而且可以通过依赖反转原理以及使用抽象对依赖关系进行建模来实现。</p></br><h1 id="控制和DI容器的反转"><a href="#控制和DI容器的反转" class="headerlink" title="控制和DI容器的反转"></a><strong>控制和DI容器的反转</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，使用另一种设计原则，我们还可以采取进一步的措施。该原理称为控制反转。通常将其视为框架的定义特征。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用库时，流程是“正常的”，我们从代码中调用库。但是在框架的情况下，它是倒置的-框架使用不同的回调方法调用我们的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并且我们可以将这一原理应用于使用特殊框架来管理依赖项。通常，这些框架称为依赖注入容器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有许多不同的容器可用。实际上，大多数人可能甚至不知道使用了一个DI容器。它是 <code>Interface Builder</code> 。在 <code>Interface Builder</code> 中，我们可以通过接口或基类使用 <code>@IBOutlet</code> 拖放任何 <code>NSObject</code> 并对其进行引用。与视图控制器相同。我们可以将情节提要和 <code>Xibs</code> 视为视图控制器的工厂。 <code>Interface Builder</code>是 <code>XML</code> 配置样式的示例。当然，它不是功能齐全的 <code>DI</code> 容器，也不是其主要目标，但仍然可以用于该目的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你访问 <code>CocoaPods</code> 并搜索“依赖注入”，则会发现很多不同的开源 <code>DI</code> 容器。也许甚至太多了。但是你会注意到，其中只有少数成功和流行。让我们简短地看一下其中的两个-一个来自 <code>Objective-C</code> ，另一个来自 <code>Swift</code> 。</p></br><h1 id="TYPHOON"><a href="#TYPHOON" class="headerlink" title="TYPHOON"></a><strong>TYPHOON</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个是 <strong><em><a href="http://typhoonframework.org" target="_blank" rel="noopener"><code>Typhoon</code></a></em></strong> ，它可能是 <code>Cocoa</code> 开发者中最受欢迎的DI容器。 它具有相对简单且文档齐全的 <code>API</code> ，具有许多强大的功能。 它得到了良好的维护和支持，并且仍将继续改进。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就 <code>API</code> <code>Typhoon</code> 而言，构件是称为程序集的对象。 这是此类装配接口的示例。 它看起来像一个简单的工厂。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIClientAssembly</span>: <span class="title">TyphoonAssembly</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">apiClient</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在实现中，不是返回某种类型的具体实例（如从工厂方法中返回），而是返回 <code>TyphoonDefinition</code> ，它描述了在请求实例时应如何创建该实例。 应该使用什么初始化以及使用什么参数，应该注入什么属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">apiClient</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">TyphoonDefinition</span>.withClass(<span class="type">APIClientImp</span>.<span class="keyword">self</span>) &#123; definition <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        definition.useInitializer(#selector(<span class="type">APIClientImp</span>.<span class="keyword">init</span>(session:))) &#123;</span><br><span class="line">            initializer <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            initializer.injectParameterWith(<span class="keyword">self</span>.session())</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        definition.injectProperty(<span class="string">"logger"</span>, with: <span class="keyword">self</span>.logger())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们定义 <code>API Client</code> 将使用 <code>init（session :)</code> 构造函数创建，并且其 <code>session</code> 参数将由同一程序集提供。 我们还定义了将由同样的程序集提供的 <code>logger</code> 实例注入 <code>logger</code> 属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以为组件定义不同的范围或生命周期策略。 例如，对于 <code>Singleton</code> 范围， <code>Typhoon</code> 将仅创建一个 <code>logger</code> 实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">TyphoonDefinition</span>.withClass(<span class="type">NSURLSession</span>.<span class="keyword">self</span>) &#123; definition <span class="keyword">in</span></span><br><span class="line">        definition.useInitializer(#selector(<span class="type">NSURLSession</span>.sharedSession))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">TyphoonDefinition</span>.withClass(<span class="type">ConsoleLogger</span>.<span class="keyword">self</span>) &#123; definition <span class="keyword">in</span></span><br><span class="line">        definition.scope = .<span class="type">Singleton</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要从程序集中获取某种类型的实例，我们首先将其激活，然后仅调用其接口方法。 激活后，组装方法将不返回 <code>TyphoonDefinitions</code> ，而是返回根据我们提供的规则创建的实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> assembly = <span class="type">APIClientAssembly</span>().activate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apiClient = assembly.apiClient() <span class="keyword">as</span>! <span class="type">APIClient</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了使这项工作有效， <code>Typhoon</code> 大量使用了 <code>Objective-C</code> 运行时。 <code>在使用Objective-C</code> 运行时的 <code>Swift</code> 应用程序中看起来并不正确。 我们仍然可以在 <code>Swift</code> 以及 <code>Objective-C</code> 中使用 <code>Typhoon</code> 。 但是，我们将面临一些问题：</p><ul><li>需要子类 <code>NSObject</code> 并使用 <code>@objc</code> 定义协议</li><li>注射过程中调用的方法应该是动态的</li><li>需要类型转换</li><li>并非所有功能都可以在 <code>Swift</code> 中使用</li><li><code>Swift</code> 的 <code>API</code> 太冗长</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Typhoon</code> 团队最近宣布，他们开始着手于纯粹的 <code>Swift</code> 实施，而我迫不及待地想看看他们会提出什么建议。 但是现在我不会在纯 <code>Swift</code> 代码库中以当前状态使用 <code>Typhoon</code> 。 尤其是当本机解决方案已经很少时。</p><h1 id="DIP"><a href="#DIP" class="headerlink" title="DIP"></a><strong>DIP</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em><a href="https://github.com/AliSoftware/Dip" target="_blank" rel="noopener"><code>Dip</code></a></em></strong> 是其中之一。 它仅在 <code>Swift</code> 中工作，根本不需要 <code>Objective-C</code> 运行时。 实际上，它甚至没有对 <code>Foundation</code> 的引用，因此我们可以在可以使用 <code>Swift</code> 的任何平台上使用它。 它也是类型安全的，与 <code>Typhoon</code> 相比实现起来并不复杂。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 就 <code>API</code> 而言，它采用的方法对于其他平台上的 <code>DI</code> 容器而言更为传统，并遵循“注册解析”模式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们用于 <code>Typhoon</code> 的相同示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="type">DependencyContainer</span>()</span><br><span class="line"></span><br><span class="line">container.register &#123; </span><br><span class="line">    <span class="keyword">try</span> <span class="type">APIClientImp</span>(session: container.resolve()) <span class="keyword">as</span> <span class="type">APIClient</span> </span><br><span class="line">&#125;</span><br><span class="line">.resolveDependencies &#123; container, client <span class="keyword">in</span></span><br><span class="line">    client.logger = <span class="keyword">try</span> container.resolve()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.register &#123; <span class="type">NSURLSession</span>.sharedSession() <span class="keyword">as</span> <span class="type">NetworkSession</span> &#125;</span><br><span class="line">container.register(.<span class="type">Singleton</span>) &#123; <span class="type">ConsoleLogger</span>() <span class="keyword">as</span> <span class="type">Logger</span> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们将 <code>APIClientImp</code> 注册为 <code>APIClient</code> 协议的实现。 容器还将解析构造器参数，并且在创建实例时将设置 <code>logger</code> 属性。 对于会话参数容器，它将使用共享的 <code>URL</code> 会话，对于记录器，它将创建一个单例实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，当我们需要获取 <code>APIClient</code> 的实例时，我们只需调用容器的 <code>resolve</code> 方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apiClient = <span class="keyword">try</span>! container.resolve() <span class="keyword">as</span> <span class="type">APIClient</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会注意到，该 <code>API</code> 与我们在 <code>Service Locator</code> 中看到的几乎相同。 但这与 <code>API</code> 或实现无关，而与我们如何使用它有关。 如果您不想将容器用作服务定位器，请记住，只能在 <code>“Composition Root”</code> 中调用它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Dip</code> 还提供了一些很酷的功能，例如自动接线。 例如，我们可以定义要自动注入的 <code>logger</code> 属性。 容器将首先创建 <code>APIClient</code> 实例，然后使用其镜像查找 <code>logger</code> 属性并将真实实例注入其中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIClientImp</span>: <span class="title">APIClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _logger = <span class="type">Injected</span>&lt;<span class="type">Logger</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> logger: <span class="type">Logger?</span> &#123; <span class="keyword">return</span> _logger.value &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，当我们使用其构造函数注册 <code>APIClient</code> 而不是调用 <code>resolve</code> 获取 <code>NetworkSession</code> 参数时，我们只是说我们要使用传递给工厂闭包的第一个参数。 然后容器将推断出它的类型并为我们解决。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIClientImp</span>: <span class="title">APIClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">NetworkSession</span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.register &#123; <span class="type">APIClientImp</span>(session: $<span class="number">0</span>) <span class="keyword">as</span> <span class="type">APIClient</span> &#125;</span><br></pre></td></tr></table></figure><p>这样可以大大简化配置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们比较 <code>“Typhoon”</code> 和 <code>“Dip”</code> 的基本特征，我们会注意到它们共享大多数特征。 尽管它没有像 <code>Objective-C</code> 一样强大的运行时功能，但是在 <code>Swift</code> 中几乎可以实现相同的功能似乎令人惊讶。 但是，泛型和类型推断实际上是其中的重点。</p><table><thead><tr><th align="left"></th><th align="center">Typhoon</th><th align="right">Dip</th></tr></thead><tbody><tr><td align="left"><strong>Constructor, property, method injection</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Lifecycle management</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Circular dependencies</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Runtime arguments</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Named definitions</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Storyboards integration</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Auto-wiring</strong></td><td align="center">✔︎</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Thread safety</strong></td><td align="center">✘</td><td align="right">✔︎</td></tr><tr><td align="left"><strong>Interception</strong></td><td align="center">✔︎</td><td align="right">✘</td></tr><tr><td align="left"><strong>Infrastructure</strong></td><td align="center">✔︎</td><td align="right">✘</td></tr></tbody></table></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会问，当我自己可以做时，为什么需要使用 <code>Typhoon</code> 或 <code>Dip</code> 或任何其他 <code>DI</code> 容器。 我可以建议的理由很少。 它们提供了与情节提要板的轻松集成，可以为您管理有时可能很棘手的组件生命周期，可以简化某些配置， <code>Typhoon</code> 还使用 <code>NSProxy</code> 和其他一些附加功能提供了轻松的拦截功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是请记住， <code>DI</code> 容器是可选的，并且依赖注入与使用 <code>DI</code> 容器不同。</p><blockquote><p><strong><em>DI ≠ DI Container</em></strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在新项目中，我们可以根据需要从它开始，但是在旧代码库中，我们应该首先使用依赖注入模式，组合根和依赖反转原理对其进行重构，然后查看是否需要DI容器（在大多数情况下，回答将为“否”）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您具有复杂的配置，并且发现自己实现了一些类似 <code>DI</code> 容器的方法来简化它们，或者需要它提供的一些其他功能，那么可能会受益于使用现有的实现。但是，如果您对自己的工厂还可以的话-它的工厂很棒，请继续使用它们。不要仅仅为了使用 <code>DI</code> 容器而使用它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DI</code> 本身也是如此。对于在何处应用它以及需要解耦系统的哪些部分，要保持理性。不要尝试解决你尚未遇到的问题。也许你永远不会拥有它们，或者当你真正面对它们时，现在解决它们的方式将不合适。最后， <code>DI</code> 只是达到目的的一种手段，就像我们使用的任何其他模式或技术一样。它本身不是目标。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我想提到一些有用的资源，你可以在其中找到有关DI和一些相关主题的更多信息。</p></br><ul><li><a href="https://www.manning.com/books/dependency-injection-in-dot-net" target="_blank" rel="noopener"><code>“Dependency Injection in .Net” by Mark Seeman</code></a></li><li><a href="https://ilya.puchka.me/dependency-injection-in-swift/" target="_blank" rel="noopener"><code>Mark Seeman’s blog</code></a></li><li><a href="https://www.objc.io/issues/15-testing/dependency-injection/" target="_blank" rel="noopener"><code>objc.io Issue 15: Testing. Dependency Injection, by Jon Reid</code></a></li><li><a href="https://martinfowler.com/articles/dipInTheWild.html" target="_blank" rel="noopener"><code>“DIP in the wild”</code></a></li><li><a href="http://www.loosecouplings.com/2011/02/non-di-code-spaghetti-code.html" target="_blank" rel="noopener"><code>Non-DI code == spaghetti code?</code></a></li></ul><hr><hr><ul><li><p><a href="https://www.manning.com/books/dependency-injection-in-dot-net" target="_blank" rel="noopener"><code>&quot;Dependency Injection in .Net&quot; Mark Seeman</code></a> ↩︎</p></li><li><p><a href="https://github.com/mutualmobile/VIPER-SWIFT/blob/master/VIPER-SWIFT/Classes/AppDependencies.swift" target="_blank" rel="noopener"><code>https://github.com/mutualmobile/VIPER-SWIFT/blob/master/VIPER-SWIFT/Classes/AppDependencies.swift</code></a> ↩︎</p></li><li><p><a href="http://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/" target="_blank" rel="noopener"><code>http://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/</code></a> ↩︎</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 依赖注入设计模式 </tag>
            
            <tag> Dependency Injection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift依赖注入设计模式</title>
      <link href="/Swift%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用Swift学习依赖注入模式,使用DI编写松耦合代码。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我真的很喜欢James Shore的这句话：依赖注入意味着给对象一个实例变量，如此而已。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我看来，学习依赖注入要稍微复杂一点，但是如果你将问题弄清楚，你将意识到实现 <a href="http://www.xuebaonline.com/Swift%E5%85%B3%E4%BA%8EDependency%20Injection%20(DI)/" title="DI模式">DI模式</a> 就像给对象实例变量一样简单。 别开玩笑，这确实是理所当然的，但是许多开发人员使它过于复杂，并在错误的位置使用了注入。 💉</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习DI并不是关于实现细节，而是关于你将如何使用该模式。 依赖项注入有四个小变化，让我们通过使用真实的示例进行遍历，这些示例将帮助你了解何时使用依赖项注入。 现在抓住键盘！ 💻</p><a id="more"></a></br><h1 id="了解依赖注入-dependency-injection"><a href="#了解依赖注入-dependency-injection" class="headerlink" title="了解依赖注入(dependency injection)"></a><strong>了解依赖注入(dependency injection)</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如我之前提到的，DI是一个简单概念，你实际上并不需要外部库或框架来开始使用它。假设你有两个单独的对象。对象A要使用对象B。向你的第一个依赖发送一个消息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果将对象B硬编码为对象A，那将是不好的，因为从那时起，如果没有B，就无法使用A。现在将其扩展到约100个对象级别。如果你对此问题不采取任何措施，那么你会毫无头绪。 🍝</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，主要目标是创建尽可能多的独立对象，或者创建一些松散耦合的代码，以提高可重用性和可测试性。关注分离和去耦也是在这里使用，因为在大多数情况下，你应该从字面上将逻辑功能分离为独立的对象。 🤐</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，从理论上讲，两个对象都应该只做一件特定的事情，并且它们之间的依赖关系通常是通过通用描述符（协议）实现的，而无需对具体实例进行硬编码。为此，使用依赖注入可以提高代码质量，因为可以在不更改其他对象实现的情况下替换依赖。这对于模拟，测试，重用等很有用。</p></br><h1 id="如何在Swift中进行DI？"><a href="#如何在Swift中进行DI？" class="headerlink" title="如何在Swift中进行DI？"></a><strong>如何在Swift中进行DI？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Swift</code> 是一种了不起的编程语言，对协议和面向对象的原理都提供了出色的支持。 它也具有强大的功能，但是现在让我们忽略它。 依赖关系注入可以通过多种方式完成，但是在本教程中，我将只关注一些基本的，没有任何外部依赖关系注入的基础知识。 😂</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，让我们从一个协议开始，但这只是因为 <code>Swift</code> 不会向公众公开 <code>Encoder</code> ，但是我们在演示中需要类似的东西。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Encoder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span>&lt;T&gt;<span class="params">(<span class="number">_</span> value: T)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Encodable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">JSONEncoder</span>: <span class="title">Encoder</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PropertyListEncoder</span>: <span class="title">Encoder</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性列表和JSON编码器已经实现了此方法，我们只需要扩展对象以符合我们的全新协议即可。</p><h1 id="Custructor-注入"><a href="#Custructor-注入" class="headerlink" title="Custructor 注入"></a><strong>Custructor 注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖项注入的最常见形式是构造函数注入或基于初始化的注入。 主要的思路是通过初始化程序传递依赖关系，并将该对象存储在（私有只读/不可变）属性变量中。 这里的主要好处是，在对象创建之前，你的对象将具有所有依赖关系，以使其正常工作。 🔨</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> encoder: <span class="type">Encoder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> title</span><br><span class="line">        <span class="keyword">case</span> content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>, encoder: <span class="type">Encoder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">        <span class="keyword">self</span>.encoder = encoder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encoded</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Constructor injection"</span>, encoder: <span class="type">JSONEncoder</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encoded(), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你也可以在构造函数中为编码器指定一个 <code>defult</code> 值，但是你应该担心恶意注入反模式！ 这意味着如果默认值来自另一个模块，则你的代码将与该模块紧密耦合。 所以请三思！ 🤔</p></br><h1 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a><strong>属性注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时很难进行初始化初始化注入，因为你的类必须从系统类继承。 如果你必须使用视图或控制器，这将使过程变得非常困难。 对于这种情况，一个好的解决方案是使用基于属性的注入设计模式。 也许你不能完全控制初始化，但是你始终可以控制属性。 唯一的缺点是，你必须先检查该属性是否已显示（已设置），然后再进行任何操作。 🤫</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> encoder: <span class="type">Encoder?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> title</span><br><span class="line">        <span class="keyword">case</span> content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encoded</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> encoder = <span class="keyword">self</span>.encoder <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Encoding is only supported with a valid encoder object."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Property injection"</span>)</span><br><span class="line">post.encoder = <span class="type">JSONEncoder</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encoded(), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>iOS</code> 框架中有很多属性注入模式，委托模式通常是这样实现的。 另外一个很大的好处是这些属性可以是可变的，因此你可以即时替换它们。 ✈️</p><h1 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a><strong>方法注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果只需要一次依赖关系，则实际上不需要将其存储为对象变量。 除了可以使用初始化参数或公开的可变属性，你还可以将依赖项作为方法参数传递，这种方法称为方法注入或基于参数的注入。 👍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(using encoder: Encoder)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Method injection"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encode(using: <span class="type">JSONEncoder</span>()), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次调用此方法时，你的依赖关系可能会有所不同，不需要从该依赖关系中保留引用，因此将仅在本地方法范围内使用它。</p></br><h1 id="上下文语境"><a href="#上下文语境" class="headerlink" title="上下文语境"></a><strong>上下文语境</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的最后一个模式非常危险。 它仅应用于与多个对象实例一起共享的通用依赖项。 日志，分析或缓存机制就是一个很好的例子。 🚧</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encoded</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">Post</span>.encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> _encoder: <span class="type">Encoder</span> = <span class="type">PropertyListEncoder</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setEncoder</span><span class="params">(<span class="number">_</span> encoder: Encoder)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._encoder = encoder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> encoder: <span class="type">Encoder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Post</span>._encoder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> post = <span class="type">Post</span>(title: <span class="string">"Hello DI!"</span>, content: <span class="string">"Ambient context"</span>)</span><br><span class="line"><span class="type">Post</span>.setEncoder(<span class="type">JSONEncoder</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? post.encoded(), <span class="keyword">let</span> encoded = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上下文语境有一些缺点。 它可能很适合横切关注点，但会创建隐式依赖关系并表示全局可变状态。 强烈不建议这样做，你应该首先考虑其他依赖注入方式，但是有时它可能非常适合你。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 依赖注入设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift委托设计模式</title>
      <link href="/Swift%E5%A7%94%E6%89%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%A7%94%E6%89%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;委托设计模式是通过 <code>Swift</code> 中的通用接口（协议）在两个对象之间进行通信的相对简单的方法。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="委托模式">委托模式</a>（delegation pattern）是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承。</p><a id="more"></a></br><h1 id="在Swift中实现委派"><a href="#在Swift中实现委派" class="headerlink" title="在Swift中实现委派"></a><strong>在Swift中实现委派</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你将需要一个委托协议，一个实际委托任务的委托人以及一个实现委托协议并完成 <strong>“老板”</strong> 所要求的实际工作的委托对象。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：客户端报告一个错误。 项目经理会创建一个问题，并告诉一位开发人员尽快解决问题。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的场景就是委托👆。 在某个时刻发生了事件，因此委托人（经理）使用外部资源（开发人员）使用一个公共接口（描述双方的问题）来完成某件事（修复🐛）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了演示委托在现实生活中的工作方式，我举了一个非常简单的例子。 我将使用类似的方法（因为Xcode游乐场仍然每1-5分钟冻结一次），就像我对命令模式所做的那样，但是此方法的目的几乎是完全不同的，因为我们正在谈论委托模式。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env swift</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InputDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldContinueListening: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didStartListening</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(input: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> delegate: <span class="type">InputDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate?.didStartListening()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> input = <span class="built_in">readLine</span>() <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.delegate?.didReceive(input: input)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.delegate?.shouldContinueListening ?? <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputReceiver</span>: <span class="title">InputDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldContinueListening: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didStartListening</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"👻 Please be nice and say \"hi\", if you want to leave just tell me \"bye\":"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(input: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> input &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"hi"</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"🌎 Hello world!"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"bye"</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"👋 Bye!"</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"🔍 Command not found! Please try again:"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inputHandler = <span class="type">InputHandler</span>()</span><br><span class="line"><span class="keyword">let</span> inputReceiver = <span class="type">InputReceiver</span>()</span><br><span class="line">inputHandler.delegate = inputReceiver</span><br><span class="line">inputHandler.listen()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是你可以在 <code>Swift</code> 中创建自己的委托模式的方式。 你可以想象，<code>Apple</code> 正在使用 <code>UICollectionViewDataSource</code> ，<code>UICollectionViewDelegate</code> 等在后台做同样的事情。你只需实现委托，它们将提供协议和委托人。 🤔</p></br><h1 id="弱属性，委托和类"><a href="#弱属性，委托和类" class="headerlink" title="弱属性，委托和类"></a><strong>弱属性，委托和类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存管理是非常重要的事情，因此值得一提的是，所有的类委托都应该是 <strong>弱引用</strong>，否则你将 <strong>很难管理器生命周期，易引起内存泄露</strong>，这一点必须注意。 😱</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InputDelegate</span>: <span class="title">class</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">InputDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputReceiver</span>: <span class="title">InputDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是修改后的 <code>Swift</code> 代码段，但是现在使用一个类作为委托。 你只需要稍微更改协议和委托者内部的属性即可。 如果要将类分配为委托，请始终使用弱引用该变量。 ⚠️</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如代码中展示的，委托模式很容易，但是很危险。 它通过提供可以由实现委托（有时是数据源）协议的任何人使用的公共接口来帮助解耦。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 委托设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift命令设计模式</title>
      <link href="/Swift%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%91%BD%E4%BB%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令设计模式是众多设计模式中的一种，也比较常用。 这是用Swift编写的命令设计模板的一个小例子。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="命令模式">命令模式</a>（英语：Command pattern）是一种设计模式，它尝试以对象来代表实际行动。命令对象可以把行动(action) 及其参数封装起来，于是这些行动可以被：</p><ul><li>重复多次</li><li>取消（如果该对象有实现的话）</li><li>取消后又再重做</li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些都是现代大型应用程序所必须的功能，即“撤销”及“重复”。除此之外，可以用命令模式来实现的功能例子还有：</p><ul><li>交易行为</li><li>进度列</li><li>向导</li><li>用户界面按钮及功能表项目</li><li>线程 pool</li><li>宏收录</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想为稍后将要执行的不同操作提供一个通用界面，那么该命令模式将非常方便。 通常，它是一个对象，其中包含正确运行基础操作所需的所有信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令通常用于处理用户界面操作，创建撤消管理器或管理事务。 让我们通过使用表情符号创建命令行参数处理程序来查看 <code>Swift</code> 中的命令模式实现。 💾</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env swift</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelpCommand</span>: <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Help</span>().info()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Help</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">info</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">             🤖 Commander 🤖</span></span><br><span class="line"><span class="string">                  v1.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Available commands:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            👉 help      This command</span></span><br><span class="line"><span class="string">            👉 ls        List documents</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Bye! 👋</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListCommand</span>: <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">List</span>().homeDirectoryContents()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">homeDirectoryContents</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> documentsURL = fileManager.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask).first <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Could not open documents directory"</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> fileURLs = <span class="keyword">try</span> fileManager.contentsOfDirectory(at: documentsURL, includingPropertiesForKeys: <span class="literal">nil</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\n\t📁 Listing documents directory:\n"</span>)</span><br><span class="line">            <span class="built_in">print</span>(fileURLs.<span class="built_in">map</span> &#123; <span class="string">"\t\t💾 "</span> + $<span class="number">0</span>.lastPathComponent &#125;.joined(separator: <span class="string">"\n\n"</span>) + <span class="string">"\n"</span> )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> commands: [<span class="type">String</span>:<span class="type">Command</span>] = [:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.commands[<span class="string">"help"</span>] = <span class="type">HelpCommand</span>()</span><br><span class="line">        <span class="keyword">self</span>.commands[<span class="string">"ls"</span>] = <span class="type">ListCommand</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arguments = <span class="type">CommandLine</span>.arguments[<span class="number">1</span>...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> key = arguments.first, <span class="keyword">self</span>.commands[key] != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Usage: ./command.swift [\(self.commands.keys.joined(separator: "</span>|<span class="string">"))]"</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.commands[key]!.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">App</span>().run()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果保存此文件，只需在终端窗口中键入 <code>./file-name.swift</code> 即可运行它。 <code>Swift</code> 编译器将负责其余的工作。 ⚒</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令设计模式的实际用例：</p><ul><li>各种按钮动作</li><li>集合/表视图选择操作</li><li>在控制器之间导航</li><li>历史记录管理/撤消管理器</li><li>交易行为</li><li>进度管理</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如你所了解那样，该模式可以应用于多个区域。 苹果为此专门制作了一个名为 <code>NSInvocation</code> 的特定类，但不幸的是，由于它的动态行为，它在 <code>Swift</code> 中不可用。 没什么大不了的，你始终可以制定自己的协议和实现，在大多数情况下，你只需要一个包装基础命令逻辑的额外类即可。 😛</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 命令设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift原型设计模式</title>
      <link href="/Swift%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型设计模式用于创建基础对象的克隆，因此让我们看一些用Swift编写的实际示例。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式是 <a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="创建型模式">创建型模式</a> 的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这也是一种创新的设计模式，当你对一个对象进行非常基本的配置并且想要将这些预定义值提供（复制）给另一个对象时，这很有用。 基本上，你是从原型对象制作复制。 😊😊😊</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法有一些好处，例如，你不必继承子类，但可以单独配置复制。 这也意味着，如果你要使用原型，则可以删除一堆样板代码（配置）。 🤔</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paragraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> font: <span class="type">UIFont</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(font: <span class="type">UIFont</span> = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>),</span><br><span class="line">         color: <span class="type">UIColor</span> = .darkText,</span><br><span class="line">         text: <span class="type">String</span> = <span class="string">""</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = font</span><br><span class="line">        <span class="keyword">self</span>.color = color</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clone</span><span class="params">()</span></span> -&gt; <span class="type">Paragraph</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Paragraph</span>(font: <span class="keyword">self</span>.font, color: <span class="keyword">self</span>.color, text: <span class="keyword">self</span>.text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> base = <span class="type">Paragraph</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = base.clone()</span><br><span class="line">title.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">title.text = <span class="string">"This is the title"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = base.clone()</span><br><span class="line">first.text = <span class="string">"This is the first paragraph"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> second = base.clone()</span><br><span class="line">second.text = <span class="string">"This is the second paragraph"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上面的代码所示，实现只是几行代码。 你只需要一个默认的初始化程序和一个复制方法。 一切都将在 <code>init</code> 方法中针对原型对象进行预配置，并且你可以使用 <code>clone</code> 方法进行复制，但这时很明显……</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们再看一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paragraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> font: <span class="type">UIFont</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(font: <span class="type">UIFont</span> = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>),</span><br><span class="line">         color: <span class="type">UIColor</span> = .darkText,</span><br><span class="line">         text: <span class="type">String</span> = <span class="string">""</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.font = font</span><br><span class="line">        <span class="keyword">self</span>.color = color</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clone</span><span class="params">()</span></span> -&gt; <span class="type">Paragraph</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Paragraph</span>(font: <span class="keyword">self</span>.font, color: <span class="keyword">self</span>.color, text: <span class="keyword">self</span>.text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> base = <span class="type">Paragraph</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = base.clone()</span><br><span class="line">title.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">18</span>)</span><br><span class="line">title.text = <span class="string">"This is the title"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = base.clone()</span><br><span class="line">first.text = <span class="string">"This is the first paragraph"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> second = base.clone()</span><br><span class="line">second.text = <span class="string">"This is the second paragraph"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你打算获取已知对象状态的快照，则原型设计模式也很有用。 例如，在绘图应用程序中，你可以将形状类作为原型，可以开始向其添加路径，有时甚至可以从中创建快照。 你可以继续处理新对象，但这将使你能够在将来的任何时间返回到保存状态。 🎉</p><p>当你的应用程序不依赖于创建，合成和表示对象的方法时，应考虑选择它，以及至少下列各项之一：</p><ul><li>在运行时创建对象</li><li>你想避免工厂的复杂层次结构</li><li>对象只能有很少的状态</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，就是 <code>Swift</code> 中的原型设计模式。 🐿</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 原型设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比较工厂设计模式</title>
      <link href="/%E6%AF%94%E8%BE%83%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/%E6%AF%94%E8%BE%83%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用Swift语言了解静态工厂，简单工厂，工厂方法和抽象工厂之间的区别。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我认为对所有工厂模式进行汇总比较会很高兴，所以这里是你应该了解的所有内容。 构造它们相对简单，在本示例中，我将使用一些用 <code>Swift</code> 编程语言编写的 <code>UIColor</code> 来向你展示基础知识。 🧙‍♂️</p><a id="more"></a><h1 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a><strong>静态工厂</strong></h1><ul><li>没有单独的工厂类别</li><li>命名静态方法来初始化对象</li><li>可以具有缓存并可以返回子类型</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> primary: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> .black &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> secondary: <span class="type">UIColor</span> &#123; <span class="keyword">return</span> .white &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> primary = <span class="type">UIColor</span>.primary</span><br><span class="line"><span class="keyword">let</span> secondary = <span class="type">UIColor</span>.secondary</span><br></pre></td></tr></table></figure><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a><strong>简单工厂</strong></h1><ul><li>一个工厂类</li><li>枚举( <code>switch-case</code> )出其中的实例对象</li><li>封装各种代码</li><li>如果列表太大，请使用工厂方法</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> primary</span><br><span class="line">        <span class="keyword">case</span> secondary</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> style: Style)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style</span><br><span class="line">        <span class="keyword">case</span> .primary:</span><br><span class="line">            <span class="keyword">return</span> .black</span><br><span class="line">        <span class="keyword">case</span> .secondary:</span><br><span class="line">            <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primary = factory.create(.primary)</span><br><span class="line"><span class="keyword">let</span> secondary = factory.create(.secondary)</span><br></pre></td></tr></table></figure><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong>工厂方法</strong></h1><ul><li>多个（解耦的）工厂类</li><li>每个实例的工厂方法</li><li>为工厂创建一个简单的协议</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .black</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> primaryColorFactory = <span class="type">PrimaryColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> secondaryColorFactory = <span class="type">SecondaryColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primary = primaryColorFactory.create()</span><br><span class="line"><span class="keyword">let</span> secondary = secondaryColorFactory.create()</span><br></pre></td></tr></table></figure><h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a><strong>抽象工厂</strong></h1><ul><li>结合简单的工厂和工厂方法</li><li>对整个应用程序具有全局作用</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exact same factory method pattern from above</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .black</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondaryColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple factory pattern from above using the factory methods</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppColorFactory</span>: <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> dark</span><br><span class="line">        <span class="keyword">case</span> light</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> theme: Theme)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> theme &#123;</span><br><span class="line">        <span class="keyword">case</span> .dark:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">PrimaryColorFactory</span>().create()</span><br><span class="line">        <span class="keyword">case</span> .light:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">SecondaryColorFactory</span>().create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">AppColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> primaryColor = factory.create(.dark)</span><br><span class="line"><span class="keyword">let</span> secondaryColor = factory.create(.light)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，所有这些都是使用 <code>Swift</code> 编写的实际示例的工厂模式。 👍</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 工厂设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift抽象工厂设计模式</title>
      <link href="/Swift%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们将工厂方法与简单的工厂外观结合起来：这是用Swift语言编写的抽象工厂设计模式！</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82" target="_blank" rel="noopener" title="抽象工厂模式">抽象工厂模式</a>（英语：Abstract factory pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举个例子来说，比如一个抽象工厂类叫做DocumentCreator（文档创建器），此类提供创建若干种产品的接口，包括createLetter()（创建信件）和createResume()（创建简历）。其中，createLetter()返回一个Letter（信件），createResume()返回一个Resume（简历）。系统中还有一些DocumentCreator的具体实现类，包括FancyDocumentCreator和ModernDocumentCreator。这两个类对DocumentCreator的两个方法分别有不同的实现，用来创建不同的“信件”和“简历”（用FancyDocumentCreator的实例可以创建FancyLetter和FancyResume，用ModernDocumentCreator的实例可以创建ModernLetter和ModernResume）。这些具体的“信件”和“简历”类均继承自抽象类，即Letter和Resume类。客户端需要创建“信件”或“简历”时，先要得到一个合适的DocumentCreator实例，然后调用它的方法。一个工厂中创建的每个对象都是同一个主题的（“fancy”或者“modern”）。客户端程序只需要知道得到的对象是“信件”或者“简历”，而不需要知道具体的主题，因此客户端程序从抽象工厂DocumentCreator中得到了Letter或Resume类的引用，而不是具体类的对象引用。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“工厂”是创建产品（对象）的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够抵消这样的“额外工作”。</p></blockquote><h1 id="Swift抽象工厂"><a href="#Swift抽象工厂" class="headerlink" title="Swift抽象工厂"></a><strong>Swift抽象工厂</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂模式提供了一种封装一组具有共同主题的单个工厂而无需指定其具体类的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，抽象工厂可以为你创建相关对象的族。 该实现通常结合简单的工厂和工厂方法原理。 单个对象是通过工厂方法创建的，而整个对象都包装在一个“抽象”的简单工厂中。 现在检查代码！ 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service protocols</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StagingService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://dev.localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StagingServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">StagingService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// production</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://live.localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProductionService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// abstract factory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Environment</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> production</span><br><span class="line">        <span class="keyword">case</span> staging</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> env: <span class="type">Environment</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(env: <span class="type">Environment</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.env = env</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>.env &#123;</span><br><span class="line">        <span class="keyword">case</span> .production:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ProductionServiceFactory</span>().create()</span><br><span class="line">        <span class="keyword">case</span> .staging:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">StagingServiceFactory</span>().create()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">AppServiceFactory</span>(env: .production)</span><br><span class="line"><span class="keyword">let</span> service = factory.create()</span><br><span class="line"><span class="built_in">print</span>(service.url)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上代码看到的，使用抽象工厂将影响整个应用程序逻辑，而工厂方法仅对本地部分产生影响。 实现可能会有所不同，例如你也可以为抽象工厂创建一个独立的协议，但是在此示例中，我想使事情尽可能简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂通常用于实现对象独立性。 例如，如果你使用通用接口用 <code>Swift</code> 编写了多个不同的 <code>SQL</code> 数据库连接器（ <code>PostgreSQL</code> ，<code>MySQL</code> 等），则可以随时使用此模式在它们之间轻松切换。 可以将类似的逻辑应用于具有类似情况的业务。 🤔</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 抽象工厂设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift工厂方法设计模式</title>
      <link href="/Swift%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法设计模式是一种专用的非静态方法，用于隐藏对象的创建逻辑。 让我们用Swift做吧！</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p><a id="more"></a><h1 id="工厂方法只是一种非静态方法"><a href="#工厂方法只是一种非静态方法" class="headerlink" title="工厂方法只是一种非静态方法"></a><strong>工厂方法只是一种非静态方法</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面对现实，这种模式只是通常由简单协议和类支持的一种方法。 从一个非常简单的示例开始：想象一个可以为您的服务端点创建基本URL的类。 我们称之为服务工厂。 😅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createProductionUrl</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ServiceFactory</span>()</span><br><span class="line">factory.createProductionUrl()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会想，这甚至不接近工厂方法模式，但请稍候…让我们通过为服务类创建协议以及返回 <code>URL</code> 的协议，使事情变得有些复杂。 现在，我们可以将基本生产环境url协议实现为一个单独的类，并从生产服务工厂类返回该特定实例。 只需检查一下代码即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionService</span>: <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)! &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionServiceFactory</span>: <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProductionService</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ProductionServiceFactory</span>()</span><br><span class="line"><span class="keyword">let</span> request = factory.create()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么我们将所有逻辑分为两类和协议？ 请相信我去耦是一件好事。 从现在开始，你可以轻松编写带有虚拟 <code>url</code> 的模拟服务。 显然，这需要一个匹配的工厂类。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些模拟实例还将实现服务协议，因此你可以以相对轻松的方式添加新类型，而无需更改原始代码库。 工厂方法解决了简单工厂模式的一个特定问题。 如果列表（ <code>switch-case</code> 的列表）太长，那么只有一个工厂就很难维护新对象。 工厂方法通过引入多个工厂对象来解决此问题。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 工厂方法设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中快速简单的工厂设计模式</title>
      <link href="/Swift%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次，我们来讨论简单的工厂设计模式，该模式使用Swift以一种非常简单的方式封装对象创建。</p></blockquote><h1 id="使用-switch-case-实现简单的工厂模式"><a href="#使用-switch-case-实现简单的工厂模式" class="headerlink" title="使用 switch-case 实现简单的工厂模式"></a><strong>使用 switch-case 实现简单的工厂模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式的目标是封装一些经常变化的东西。 想象一下应用程序的调色板。 你可能必须每天根据设计师的最新习惯来更改颜色。 如果你不得不手动搜索和替换每个单独的颜色代码实例，那将给你带来极大的不便。 因此，让我们在Swift中创建一个简单的工厂，该工厂可以根据给定的样式返回颜色。 🎩</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> text</span><br><span class="line">        <span class="keyword">case</span> background</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> style: Style)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style &#123;</span><br><span class="line">        <span class="keyword">case</span> .text:</span><br><span class="line">            <span class="keyword">return</span> .black</span><br><span class="line">        <span class="keyword">case</span> .background:</span><br><span class="line">            <span class="keyword">return</span> .white</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">ColorFactory</span>()</span><br><span class="line"><span class="keyword">let</span> textColor = factory.create(.text)</span><br><span class="line"><span class="keyword">let</span> backgroundColor = factory.create(.background)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这真的很有用，尤其是涉及复杂的对象初始化过程时。 您还可以定义一个协议，并使用 <code>switch-case</code> 块返回实现所需接口的各种实例类型。 🚦</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevEnvironment</span>: <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"dev"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiveEnvironment</span>: <span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"live"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnvironmentFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> dev</span><br><span class="line">        <span class="keyword">case</span> live</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> type: EnvType)</span></span> -&gt; <span class="type">Environment</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> type &#123;</span><br><span class="line">        <span class="keyword">case</span> .dev:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">DevEnvironment</span>()</span><br><span class="line">        <span class="keyword">case</span> .live:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">LiveEnvironment</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factory = <span class="type">EnvironmentFactory</span>()</span><br><span class="line"><span class="keyword">let</span> dev = factory.create(.dev)</span><br><span class="line"><span class="built_in">print</span>(dev.identifier)</span><br></pre></td></tr></table></figure><p>因此，有关简单工厂设计模式的几件事要记住：</p><ul><li>通过分离初始化和使用逻辑，有助于松耦合</li><li>它只是包装可以经常更改的东西的包装器</li><li>可以使用枚举和开关盒在Swift中实现简单的工厂</li><li>如果您计划返回不同的对象（POP🎉），请使用协议</li><li>保持简单🏭</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式将创建与实际用法分开，并将职责移至特定角色，因此，如果发生某些变化，你只需要修改工厂即可。 你可以保留所有测试，而其他所有功能则完全不受影响。 强大而简单！ 💪</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 工厂模式 </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 静态工厂方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中构造函数与静态工厂方法的比较</title>
      <link href="/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当实例化对象时，哪个更好：构造函数还是静态工厂方法？ 我们来看一看。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我相信Joshua Bloch 在他的非常不错的书 《Effective Java》 中首先说了它：与构造函数相比，静态工厂方法是实例化对象的首选方法。 我不同意。 不仅因为我相信静态方法是纯粹的邪恶，而且主要是因为在这种特殊情况下，它们形成好的方法，使我们认为我们必须偏向使用它们。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们从面向对象的角度分析推理并弄清楚其原因。这是一个具有一个主要构造函数和两个次要构造函数的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">Color</span>(<span class="type">String</span> rgb) &#123;</span><br><span class="line">        this(<span class="type">Integer</span>.parseInt(rgb, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Color</span>(int red, int green, int blue) &#123;</span><br><span class="line">        this(red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是带有三个静态工厂方法的类似类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromRGB(<span class="type">String</span> rgb) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(<span class="type">Integer</span>.parseInt(rgb, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromPalette(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromHex(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你更喜欢哪一个？</p><p>根据Joshua Bloch的说法，使用静态工厂方法而不是构造函数具有三个基本优点（实际上有四个优点，但是第四个不再适用于Java）：</p><ul><li>他们有名字。</li><li>他们可以缓存。</li><li>它们可以是子类型。</li></ul><p>我认为，如果设计错误，那么这三者都是很合理的。 它们是解决问题的好办法。 让我们一一介绍。</p><h1 id="命名存在"><a href="#命名存在" class="headerlink" title="命名存在"></a><strong>命名存在</strong></h1><p>这是使用构造函数制作 <code>red tomato</code> 颜色对象的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>这是使用静态工厂方法的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>makeFromPalette（）</code> 在语义上比新的 <code>Color（）</code> 更丰富。 如果我们将它们传递给构造函数，谁知道这三个数字意味着什么。 但是“palette”可以帮助我们立即解决所有问题。</p><p>但是，正确的解决方案是使用多态和封装，以将问题分解为几个语义丰富的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="type">Color</span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HexColor</span> <span class="title">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">HexColor</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RGBColor</span> <span class="title">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Color</span> origin;</span><br><span class="line">    <span class="type">RGBColor</span>(int red, int green, int blue) &#123;</span><br><span class="line">        this.origin = new <span class="type">HexColor</span>(</span><br><span class="line">            red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们使用类的构造函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">RGBColor</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure></br><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h1><p>假设我在应用程序中的多个位置需要一个 <code>red tomato</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// ... sometime later</span></span><br><span class="line"><span class="type">Color</span> red = new <span class="type">Color</span>(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此创建两个对象，这显然是低效的，因为它们是相同的。 最好将第一个实例保留在内存中的某个位置，并在第二个调用到达时将其返回。 静态工厂方法可以解决这个问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// ... sometime later</span></span><br><span class="line"><span class="type">Color</span> red = <span class="type">Color</span>.makeFromPalette(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在 <code>Color</code> 内的某个地方，保存一个私有静态 <code>Map</code> ，其中已实例化了所有对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Map</span> &lt; <span class="type">Integer</span>, <span class="type">Color</span> &gt; <span class="type">CACHE</span> =</span><br><span class="line">        new <span class="type">HashMap</span> &lt; &gt; ();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> makeFromPalette(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">final</span> int hex = red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Color</span>.<span class="type">CACHE</span>.computeIfAbsent(</span><br><span class="line">            hex, h - &gt; new <span class="type">Color</span>(h)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是非常高效的。 对于像我们的 <code>Color</code> 这样的对象，问题可能不会那么明显，但是当对象较大时，其实例化和垃圾回收可能会浪费大量时间。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有一种面向对象的方法可以解决此问题。 我们只是介绍了一个新的类 <code>Palette</code> ，它将变成一个颜色存储区：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Palette</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Map</span> &lt; <span class="type">Integer</span>, <span class="type">Color</span> &gt; colors =</span><br><span class="line">        new <span class="type">HashMap</span> &lt; &gt; ();</span><br><span class="line">    <span class="type">Color</span> take(int red, int green, int blue) &#123;</span><br><span class="line">        <span class="keyword">final</span> int hex = red &lt;&lt; <span class="number">16</span> + green &lt;&lt; <span class="number">8</span> + blue;</span><br><span class="line">        <span class="keyword">return</span> this.computerIfAbsent(</span><br><span class="line">            hex, h - &gt; new <span class="type">Color</span>(h)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，我们一次创建一个 <code>Palette</code> 实例，并要求它在每次需要时向我们返回一种颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> tomato = palette.take(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br><span class="line"><span class="comment">// Later we will get the same instance:</span></span><br><span class="line"><span class="type">Color</span> red = palette.take(<span class="number">255</span>, <span class="number">99</span>, <span class="number">71</span>);</span><br></pre></td></tr></table></figure><p><strong>没有静态方法，没有静态属性。</strong></p></br><h1 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a><strong>子类型</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们的 <code>Color</code> 类具有 <code>lighter()</code> 方法，该方法应该将颜色转移到下一个可用的 <code>lighter</code> 上：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    protected <span class="keyword">final</span> int hex;</span><br><span class="line">    <span class="type">Color</span>(int h) &#123;</span><br><span class="line">        this.hex = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">Color</span>(hex + <span class="number">0x111</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，有时更希望通过一组可用的 <code>Pantone</code> 颜色选择下一种较浅的颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PantoneColor</span> <span class="title">extends</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">PantoneName</span> pantone;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">String</span> name) &#123;</span><br><span class="line">        this(new <span class="type">PantoneName</span>(name));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">PantoneName</span> name) &#123;</span><br><span class="line">        this.pantone = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">PantoneColor</span>(this.pantone.up());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建一个静态工厂方法，该方法将决定哪种 <code>Color</code> 实现最适合我们：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> code;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Color</span> make(int h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> new <span class="type">PantoneColor</span>(<span class="string">"19-1664 TPX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">RGBColor</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果要求使用真正的红色，我们将返回 <code>PantoneColor</code> 的一个实例。 在所有其他情况下，它只是标准的 <code>RGBColor</code> 。 该决定是通过静态工厂方法做出的。 这就是我们所说的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> color = <span class="type">Color</span>.make(<span class="number">0xBF1932</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于构造函数只能返回在其中声明的类，因此不可能对构造函数执行相同的 <code>“forking”</code> 。静态方法具有返回 <code>Color</code> 的任何子类型所需的所有自由。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是，在面向对象的世界中，我们可以而且必须以不同的方式去做。 首先，我们将 <code>Color</code> 设置为接口：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="type">Color</span> &#123;</span><br><span class="line">    <span class="type">Color</span> lighter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们将需要的构造方法移至其自己的类 <code>Colors</code> ，就像在上一个示例中所做的那样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colors</span> </span>&#123;</span><br><span class="line">    <span class="type">Color</span> make(int h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> new <span class="type">PantoneColor</span>(<span class="string">"19-1664-TPX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">RGBColor</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而且我们将使用 <code>Colors</code> 类的实例，而不是 <code>Color</code> 内部的静态方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colors.make(<span class="number">0xBF1932</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，这仍然不是真正的面向对象的思维方式，因为我们正在将决策权从它所属的对象上移开。 通过静态工厂方法 <code>make（</code>）或新类 <code>Colors</code> （实际上并不重要），我们将对象分成两部分。 第一部分是对象本身，第二部分是决策算法，它位于其他地方。<br>面向对象的设计是将逻辑放入 <code>PantoneColor</code> 类的对象中，该对象将装饰原始的RGBColor：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PantoneColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Color</span> origin;</span><br><span class="line">    <span class="type">PantoneColor</span>(<span class="type">Color</span> color) &#123;</span><br><span class="line">        this.origin = color;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Color</span> lighter() &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Color</span> next;</span><br><span class="line">        <span class="keyword">if</span> (this.origin.hex() == <span class="number">0xBF1932</span>) &#123;</span><br><span class="line">            next = new <span class="type">RGBColor</span>(<span class="number">0xD12631</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next = this.origin.lighter();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new <span class="type">PantoneColor</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，我们创建一个 <code>RGBColor</code> 实例，并使用 <code>PantoneColor</code> 装饰它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> red = new <span class="type">PantoneColor</span>(</span><br><span class="line">    new <span class="type">RGBColor</span>(<span class="number">0xBF1932</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要求红色返回较浅的颜色，它返回 <code>Pantone</code> 调色板中的一种，而不是仅在 <code>RGB</code> 坐标中较浅的颜色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span> lighter = red.lighter(); <span class="comment">// 0xD12631</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，这个示例是原始的，如果我们真的希望它适用于所有 <code>Pantone</code> 颜色，则需要进一步改进。 逻辑必须保留在类内部，而不是外部，静态工厂方法甚至其他补充类中。 当然，我在说的是属于这个特定类的逻辑。 如果与类实例的管理有关，则可以有容器和存储，就像上面的上一个示例一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总而言之，我强烈建议您不要使用静态方法，尤其是当它们要替换对象构造函数时。 通过其构造函数生成对象是任何面向对象软件中最“神圣”的时刻，请不要错过它的美丽。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 工厂模式 </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 静态工厂方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift静态工厂设计模式</title>
      <link href="/Swift%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，我们一起看一下有关 <a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95" target="_blank" rel="noopener" title="静态工厂设计模式">静态工厂设计模式</a> 的知识，并展示一些使用Swift编程语言的用例。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。” </p></blockquote><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个对象常常需要复杂的过程，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。</p></blockquote></br><h1 id="静态工厂模式示例"><a href="#静态工厂模式示例" class="headerlink" title="静态工厂模式示例"></a><strong>静态工厂模式示例</strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象创建中的有些过程包括决定创建哪个对象、管理对象的生命周期，以及管理特定对象的创建和销毁的概念。</p></blockquote><h2 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a><strong>命名构造函数</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于静态装饰模式的第一个好处是，每个静态装饰方法都可以有一个名称。 <code>Apple</code> 在其 <code>UIColor</code> 类实现中使用此模式来创建诸如 <code>.red</code> ，<code>.yellow</code> 等的命名颜色。请注意，<code>Swift</code> 中的实现实际上不是方法，而是静态属性，它返回实际实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">TimeInterval</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> second: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> minute: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">60</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> hour: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">3_600</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> day: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">86_400</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> week: <span class="type">TimeInterval</span> &#123; <span class="keyword">return</span> <span class="number">604_800</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果很难记住一天或一周是几秒钟，为什么不为它创建一个命名初始化器。 看到 <code>TimeInterval.week</code> 比 <code>604_800</code> 好得多。 😅</p></br><h2 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a><strong>缓存对象</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态工厂模式的下一个优点是，为了更好地使用内存，它可以支持缓存。 这样，如果你通过静态构造函数（也称为<a href="http://www.xuebaonline.com/Swift%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/" title="Swift中构造函数与静态工厂方法的比较">静态工厂方法</a>）对其进行初始化，则可以限制所创建对象的数量。 🏭</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - cache</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> cache: [<span class="type">String</span>:<span class="type">Service</span>] = [:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cached</span><span class="params">(name: String)</span></span> -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">Service</span>.cache[name] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="type">Service</span>.cache[name] = <span class="type">Service</span>(named: name)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cache[name]!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - static factory</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> local: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cached(name: <span class="string">"local"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> remote: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>.cached(name: <span class="string">"remote"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(named name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><h2 id="本地初始化范围"><a href="#本地初始化范围" class="headerlink" title="本地初始化范围"></a><strong>本地初始化范围</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于静态工厂方法的另一个好处是，你可以将类的初始化限制为私有作用域。 换句话说，只能通过静态工厂方法进行对象创建。 你只需要将 <code>init</code> 方法设为私有。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> local: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>(name: <span class="string">"local"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> remote: <span class="type">Service</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Service</span>(name: <span class="string">"remote"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>请注意，您可以使用 <code>final＆static</code> 关键字限制子类化。 如果要允许子类化，则应删除 <code>final</code> 并为属性使用 <code>class</code> 关键字而不是 <code>static</code> ，这样子类可以覆盖工厂方法。</strong> 🤔</p></br><h2 id="静态返回任何数据"><a href="#静态返回任何数据" class="headerlink" title="静态返回任何数据"></a><strong>静态返回任何数据</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 静态工厂也可以返回给定对象的子类型，但是为什么我们不更进一步呢？ 你还可以从静态方法返回任何类型的数据，我知道这似乎是一种作弊，因为我不是在这里创建 <code>UIColor</code> 的实例，但是我相信在这里值得一提这个方法，静态工厂。 有时，这个技术可能非常有用。 😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span><span class="params">(with color: UIColor)</span></span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">1</span>, height: <span class="number">1</span>)</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(rect.size)</span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()!</span><br><span class="line">        context.setFillColor(color.cgColor)</span><br><span class="line">        context.fill(rect)</span><br><span class="line">        <span class="keyword">let</span> img = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> img!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> redImage: <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>.image(with: .red)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift生成器模式</title>
      <link href="/Swift%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>了解如何在Swift中实现生成器模式，以隐藏创建具有许多单独属性的对象的复杂性。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>iOS</code> 开发中，会使用到很多设计模式，<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="生成器模式">生成器模式</a> 也叫构建器模式，我们也会经常用到。在以下的行文过程中均使用生成器模式来表述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成器模式（英：Builder Pattern）是一种设计模式，又名：建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p><a id="more"></a></br><h1 id="生成器模式如何工作？"><a href="#生成器模式如何工作？" class="headerlink" title="生成器模式如何工作？"></a><strong>生成器模式如何工作？</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成器模式可以通过多种方式实现，但是如果你了解该模式的主要目标，那实际上就没有关系：</p><blockquote><p><strong>Builder设计模式的目的是将复杂对象的构造与其表示分开。</strong></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如果你有一个具有很多属性的对象，想隐藏初始化过程的复杂性，可以编写一个生成器并通过该生成器构造该对象。 它可以像控制整个构建过程的构建方法或外部类一样简单。 这完全取决于给定的环境。 🏗</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，我们对该设计模式有一个详细的认知，让我们来看一下使用实例和强大的 <code>Swift</code> 编程语言的生成器模式！ 💪</p></br><h1 id="简单的-Emitter-生成器"><a href="#简单的-Emitter-生成器" class="headerlink" title="简单的 Emitter 生成器"></a><strong>简单的 Emitter 生成器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SKEmitterNode</code> 是一个很好的例子。 如果要创建自定义 <code>Emitter</code> 并以编程方式设置属性（通常用于 <code>SpriteKit</code> 游戏），则像这样的 <code>Emitter</code> 生成器类可能是一个合理的解决方案。 👾</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmitterBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKEmitterNode</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> emitter = <span class="type">SKEmitterNode</span>()</span><br><span class="line">        emitter.particleTexture = <span class="type">SKTexture</span>(imageNamed: <span class="string">"MyTexture"</span>)</span><br><span class="line">        emitter.particleBirthRate = <span class="number">100</span></span><br><span class="line">        emitter.particleLifetime = <span class="number">60</span></span><br><span class="line">        emitter.particlePositionRange = <span class="type">CGVector</span>(dx: <span class="number">100</span>, dy: <span class="number">100</span>)</span><br><span class="line">        emitter.particleSpeed = <span class="number">10</span></span><br><span class="line">        emitter.particleColor = .red</span><br><span class="line">        emitter.particleColorBlendFactor = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> emitter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">EmitterBuilder</span>().build()</span><br></pre></td></tr></table></figure></br><h1 id="简单的-theme-生成器"><a href="#简单的-theme-生成器" class="headerlink" title="简单的 theme 生成器"></a><strong>简单的 theme 生成器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们远离游戏，想象一下你正在为UIKit应用程序创建一个主题引擎，该引擎具有许多自定义字体，颜色等。生成器对于构造独立主题可能很有用。 🔨</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> textColor: <span class="type">UIColor?</span></span><br><span class="line">    <span class="keyword">let</span> backgroundColor: <span class="type">UIColor?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> light</span><br><span class="line">        <span class="keyword">case</span> dark</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(<span class="number">_</span> style: Style)</span></span> -&gt; <span class="type">Theme</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> style &#123;</span><br><span class="line">        <span class="keyword">case</span> .light:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Theme</span>(textColor: .black, backgroundColor: .white)</span><br><span class="line">        <span class="keyword">case</span> .dark:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Theme</span>(textColor: .white, backgroundColor: .black)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="type">ThemeBuilder</span>()</span><br><span class="line"><span class="keyword">let</span> light = builder.build(.light)</span><br><span class="line"><span class="keyword">let</span> dark = builder.build(.dark)</span><br></pre></td></tr></table></figure></br><h1 id="“Chained”-URL构建器"><a href="#“Chained”-URL构建器" class="headerlink" title="“Chained” URL构建器"></a><strong>“Chained” URL构建器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用这种方法，你可以通过多种方法配置对象，并且每个方法都将返回相同的生成器对象。 这样，您可以链接配置，并在最后一步构建最终对象实例。 ⛓</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> components: <span class="type">URLComponents</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.components = <span class="type">URLComponents</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(scheme: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.scheme = scheme</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(host: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.host = host</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(port: Int)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.port = port</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(path: String)</span></span> -&gt; <span class="type">URLBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> path = path</span><br><span class="line">        <span class="keyword">if</span> !path.hasPrefix(<span class="string">"/"</span>) &#123;</span><br><span class="line">            path = <span class="string">"/"</span> + path</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.components.path = path</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addQueryItem</span><span class="params">(name: String, value: String)</span></span> -&gt; <span class="type">URLBuilder</span>  &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.components.queryItems == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.components.queryItems = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.components.queryItems?.append(<span class="type">URLQueryItem</span>(name: name, value: value))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">URL?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.components.url</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URLBuilder</span>()</span><br><span class="line">    .<span class="keyword">set</span>(scheme: <span class="string">"https"</span>)</span><br><span class="line">    .<span class="keyword">set</span>(host: <span class="string">"localhost"</span>)</span><br><span class="line">    .<span class="keyword">set</span>(path: <span class="string">"api/v1"</span>)</span><br><span class="line">    .addQueryItem(name: <span class="string">"sort"</span>, value: <span class="string">"name"</span>)</span><br><span class="line">    .addQueryItem(name: <span class="string">"order"</span>, value: <span class="string">"asc"</span>)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure></br><h1 id="director-类的生成器模式"><a href="#director-类的生成器模式" class="headerlink" title="director 类的生成器模式"></a><strong>director 类的生成器模式</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 让我们认识一下 <code>director</code> 实例。 使构建器与确切的配置部分解耦。 因此，举例来说，你可以制作带有圆圈的游戏，但是后来如果你改变主意并想使用正方形，那相对容易。 你只需要创建一个新的生成器，其他所有内容都可以相同。 🎬</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NodeBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">SKColor</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NodeDirector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> builder: <span class="type">NodeBuilder</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleNodeBuilder</span>: <span class="title">NodeBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">SKColor</span> = .clear</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="type">SKShapeNode</span>(circleOfRadius: <span class="keyword">self</span>.size)</span><br><span class="line">        node.name = <span class="keyword">self</span>.name</span><br><span class="line">        node.fillColor = <span class="keyword">self</span>.color</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerNodeDirector</span>: <span class="title">NodeDirector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> builder: <span class="type">NodeBuilder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(builder: <span class="type">NodeBuilder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.builder = builder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">()</span></span> -&gt; <span class="type">SKShapeNode</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.builder.name = <span class="string">"Hello"</span></span><br><span class="line">        <span class="keyword">self</span>.builder.size = <span class="number">32</span></span><br><span class="line">        <span class="keyword">self</span>.builder.color = .red</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.builder.build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="type">CircleNodeBuilder</span>()</span><br><span class="line"><span class="keyword">let</span> director = <span class="type">PlayerNodeDirector</span>(builder: builder)</span><br><span class="line"><span class="keyword">let</span> player = director.build()</span><br></pre></td></tr></table></figure><h1 id="基于Block的构建器"><a href="#基于Block的构建器" class="headerlink" title="基于Block的构建器"></a><strong>基于Block的构建器</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一种更快捷的方法是使用 <code>Block</code> 而不是生成器类来配置对象。 当然，我们可以争论这是否仍然是生成器模式…😛</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(block: <span class="params">(<span class="params">(UILabel)</span></span></span></span> -&gt; <span class="type">Void</span>)) -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: .zero)</span><br><span class="line">        block(label)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> label = <span class="type">UILabel</span>.build &#123; label <span class="keyword">in</span></span><br><span class="line">    label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    label.text = <span class="string">"Hello wold!"</span></span><br><span class="line">    label.font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">12</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 请注意，生成器的实现可能会因具体实例而异。 有时，生成器模式与工厂模式结合在一起。 对此，几乎每个人都以不同的方式解释它，但是我认为这不是问题。 设计模式是精心设计的准则，但有时你必须这么做。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 生成器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Swift中重构单例模式用法</title>
      <link href="/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/"/>
      <url>/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>清洁，模块化和可测试代码库的小技巧。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件开发中，不鼓励使用单例，并且对此表示反对，但这是有充分理由的。 它们很难测试或无法测试，并且在其他类中隐式使用它们时会纠缠你的代码库，从而使代码重用变得困难。 在大多数情况下，单例模式无非是对全局易变状态的保存。 每个人至少知道这是一个糟糕的主意。 但是，<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener" title="单例模式">单例模式</a> 有时是不可避免和必要的错误。 我们如何以一种干净，模块化和可测试的方式将它们合并到我们的代码中？</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 </p></blockquote><a id="more"></a><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p></blockquote><h1 id="单例模式无处不在"><a href="#单例模式无处不在" class="headerlink" title="单例模式无处不在"></a><strong>单例模式无处不在</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 <code>Apple</code> 平台上，<code>Cocoa</code> 和 <code>Cocoa Touch</code> 框架中到处都有单例。 有 <code>UIApplication.shared</code>，<code>FileManager.default</code>，<code>NotificationCenter.default</code>，<code>UserDefaults.standard</code>，<code>URLSession.shared</code> 等。 设计模式甚至在 <code>Cocoa</code> 核心能力指南中都有自己的部分。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当你隐式引用这些（以及你自己的）单例时，将增加更改代码所需的工作量。 这也使测试代码变得困难或不可能，因为无法从使用它们的类之外更改或模拟这些单例。 这是你在iOS应用中都会看到的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentUser = <span class="type">CurrentUserManager</span>.shared.user</span><br><span class="line">        <span class="keyword">if</span> currentUser != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// do something with current user</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mySetting = <span class="type">UserDefaults</span>.standard.bool(forKey: <span class="string">"mySetting"</span>)</span><br><span class="line">        <span class="keyword">if</span> mySetting &#123;</span><br><span class="line">            <span class="comment">// do something with setting</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">URLSession</span>.shared.dataTask(with: <span class="type">URL</span>(string: <span class="string">"http://someResource"</span>)!) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// handle response</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这就是我所说 隐式引用 的意思-你只需在类中直接使用单例。 我们可以做得更好。 在Swift中，有一种轻量级，简便且影响小的方式来改善这一点。 Swift也使其使用起来更加优雅。</p><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简而言之，答案是 <a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener" title="依赖注入"><strong>依赖注入</strong></a> 。 该原则表明你应该设计类和函数，以使所有输入都是显式的。 如果你重构上面的代码片段以使用依赖项注入，它将看起来像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> userManager: <span class="type">CurrentUserManager</span></span><br><span class="line">    <span class="keyword">let</span> defaults: <span class="type">UserDefaults</span></span><br><span class="line">    <span class="keyword">let</span> urlSession: <span class="type">URLSession</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userManager: <span class="type">CurrentUserManager</span>, defaults: <span class="type">UserDefaults</span>, urlSession: <span class="type">URLSession</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">        <span class="keyword">self</span>.defaults = defaults</span><br><span class="line">        <span class="keyword">self</span>.urlSession = urlSession</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentUser = userManager.user</span><br><span class="line">        <span class="keyword">if</span> currentUser != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// do something with current user</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mySetting = defaults.bool(forKey: <span class="string">"mySetting"</span>)</span><br><span class="line">        <span class="keyword">if</span> mySetting &#123;</span><br><span class="line">            <span class="comment">// do something with setting</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        urlSession.dataTask(with: <span class="type">URL</span>(string: <span class="string">"http://someResource"</span>)!) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// handle response</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此类不再隐式（或显式）依赖于任何单例。 它显式依赖于 <code>CurrentUserManager</code>， <code>UserDefaults</code> 和 <code>URLSession</code> ，但是有关这些依赖项的任何内容均表示它们是单例。 这个细节不再重要，但是功能保持不变。 视图控制器仅知道这些对象的实例存在。 在需要使用该对象时，你可以传递单例。 同样，从类的角度来看，此细节无关紧要。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>(userManager: .shared, defaults: .standard, urlSession: .shared)</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p><strong>特别提示：<code>Swift</code> 类型推断在这里起作用。 除了编写 <code>URLSession.shared</code>，您还可以编写 <code>.shared</code> 。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你需要提供其他默认值（例如，如果你需要与<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW6" target="_blank" rel="noopener" title="应用组内共享数据">应用组共享数据</a>），则更改起来很容易。 实际上，你不必更改此类中的任何代码。 而不传递 <code>UserDefaults.standard</code>，而是传递 <code>UserDefaults（suiteName：“ com.myApp”）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，在单元测试中，你现在可以传递这些类的其他实例。 在Swift中无法进行真正的模拟，但是有一些解决方法。 这取决于您要如何构造代码。 你可以为 <code>CurrentUserManager</code> 使用协议，然后可以在测试中“模拟”该协议。 你可以为 <code>UserDefaults</code> 提供构造的方法类进行测试。 你可以将 <code>URLSession</code> 设置为可选，并在测试中传递 <code>nil</code>。</p><h1 id="重构陷阱"><a href="#重构陷阱" class="headerlink" title="重构陷阱"></a><strong>重构陷阱</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能对这个想法很感兴趣，现在你想解开并解放陷入困境的代码库。尽管依赖注入是理想的选择，并且可以为你提供更纯净的对象模型，但是实现它通常很困难。更重要的是，在首次编写代码时，很少会设计出适应这种情况的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们上面重构的内容现在更具模块化和可测试性-但确实存在问题。 <code>MyViewController</code> 的初始值设定项曾经是空的 <code>（init（））</code> ，但现在需要三个参数。每个调用位置都必须更改。构造此方法的干净而正确的方法是将实例从上到下或从以前的视图控制器传递到此实例。这将需要将数据从对象图的根传递到所有子类。特别是在iOS中，当你将数据从视图控制器传递到视图控制器时，这可能会引起很多麻烦。尤其是传统代码库将难以立即实现如此大的更改。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大多数类（尤其是视图控制器）的初始化程序都需要更改。当你意识到必须重构整个应用程序时，这种更改变得异常困难。要么一切都将被破坏，要么仅某些类将被更新以进行依赖注入，而其他一些类将继续隐式引用单例。这种不一致可能在将来引起问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在复杂、大型的旧版代码库中，这样的重构可能根本不可行-至少不能同时进行，而且也不能没有回归。因此，你可能会争辩说，你根本不应该重构并忍受这种情况。然后需要几个月或几年的时间你您必须支持多个用户-现在在实现切换帐户时 <code>CurrentUserManager</code> 无法正常工作。你如何应对？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一种更为先进的方式，也有一种从一开始就设计你要使用的类以适应下一次此类变化的方法。</p><h1 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a><strong>默认参数值</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最喜欢的Swift功能之一是默认参数值。 它们非常有用，可以为你的代码带来很大的灵活性。 使用默认参数，你可以解决上述问题，而不必担心依赖注入问题，也不会在代码库中引入过多的复杂性。 也许你的应用程序实际上只有一个用户，所以实现所有这种依赖注入是不必要的开销。</p><p>你可以给单例设置默认参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userManager: <span class="type">CurrentUserManager</span> = .shared, defaults: <span class="type">UserDefaults</span> = .standard, urlSession: <span class="type">URLSession</span> = .shared) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userManager = userManager</span><br><span class="line">        <span class="keyword">self</span>.defaults = defaults</span><br><span class="line">        <span class="keyword">self</span>.urlSession = urlSession</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，从方法调用的角度来看，初始化程序没有改变。 但是类本身存在很大的差异，它现在使用依赖项注入，不再引用单例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>()</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你从此更改中学到了什么？你可以使用此模式重构每个类，而无需更新任何调用的地方。语义上或功能上都没有改变。但是，你的类也在使用依赖注入。他们只是在内部使用实例。你可以如上所述测试它们并维护一个灵活的模块化API，同时公共接口保持不变。本质上，你可以继续在代码库中工作，就好像什么都没有改变一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有时间传入自定义非空参数，你可以执行此操作而无需更改任何类。你只需要更新调用的位置即可。此外，如果你决定使用成熟的依赖关系注入并从上至下传递每个单个依赖关系，则只需删除默认参数并从上方传递依赖关系。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要，你甚至可以选择加入或选择退出任何默认值。在以下示例中，我们提供了自定义 <code>UserDefaults</code>，但保留了 <code>CurrentUserManager</code> 和 <code>URLSession</code> 的默认参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appGroupDefaults = <span class="type">UserDefaults</span>(suiteName: <span class="string">"com.myApp"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = <span class="type">MyViewController</span>(defaults: appGroupDefaults)</span><br><span class="line"></span><br><span class="line">present(controller, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></bar><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Swift</code> 使这种“部分”依赖注入变得很方便实用。通过为类添加新属性和带有默认值的初始化参数，你可以使你的代码具有更大的模块化和可测试性，而不必重构，也不必完全使用成熟的依赖项注入。如果从一开始就设计这样的类，那么你会发现自己写出 <code>bug</code> 的概率降低了很多-当你遇到 <code>bug</code> 是，将更容易定位和解决。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 除了此处的简单示例（类，结构，枚举，函数）之外，你还可以将这些概念和设计应用于代码的所有区域。 <code>Swift</code> 中的每个函数都可以采用默认参数值。通过花一些时间来思考未来可能发生的变化，我们可以创建可以轻松适应变化的类型和功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 构建和设计好的软件意味着编写<strong>易于更改</strong>但<strong>难以破解的代码</strong>。这就是依赖项注入的动机，而 <code>Swift</code> 的默认参数可以帮助你快速，轻松且优雅地实现这一目标。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift单例模式</title>
      <link href="/Swift%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/Swift%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Singleto</code>n 是有史以来最受争议的设计模式。了解在 <code>iOS</code> 项目中使用 <code>Swift</code> 单例类的正确方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每个人都在批评的单例模式，大多数人都将其称为反模式。但是单例模式到底是什么，为什么这么差呢？</p><a id="more"></a><h1 id="Singleton-是什么"><a href="#Singleton-是什么" class="headerlink" title="Singleton 是什么?"></a><strong>Singleton 是什么?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于简单，这是一种非常流行且普遍采用的模式。在整个应用程序生命周期中，单例类只能有一个实例。单个实例只能通过静态属性访问，并且初始化后的对象通常在全局范围内共享。这就像一个全局变量。 🌏</p><h1 id="全局变量和状态"><a href="#全局变量和状态" class="headerlink" title="全局变量和状态"></a><strong>全局变量和状态</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式的声誉很差，因为他们共享全局可变的状态。即使在经验丰富的开发人员圈子中，始终会担心使用 <code>global</code> 关键字。全局状态和变量是副作用的温床。可以从程序的任何位置访问全局变量，因此使用它们的类将变为有状态，不安全，紧密耦合且难以调试。出于明显的原因，通过这种方式与对象共享状态不是一个好习惯。 🤮</p><h1 id="Singleton-的副作用"><a href="#Singleton-的副作用" class="headerlink" title="Singleton 的副作用"></a><strong>Singleton 的副作用</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你应该尽可能确定范围和隔离变量，并最大程度地减少代码的状态性。这将消除副作用，使您的代码更安全地使用。考虑以下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// method is written by someone else</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    global = x</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">global = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> result = square(<span class="number">5</span>)</span><br><span class="line">result += global <span class="comment">//we assume that global is 1</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">//wtf 30 it should be 26</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>square</code> 方法由其他人编写，由于某种原因，他们希望将输入存储在相同的全局变量中。现在，当您调用该函数时，除非您查看他的代码，否则您将一无所获。想象一下，在一个由多个代码作者编写的具有大量oop类的项目中的此类问题……GOOD LUCK! 🐛🐛🐛</p><h1 id="单例对象的生命周期"><a href="#单例对象的生命周期" class="headerlink" title="单例对象的生命周期"></a><strong>单例对象的生命周期</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 单例创建一次并永久存在，它们的工作几乎就像全局变量一样，这就是为什么你必须格外小心。你应该仅使用在应用程序整个生命周期内都能维持的单例状态来管理这些状态。例如，特定于用户的会话通常是不好的做法，你应该重新考虑设计。另外，默认情况下，Swift也不是线程安全的，因此，如果你使用单例，则还必须为多线程问题做好准备。但是，如果它们因此造成问题，我们难道不应该完全避免它们吗？答案是不。 🚫</p><h1 id="我们应该在什么时候使用单例类"><a href="#我们应该在什么时候使用单例类" class="headerlink" title="我们应该在什么时候使用单例类"></a><strong>我们应该在什么时候使用单例类</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>UIApplication</code> 很可能是单例的，因为应该只有一个应用程序实例，并且该实例应该一直存在，直到你将其关闭为止。这就是单例的完美例子。另一个用例可以是 <code>Logger</code> 类。使用单例是安全的，因为无论记录器是否打开，你的应用程序的行为都不会有所不同。没有其他人会拥有或管理记录器，并且你只会将信息传递到记录器中，因此状态不会混乱。<strong>结论：对于单例模式的使用，控制台或记录器类是完全可以接受的方案。</strong> 👏</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Console</span>.<span class="keyword">default</span>.notice(<span class="string">"Hello I'm a singleton!"</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apple 框架中有很多“单一”（并非一切都是真正的单例对象）用例，这是一个简短列表，因此您可以从中获得一些启发：</p><ul><li>HTTPCookieStorage.shared</li><li>URLCredentialStorage.shared</li><li>URLSessionConfiguration.default</li><li>URLSession.shared</li><li>FileManager.default</li><li>Bundle.main</li><li>UserDefaults.standard</li><li>NotificationCenter.default</li><li>UIScreen.main</li><li>UIDevice.current</li><li>UIApplication.shared</li><li>MPMusicPlayerController.systemMusicPlayer</li><li>GKLocalPlayer.localPlayer（）</li><li>SKPaymentQueue.default（）</li><li>WCSession.default</li><li>CKContainer.default（）</li><li>etc</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经看到许多管理器类以单例形式实现，例如网络，位置或核心数据管理器，但是这些对象通常不应该是单例，仅仅是因为它可以是多个单例。 💩</p><p><strong>单例模式可能非常有用，但应谨慎使用。</strong></p><p>如果要将某个类变成单例，请问自己以下问题：</p><ul><li>还有其他任何东西拥有，管理或负责吗？</li><li>是否将只有一个实例？</li><li>它会是一个全局状态变量吗？</li><li>我真的应该使用全局共享对象吗？</li><li>是否应该贯穿整个应用程序生命周期？</li><li>有其他选择吗？</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果以上所有内容的答案都是肯定的，那么您可以“安全地”使用单例或全局变量来存储数据。 🎉🎉🎉</p><h1 id="如何使用Swift创建一个单例"><a href="#如何使用Swift创建一个单例" class="headerlink" title="如何使用Swift创建一个单例?"></a><strong>如何使用Swift创建一个单例?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Swift</code> 中创建单例对象确实很容易，但是在应用此设计模式之前，请务必三思而后行，并考虑其他选择。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Singleton</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// don't forget to make this private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> singleton = <span class="type">Singleton</span>.shared</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，我总是创建一个特定的单例对象，称为App。通过这种方式，我可以将与应用程序相关的全局状态属性连接到那个单例中。命名约定也有助于关联和理解其中的内容。 💡</p><h1 id="如何消除单例"><a href="#如何消除单例" class="headerlink" title="如何消除单例?"></a><strong>如何消除单例?</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果还有其他方法，则应在大约90％的情况下使用该方法。单例模式最常见的替代解决方案是依赖注入。首先，你应该将单例方法抽象为协议，然后，如果仍然需要，可以将其用作默认实现。现在，您可以将单例或<a href="http://www.xuebaonline.com/%E5%9C%A8Swift%E4%B8%AD%E9%87%8D%E6%9E%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%B3%95/" title="重构对象">重构的对象</a>注入正确的位置。这样，你的代码就可以使用协议的模拟对象进行测试，甚至可以忽略单例本身。 😎</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">DataCompletionBlock</span> = (<span class="type">Data?</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. abstract away the required functions</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. make your "singleton" conform to the protocol</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSession</span>: <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> task = <span class="keyword">self</span>.dataTask(with: request) &#123; data, <span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            completionHandler(data)</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> session: <span class="type">Session</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. using dependency injection with the "singleton" object</span></span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">Session</span> = <span class="type">URLSession</span>.shared) &#123;</span><br><span class="line">        <span class="keyword">self</span>.session = session</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(<span class="number">_</span> request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.session.make(request: request, completionHandler: completionHandler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. create mock object</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockedSession</span>: <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(request: URLRequest, completionHandler: @escaping DataCompletionBlock)</span></span> &#123;</span><br><span class="line">        completionHandler(<span class="string">"Mocked data response"</span>.data(using: .utf8))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. write your tests</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> api = <span class="type">ApiService</span>(session: <span class="type">MockedSession</span>())</span><br><span class="line">    <span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="string">"https://localhost/"</span>)!)</span><br><span class="line">    api.load(request) &#123; data <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(data: data!, encoding: .utf8)!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像你看到的，单例模式非常容易实现，但是很难决定其应用程序形式。我并不是说这是一种反模式，因为显然不是这样，但是如果你打算使用单例模式，请当心。 😉</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSCODER和SWIFT初始化</title>
      <link href="/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您正在使用 <code>Swift</code> 并想对实现 <code>NSCoding</code> 的东西进行子类化（例如 <code>UIView</code>，<code>UIViewController</code> 等），则可能会遇到麻烦的情况。即，<code>NSCoding</code> 协议需要 <code>init(coder：aDecoder)</code> 初始化程序，这意味着如果你为超类重写了指定的初始化程序，则需要实现该初始化程序。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那就好了，但是 <code>Swift</code> 在确保对类的所有属性进行超级严格的调用之前，都要确保在 <code>init()</code> 中分配了一个值。这意味着，如果您想提供自己的初始化程序，则无法执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    name = <span class="string">"Bar"</span></span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle:<span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>init（coder :)</code> 初始值设定项未设置 <code>name</code> 属性，因此不会进行编译。你可以在两个初始值设定项中都重复初始化和设置名称，但是当你在init中进行了很多工作时，这很糟糕（如果希望尽可能避免使用可选属性，则应该这样做）。</p><p>在 Objective-C 中，如果要在多个 <code>init</code> 方法之间共享初始化逻辑，则只需定义一个通用的 <strong>“setup”</strong> 方法即可执行所有共享的东西，并从两个初始化器中调用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype) <span class="keyword">init</span> &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span> <span class="keyword">self</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype) initWithCoder:(<span class="type">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span> <span class="keyword">self</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setup];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) setup &#123;</span><br><span class="line">  <span class="keyword">self</span>.name = @<span class="string">"Foo"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  这种方式不会立即就创建出你想要的对象。问题在于，在这两个初始化程序中，我们都在调用    <code>[super init]</code> 之前，先给 <code>self.name</code> 分配了一个值，但这在 <code>Swift</code> 语法中是不可行的。我们也不能将对 <code>self.setup</code> 的调用移到对 <code>super.init（）</code> 的调用之上，因为在类通过调用 <code>super.init（）</code> 完全初始化之后，才允许您引用 <code>self</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  那么，如何将这只鸡从鸡蛋中取出并放到盘子上呢？好吧，我们要等到初始化后才能对 <code>self</code> 调用方法，但是只要我们从 <strong>“convienience”</strong> 初始化程序中调用它，就可以调用另一个 <code>init</code> 。仅通过示例进行解释可能更容易：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> coder: <span class="type">NSCoder?</span> = <span class="literal">nil</span>) &#123;</span><br><span class="line">    name = <span class="string">"Bar"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> coder = coder &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle:<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(coder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在指定的初始化程序中添加了一个可选的 <code>NSCoder</code> 参数，并将其默认设置为 <code>nil</code> ，因此我们仍然可以像以前一样在没有任何参数的情况下调用它。但是，现在已将<code>NSCoding</code> 协议中要求的 <code>init（coder :)</code> 初始值设定项标记为<strong>convienience</strong>，这意味着它可以调用指定的初始值设定项并传入编码器。</p><p>在指定的 <code>init</code> 中，我们检查 <code>coder</code> 是否为非 <code>nil</code> （如果让coder = conditional为条件），如果是，则调用 <code>super.init（coder :)</code> 。如果为 <code>nil</code>，我们将执行本来应该做的事情，并调用 <code>super.init（nibName：nil，bundle：nil）</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，编译器很高兴在调用 <code>super.init（）</code> 之前为属性分配值，并且可以将初始化逻辑放在一个地方。如果要在情节提要中使用 <code>ViewController</code> ，则框架将调用init（coder :)，如果要以编程方式创建一个，则可以说 <code>let fooVC = FooViewController（）</code>。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIKit初始化模式</title>
      <link href="/UIKit%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/"/>
      <url>/UIKit%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>了解UIKit中两个常用类的初始化过程。了解UIViewcontroller和UIView初始化模式。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UIKit</code> 是在iOS开发过程中必须也是使用频次最高的一个类库，里面包含了许多与用户直接交互的控件比如：<code>UIView</code>, <code>UITableView</code>, <code>UIScrollView</code> 等。在收到用户交互的设计图之后，我们要合理的使用这些控件，就能编写出交互良好的应用。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了类库中包含的基础控件之外，我们也能够对控件根据业务需要进行整合，也就是设计出一套适用于本公司的组件，提高开发速度。</p><h1 id="UIViewController-初始化"><a href="#UIViewController-初始化" class="headerlink" title="UIViewController 初始化"></a><strong>UIViewController 初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，<code>UIViewController</code> 的初始化非常简单。如果要完全控制，则只需要重写一些方法。这取决于你使用何种方式调用 <code>init</code> ，如果你使用一个 <code>storyboard</code> 初始化控制器，那么 <a href="http://www.xuebaonline.com/NSCODER%E5%92%8CSWIFT%E5%88%9D%E5%A7%8B%E5%8C%96/" title="NSCODER和SWIFT初始化">init(coder)</a> 是你所需要的。如果你尝试从外部 <code>nib</code> 文件启动控制器，则将调用 <code>init（nib，bundle）</code> 。你还有第三个选择，你可以通过代码以编程方式初始化控制器。简而言之，为了进行合理的初始化过程，这是你必须要做的。</p></br><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面介绍两种 <code>UIViewControllers</code> 的初始化模式，第一种只是一个常见的init函数，在每种情况下都可以调用该函数来初始化控制器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(nibName nibNameOrNil: <span class="type">String?</span>, bundle nibBundleOrNil: <span class="type">Bundle?</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do your stuff here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以在之后的子类中隐藏 <code>init（nib，bundle）</code> 和 <code>init（coder）</code> 方法。在子类中不必重写 <code>init（nib，bundle）</code>，并且可以将 <code>init（coder）</code> 标记为默认初始化程序。这个似乎是有点棘手的解决方案，使用起来不是很方便，但确实可以完成 <code>ViewController</code> 的初始化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do your stuff here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFutureViewController</span>: <span class="title">ViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> vc = <span class="type">MyFutureViewController</span>()</span><br></pre></td></tr></table></figure><hr></br><h1 id="UIView-初始化"><a href="#UIView-初始化" class="headerlink" title="UIView 初始化"></a><strong>UIView 初始化</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通常为 <code>UIView</code> 创建一个通用的初始化程序，以使初始化过程更加轻松，使用起来更加方便。还会在该初始值设定项方法中将 <code>translate autoresizing mask</code> 属性设置为 <code>false</code> ，因为它是2017年，没有人再使用 <code>spring＆struts</code> 了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.initialize()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用自动布局助手也很不错，如果你想从nib文件中初始化视图，那么有一些便利的方法也很好。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(autolayout: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(frame: .zero)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(autolayout: Bool = <span class="literal">true</span>)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _self = <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">let</span> view  = _self <span class="keyword">as</span> <span class="type">UIView</span></span><br><span class="line">        view.translatesAutoresizingMaskIntoConstraints = !autolayout</span><br><span class="line">        <span class="keyword">return</span> _self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">createFromNib</span><span class="params">(owner: <span class="keyword">Any</span>? = <span class="literal">nil</span>, options: [AnyHashable: <span class="keyword">Any</span>]? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Bundle</span>.main.loadNibNamed(<span class="type">String</span>(describing: <span class="keyword">self</span>), owner: owner, options: options)?.last <span class="keyword">as</span>! <span class="type">UIView</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> view = <span class="type">UIView</span>(autolayout: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>使用这些代码片段，为所有 <code>UIKit</code> 类维护一个合理的初始化过程确实很容易，因为其中大多数都是从这两个 “主要” 类派生的。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
          <category> 设计模式 </category>
          
          <category> UIKit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UIKit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端实践三:Ubuntu18.04安装Vapor4.0</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89:Ubuntu18.04%E5%AE%89%E8%A3%85Vapor4.0/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89:Ubuntu18.04%E5%AE%89%E8%A3%85Vapor4.0/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文章《<a href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/" title="后端实践二:Ubuntu18.04安装最新版Swift5.2">后端实践二:Ubuntu18.04安装最新版Swift5.2</a>》可以在 Ubuntu18.04 的服务器上顺利安装最新版本的 <code>Swift</code> 。我们参照 <a href="https://docs.vapor.codes/3.0/install/ubuntu/" target="_blank" rel="noopener">官网文档</a> 安装 <code>Vapor4.0</code> 的开发环境。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官网上的文档跟开发维护的速度有一定的版本误差，所以现在在官网上看到的安装方法是针对 <code>Vapor(&gt;3.0 &amp;&amp; &lt; 4.0)</code> 的版本。由于版本间差异比较大，在实践过程中，只会关注到 <code>Vapor(&gt;=4.0)</code> 以上版本的新特性。在创建工程和引入依赖库的过程中也会出现微小的差别，我们在后续的实践中会总结到。</p></blockquote><h1 id="验证-Swift-安装"><a href="#验证-Swift-安装" class="headerlink" title="验证 Swift 安装"></a><strong>验证 Swift 安装</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过访问 <code>Swift.org</code>，可以得到一份如何在 <code>Linux</code> 上安装 <code>Swift</code> 的文档。我们完成对 <code>Swift</code> 的安装之后，在终端中输入如下命令：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><a id="more"></a><p>如果在终端中输出如下信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Apple</span> <span class="type">Swift</span> version <span class="number">4.1</span>.<span class="number">0</span> (swiftlang-<span class="number">900.0</span>.<span class="number">69.2</span> clang-<span class="number">900.0</span>.<span class="number">38</span>)</span><br><span class="line"><span class="type">Target</span>: x86_64-apple-macosx10.<span class="number">9</span></span><br></pre></td></tr></table></figure><p>那么标识我们在 <code>Linux</code> 上成功安装 <code>Swift</code>。</p><h1 id="安装-Vapor-Toolbox"><a href="#安装-Vapor-Toolbox" class="headerlink" title="安装 Vapor Toolbox"></a><strong>安装 Vapor Toolbox</strong></h1><p>在 <code>Vapor 4.0</code> 发布之前，在 <code>Linux</code> 上安装，只需要在终端中敲入如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL apt.vapor.sh -o apt.vapor.sh</span><br></pre></td></tr></table></figure><p>这个执行安装的命令已经被废弃。</p><h2 id="Toolbox-源代码"><a href="#Toolbox-源代码" class="headerlink" title="Toolbox 源代码"></a><code>Toolbox</code> 源代码</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于之后的版本中，不在将该文件托管至软件源，所以我们在安装时需要做出如下操作获取到 <code>Toolbox</code> 源代码到本地文件夹中：</p><p>下载 <code>Toolbox</code> 源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vapor/toolbox.git</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-1stp.png" alt="Toolbox"></p><h2 id="编译-Vapor-可执行文件"><a href="#编译-Vapor-可执行文件" class="headerlink" title="编译 Vapor 可执行文件"></a>编译 <code>Vapor</code> 可执行文件</h2><p>进入到 <code>Toolbox</code> 工程的根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> toolbox/</span><br></pre></td></tr></table></figure><p>编译 <code>Toolbox</code>  发布版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build -<span class="built_in">c</span> release</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于获取的源代码中缺少部分文件，期间或存在报错发现 <code>Toolbox</code> 中没有 <code>LinuxMain.swift</code> 文件在 <code>Tests</code> 文件夹中，这时我们进入到 <code>XCTest</code> 文件夹中。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-2stp.png" alt="Vapor"></p><p>创建 <code>LinuxMain.swift</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch LinuxMain.swift</span><br></pre></td></tr></table></figure><p>编辑 <code>LinuxMain.swift</code> 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim LinuxMain.swift</span><br></pre></td></tr></table></figure><p>向 <code>LinuxMain.swift</code> 文件中添加测试代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> AppTests</span><br><span class="line"></span><br><span class="line"><span class="type">XCTMain</span>([testCase(<span class="type">AppTests</span>.allTests)])</span><br></pre></td></tr></table></figure><p>保存修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq!</span><br></pre></td></tr></table></figure><p>重新执行如下命令，完成编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build -c release</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-3stp.png" alt="Vapor"></p><p>找到编译成功的 <code>Vapor</code> 文件</p><blockquote><p>执行完 <code>build</code> 命令之后，会在输出的文件中生成一个可执行的二进制文件。</p></blockquote><p>查找 <code>Vapor</code> 所在的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name vapor</span><br></pre></td></tr></table></figure><blockquote><p>这时会看到输出一个类似如下的文件夹 <code>.build/x86_64-unknown-linux/release/vapor</code> ,这个文件夹里就是我们要使用到的文件 <code>Vapor</code> 。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-4stp.png" alt="Vapor"></p><p>配置 <code>Vapor</code> 的环境变量</p><p>将包含可执行文件 <code>Vapor</code> 的文件目录添加在 <code>PATH</code> 中。</p><p>配置 <code>Vapor</code> 环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp vapor /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>验证是否配置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vapor --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/tl-5stp.png" alt="Vaporhelp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此 <code>Vapor 4.0</code> 的环境配置已经完成。由于 <code>3.0</code> 和 <code>4.0</code> 版本差异比较大，在配置方面也有差异。在创建项目时更需要加上 <code>branch=4</code> 等。后续会加入：创建第一个 <code>Hello World</code> 工程。</p>]]></content>
      
      
      <categories>
          
          <category> Server </category>
          
          <category> Vapor4.0 </category>
          
          <category> Ubuntu18.04 </category>
          
          <category> Swift5.2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Server </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端实践二:Ubuntu18.04安装最新版Swift5.2</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C:Ubuntu18.04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Swift5.2/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文章《<a href="http://www.xuebaonline.com/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/" title="后端实践一:开发环境搭建VMware下安装Ubuntu18.04">后端实践一:开发环境搭建VMware下安装Ubuntu18.04</a>》可以完成在  <code>mac</code> 上搭建起可用的 <code>Ubuntu 18.04</code> 的服务器。接下来我们要在此基础上完善 <code>Vapor 4.0</code> 的开发环境。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ubuntu 18.04 安装 Swift 5.2.2 ，可在 Vapor 官网的引导完成。这篇文章就是讲解如何完成在 Ubuntu 上安装最新版本 Swift，构建出一个强大的云端服务器。</p></blockquote><h1 id="Ubuntu-系统环境搭建"><a href="#Ubuntu-系统环境搭建" class="headerlink" title="Ubuntu 系统环境搭建"></a><strong><code>Ubuntu</code> 系统环境搭建</strong></h1><h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里使用的SecureCRT作为终端连接服务器，也可以使用 <code>iTerm2</code> 连接服务器。</p></blockquote><a id="more"></a><p>使用 <code>SecureCRT</code> 提供的远程登录功能连接 <code>Ubuntu</code> 服务器的配置信息：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-1stop.png" alt="SecureCRT"></p><p>使用 <code>SecureCRT</code> 终端使用系统自带的远程登录功能连接 <code>Ubuntu</code> 服务器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-2stp.png" alt="使用SecureCRT"></p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-3stp.png" alt="使用SecureCRT"></p><p>使用 <code>iTerm2</code> 终端使用系统自带的远程登录功能连接Ubuntu 服务器：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-4stp.png" alt="iTerm2"></p><p>查看当前服务器系统版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><blockquote><p>Swift 依赖一些三方类库。</p></blockquote><p>必须安装的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install clang libicu-dev -y</span><br><span class="line">sudo apt-get install libcurl3 libpython2.7 libpython2.7-dev</span><br></pre></td></tr></table></figure><h2 id="安装-Swift"><a href="#安装-Swift" class="headerlink" title="安装 Swift"></a>安装 <code>Swift</code></h2><p>在 <a href="https://swift.org/download/#releases" target="_blank" rel="noopener">Swift.org</a> 查找我们要安装的Swift对应版本的Toolchain，复制下载链接。</p><blockquote><p>在写这篇文章时最新版的Swift是v5.2.2。</p></blockquote><p>找到对应系统以及对应版本<a href="https://swift.org/builds/swift-5.2.2-release/ubuntu1804/swift-5.2.2-RELEASE/swift-5.2.2-RELEASE-ubuntu18.04.tar.gz" target="_blank" rel="noopener">下载链接</a>：</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-5stp.png" alt="下载链接"></p><p>可以采用两种下载方式：</p><ul><li>在本机上使用上方链接，下载 <code>Toolchain</code> ，上传到 <code>Ubuntu</code> 服务器上，完成后续安装；</li><li>在 <code>Ubuntu</code> 上使用 <code>wget url</code> 的方式直接在服务器上安装。</li></ul><p>接下来 使用  <code>wget url</code> 下载 <code>swift</code> 安装包，并解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://swift.org/builds/swift-5.2.2-release/ubuntu1804/swift-5.2.2-RELEASE/swift-5.2.2-RELEASE-ubuntu18.04.tar.gz</span><br></pre></td></tr></table></figure><p>解压 <code>swift</code> 到文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf swift-5.2.2-RELEASE-ubuntu18.04.tar.gz</span><br></pre></td></tr></table></figure><p>将解压的文件保存在 <code>share</code> 目录下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv swift-5.2.2-RELEASE-ubuntu18.04 /usr/share/swift</span><br></pre></td></tr></table></figure><h2 id="配置-Swift-环境变量"><a href="#配置-Swift-环境变量" class="headerlink" title="配置 Swift 环境变量"></a>配置 <code>Swift</code> 环境变量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成以上操作即完成了 <code>swift</code> 的的安装，为了更方便的使用 <code>Swift</code> ，需要配置其在全局任意目录下可使用。</p><p>配置 <code>Swift</code> 环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=/usr/share/swift/usr/bin:<span class="variable">$PATH</span>"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h2><p>检查当前系统的 <code>Swift</code> 版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift -version</span><br></pre></td></tr></table></figure><ul><li>如果出现 <code>Command &#39;swift&#39; not found ...</code> 该提示，关闭连接终端，重新连接服务器，再次执行上述命令。</li></ul><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-6stp.png" alt="installSuccess"></p><h1 id="运行-Swift-程序"><a href="#运行-Swift-程序" class="headerlink" title="运行 Swift 程序"></a><strong>运行 <code>Swift</code> 程序</strong></h1><h2 id="在终端运行程序，简单测试环境是否达建成功。"><a href="#在终端运行程序，简单测试环境是否达建成功。" class="headerlink" title="在终端运行程序，简单测试环境是否达建成功。"></a>在终端运行程序，简单测试环境是否达建成功。</h2><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift</span><br></pre></td></tr></table></figure><p>此时进入到终端界面。</p><p>编辑一段 <code>Swift</code> 程序代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>, b = <span class="number">13</span>, <span class="built_in">c</span> = a + b</span><br></pre></td></tr></table></figure><p>在终端输入以下命令退出编辑模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:exit</span><br></pre></td></tr></table></figure><p><img src="http://q8wtfza4q.bkt.clouddn.com/swift-7stp.png" alt="Swift"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成 <code>Swift</code> 在 <code>Ubuntu</code> 环境下的配置，接下来可以配置 <code>Vapor 4.0</code> 的开发环境。</p>]]></content>
      
      
      <categories>
          
          <category> Server </category>
          
          <category> Vapor4.0 </category>
          
          <category> Ubuntu18.04 </category>
          
          <category> Swift5.2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Server </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04替换国内源</title>
      <link href="/Ubuntu18.04%E6%9B%BF%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"/>
      <url>/Ubuntu18.04%E6%9B%BF%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再国内使用国外的软件源普遍会比较慢，但是国内也有很多的软件源可供选择。在修改软件源之前，查看系统软件源版本：</p><p><strong><em>查看版本：</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -c</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong><em>备份系统源配置文件：</em></strong></p><p>在修改之前要对系统的配置文件做好备份，这是个好习惯。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h1 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a><strong>阿里源</strong></h1><h2 id="更新源的配置文件"><a href="#更新源的配置文件" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multivers</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a><strong>中科大源</strong></h1><h2 id="更新源的配置文件-1"><a href="#更新源的配置文件-1" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="163源"><a href="#163源" class="headerlink" title="163源"></a><strong>163源</strong></h1><h2 id="更新源的配置文件-2"><a href="#更新源的配置文件-2" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-2"><a href="#更新-2" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h1 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a><strong>清华源</strong></h1><h2 id="更新源的配置文件-3"><a href="#更新源的配置文件-3" class="headerlink" title="更新源的配置文件"></a>更新源的配置文件</h2><p>下面是软件源的配置文件，将如下代码添加到sources.list中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h2 id="更新-3"><a href="#更新-3" class="headerlink" title="更新"></a>更新</h2><p> 执行如下命令，完成系统源的更新：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Ubuntu18.04的配置中，更新了系统的软件源，国内源推荐使用清华源。</p>]]></content>
      
      
      <categories>
          
          <category> Server </category>
          
          <category> Vapor4.0 </category>
          
          <category> Ubuntu18.04 </category>
          
          <category> Ubuntu软件源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端实践一:开发环境搭建VMware下安装Ubuntu18.04</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80:%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVMware%E4%B8%8B%E5%AE%89%E8%A3%85Ubuntu18.04/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Mac</code> 环境下使用 <code>VMware</code> 安装 <code>Ubuntu 18.04</code> 的主要目的是用于对后端开发框架：<code>Vapor 4.0</code> 的实践。由于 <code>Vapor 4.0</code> 框架支持 <code>MacOS</code> 和 <code>Ubuntu</code> ，所以实践时间，以使用 <code>Ubuntu</code> 为主。</p><a id="more"></a><blockquote><p>VMware  的下载和安装这里就不在赘述，自行下载安装即可。</p></blockquote><h1 id="下载-Ubuntu-的-ISO-文件"><a href="#下载-Ubuntu-的-ISO-文件" class="headerlink" title="下载 Ubuntu 的 ISO 文件"></a><strong>下载 <code>Ubuntu</code> 的 <code>ISO</code> 文件</strong></h1><h2 id="国内有很多镜像源，这里选用网易的镜像源。"><a href="#国内有很多镜像源，这里选用网易的镜像源。" class="headerlink" title="国内有很多镜像源，这里选用网易的镜像源。"></a>国内有很多镜像源，这里选用<a href="http://mirrors.163.com/ubuntu-releases/" target="_blank" rel="noopener" title="网易的镜像源">网易的镜像源</a>。</h2><p>这里建议使用 <code>Ubuntu 18.04</code> 版本，按照图示下载即可。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/163-source.png" alt="网易镜像源"></p><p>本次安装中使用的镜像为：<a href="http://mirrors.163.com/ubuntu-releases/18.04/ubuntu-18.04.4-live-server-amd64.iso" target="_blank" rel="noopener" title="Ubuntu18.04"><code>ubuntu-18.04.4-live-server-amd64.iso</code></a>。</p><p><img src="http://q8wtfza4q.bkt.clouddn.com/Ubuntu-1804-server.png" alt="Ubuntu1804"></p><h1 id="VMware-虚拟机配置"><a href="#VMware-虚拟机配置" class="headerlink" title="VMware 虚拟机配置"></a><strong><code>VMware</code> 虚拟机配置</strong></h1><p>在使用 <code>VMware</code> 安装 <code>Ubuntu</code>虚拟机时，按照引导安装即可。</p><h2 id="打开-VMware-软件"><a href="#打开-VMware-软件" class="headerlink" title="打开 VMware 软件"></a>打开 <code>VMware</code> 软件</h2><blockquote><p>根据提示我们在准备安装时，选择<strong>自定义安装</strong>。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-1stp.png" alt="自定义安装"></p><h2 id="选择虚拟的操作系统"><a href="#选择虚拟的操作系统" class="headerlink" title="选择虚拟的操作系统"></a>选择虚拟的操作系统</h2><p>这里选择 <code>Linux</code> -&gt; <code>Ubuntu</code> 64位。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们下载的系统就是 <code>Ubuntu 18.04</code> 64位。还有很重要的一点，因为安装这个操作系统的目的是作为 <code>Vapor 4.0</code> 的服务器，所以在选用操作系统时，我们不需要图形界面。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-2stp.png" alt="选择操作系统类型"></p><h2 id="选择固件类型"><a href="#选择固件类型" class="headerlink" title="选择固件类型"></a>选择固件类型</h2><p>选择固件类型其实就是选择磁盘引导方式。</p><blockquote><p>相对这两种方式进一步了解，可自行查资料。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-3stp.png" alt="选择引导方式"></p><h2 id="选择虚拟磁盘"><a href="#选择虚拟磁盘" class="headerlink" title="选择虚拟磁盘"></a>选择虚拟磁盘</h2><p>选择虚拟磁盘为虚拟操作系统在本机上开辟操作磁盘的空间。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为不会再虚拟机上做比较大的文件操作， <code>20G</code> 的磁盘空间已经够用。在开辟磁盘空间时，开辟的是空间使用上限，在虚拟操作系统文件所占用的空间以实际使用为准，并不是开辟了多少，就是用多少。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-4stp.png" alt="选择虚拟磁盘"></p><h2 id="完成配置"><a href="#完成配置" class="headerlink" title="完成配置"></a>完成配置</h2><p>点击继续即可完成虚拟机配置。</p><blockquote><p>虚拟机配置采用 <code>VMWare</code> 提供的默认配置即可，不用过多的操作。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-5stp.png" alt="完成配置"></p><h2 id="保存虚拟机文件"><a href="#保存虚拟机文件" class="headerlink" title="保存虚拟机文件"></a>保存虚拟机文件</h2><p>点击保存将虚拟机文件保存在默认文件夹中。</p><blockquote><p>文件的保存位置可以是默认位置，也可以是自定义的位置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-6stp.png" alt="完成配置"></p><h1 id="安装-Ubuntu-18-04"><a href="#安装-Ubuntu-18-04" class="headerlink" title="安装 Ubuntu 18.04"></a><strong>安装 <code>Ubuntu 18.04</code></strong></h1><p>在使用 <code>VMware</code> 完成对 <code>Ubuntu</code>虚拟机配置时，即会进入系统的安装界面。</p><h2 id="开启-CD-DVD-，并选取镜像"><a href="#开启-CD-DVD-，并选取镜像" class="headerlink" title="开启 CD/DVD ，并选取镜像"></a>开启 <code>CD/DVD</code> ，并选取镜像</h2><p>在完成对虚拟机配置之后，进入到引导界面，开启 <code>CD/DVD</code> ，并加载镜像。</p><blockquote><p>因为启动时未加载系统镜像，所在期初会出现引导出错的问题。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-7stp.png" alt="引导失败"></p><blockquote><p>开启CD/DVD，并加载镜像。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-8stp.png" alt="加载镜像"></p><h2 id="选择系统引导语言"><a href="#选择系统引导语言" class="headerlink" title="选择系统引导语言"></a>选择系统引导语言</h2><p>镜像加载完成，选择系统引导语言的默认语言。</p><blockquote><p>安装系统的提示比较简单，也见名知意，所以在安装的全过程，我们均会使用英文完成安装。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-9stp.png" alt="选择系统引导语言"></p><h2 id="选择系统语言"><a href="#选择系统语言" class="headerlink" title="选择系统语言"></a>选择系统语言</h2><p>镜像加载完成，选择操作系统的默认语言。</p><blockquote><p>因为是作为服务器使用，为了避免以后因为字符编码上造成不必要的麻烦，这里选择英文。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-10stp.png" alt="选择系统语言"></p><h2 id="选择键盘布局"><a href="#选择键盘布局" class="headerlink" title="选择键盘布局"></a>选择键盘布局</h2><p>选择键盘布局默认选择英文键盘。</p><blockquote><p>键盘布局选择英文，大部分的笔记本、台式电脑键盘采用英文布局。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-11stp.png" alt="选择键盘布局"></p><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>网络设置主要是设置操作系统的网络链接方式，这里采用默认跟随本机网络变化。</p><blockquote><p>因为是在虚拟软件中使用操作系统，网络配置采用默认配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-12stp.png" alt="网络设置"></p><h2 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h2><p>系统需要一个代理接口联网，默认网络链接走本机。</p><blockquote><p>代理网络可以设置链接特定的网络中，比如公司内网。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-13stp.png" alt="代理设置"></p><h2 id="设置系统镜像"><a href="#设置系统镜像" class="headerlink" title="设置系统镜像"></a>设置系统镜像</h2><p>这里的镜像是软件包的镜像源。</p><blockquote><p>在安装的过程中使用默认的软件包镜像源，后续推荐替换的国内镜像。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-14stp.png" alt="设置系统镜像"></p><h2 id="设置文件系统"><a href="#设置文件系统" class="headerlink" title="设置文件系统"></a>设置文件系统</h2><p>文件系统设置采用默认设置。</p><blockquote><p>选取使用整个磁盘空间。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-15stp.png" alt="设置文件系统"></p><blockquote><p>文件系统采用系统推荐的默认方式配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-16stp.png" alt="设置文件系统"></p><blockquote><p>文件系统分区采用默认的分区方式。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-17stp.png" alt="设置文件系统"></p><h2 id="个人信息设置"><a href="#个人信息设置" class="headerlink" title="个人信息设置"></a>个人信息设置</h2><p>个人信息设置主要是设置 <code>root</code> 账户密码，服务器名称，登录账户及密码。</p><blockquote><p>完成设置信息之后，建议对该信息进行备份保存。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-18stp.png" alt="个人信息设置"></p><h2 id="OpenSSH-设置"><a href="#OpenSSH-设置" class="headerlink" title="OpenSSH 设置"></a><code>OpenSSH</code> 设置</h2><p>OpenSSH可是系统支持远程登录，远程操作。</p><blockquote><p>建议安装，在以后的操作中会比较方便，远程操作软件推荐 <code>SecureCRT</code> 。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-19stp.png" alt="OpenSSH设置"></p><h2 id="服务软件"><a href="#服务软件" class="headerlink" title="服务软件"></a>服务软件</h2><p>这里可以选择性的安装。</p><blockquote><p>针对自己想用的软件进行安装，建议用到什么安装什么。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-20stp.png" alt="服务软件一览"></p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>完成所有的配置之后，系统机会进入安装界面，安装过程比较久。</p><blockquote><p>系统安装时间会长一些，具体看各自电脑配置。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-21stp.png" alt="安装系统"></p><h1 id="登录-Ubuntu18-04"><a href="#登录-Ubuntu18-04" class="headerlink" title="登录 Ubuntu18.04"></a><strong>登录 <code>Ubuntu18.04</code></strong></h1><p>完成安装之后，系统就会进入终端，输入用户名和密码进入系统。</p><h2 id="输入用户信息"><a href="#输入用户信息" class="headerlink" title="输入用户信息"></a>输入用户信息</h2><p>输入用户名和密码，按照提示输入。</p><blockquote><p>在 <code>2.9</code> 中的用户信息，就是需要的登录信息。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-22stp.png" alt="输入用户信息"></p><blockquote><p>成功进入 <code>Ubuntu</code> 系统中。</p></blockquote><p><img src="http://q8wtfza4q.bkt.clouddn.com/vm-23stp.png" alt="输入用户信息"></p><h1 id="Ubuntu-18-04-个性化配置"><a href="#Ubuntu-18-04-个性化配置" class="headerlink" title="Ubuntu 18.04 个性化配置"></a><strong><code>Ubuntu 18.04</code> 个性化配置</strong></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后续会加入一些实用的小技巧：国内的软件源，远程登录、配置数据库、安装 <code>Vapor 4.0</code> 开发环境等。</p>]]></content>
      
      
      <categories>
          
          <category> Server </category>
          
          <category> Vapor4.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
